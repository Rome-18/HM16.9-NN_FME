/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2016, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     TEncSearch.cpp
 \brief    encoder search class
 */

#include "TLibCommon/CommonDef.h"
#include "TLibCommon/TComRom.h"
#include "TLibCommon/TComMotionInfo.h"
#include "TEncSearch.h"
#include "TLibCommon/TComTU.h"
#include "TLibCommon/Debug.h"
#include <math.h>
#include <limits>
#include <fstream>
#include <iostream>
#include <algorithm>


// EMI: Parameters declaration

signed short MVX_HALF, MVX_QRTER, MVY_HALF, MVY_QRTER = 0;
float  C, H1, H2, V1, V2, U1, U2, U3, U4;
long int array_e[100000];

float IN[26] = {};
float X1[22] = {};
float X2[20] = {};
float OUT[49] = {};
int N, NN_out, index_ref, counter_i, PUHeight, PUWidth, PIdx, PAddr;

/*
The next group of variables are all 1D and 2D arrays. The reason why I declared them as std::array is because that
way they can be assigned in a cleaner manner. These arrays are assigned values in TEncSearch::init() function depending
on the chosen Quantization Parameter
https://stackoverflow.com/questions/16059781/2d-array-value-assign-after-declaration-in-c for more info on 2D array assignment
*/
std::array<std::array<float,4>,8> embs0, embs1;
std::array<std::array<float,2>,3> embs2;
std::array<std::array<float,7>,14> embs3;
std::array<std::array<float,26>,22> in_h1;
std::array<std::array<float,22>,20> h1_h2;
std::array<std::array<float,20>,49> h2_out;
std::array<float ,22> b1, BN_gamma_1, BN_beta_1;
std::array<float ,20> b2, BN_gamma_2, BN_beta_2;
std::array<float ,49> bout;
std::array<float ,9> BN_gamma_in, mean, stdev;

// Helper Functions

float relu(float x){
	if (x>0)	{	return x; }
	else { return 0; }
}

float sigmoid(float x){
  return (1 / (1 + std::exp(-x)));
}

//end of modification


//! \ingroup TLibEncoder
//! \{

static const TComMv s_acMvRefineH[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static const TComMv s_acMvRefineQ[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static Void offsetSubTUCBFs(TComTU &rTu, const ComponentID compID)
{
        TComDataCU *pcCU              = rTu.getCU();
  const UInt        uiTrDepth         = rTu.GetTransformDepthRel();
  const UInt        uiAbsPartIdx      = rTu.GetAbsPartIdxTU(compID);
  const UInt        partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

  //move the CBFs down a level and set the parent CBF

  UChar subTUCBF[2];
  UChar combinedSubTUCBF = 0;

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);

    subTUCBF[subTU]   = pcCU->getCbf(subTUAbsPartIdx, compID, uiTrDepth);
    combinedSubTUCBF |= subTUCBF[subTU];
  }

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);
    const UChar compositeCBF = (subTUCBF[subTU] << 1) | combinedSubTUCBF;

    pcCU->setCbfPartRange((compositeCBF << uiTrDepth), compID, subTUAbsPartIdx, partIdxesPerSubTU);
  }
}


TEncSearch::TEncSearch()
: m_puhQTTempTrIdx(NULL)
, m_pcQTTempTComYuv(NULL)
, m_pcEncCfg (NULL)
, m_pcTrQuant (NULL)
, m_pcRdCost (NULL)
, m_pcEntropyCoder (NULL)
, m_iSearchRange (0)
, m_bipredSearchRange (0)
, m_motionEstimationSearchMethod (MESEARCH_FULL)
, m_pppcRDSbacCoder (NULL)
, m_pcRDGoOnSbacCoder (NULL)
, m_pTempPel (NULL)
, m_isInitialized (false)
{
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    m_ppcQTTempCoeff[ch]                           = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]                        = NULL;
#endif
    m_puhQTTempCbf[ch]                             = NULL;
    m_phQTTempCrossComponentPredictionAlpha[ch]    = NULL;
    m_pSharedPredTransformSkip[ch]                 = NULL;
    m_pcQTTempTUCoeff[ch]                          = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = NULL;
#endif
    m_puhQTTempTransformSkipFlag[ch]               = NULL;
  }

  for (Int i=0; i<MAX_NUM_REF_LIST_ADAPT_SR; i++)
  {
    memset (m_aaiAdaptSR[i], 0, MAX_IDX_ADAPT_SR * sizeof (Int));
  }
  for (Int i=0; i<AMVP_MAX_NUM_CANDS+1; i++)
  {
    memset (m_auiMVPIdxCost[i], 0, (AMVP_MAX_NUM_CANDS+1) * sizeof (UInt) );
  }

  setWpScalingDistParam( NULL, -1, REF_PIC_LIST_X );
}


Void TEncSearch::destroy()
{
  assert (m_isInitialized);
  if ( m_pTempPel )
  {
    delete [] m_pTempPel;
    m_pTempPel = NULL;
  }

  if ( m_pcEncCfg )
  {
    const UInt uiNumLayersAllocated = m_pcEncCfg->getQuadtreeTULog2MaxSize()-m_pcEncCfg->getQuadtreeTULog2MinSize()+1;

    for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
    {
      for (UInt layer = 0; layer < uiNumLayersAllocated; layer++)
      {
        delete[] m_ppcQTTempCoeff[ch][layer];
#if ADAPTIVE_QP_SELECTION
        delete[] m_ppcQTTempArlCoeff[ch][layer];
#endif
      }
      delete[] m_ppcQTTempCoeff[ch];
      delete[] m_puhQTTempCbf[ch];
#if ADAPTIVE_QP_SELECTION
      delete[] m_ppcQTTempArlCoeff[ch];
#endif
    }

    for( UInt layer = 0; layer < uiNumLayersAllocated; layer++ )
    {
      m_pcQTTempTComYuv[layer].destroy();
    }
  }

  delete[] m_puhQTTempTrIdx;
  delete[] m_pcQTTempTComYuv;

  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    delete[] m_pSharedPredTransformSkip[ch];
    delete[] m_pcQTTempTUCoeff[ch];
#if ADAPTIVE_QP_SELECTION
    delete[] m_ppcQTTempTUArlCoeff[ch];
#endif
    delete[] m_phQTTempCrossComponentPredictionAlpha[ch];
    delete[] m_puhQTTempTransformSkipFlag[ch];
  }
  m_pcQTTempTransformSkipTComYuv.destroy();

  m_tmpYuvPred.destroy();
  m_isInitialized = false;
}

TEncSearch::~TEncSearch()
{
  if (m_isInitialized)
  {
    destroy();
  }
}




Void TEncSearch::init(TEncCfg*       pcEncCfg,
                      TComTrQuant*   pcTrQuant,
                      Int            iSearchRange,
                      Int            bipredSearchRange,
                      MESearchMethod motionEstimationSearchMethod,
                      const UInt     maxCUWidth,
                      const UInt     maxCUHeight,
                      const UInt     maxTotalCUDepth,
                      TEncEntropy*   pcEntropyCoder,
                      TComRdCost*    pcRdCost,
                      TEncSbac***    pppcRDSbacCoder,
                      TEncSbac*      pcRDGoOnSbacCoder
                      )
{
  assert (!m_isInitialized);
  m_pcEncCfg                     = pcEncCfg;
  m_pcTrQuant                    = pcTrQuant;
  m_iSearchRange                 = iSearchRange;
  m_bipredSearchRange            = bipredSearchRange;
  m_motionEstimationSearchMethod = motionEstimationSearchMethod;
  m_pcEntropyCoder               = pcEntropyCoder;
  m_pcRdCost                     = pcRdCost;

  m_pppcRDSbacCoder              = pppcRDSbacCoder;
  m_pcRDGoOnSbacCoder            = pcRDGoOnSbacCoder;
  
  for (UInt iDir = 0; iDir < MAX_NUM_REF_LIST_ADAPT_SR; iDir++)
  {
    for (UInt iRefIdx = 0; iRefIdx < MAX_IDX_ADAPT_SR; iRefIdx++)
    {
      m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange;
    }
  }

  // initialize motion cost
  for( Int iNum = 0; iNum < AMVP_MAX_NUM_CANDS+1; iNum++)
  {
    for( Int iIdx = 0; iIdx < AMVP_MAX_NUM_CANDS; iIdx++)
    {
      if (iIdx < iNum)
      {
        m_auiMVPIdxCost[iIdx][iNum] = xGetMvpIdxBits(iIdx, iNum);
      }
      else
      {
        m_auiMVPIdxCost[iIdx][iNum] = MAX_INT;
      }
    }
  }

  const ChromaFormat cform=pcEncCfg->getChromaFormatIdc();
  initTempBuff(cform);

  m_pTempPel = new Pel[maxCUWidth*maxCUHeight];

  const UInt uiNumLayersToAllocate = pcEncCfg->getQuadtreeTULog2MaxSize()-pcEncCfg->getQuadtreeTULog2MinSize()+1;
  const UInt uiNumPartitions = 1<<(maxTotalCUDepth<<1);
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    const UInt csx=::getComponentScaleX(ComponentID(ch), cform);
    const UInt csy=::getComponentScaleY(ComponentID(ch), cform);
    m_ppcQTTempCoeff[ch] = new TCoeff* [uiNumLayersToAllocate];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]  = new TCoeff*[uiNumLayersToAllocate];
#endif
    m_puhQTTempCbf[ch] = new UChar  [uiNumPartitions];

    for (UInt layer = 0; layer < uiNumLayersToAllocate; layer++)
    {
      m_ppcQTTempCoeff[ch][layer] = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy)];
#if ADAPTIVE_QP_SELECTION
      m_ppcQTTempArlCoeff[ch][layer]  = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy) ];
#endif
    }

    m_phQTTempCrossComponentPredictionAlpha[ch]    = new SChar  [uiNumPartitions];
    m_pSharedPredTransformSkip[ch]                 = new Pel   [MAX_CU_SIZE*MAX_CU_SIZE];
    m_pcQTTempTUCoeff[ch]                          = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#endif
    m_puhQTTempTransformSkipFlag[ch]               = new UChar [uiNumPartitions];
  }
  m_puhQTTempTrIdx   = new UChar  [uiNumPartitions];
  m_pcQTTempTComYuv  = new TComYuv[uiNumLayersToAllocate];
  for( UInt ui = 0; ui < uiNumLayersToAllocate; ++ui )
  {
    m_pcQTTempTComYuv[ui].create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  }
  m_pcQTTempTransformSkipTComYuv.create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  m_tmpYuvPred.create(MAX_CU_SIZE, MAX_CU_SIZE, pcEncCfg->getChromaFormatIdc());
  m_isInitialized = true;

  // EMI: Weights and Bias Initialization based on QP

  if(m_pcEncCfg->getQP() == 27){
    
    embs0 = {{
      {{0.017645061,-0.14282376,0.10562852,0.20343474}},
      {{0.017611617,0.006190995,0.008554706,0.0049515273}},
      {{-0.00061942165,-0.0039749728,0.00010614828,-0.0008092777}},
      {{0.0084226895,0.0414466,-0.018555619,-0.004863877}},
      {{-0.023993868,0.010360363,-0.016844165,-0.01377493}},
      {{-0.010646318,0.104722336,-0.048724137,-0.02165324}},
      {{-0.0866573,0.0014095438,-0.016641537,0.010879254}},
      {{-0.22743696,-0.19665375,-0.034515988,0.06054912}}
    }};

    embs1 = {{
      {{-0.121944904,0.37564924,0.13877568,-0.122540385}},
      {{0.0038139315,0.007076237,0.020877084,0.0057008755}},
      {{-0.0030095284,-0.0019870303,-0.00074965594,-0.0047105807}},
      {{-0.013601813,-0.040270057,0.071739495,0.1192632}},
      {{0.006215589,-0.0040797465,-0.040208273,0.0100668445}},
      {{0.016938148,0.05992003,-0.013002481,0.08415818}},
      {{0.03316566,-0.070954345,-0.06566887,-0.017359348}},
      {{-0.03158518,-0.20124607,-0.15165696,-0.13348722}}
    }};

    embs2 = {{
      {{-0.48238945,0.28674966}},
      {{-0.002705084,0.14749537}},
      {{0.0044410946,0.1474887}}
    }};
    
    embs3 = {{
      {{0.23947164,-0.10340303,-0.2233448,-0.14377543,0.07328129,-0.034581512,0.18986377}},
      {{-0.00039837082,-0.000376382,0.1354311,-0.0001257329,3.8059778e-05,-0.00077428686,-0.0005189909}},
      {{-0.00054068334,0.00030664194,0.13537157,0.0014167549,-0.0018501087,-0.001513888,3.892474e-05}},
      {{-0.0012052744,-0.0004937744,0.13541932,-0.0011771256,-0.00035612728,-0.0016475957,0.0010346719}},
      {{-0.0029659534,-0.0029416345,0.1354487,0.0065563405,0.005762843,0.01648743,0.010820362}},
      {{0.114524394,0.0025990596,0.14043915,0.020401308,-0.04655409,0.0067374306,0.0069655427}},
      {{0.00015136178,0.0019986394,0.1355095,0.0019776297,0.0034153804,0.015495001,0.0008117717}},
      {{0.13140365,0.0030523164,0.14063562,0.01134781,-0.06917517,0.0059324447,0.00083714566}},
      {{-0.0038902408,0.019429378,0.1345711,-0.031168899,0.00065808464,0.013421809,-0.012885051}},
      {{0.25069362,-0.047861665,0.15361848,0.0018657086,0.082044005,0.040610146,0.023623079}},
      {{0.009163467,0.017915457,0.13500829,-0.02284991,-0.015755285,-0.01921983,0.018459773}},
      {{0.26614058,-0.035785273,0.15594962,-0.111072086,0.1317169,-0.012176544,0.012223573}},
      {{0.03145499,0.1239213,0.15267493,0.026224814,0.13935642,-0.084072255,-0.065370455}},
      {{0.17327686,0.0042482866,0.15292089,0.0966577,0.031954996,-0.06458047,-0.0646742}}
    }};

    in_h1 = {{
      {{0.062803954,-0.13215771,0.16755132,-0.22329271,-0.16179669,0.037053913,0.028653814,-0.0033212241,-0.026677668,0.20029467,-0.0050451662,0.011415256,0.20686288,-0.0045994506,-0.0388035,0.08726525,0.06474372,-3.3539102,0.84781504,1.0468061,-1.2267765,3.0542483,-0.8601594,2.0947206,0.9065105,-1.3875382}},
      {{-0.32105732,0.032807443,-0.16552207,0.014635604,-0.0045016264,-0.22811034,-0.15456682,0.008378877,0.00049632264,-0.038100872,0.004728745,0.018057419,-0.10948511,-0.02661841,-0.06617574,-0.085349105,-0.08729349,1.3619555,-1.7383838,0.4084883,0.9664966,-6.8527074,-1.2865393,1.8380833,1.5968037,0.21374626}},
      {{0.21257377,0.17424756,0.27088955,-0.041184086,0.05726111,0.16397515,0.2112472,0.08963501,-0.025924642,0.15002926,0.024773693,0.022576094,0.5803284,0.00951457,0.027041273,-0.0573005,-0.01259457,-1.1233414,-1.1992891,0.55082464,0.7793103,10.651431,0.713764,1.4767731,0.5001143,-0.26756573}},
      {{-0.5583389,0.056281254,-0.58984655,-0.4868801,-0.06779672,-0.29064685,-0.7002501,0.13511363,-0.0014237696,0.14663163,-0.03758451,0.018842546,0.24961296,0.0009833564,-0.07395316,0.10732702,-0.031323582,-1.158758,-0.033845503,-1.2362587,-2.4034455,-2.9682705,-0.94123286,-1.7626789,0.45893335,-0.7897284}},
      {{-0.26873627,0.015294697,-0.25056908,0.0586264,0.09642225,-0.16264729,-0.2785064,0.00943323,-0.014493251,0.36956787,-0.09554052,-0.06080162,0.44662732,0.037342113,0.010327734,0.03877664,0.0266155,-0.08012772,-1.674542,0.54819155,-3.0223851,-10.358404,-0.22778045,-0.55215883,0.3952544,0.14648788}},
      {{0.6700717,-0.05531841,-0.1081729,0.10339549,-0.19885431,0.5810449,0.37080657,-0.1283524,-0.021987645,0.17290531,0.05831917,0.09484649,0.42861602,0.0443959,0.1484904,-0.011298559,-0.078725025,0.88088834,-1.699526,0.05798665,1.3091743,-9.144651,0.84917575,1.0407196,0.6235669,-0.1529853}},
      {{-0.036352295,0.027730858,-0.22324269,0.1512327,0.019122165,-0.034923676,-0.072528355,0.020648228,0.0041647977,0.4254621,-0.02893281,-0.009095258,0.4834314,-0.0057964576,-0.015278019,-0.01496061,-0.0061856387,2.9994519,-1.7041057,-0.73570704,5.710247,-3.5846803,-1.968096,2.6754563,0.9195862,0.20636041}},
      {{-0.22181666,0.010617093,0.072507866,0.038494352,0.06234556,-0.14921771,-0.07482521,-0.021518635,0.01945089,0.38035527,-0.056042355,0.006108302,0.29103285,0.0018091014,-0.025192127,-0.048107658,-0.0068537234,-1.208381,0.15662335,0.3370192,-1.694119,-5.389379,-1.5798216,0.60147464,0.2995219,-1.5374719}},
      {{-0.1324178,0.071639925,0.25491527,-0.10046462,0.09114009,-0.05457987,-0.018556353,0.0066066906,0.0053905197,-0.15053016,-0.054410618,0.011128657,-0.10518976,-0.0033116885,-0.009659733,0.0072735865,0.007988993,1.0462539,0.46835417,0.14389928,0.12710519,-14.988875,0.23867583,0.63740605,0.0907534,-0.011686588}},
      {{-0.07592477,-0.028166426,0.18465234,-0.13412918,0.026186384,-0.043456502,0.010504232,-0.076460175,-0.050149817,-0.23632899,0.01003333,-0.008412078,-0.30242872,0.027266467,-0.0014885335,0.055527728,-0.11485451,2.53989,-3.9765923,-0.8297249,3.9155045,4.9863825,0.6023678,0.47802666,-1.2887836,0.49815446}},
      {{-0.14194974,-0.0014777746,-0.12493549,-0.08666476,-0.037485596,-0.05323194,-0.15455242,0.048308704,0.0037889832,0.15783265,-0.019995492,-0.016427994,0.39859155,0.014259788,-0.006534809,-0.015207641,0.001934103,0.49102953,0.38864914,0.75729233,0.28399616,-6.0863256,2.5522807,1.0252451,-1.2397041,0.6269605}},
      {{-0.12812595,-0.031320874,-0.0578011,0.0011975581,-0.018601133,-0.06512148,-0.102962084,-0.002293546,-0.022955196,-0.30141264,-0.014613055,-0.011107582,-0.19131212,0.028301239,0.016535379,-0.031141378,0.024404027,1.001048,0.6496741,-2.3002098,-1.4312731,-3.0823817,-2.2203717,-2.4358366,0.3493336,-0.2561899}},
      {{-0.049430408,-0.015096595,-0.18347137,0.09634193,-0.016243523,-0.048509184,-0.07780116,0.004590039,-0.008784992,-0.12041507,0.008833395,-0.008339294,-0.13667916,0.009450092,0.010368269,-0.010378476,-0.00069737725,-2.911941,-2.1165795,0.50425863,-4.515436,-4.5771284,4.4268355,-0.19976689,0.7704234,-0.10085765}},
      {{-0.50621307,0.108611554,-0.15236518,0.21756011,0.12313507,-0.4052806,-0.2075026,0.0056914524,-0.07741204,0.13244034,-0.054645605,-0.08460994,0.1629668,0.025889726,-0.09861155,-0.04142376,-0.2037686,0.46318913,1.6089501,1.2802148,2.515867,-4.838519,-0.44428468,1.8649107,-1.3658657,-0.012678079}},
      {{0.18703575,-0.0267572,-0.2143058,0.060265,0.014842022,0.17145541,0.008813232,-0.07393091,0.013096371,-0.0024589163,0.04823653,0.06410935,-0.18728797,0.07486756,0.12540536,0.049402457,-0.016713385,-4.166335,0.4099866,0.93703735,-4.6234927,-4.4146137,-2.4762177,-0.74499696,0.82508576,-0.34101188}},
      {{-0.07461649,0.0016319245,-0.07641847,-0.056192208,0.0011195864,-0.051668793,-0.09608583,0.008558991,0.0019721575,-0.2838638,0.0025428322,-0.0038769012,-0.36630258,-0.002213751,-0.014718114,0.0010574402,-0.010511019,-1.4785041,-1.1390175,-1.77802,-1.8740745,-4.401631,-2.8010013,-1.2237725,-1.4019278,-1.8871163}},
      {{0.4032216,-0.17031945,0.2301855,-0.07684549,-0.14149743,0.22048907,0.3094031,-0.038626462,0.025954548,-0.75008154,0.050097447,-0.025242072,-0.35534567,-0.0066134185,-0.010401637,0.06308879,0.03375661,-2.1074436,0.74908304,0.9254837,-6.1166573,5.200872,-1.7347198,-0.59379816,0.236299,0.89900476}},
      {{-0.005627165,-0.008770522,0.004643611,0.020993114,0.008160391,-0.0175224,0.002895135,-0.026534805,-0.021165356,0.13158941,-0.011118179,-0.0013524857,0.07387264,0.013088941,-0.0047722147,0.013400582,-0.023808291,2.2846148,3.9626665,0.0062979595,-0.7417374,-5.243131,-1.5337479,0.39633912,0.8731484,0.35863328}},
      {{-0.09914513,0.0055547673,-0.24909341,0.07208968,-0.009362374,-0.06166994,-0.12403747,0.008624696,0.0036370151,-0.022836074,0.013417502,0.006469114,-0.20972209,-0.0058982424,0.007534991,-0.042764906,0.003283183,0.9641156,2.4408712,0.5077997,0.7413464,-0.047178965,0.019357545,1.4329994,-2.4886432,-0.20559758}},
      {{1.6203167,-0.63302875,1.5438297,0.2746586,-0.38343334,0.6626044,1.4305024,-0.5612148,0.5063021,0.12757453,0.25783336,-0.31572708,0.13330889,0.41396716,-0.31861493,0.16818781,0.36960804,4.573441,0.16783342,1.0871811,2.5491848,-4.935032,-0.076710336,2.5120206,-0.9223845,1.2272106}},
      {{0.02728897,-0.06375576,-0.07943444,0.034284674,-0.053204574,0.0075951614,-0.018980851,0.0054776673,0.027213397,0.21840309,-0.025396997,0.033014055,0.51779294,0.005219334,0.0011744011,-0.006576617,0.10871101,4.242297,-0.033606164,0.3107123,5.182983,-4.9827757,-0.045705263,0.27466476,-0.4517721,1.0971482}},
      {{-0.12857643,0.022352673,-0.09310051,0.16642135,0.026140576,-0.13465716,0.00044754168,-0.019764151,0.030060556,0.47737122,-0.010389295,0.05289037,0.32940632,-0.01787367,-0.057027083,-0.05301721,-0.022564683,2.3645897,1.9753227,-0.9685442,-4.246769,-2.634582,1.6283311,-4.1272173,-0.07856059,0.74940145}}
    }};

    h1_h2 = {{
      {{-0.07754491,0.9260738,0.09085672,0.18893647,0.11304946,0.95940506,-0.98826146,2.8936584,-0.22026931,-2.765353,-0.17444447,-2.332596,1.4227909,1.4245355,0.54483306,0.41147166,-0.9659391,-1.2050824,-1.1209011,-0.59035134,0.4628965,-3.5741794}},
      {{-0.12076779,-0.056450292,-0.3444866,-0.41369176,1.2721606,-1.0626577,0.6978437,-0.8487991,-1.3539027,-0.14545424,-3.1279635,-0.574889,-3.6249585,0.551072,1.4655252,-5.2971087,-0.9928099,0.5928806,-0.11701197,-0.2522519,0.9226109,-0.7815566}},
      {{-1.9757262,-1.6338394,-0.3094856,0.11330202,-0.4287876,-0.28122443,-0.6906481,-0.6991671,-0.41412294,-0.26737058,0.7994266,0.36916512,-2.5102532,1.0349191,-0.29973507,-1.066716,-0.92058206,0.45998085,-0.51241076,-0.8408548,0.98741055,1.1513281}},
      {{-0.9988485,0.1896358,-1.7973884,0.026079532,-0.11341267,0.40384576,-0.54456335,0.62567574,2.1203985,-1.0849748,0.6108179,-1.0944995,0.34019464,-0.10543342,-1.2103525,-0.80060905,-0.8671004,0.7621851,0.6749823,-0.10013853,-0.35968074,-2.8769042}},
      {{-0.48634493,1.0601097,0.11591624,-0.57767326,1.12907,0.6867729,-1.4376363,-1.2936617,2.2291765,0.50528175,1.0452125,-1.1547757,-0.76494503,-0.114382125,-2.034343,-1.8212687,-0.63793117,0.0155242,0.37557372,-0.4728008,1.2029,-1.6292416}},
      {{-0.13924311,0.08352007,-2.296625,0.37731874,1.8732971,0.9853576,0.04241585,-0.49829543,1.4680904,-0.65697783,-0.21197248,0.58790624,-0.15970878,0.4947374,-0.4454926,-1.7899896,0.048536923,0.18491074,0.6198214,-0.300176,0.14435545,0.1915278}},
      {{-0.21601686,0.14090598,0.013371245,-0.53299457,1.67179,-0.442906,-1.3456968,-0.5293861,0.58688587,-1.4930507,0.33197856,0.64414704,-0.12211735,1.2228462,1.6948096,0.3754995,-0.5792006,1.1689504,-0.5529368,-0.33508605,0.3140812,-0.120673165}},
      {{-0.473832,0.62009925,-2.1396852,-0.339467,-2.068482,-0.1682561,-0.20565212,-3.3326507,2.9549155,-1.2741157,1.9278849,-0.025703168,-0.7123569,-0.9262648,-2.0511613,-2.7143161,-1.0849385,0.8334907,-0.737861,-1.0332696,1.2965778,0.14960562}},
      {{0.18761359,-0.2830503,-1.5302019,-0.3617958,1.274794,2.3597593,0.17621389,0.728002,3.8669066,-0.83943564,-0.096128955,-0.45259246,-0.038497005,0.22685646,-0.29411566,-0.8249251,-0.33932802,-0.2233117,-0.47127113,-0.19455467,0.34418327,0.2446493}},
      {{-2.852242,-0.9647495,-0.65736586,0.0249867,0.32247332,-0.044195883,-2.9327416,-0.2915447,0.20117088,-0.8892671,-0.14527623,-0.2882839,0.58554864,0.6354089,-0.26667482,-4.0099845,-1.9002357,-3.5192,-2.6536672,-1.3148786,-0.49010035,0.59253883}},
      {{-0.594409,0.65535575,0.18010199,0.4470791,0.5062061,-0.13261373,-1.4416625,-0.87184936,-2.3928201,0.34589866,-0.5282718,0.45056033,1.4278095,-1.4829519,-0.41282845,-2.1378248,-1.6130488,0.59438413,-3.151444,-0.54426396,0.69250846,1.0474273}},
      {{-4.1406903,-2.3543231,-0.20994608,0.018445373,0.8392729,0.9727446,0.18001644,0.39838284,-0.3494177,0.20688768,0.13492058,0.43771762,-0.10422525,0.97517,-1.5016088,2.7002828,-2.8984647,-4.991064,-2.910312,-0.95553845,-0.67974746,1.8912884}},
      {{-0.8951249,2.2700996,-0.13826832,-0.17596197,1.2685375,-0.11390934,0.5090292,0.27030945,-0.5141135,-0.71042436,-0.24371281,-0.5387421,1.0043333,-0.58514714,1.133368,0.4308061,-0.3637189,-0.59901327,-3.1541586,-0.12854883,0.3813127,-1.7284827}},
      {{-0.4399026,0.18593071,-0.022909218,0.12866375,-1.0118876,0.14192358,0.724153,0.049293224,-0.8071354,0.049946852,-0.44697925,-0.21383195,-1.8494649,0.9888965,-0.34291846,-1.7173207,-0.7801477,-0.03794987,0.12891082,-0.73197234,2.8645227,-2.2883875}},
      {{-1.3553078,0.5068725,-0.68015146,0.115067646,0.0560777,-0.3587754,-3.4935787,-0.58440375,0.906287,-2.0243485,0.8875336,-0.4775934,-0.68382376,1.3201745,1.9936745,1.2934003,-0.4827012,1.2272382,-2.1328008,-2.6836212,-0.2932659,0.041028965}},
      {{-0.45733622,-2.398736,0.18857545,0.26018387,0.22620764,0.29684758,-7.587471,-0.021446902,-3.6849136,-2.2547095,2.056379,-0.98489463,-0.7015013,1.0776422,0.0035861304,-2.9604988,-1.0780828,0.07593525,-0.093018375,-0.6783968,-0.20408127,1.5377808}},
      {{0.9512796,-1.057266,-0.6631284,0.50902975,-0.54974633,-0.28117478,1.8048024,1.7199614,-2.6247916,-0.089882,-2.7481441,3.457428,-3.3013315,-0.68123156,0.5824971,0.31076905,-0.55646586,-2.4831846,-0.15948705,0.35259673,-3.6666632,1.3749647}},
      {{-0.77737445,0.03419436,0.004054874,-0.23188615,1.1756668,0.03645037,-3.7524674,-0.10418725,-0.18429728,0.23098828,0.24196002,-0.79579043,3.6483297,-1.01128,-0.9245389,-2.2517345,-0.5798487,0.969513,-0.02270089,-1.2274358,-0.3953566,0.19067699}},
      {{0.019594284,0.6806374,-0.06013672,0.038096324,1.5486901,0.20798615,0.1913135,-0.67898047,-0.10904511,1.1231153,0.20649298,-1.896195,0.5749713,-0.40856755,-0.30406895,-5.1330547,-0.9597401,-4.939915,-2.0832007,-0.32564512,0.18585494,-0.76433295}},
      {{-0.2564824,-0.99397457,-0.96344423,0.2722624,0.62597793,0.54311,2.0094044,-1.3327718,4.651198,0.51857024,0.31071863,0.9608826,0.075094506,1.4866763,0.15079145,-0.20679824,-0.50034153,-0.9287776,-0.47490323,-0.6591965,0.35740042,1.1443976}}
    }};

    h2_out = {{
      {{0.846027,0.04691352,-6.034407,1.941434,-0.8511566,-0.44252443,-0.90577346,-5.5427876,0.1162423,4.4660125,0.10362827,-3.5132263,-0.145621,-2.5471644,-1.0480608,-0.2164995,-3.8692415,0.042723775,-0.46930516,-2.1279485}},
      {{0.7053079,-1.6618819,-7.6664224,1.1702104,-0.4093292,-0.4243715,-1.3001633,-4.0806026,-1.0385153,4.5809393,0.110408925,-1.6375197,0.27609122,-0.15368223,-1.7780713,0.3913836,-4.132849,-0.6279955,0.7351099,-1.0228474}},
      {{0.7310888,-1.7518414,-6.51178,0.16851456,0.3370977,-0.25465468,-2.1843743,-1.3361413,-1.6880233,3.3214457,-0.040013444,-1.0158226,0.41102472,-0.06311371,-3.492388,-0.24299903,-3.3379645,-0.46053904,2.7123585,0.10314568}},
      {{0.4401032,-0.9149964,-1.0118011,-0.11268066,0.55156815,0.31453213,-2.2380583,0.14828284,-0.12721376,0.67559344,0.500612,0.16268882,-0.25017452,0.4501124,-3.3242445,-0.8491394,-3.0188131,-0.28536594,2.606791,1.1213249}},
      {{-3.2130408,-0.4543181,1.1034209,-1.4857757,0.33923197,1.0361987,-4.3152504,-0.013732034,-2.2232668,0.11141845,1.3020108,1.9656775,0.23425576,0.71216327,-3.7747905,-2.6350124,-3.6783185,0.09522799,3.769495,0.043523856}},
      {{-6.2151647,1.4086424,1.6281995,-2.290495,-0.5861096,1.6755809,-3.7574637,0.5677731,-1.8853685,-0.0027412698,0.9828458,1.8026829,-0.010032686,0.98698974,-3.1041636,-1.8795699,-3.2417533,0.27949908,1.1876707,-0.6717566}},
      {{-6.3326035,1.8025107,2.1563032,-3.695314,-1.9186838,1.4108224,-1.9375314,0.4595564,0.025091242,2.3934553,0.98816204,-1.9003062,-0.6789746,-0.41161257,-1.658825,-1.709204,-3.6201677,1.3191959,-1.5105627,0.33709058}},
      {{0.498565,0.9937468,-4.9302697,0.98822314,-2.9649231,-1.0498285,0.11136678,-4.986893,-0.7411539,3.020717,0.4800492,-3.2530353,0.33130452,-4.72512,0.19428186,-0.20972033,-2.7876403,-0.11977288,-1.9515963,-1.4256597}},
      {{0.59005016,-0.97406214,-4.2935653,0.23369388,-0.7048757,-1.0304929,-0.44150975,-3.548213,-0.3114976,0.8305941,0.54672027,1.0639526,0.393448,-1.5093249,0.024275722,0.3448754,2.1187665,-0.6131564,0.061055284,-0.8956186}},
      {{0.57014287,-1.5284433,-4.6013994,-0.45210215,0.20075019,-0.46641237,-1.0572597,-1.5724283,-1.4974891,2.0051854,0.73733234,-0.016055718,0.44500396,-0.3159222,-0.5599224,-0.31516874,-2.3142319,-0.5114126,1.0674778,-0.3520379}},
      {{0.64093596,-1.1974528,-1.2249581,-0.2686891,0.5329768,0.013351805,-2.0134428,-0.14415887,-1.0156668,-0.99288535,1.11674,1.9365901,0.43981418,0.42095986,-2.0808382,-0.9604851,2.9129148,-0.22843325,2.350933,1.191312}},
      {{-0.52600944,-0.12164566,0.8730769,-1.5666218,-0.041104402,0.48174748,-2.2458777,0.20765607,-2.7028375,-0.491435,1.2499537,1.8191065,0.41621235,0.8669227,-2.1455152,-2.3986614,-2.2946393,0.70420766,1.5264621,-0.5372405}},
      {{-2.5847554,1.7076231,1.4987109,-2.6958642,-1.3774389,0.8196967,-1.5813397,0.76248497,-0.89857763,-2.036667,0.66336757,1.9725494,0.31591558,1.0090542,-1.7020663,-1.8015473,-1.5819992,1.4573743,-0.38587922,-0.22074366}},
      {{-5.040429,1.9844007,1.5472643,-3.2363327,-5.1137714,0.42966312,-0.5056711,0.74445474,-0.8061282,1.5640383,0.5810711,-1.833301,0.30595526,0.22177488,-0.5654188,-1.6043345,-3.3551533,2.64006,-2.999047,0.55664855}},
      {{0.2266888,0.61951715,-3.612475,0.106251016,-5.5703707,-0.5054298,0.39563116,-1.8723977,-0.20386595,2.320706,0.24016057,-2.4097402,0.26479378,-6.9064436,0.8064796,0.4137187,-2.6280837,-0.09257744,-1.9178565,-1.448262}},
      {{0.29255182,-0.57317436,-2.8988674,-0.7987597,-1.3594226,-0.6254595,0.24773993,-1.6907715,-0.727501,1.3488201,0.58049446,0.12808777,0.26054293,-4.40229,0.5544992,0.61926967,0.38427716,-0.66041726,-1.1159636,-1.0652467}},
      {{0.37745067,-1.4912796,-2.9819853,0.7830753,0.3634757,-0.8921282,-0.0011970018,-0.51315314,-0.28017077,0.84056884,0.6602563,0.18895838,0.36094326,-0.16937435,0.21489516,0.07893354,-0.13894416,-0.5367441,-0.3986593,-0.40237406}},
      {{0.5202864,-1.0381008,-0.2050368,0.33435187,0.5554218,-0.5591513,-0.45391217,0.43388468,0.09016955,-1.1755966,0.66812795,0.19802104,0.43779168,0.47003198,0.044028617,-0.752784,-0.67771274,-0.22917335,0.8946873,1.1067997}},
      {{0.28033924,0.11537315,1.0711685,-2.3049483,0.12574966,0.09263266,-0.38633123,0.9283978,-0.8690518,-2.2866743,0.13598636,1.4427294,0.40270475,0.83842427,-0.18965104,-1.4285911,-0.95159525,0.9386993,0.7276294,-0.18267484}},
      {{-0.93986654,2.1926923,1.2892393,-2.3497102,-1.7418854,0.19370331,-0.010501649,0.6631866,-1.2991402,-1.0525113,-0.15552542,0.5852611,0.25601712,1.0322559,-0.5046717,-1.8344929,-2.2424743,3.1127756,-1.308133,-0.68910766}},
      {{-2.9241364,2.3712108,1.2421429,-0.74149346,-6.573015,0.14467818,0.18058981,0.7754732,-0.25950727,1.0552975,-0.17364311,-1.6495825,0.33598083,0.27840593,0.043981507,-1.3717097,-5.040207,5.70193,-3.0257397,-0.70136315}},
      {{-0.5960632,1.3331027,-0.60114086,-0.49060217,-1.7106359,1.189042,0.6008422,0.21239008,1.0431241,2.4328752,0.010963797,-1.4726337,0.14284614,-5.685257,0.81281215,0.56881434,-2.0454757,0.21879488,-2.7335973,-1.0174904}},
      {{-0.2509361,-0.25237668,-0.7455247,-1.3225563,-2.4134674,1.3785975,0.5791897,-0.01852703,0.4653718,1.2693412,0.48383105,-0.061849337,0.1323878,-5.758489,0.9396778,0.94943976,3.1183608,-0.68072,-1.3882612,-1.2307966}},
      {{0.028982118,-1.2306969,-0.1992064,0.41814214,0.20577155,0.6037999,0.68267274,0.48422638,0.59976196,0.73498607,0.2085124,-0.4731466,0.18648235,-1.3745214,0.76321185,0.33269733,-1.2316641,-0.5766332,-1.1486826,-0.57911944}},
      {{0.20063248,-0.7756345,0.47581837,1.4307755,0.5803187,0.31626517,0.6979008,0.8708053,2.521147,-1.6213462,-0.3468489,0.0026972345,0.20831384,0.4883777,0.67246854,-0.3615865,6.1134157,-0.282564,-0.6897789,1.0274487}},
      {{0.35774544,0.38617957,1.0997854,0.19612637,0.18718791,0.5691689,0.62338376,0.738369,0.23257595,-2.0872135,-0.92681587,0.2872414,0.23271477,0.81216437,0.59958893,-0.9332324,-1.8592055,1.4445497,0.011930603,-0.86883545}},
      {{0.17676426,1.896472,0.79054034,-0.71564174,-1.5630682,1.4175162,0.5387401,0.26594475,0.12429959,-0.8302264,-1.0834562,-0.053315468,0.15598664,1.0275638,0.4808869,-1.1275759,0.38879347,5.6315103,-0.76474833,-1.7195718}},
      {{-0.25015524,1.8160601,-0.42013663,-0.3768006,-0.5764968,1.1256973,0.6097827,0.16115703,0.69850296,1.96291,-0.5335044,-1.4934477,0.15329736,-0.67445266,0.6434568,-0.63309705,-5.5856037,7.924435,-1.866694,-1.2979848}},
      {{-2.929826,0.45511743,0.83315086,-1.0831969,-5.5620723,0.14462946,0.27483985,0.5522899,0.039886545,2.6603065,0.7340669,-2.0188775,-0.3716938,-4.765637,1.1363282,0.8292627,-3.0613809,-0.17044619,-3.9791763,-0.46504244}},
      {{-1.5047041,-0.90020233,0.98057026,-1.274075,-3.0882616,-0.29273745,0.40312922,0.38957894,-0.4251191,0.6482634,0.8601058,0.3202402,-0.9510211,-3.9937034,1.0970162,1.1635137,1.7280874,-0.6901123,-2.0780215,-0.53941005}},
      {{-0.37693644,-1.1044868,1.0099952,-1.7278028,0.44989255,0.16825145,0.6432512,0.7649976,0.0629204,0.15033501,0.27532673,0.5410158,-1.1636399,-0.41965118,0.6400947,0.6424061,0.15727848,-0.5396073,-1.5983467,-0.4839069}},
      {{0.18290573,-0.9491241,1.1437749,1.4933403,0.585536,-1.1919883,0.7126001,0.83263445,-0.4662933,-1.0043383,-0.6730506,-0.7909043,-0.7554179,0.5292556,0.41351652,0.13880694,-0.70030606,-0.30686685,-1.3516402,0.9301903}},
      {{0.6697295,0.15480499,1.435773,0.12870497,0.23290402,-1.0428702,0.6781107,0.19168542,-0.43353826,-2.145969,-2.5762136,0.11724965,-0.33122215,0.8156528,0.5418685,-0.33283514,-0.10887879,0.7311714,0.21157292,-1.0235099}},
      {{0.7601053,2.1034453,0.07630193,-0.35580912,-1.7093278,-0.26992676,0.60026586,-1.1668394,-1.15572,-0.7873761,-2.246323,-0.048944432,-0.40687695,1.0536482,0.38331127,-0.64385086,-1.4620011,3.2307312,-1.1288126,-1.8281962}},
      {{0.46540022,2.7015848,-2.6194246,0.7936564,-5.5326796,-0.16974925,0.48411885,-1.6609472,-0.39456773,2.0031817,-2.0067394,-2.4432728,0.16339682,-0.35202843,0.5615278,-0.551988,-4.1696444,5.6749935,-2.1080327,-2.358897}},
      {{-4.002996,0.05262488,1.6426892,-2.6247883,-3.6776743,0.15403073,0.40910465,0.57554007,-0.37432644,3.3110876,0.7619262,-2.3610795,-1.1336937,-2.8573816,0.771363,0.88418007,-2.9374616,0.18846752,-4.5682406,0.24814826}},
      {{-2.4878225,-1.2249573,1.7402071,-1.7396734,-2.4173715,0.21077129,0.14840573,0.58999556,0.1734734,0.8077768,0.9270467,0.6393462,-1.8949919,-1.752533,0.34085318,1.2621781,-1.1775322,-0.62336516,-2.2181497,-0.04574252}},
      {{-1.8536494,-1.3865539,1.7607265,-1.0422579,0.34410986,-0.14348249,0.5917641,0.40994263,-1.8022871,1.3742793,-0.24447635,0.11612094,-2.6986332,-0.3612563,-0.14000846,0.97295094,-3.4796138,-0.5235632,-1.6614579,-0.44739997}},
      {{0.11171604,-1.0217445,1.6431588,1.2324312,0.5732339,-0.40945262,0.28653598,0.21855327,-1.7410107,-1.1958728,-1.0698624,0.75928766,-4.9287086,0.5416175,-1.1375698,0.6706709,-0.15067145,-0.25956225,0.18584947,0.94320136}},
      {{0.6726066,-0.120728254,1.025473,0.6344674,0.09191935,-0.8061888,0.59920686,-0.57101816,-1.8629197,-0.49620488,-3.6956642,-0.5647573,-2.058813,0.8471189,-1.2858802,0.65956837,-3.1513364,1.5804936,0.7309479,-1.1943812}},
      {{0.9442602,1.4279755,-0.73401165,0.20875092,-1.0907294,-0.7323481,0.47076917,-5.9264793,-0.5697052,-1.0813782,-2.9839795,0.24157779,-0.69302344,1.0185966,-0.48893496,0.10884912,-1.5710707,1.2973759,-0.055504367,-1.3992853}},
      {{0.8057391,2.4604745,-4.0279584,1.2373646,-5.4995685,-1.0191102,0.60194284,-7.13899,-0.6011997,2.7036357,-2.0487595,-3.244285,-0.40933147,-0.103360206,0.19471225,-0.1213881,-3.160073,2.6108813,-2.4980247,-1.8033365}},
      {{-5.0253005,-0.2089135,2.3655424,-3.0765185,-1.9632964,1.0131339,-1.2160151,0.40371642,-0.0035264825,3.8772304,0.8927736,-2.5516038,-1.7844542,-2.2003322,-0.0045579183,0.26897666,-3.7092693,0.082256846,-2.6951888,0.10629626}},
      {{-4.4540977,-1.2306573,2.1365469,-1.6067017,-0.7815569,0.8794315,-1.868288,0.7609424,-1.0515674,2.924282,0.661586,-0.013696577,-1.5013769,-0.48377392,-0.86321175,1.2367207,-3.5817938,-0.65727717,-2.0872648,-0.49715626}},
      {{-3.7490637,-1.4905021,1.9809719,0.21557713,0.5368658,0.6947107,-2.0271182,0.49896652,-2.3887904,1.4323347,-0.10434076,0.73972106,-4.288543,0.31353733,-1.630307,1.3267856,-4.0992923,-0.48015606,-0.06262585,0.03803074}},
      {{0.20049033,-0.8036664,1.1583017,0.8231841,0.58045506,-0.023495672,-0.51937556,0.095384516,-0.7773512,-0.06042891,-0.859945,-0.2571302,-5.329657,0.5171776,-2.307514,0.3073611,-3.4496272,-0.26919425,1.4857256,0.94120395}},
      {{0.75631416,-0.6701911,-1.859872,1.5651304,0.34086728,-0.54587835,-0.3219369,-1.2753425,-1.8969033,0.7198267,-3.6796107,-0.956995,-5.1182303,0.75416756,-3.564057,0.6050268,-3.9728105,0.6188727,2.7936983,-0.7211711}},
      {{1.0794967,0.6015417,-4.186098,1.2811939,-0.5992048,-0.7161086,-0.38294488,-6.877228,-1.0092634,2.543691,-3.318096,-1.9835818,-1.3044147,1.0024925,-3.0500274,0.13495113,-3.018877,0.6880286,1.3982757,-1.7696835}},
      {{1.0458066,1.7551131,-5.1547313,1.1803173,-1.0323719,-0.310084,-0.5150626,-12.102383,0.77991706,3.845115,-2.048158,-3.3613124,-0.76312554,-0.29360008,-1.5440917,-0.38192785,-3.9333394,0.96838206,-0.74015933,-2.7783399}}
    }};

    b1 = {
      -0.07253645, 0.12269868, -0.027004793, -0.26110694, -0.06458344, -0.01098946, -0.10069475, -0.2557492, 0.05305145, 0.07792328, 0.04317195, -0.13762778, 0.12321332, 0.07940552, 0.025667487, -0.40185633, 0.2687612, 0.090003535, 0.0046280036, -0.041652776, 0.05285953, -0.003062314
    };

    b2 = {
      0.061771806, -0.026946096, 0.0011680477, 0.18581599, -0.0015440249, 0.14114083, 0.33556503, 0.00960281, 0.0515432, 0.028402, -0.019514237, 0.14869696, 0.078452624, -0.03321669, 0.048052542, 0.018995183, -0.13866347, 0.055818196, 0.021907583, 0.22924355
    };

    bout = {
      -1.7936727, -1.3765054, -1.0573771, -0.5735514, -1.2984071, -1.5365806, -1.8205962, -1.9077622, -0.60112464, -1.018695, 0.16853122, -1.2336335, -0.8953235, -1.9873626, -1.5342577, -0.867512, -0.051584333, 0.3784652, -0.19350436, -1.102205, -1.5579807, -0.6184024, 0.1714247, 0.40711045, 3.0058734, 0.503725, 0.02281253, -0.60394305, -1.546841, -0.8922084, -0.22262992, 0.44695586, -0.18947423, -1.0553405, -1.5958806, -2.114249, -0.9537099, -1.3748662, -0.12311869, -1.2455873, -0.89967346, -2.1469061, -2.072322, -1.7772268, -1.4974308, -0.8456837, -1.3788544, -1.4947082, -2.0652337
    };

    BN_gamma_in = {
      0.019606411, 0.18060088, 0.53806365, 0.04556954, 0.046685696, 0.16704714, 0.11200261, 0.55752754, 0.9657659
    };

    BN_gamma_1 = {
      2.7067733, 2.242081, 2.6876745, 2.5692723, 1.3908123, 1.6150726, 2.0171874, 2.7667878, 2.7975004, 2.0797844, 2.3055143, 2.9751697, 2.718853, 1.4575815, 1.3423176, 4.850289, 2.1581042, 2.740049, 2.97647, 2.6338403, 2.0114613, 1.6664644
    };

    BN_gamma_2 = {
      3.836753, 2.9807858, 4.993057, 2.2865627, 3.2150345, 3.3764412, 1.9110714, 2.725086, 2.6414163, 4.551048, 4.058906, 3.5022008, 3.1971688, 5.2838387, 4.02992, 3.9342294, 10.50157, -2.9968698, 3.3553524, 2.8614404
    };

    BN_beta_1 = {
      -0.028925624, -0.024754258, -0.02903575, 0.002914742, -0.07508395, -0.108308226, -0.015042072, -0.040074717, -0.039790057, -0.15034181, -0.035643145, -0.05606133, -0.06838546, -0.09891498, -0.042880047, -0.0088331, -0.007562461, -0.02321939, -0.063237034, 0.0045192474, -0.020985426, -0.17669222
    };

    BN_beta_2 = {
      -0.06121628, -0.3709299, -0.08344363, -0.30251393, -0.037959363, -0.40351704, -0.5344273, -0.016055573, -0.12650357, -0.18020825, -0.17812642, -0.2624408, -0.2459709, -0.086077146, -0.06219445, -0.2919665, -0.056802128, 0.044244595, -0.2585858, -0.44666642
    };
    
    mean = {
      29392.970371108513,14449.27256774253,29468.812044811177,20007.27959930253,1629.7166661930034,19975.9895674184,29320.02856944484,14235.348064378382,29209.857008158637
    };

    stdev = {
      256515.60077313037,159941.94146627083,254284.04904751695,172390.6796552528,31795.403944595513,171971.81685380894,254690.44250619222,159896.30559834707,256222.83102018837
    };
  }

  else if(m_pcEncCfg->getQP() == 32){
    
    embs0 = {{
      {{0.03909254,0.13153163,-0.23330064,0.12816033}},
      {{0.008626064,0.029273897,-0.012774331,0.006075536}},
      {{-0.0053015593,0.0022506958,0.002285266,-0.008365554}},
      {{0.3104417,0.030203646,0.15534423,-0.07003701}},
      {{-0.017088959,-0.05305332,0.028858908,0.009275231}},
      {{0.2633047,-0.036459252,0.11436868,-0.008624557}},
      {{-0.01698129,-0.110361174,-0.07756774,-0.023254082}},
      {{0.19597635,-0.19242387,-0.18565321,-0.040489722}}
    }};

    embs1 = {{
      {{-0.1635971,-0.021389782,-0.38403353,-0.3629636}},
      {{0.013816935,-0.015319826,0.009917404,0.03474919}},
      {{-0.009458494,0.002892516,-0.0009135544,0.023455957}},
      {{0.029506937,-0.057927553,0.16023229,0.10347677}},
      {{-0.031754714,0.03800566,-0.024954686,0.004420899}},
      {{-0.06687033,-0.07076819,0.12353921,0.07899443}},
      {{0.0135206655,0.107483,-0.05515027,-0.0065640216}},
      {{0.19648187,0.21654356,-0.053370602,0.040621072}}
    }};

    embs2 = {{
      {{0.1994955,0.3444391}},
      {{-0.00041002416,-0.33523723}},
      {{0.0007989347,-0.33540165}}
    }};

    embs3 = {{
      {{0.050492615,-0.053070217,-0.10410187,0.1347251,-0.22868696,0.13355517,-0.17284286}},
      {{0.0002803255,-0.0024194603,0.0007577299,0.004017018,-0.002474538,-8.7104e-05,0.0022790155}},
      {{0.0014469876,0.0065046838,0.0017127614,-0.010529203,-0.0012285723,-0.004122285,-0.0072449204}},
      {{-0.0006528317,-0.0071511744,0.0018119459,-0.007713432,0.0010364552,0.00067213544,0.0045054965}},
      {{-0.022365117,0.022027122,-0.007129437,0.013197039,-0.023538535,0.0034078849,0.025161419}},
      {{0.01597543,-0.024527352,-0.31144512,-0.0317037,-0.0141896475,-0.043971084,-0.02686654}},
      {{0.022060513,0.006802907,-0.010662684,0.0038091424,0.016130075,0.00464603,0.028533213}},
      {{0.06564,-0.09277788,-0.3604029,0.026705928,-0.04317927,-0.021021264,-0.029126521}},
      {{-0.042028353,0.018041171,0.003253556,0.013787284,0.013975614,0.028416239,-0.032649927}},
      {{-0.03051614,0.030790882,-0.30069792,0.00088251574,0.10492862,0.037482012,-0.07628806}},
      {{-0.01520496,0.016867008,0.005523228,-0.0037729186,-0.010025921,0.06453794,-0.0009651172}},
      {{0.028264664,-0.011655126,-0.3718393,0.01941727,0.12712453,0.073651604,0.019139362}},
      {{-0.009476402,0.050490323,0.03813678,0.04997732,-0.0288544,-0.02413638,0.00087109965}},
      {{-0.05425777,-0.01776352,-0.00626434,0.07161159,0.09589553,-0.016585173,0.0015981062}}
    }};

    in_h1 = {{
      {{0.027794346,-0.53009963,0.18111682,-0.31608707,-0.32004774,0.7319308,0.7735601,-0.22279893,-0.040616408,-0.36602423,0.043147624,-0.21449018,-0.061008897,-0.06939385,0.0595228,0.015232205,-0.017395273,-0.2567279,-0.0084637785,1.250453,1.2263124,-0.9897063,1.6258909,1.3158859,-3.4505363,-0.34372902}},
      {{0.051295046,-0.18474963,-0.24894099,0.13668811,0.22969082,0.140794,-0.5065632,-0.01567927,-0.005864037,0.08757576,-0.014728911,0.08635094,0.16001873,-0.009489815,-0.03537765,0.01425803,-0.14927825,0.2825482,0.68132126,0.13356066,0.7327745,-1.3134507,-4.205028,0.22976233,5.504675,-1.3236667}},
      {{0.123701654,0.0018657052,-0.29542708,-0.09795,0.24579367,0.25428802,-0.051592328,0.40976876,-0.011726329,0.094678864,-0.075160846,0.012852513,0.03881793,0.020591447,-0.1749665,-0.06246844,0.07740241,0.8537697,-1.870995,0.1779076,-0.3337071,-4.0764055,1.5317034,-1.6399878,-2.6439815,0.89825135}},
      {{-0.010728761,-0.085038,0.044627234,-0.06492137,-0.03894528,0.081656195,0.06657102,-0.09293052,-0.008581121,-0.34295535,-0.020753516,-0.025124101,0.0053819474,-0.0043308935,0.02169346,0.021127317,-0.059841085,0.65150416,-1.947129,0.46349213,-0.91202265,0.3537497,2.1746492,0.36439142,7.0851855,0.17279698}},
      {{0.019529307,-0.053039156,-0.08142482,0.059186134,0.085783385,0.09628684,0.14956608,-0.20056671,0.007970315,-0.31013653,0.015640948,-0.01280422,0.032555215,0.012624742,0.002002673,-0.022721214,-0.01992097,0.81156796,-0.3478309,-3.0261688,0.51581806,-0.30775645,-2.1599076,-0.019657291,0.3473944,0.5751439}},
      {{0.0067139,-0.011553038,-0.0023628091,-0.0025411504,-0.0035952206,0.018793734,-0.01773663,0.03594409,-7.1383016e-05,0.010674923,0.00076759874,-0.0023665698,0.0015573987,-0.00073690957,-0.001953306,-0.0053364253,-0.0013344667,-0.50976336,0.7284953,-0.7266704,-2.0560038,0.8247889,-1.6419532,-0.1938317,2.3049486,-0.09355689}},
      {{0.0018455664,0.21326458,-0.010768249,0.099007964,0.022496391,-0.24537247,-0.132557,0.20312493,0.011504579,0.33295992,0.04070072,0.023081172,-0.036320105,0.025342546,-0.019530315,0.0053472132,0.07014781,0.35208103,-1.0550696,0.5336802,-0.37836468,0.31442884,-1.9637252,0.25686494,6.9204583,-0.0529796}},
      {{-0.072010994,0.07614696,0.06740449,-0.05373557,0.016365891,-0.18975028,-0.04128921,-0.28050062,-0.009379896,0.28927186,-0.05935394,0.0064049265,0.009130316,0.03777194,0.024380453,0.019049369,-0.03866453,-0.74579185,0.99457234,0.19116163,0.36082327,0.71609336,-2.8588994,0.37787473,0.92000836,-2.3848047}},
      {{-0.21291022,0.59850526,0.23636109,-0.18705605,-0.015882816,-0.718871,0.1697586,0.53182614,0.056020096,0.15967149,0.3085827,0.14116982,-0.15758534,-0.39654034,0.017130628,0.010786149,-0.10844844,0.22029343,-0.7371482,-0.31173286,0.52782965,-0.16362391,0.2379961,1.8607044,0.18585671,-0.51311684}},
      {{0.036914676,0.024455555,0.016519638,0.16316625,-0.014807791,0.05818584,0.31213152,-0.19035096,0.024092903,-0.23476826,-0.0028782296,0.01461089,0.0019143125,-0.024088912,0.09535007,-0.060247283,-0.084837236,-1.9434355,0.7662617,1.3967452,-1.0758656,0.019649377,5.256142,1.7273418,-1.0266068,0.07005999}},
      {{0.007438519,-0.049896613,-0.0731978,-0.009088218,0.0828925,0.10031873,0.12824067,-0.1536878,0.0027747888,0.009382459,-0.01584784,-0.0030962755,0.008737643,-0.04418947,-0.039209735,-0.010672823,0.01505025,-1.5728198,-2.1927047,0.6146833,0.61024487,0.40184343,1.7298446,0.6530425,-2.1545057,0.087651275}},
      {{-0.051947385,1.3137972,-0.24109358,0.8038357,-0.13527492,-0.82142127,-0.20393279,-0.08801612,0.056863926,0.22027975,-0.7828587,0.3673729,-0.11188965,-0.25779584,-0.2025107,0.016146699,-0.42673704,0.28559428,2.4437985,2.0001907,-0.1400566,-0.3911497,-0.22918156,-0.6237321,-2.195595,-0.34833038}},
      {{-0.06225013,-0.06122073,0.11318042,-0.0041592815,-0.009757399,0.018687604,0.015386364,-0.34930453,0.0013835978,0.2949582,-0.00046267454,0.011123144,0.0121271005,0.006534631,0.023630604,-0.00035495977,0.017195886,-1.2550763,-1.014557,-1.4027722,-2.1376736,-2.2727482,-1.8460112,-1.3784026,-0.27350736,-1.727077}},
      {{-0.011783107,-0.16419345,0.27078375,0.010639599,-0.06611894,0.006660447,0.04581463,-0.69553506,-0.00083528395,0.34527883,0.03251396,0.012306467,-0.0021230641,0.0025075949,0.06597027,-0.02073932,0.05339436,0.24829331,-0.21641804,0.53035223,-0.3320492,-5.3314714,-0.43696514,0.17542264,1.2816267,0.18171221}},
      {{0.0007591587,0.0278775,0.020373745,-0.008029367,-0.018994791,-0.013383235,0.0513761,-0.0038957682,0.0016605818,0.31587097,-0.0055728382,-0.011326431,-0.019650694,-0.00716862,0.0075896606,0.013304331,-0.018961977,0.51220804,2.6938488,0.4471362,-0.7842278,-0.61343825,1.1852778,0.4513348,-2.6245778,0.021226054}},
      {{0.037274558,0.26862612,-0.04658337,-0.07751951,0.087958775,-0.20158365,-0.09802429,0.33491817,-0.0075340252,0.15781482,0.0008629978,0.01995751,0.019595526,0.10263232,-0.11905219,0.009099651,0.18894045,-0.63010263,0.5775778,0.28447348,0.6295857,-5.6893525,1.4996061,0.057604153,0.715126,-0.1425817}},
      {{-0.29511997,0.27574342,-0.098935835,0.006535622,0.03242903,-0.048215456,-0.04469134,0.40358895,0.0017721002,0.03253524,-0.08028061,0.07198978,0.20810646,0.1080435,-0.04457378,0.113720104,-0.073800415,0.37222534,1.006469,-0.26242495,-0.6273499,-3.4947627,0.21649791,0.6807842,5.5145893,0.16498129}},
      {{0.02028715,-0.48550603,-0.2541753,-0.14385004,0.15064004,0.6276081,-0.15387678,-0.2970649,-0.037035264,-0.3058494,-0.10613231,0.026295261,0.181067,-0.047513887,-0.116683595,-0.024002321,-0.08834783,0.96125144,0.36088833,0.5354723,-0.7733258,-2.0345263,5.2041483,0.394505,3.4627693,0.7388091}},
      {{-0.0090003675,-0.21034576,0.054685257,-0.117794566,-0.069925606,0.21585266,0.19729869,-0.180838,-0.019902792,0.3558641,0.0041198004,-0.076058485,-0.006287965,-0.029129388,0.007653432,0.0033258444,0.034568813,-0.37028053,0.642153,0.058877368,-2.6316137,0.81035435,0.5317904,-0.065120496,0.5795169,0.20563819}},
      {{-0.61013705,-0.27548385,0.2088436,0.17120056,-0.6486128,-0.008718331,-0.52019405,0.36160702,0.04493875,0.01998635,0.075053334,-0.04405743,0.17626862,-0.15169448,0.15368673,-0.0013052088,-0.007634028,-0.39023432,0.021210672,0.53786236,0.62346995,-4.5695543,2.1644583,-0.0736557,0.8926766,-0.009295822}},
      {{-0.0016077422,-0.2091866,0.032817833,-0.13272634,-0.073299594,0.29289103,0.210533,-0.14297605,-0.008469315,-0.35678723,-0.042004786,-0.043790027,0.011328338,-0.03165478,0.008383466,-0.011494308,-0.030039264,-0.30474654,0.55294615,-0.08183019,0.4449323,-0.64136827,-7.408237,0.014225557,6.6303864,0.21704015}},
      {{-0.06545373,-0.06855614,0.015115464,0.067842975,-0.028441748,-0.10719993,-0.15730841,-0.04413989,-0.006166813,0.0054601687,-0.0030772872,-0.05004983,0.046858512,-0.036660448,0.04757176,0.011280181,0.0057082344,0.07471836,-0.16290334,-2.9086812,-0.30586603,0.5810522,-3.021181,-1.0489119,1.5034086,-0.44143996}}
    }};

    h1_h2 = {{
      {{0.7977656,-0.31922156,1.4710803,-0.3858743,0.28836668,0.66436577,-0.77720815,-0.645113,-1.0395263,-0.047045253,0.45241913,-0.00866509,-1.8022906,1.2753786,-0.42736343,1.361381,0.6710628,0.12669866,-1.1568722,0.5713812,0.3476986,-1.4225585}},
      {{0.22939584,0.41378036,0.23529775,0.59737414,-0.104415976,-0.9904464,0.1009562,-0.66708565,-0.22071636,0.233526,0.022433518,-0.6744633,-3.0206258,-0.29449627,-1.9857607,0.31204596,-1.0489321,0.12914065,-0.37317985,-0.11932476,-0.65927976,-0.40142617}},
      {{0.2117342,1.2684324,-1.0892061,-1.7226018,-0.542344,-2.1608307,1.389318,-0.15265469,-1.1069942,-0.16272709,-0.56669605,-0.31279835,-1.0483122,-0.41568682,-0.6347398,0.47709405,-0.13804294,0.79375714,-0.9397861,-0.31877074,2.7730575,0.5385421}},
      {{0.5280846,0.2165603,0.9427343,1.2896647,-0.4718477,6.2141623,-0.14624058,-0.44681734,-0.29940492,0.80454063,-0.36354175,-0.83198565,2.5748756,-1.3794913,-2.8366055,0.66972655,-1.9293487,0.5208296,-1.0863457,0.15516002,-0.7603698,0.78497845}},
      {{-0.7141151,1.3518541,-0.6314149,1.4652573,-0.04679239,1.4833039,-0.7590917,-0.54978114,0.18319882,-0.6791319,-0.11045745,0.00915647,-0.51088417,0.78781784,-0.10548142,1.2370735,-0.025629675,-0.19897044,0.4754348,0.5086535,0.0074415873,0.47737357}},
      {{-0.5076435,-0.023708314,0.18388039,-0.17141981,0.3661366,-0.09753094,0.006214851,-0.18186893,-0.57749593,-0.18402301,0.2922763,-0.051608305,0.3367594,-0.9730615,-0.42254654,-0.14264551,-0.2873624,0.15385777,0.22162788,-0.045521915,-0.55938476,0.1951551}},
      {{0.052693408,1.2605711,-0.26170567,-0.7168834,-0.2226607,-0.87236726,-0.26115713,-0.5233475,-0.6757317,0.49402085,-0.5738713,-0.60262024,0.10688948,-0.37737337,-0.07006635,0.9909028,0.69808596,-0.8018478,-0.53857994,1.4174148,0.14423053,0.48684117}},
      {{0.10634725,-0.8713718,1.5033687,-2.0642302,0.12011913,-0.21103278,-2.4204218,-1.0663772,0.07056507,0.29518217,-0.51705515,-1.3880849,1.3967494,-0.57626235,1.7318033,-0.15188868,0.13774511,-0.13175236,-1.3300984,-0.17302345,-0.31640676,2.057091}},
      {{0.47330493,0.13817006,-0.44597375,-1.7418463,-0.44358188,-1.8992548,-2.5823054,-0.419535,-0.010197365,0.3550874,-0.50454426,-0.65872425,-0.41712394,-0.68758285,0.410148,0.28699532,-0.61588717,-0.06926178,0.0104487585,-0.042992998,-2.8662856,-0.5254724}},
      {{0.4938856,0.40226316,-0.30841267,-1.6676133,-0.93117964,-1.1651152,0.76695234,-1.2513773,-0.46934697,0.8210082,-0.89013565,-0.89952815,0.95680654,-0.7614587,0.4219804,0.24556777,1.5972478,-1.0931219,0.33422023,0.23766689,0.8297583,-0.29907635}},
      {{0.533765,-2.16231,0.015283872,0.08953856,-1.0067338,0.3121703,-0.4337366,-0.4696049,-0.5588819,0.68460107,-0.3521184,-0.19152124,2.2973907,-1.8029565,0.07750734,0.05377608,0.009111099,-2.5297487,-0.9427242,-0.07424271,-1.8149666,0.141237}},
      {{0.5896748,0.1331525,0.6186874,-3.1556776,0.3440591,3.019634,-0.29803774,0.34506983,-0.6810737,-0.69061464,-0.5197694,0.13560589,1.0190215,-0.1024089,-0.2789612,-1.2928494,-0.5589697,0.57208234,-1.1855743,-0.46307448,0.849328,1.1653603}},
      {{-0.38382217,-0.3624437,1.6777531,0.95238477,0.16379222,-2.866263,-0.63872355,-3.9300992,0.2445389,-0.11356584,-3.8635914,-0.15280758,2.6160684,-0.7983256,-0.14135453,-1.4690605,0.410961,-0.3291343,-0.4066017,-0.52989733,0.16710968,1.4007244}},
      {{0.95501834,0.281799,-0.008224361,-0.4601601,-0.15871671,-6.0741563,0.31827956,-0.41093132,-0.9448745,-0.5110844,0.40506905,0.018718347,-0.48439416,-0.13286224,-0.25667784,-0.03159029,0.1856411,-0.0047485163,-2.0978742,-0.055315807,1.2566471,-0.008415443}},
      {{-0.35805005,-0.5139615,0.55165756,-3.1489365,-0.08885188,0.95224464,-2.6086679,-1.8094503,0.03949277,-0.21873936,-3.8758166,-0.14629287,0.14832187,-0.68446344,0.036954507,-0.24447195,-0.22584163,0.6140944,-0.91571987,-0.32635143,1.4634259,0.2988306}},
      {{1.3340334,1.3910576,-0.87838423,-2.4467995,-0.9737772,4.3896017,-1.0571889,0.29662994,-0.8859956,-0.02848896,-0.61958,-0.15684196,0.79016054,-0.16100085,0.027397245,0.26513085,0.30715767,0.40950036,-1.0245827,-0.084278755,-0.8250479,0.20509763}},
      {{0.4374581,-0.129388,0.40889153,0.22986937,-0.17912444,-5.171747,-0.787722,-0.36636367,-0.26680347,0.6181709,-0.7666295,-0.8463509,-0.9868244,-1.3432232,-3.4136229,0.39344326,-0.08935177,0.45380676,-0.52711934,0.18710725,-0.27707046,0.25194243}},
      {{0.07668608,0.1371502,-0.86239946,-0.7258287,-3.7903223,-3.7361479,-0.16106267,-0.30962908,-1.1095084,1.9066242,0.055208024,-0.5997705,-0.108716704,-0.15147737,-0.24485864,1.0191545,-0.44743115,0.05601176,-0.26099053,0.1306942,1.0611296,-0.22409801}},
      {{-0.6494079,-0.046809267,-0.053428028,-0.48374254,0.07466555,1.0727646,-1.0431184,-1.5411923,-0.7017128,0.13100271,-2.1536777,-1.3182925,-0.4382592,1.1369712,0.59909356,0.22913246,0.5910272,-0.5911229,-0.0025121383,0.45057037,0.87108743,-2.5724063}},
      {{0.9661673,-1.4334419,1.2259401,-0.6027493,0.24475846,-2.102893,-0.44716907,-2.14592,-0.62192386,-0.9244251,-1.6557214,-0.100609526,-2.2405765,0.22930646,-0.26701307,0.22470666,0.4075519,-1.4003243,-0.7138287,1.7166095,-0.4169804,-1.4205177}}
    }};

    h2_out = {{
      {{-0.8516022,1.1798576,0.2569856,-2.8790932,-1.1551298,1.057991,0.8282024,-1.9427075,0.5778272,-1.5002315,-0.09801605,0.75273365,-0.5074956,-1.4369851,-2.285521,-0.031044612,1.6218591,2.9169283,-2.83364,-3.5548232}},
      {{-0.837784,2.341366,-1.2843512,-0.76795805,-0.7889235,0.42788208,-0.332034,-1.790991,1.0244633,-2.2667012,0.50627613,1.1006583,-0.730998,0.18911941,-2.8546307,-0.30066997,1.1461276,2.9825363,-2.5683448,-2.6432898}},
      {{0.32142106,2.347249,-1.0483273,0.87972283,-0.57862765,0.634312,-1.0659518,-2.9463074,0.96380657,-1.8870906,0.38002473,-0.6244521,-0.8978853,0.80220675,-1.6923666,-0.56892055,1.6208298,1.6361294,-2.248493,-1.0823785}},
      {{0.47693047,2.8898852,-0.46982333,0.48703825,0.36239117,-0.09044165,-0.05849146,-2.7192476,-0.665896,-1.5301654,0.3452868,-0.772807,-0.025192115,0.44531044,0.5886937,0.1397575,1.0674753,-0.19057457,-2.3990006,0.6775441}},
      {{-0.10289799,3.3304894,0.13489518,-0.23511758,-0.0038652804,0.7353563,-1.799667,-1.4829019,-0.8861076,-2.957247,-0.23530729,0.22366089,0.79613966,0.291999,0.7584151,-0.63302314,2.7540238,-3.0330527,-1.0026975,1.0207801}},
      {{-0.7982369,1.7701784,1.258889,-1.0907258,-1.1794449,0.7260061,0.066071,-0.48634067,-0.5337709,-4.4364486,-0.7297275,1.0947522,1.4130534,0.046652317,0.69630677,-1.6499009,2.3738105,-3.4891865,-0.013257468,0.20774709}},
      {{-0.8946995,1.6517689,1.3260931,-2.5684693,-1.5988233,1.0468107,-0.16689704,-0.08459549,-0.5325914,-1.8855685,-3.17316,-0.29370677,1.46987,-0.8917995,0.99187493,-2.2872086,1.5437188,-4.143806,-0.08605207,0.2485909}},
      {{-1.9647584,-0.66372,0.78979903,-2.5718203,-0.5730649,1.2530237,0.11307968,-1.1209061,-0.23823632,-0.43531027,-0.16337708,1.0628601,0.37228546,-2.1650522,-2.7363415,-0.34299028,0.9760362,2.7728934,-1.3799353,-4.3144917}},
      {{-1.2060591,-1.0620319,-0.1253806,1.6370971,-0.64814776,-0.021374641,-0.37553698,-1.2685057,0.4169535,-0.79562545,0.6114944,0.8709643,1.1550423,-0.8747566,-2.8862236,-0.25285262,-1.2112,2.9148622,-2.794755,-2.6954618}},
      {{-0.6608152,0.6403281,-0.17111477,1.4027897,0.007067199,0.21111482,-1.1851149,-2.225039,0.45115772,-0.44399774,0.5925416,0.045445677,0.7137647,0.6269804,-2.0655153,-0.9391886,-0.20910028,1.7802333,-2.0096347,-0.8365066}},
      {{0.42798078,1.0134218,0.37807274,1.9029942,0.47776923,-0.30769184,-0.56635964,-1.9050838,-1.1788222,-0.951481,0.23560248,-1.0235574,0.58765715,0.7545638,-0.5489653,-0.11445927,-0.1498236,-0.20682274,-1.4283195,0.59634054}},
      {{-0.63158995,0.9342339,1.2021759,1.059642,-0.34789324,0.5712188,-1.5450383,-1.1641842,-0.81031847,-0.64851445,-0.94419575,0.3292249,1.1687071,0.73311347,-0.06074902,-1.0891118,0.54714125,-1.7325761,-0.2860507,0.6087175}},
      {{-0.70749295,0.008446693,1.9285307,0.48618767,-0.6531774,0.34827796,-0.6599116,0.0068719345,-0.86960083,-1.6548349,-2.2505698,1.1333185,1.2339436,0.15187122,-0.07726192,-1.6991242,0.36577755,-2.2172852,0.8849807,-0.33880684}},
      {{-1.7342939,0.5806539,1.8016864,-2.3447852,-1.049337,0.8057447,-0.4090912,0.080658816,-0.8779933,-0.7867739,-6.5801864,0.42305446,1.4397237,-0.7374446,0.2430046,-2.4581037,0.7912137,-3.1873307,0.9912473,-0.36007464}},
      {{-3.6559548,-0.9204241,0.36930308,-2.224202,-0.6274866,0.40494353,-0.28867957,-0.50988454,-0.32375658,0.2500887,-0.23764008,1.3661655,0.31114888,-4.0687046,-2.030097,-0.72619474,1.114028,2.117629,-0.32578883,-2.6507838}},
      {{-2.2444756,-0.57119256,-0.48653454,0.043592602,-0.50215536,0.18160562,-0.52590007,-0.5793556,-0.017056787,0.08866903,0.75197613,1.2404591,1.09981,-1.4418277,-2.5548813,-0.36584017,-0.68230176,2.0879834,-0.6440302,-2.9634366}},
      {{-0.21045966,-0.37957695,-0.2788435,0.43070394,-0.27228692,-0.25945088,-0.49736023,-0.98583144,-0.054255195,0.32318854,0.6783205,-0.15977159,1.0571675,0.3709057,-2.1917853,-0.00057867693,-0.3858316,1.1618127,-0.6480511,-0.4318832}},
      {{0.45786932,0.4009692,0.390667,0.42340434,-0.013258627,-0.4913941,-0.12138588,-1.3386471,-1.218742,0.3002139,0.29720783,-0.9348696,0.579597,0.71562445,-0.4071681,0.11222709,-0.6080748,0.15158828,-0.1179645,0.57368827}},
      {{-0.21197614,-0.27968362,0.99990517,0.97523814,-0.23814408,-0.18577693,-1.3160595,-0.30467644,-1.0736369,0.17811503,-0.87784725,0.25686315,0.6816011,0.7617668,0.009762211,-0.3943334,-0.10544573,-0.61715883,0.34701765,0.51422364}},
      {{-1.4245458,-0.025573837,1.8789881,-0.17431349,-0.6977763,0.16145898,-0.44484308,0.15105486,-1.3413073,-0.20733394,-3.1731877,1.2766447,0.5585881,0.24463627,0.35779023,-1.4945998,-0.11816377,-1.6452112,0.6532616,-0.99724394}},
      {{-3.1511557,-0.32651976,1.616222,-1.8015574,-0.76894164,0.5499237,-0.5126425,-0.0037576419,-0.7500663,0.1679042,-7.333051,0.79426634,0.6955088,-0.3067262,0.7160149,-2.221669,1.0720545,-2.0135624,0.78699595,-1.5383568}},
      {{-2.669559,-0.41789734,-0.1521238,-3.1935685,0.31070536,-0.062739156,0.64472616,0.120728135,-0.115349315,0.3268929,-1.0099205,1.09343,0.31826332,-6.5917153,-0.8097049,-1.6913368,1.9908944,0.28020212,0.7966905,-0.03686027}},
      {{-1.4095536,-0.055271685,-1.931272,-0.15671484,0.15643324,-0.5452713,-0.45624077,0.03025043,0.0480996,0.3788895,0.77140194,1.4037539,0.67736727,-2.4776404,-1.1704327,-0.2965856,-0.51279384,0.6013651,0.7477452,-1.743589}},
      {{-0.78799796,0.18235858,-1.4342786,-0.8991548,0.20411563,-0.52076405,0.42682168,0.027481789,-0.13227598,0.43811166,0.70182383,0.0918936,0.56363785,0.066538446,-1.1724979,0.053348303,-0.34168637,0.6114876,0.5826058,0.012457848}},
      {{0.4697732,-1.0310249,0.11097962,0.66707593,0.9307218,-0.4066761,1.5724311,0.16467957,-0.772539,0.36356246,0.37021142,-0.6602224,-0.31995913,0.5220254,-0.29231673,0.5015405,-2.2423525,-0.28870255,0.49063239,0.61164033}},
      {{-0.76939154,-0.13761716,0.99727875,-0.028635997,0.11439731,-0.51351714,0.28834334,0.12867253,-1.2258744,0.35424566,-0.7405624,0.24252966,-0.64314973,0.6084586,0.5242143,0.1915221,-0.32643846,-0.18491,0.77696663,0.33760583}},
      {{-1.723089,-0.39304772,1.5834278,-0.10851648,0.35506138,-0.2843882,0.027403412,0.090907246,-1.1326004,0.3026687,-3.7674315,1.3149475,-0.8994382,0.19846529,0.85711616,-0.70516783,0.12053633,-0.5235245,0.79435277,-1.6270897}},
      {{-0.91813236,-0.6291218,1.8016778,-1.8530996,0.24650547,-0.09380201,0.38264012,0.10877939,-0.8235074,0.32767147,-7.6819577,0.7152853,-0.76363695,-0.76934683,0.5223865,-1.0113398,1.3112742,-0.36956415,0.8220057,-0.9509051}},
      {{-2.883339,-0.15051943,-1.5946788,-2.9215474,-0.37857398,0.794776,-0.96913147,0.37502015,0.23443446,0.032613397,-0.7141577,1.1888703,1.0955569,-4.5345955,0.37369758,-2.4764464,1.5766871,-0.99421704,0.8792104,-0.8222028}},
      {{-1.4019951,-0.6099678,-2.1561236,0.08810697,-0.39392865,0.027377557,-1.1449841,0.49773985,0.6785709,-0.25951353,0.77772456,0.89987046,1.1131892,-2.0913613,-0.0009933794,-1.4234408,-0.6466576,-0.724089,0.6938556,-0.96665466}},
      {{-0.35693395,-0.67219335,-1.812014,0.5116155,-0.24872251,-0.18034945,-1.3710829,0.45644656,0.565477,0.044908177,0.6561226,-0.87191725,0.62122524,0.04545484,0.4182256,-0.1894342,-0.2399565,-0.1978724,0.16781,0.28937784}},
      {{0.52279687,-0.56012815,-0.77156,-0.24529584,-0.56034285,-0.4159667,0.6770311,0.3728167,0.12495372,0.13376705,0.38340425,-0.31515917,-0.5466267,0.39392975,0.69735557,0.63915837,-0.66361517,-0.1240737,-0.19526999,0.603239}},
      {{-0.008300917,-0.57865006,0.05026492,0.68028265,-1.5152962,-0.32300207,-0.015073063,0.31020677,-0.25729045,0.17617044,-0.52074677,0.3546628,-1.1833373,0.50325173,0.8706843,0.7576086,-0.25771675,0.15883479,-0.36329916,-0.30222154}},
      {{-2.410891,-1.0231144,1.0850304,-0.13040274,-1.1511196,0.23867041,0.16839695,0.27556843,-0.6089957,-0.073365904,-2.65263,0.99723047,-1.6597966,0.3027274,0.83319366,0.33213472,0.12787844,-0.06105065,-0.0058098743,-2.7227824}},
      {{-2.3616457,-0.49593076,1.8397384,-1.9124844,-1.3287146,0.5360689,0.051126298,0.3687246,-0.56862056,0.1367964,-6.374023,0.23461209,-1.9263151,-0.7003321,0.39019662,-0.2128462,0.49254143,0.22526498,0.14794329,-2.505544}},
      {{-0.862944,-0.54139674,-1.1670622,-2.5394022,-0.38059312,1.1987411,-1.234333,0.5856636,0.8418013,-0.57965153,-0.7363941,-1.2896237,1.0558205,-2.0188055,0.90297484,-2.6492536,1.1526842,-2.0701067,0.63605624,-0.40867907}},
      {{-0.48218584,-0.4364641,-2.0292845,0.03949353,-0.2876046,0.1858722,-1.0324756,0.63363385,1.2378894,-1.6494477,0.6993339,-0.17284545,1.0112106,-1.6257277,0.78512895,-1.6575797,-0.12694204,-1.1322373,0.30241224,-0.27620423}},
      {{-1.1396633,0.64514416,-2.554349,-0.18685971,-0.4700858,0.3332721,-1.2133008,0.6306492,1.4419026,-1.6363746,0.6814422,-0.43930238,0.20124182,-0.058140572,1.2129325,-0.36398563,0.49954957,-0.9490386,-0.69609314,0.5003662}},
      {{0.54747885,-0.13850021,-1.3903306,0.5306858,0.2829504,-0.32430995,0.16612712,0.39993584,1.546797,-2.1032422,0.28589082,-0.30290166,-0.7871976,0.4565263,1.2015247,0.53907436,-0.33662376,-0.041079108,-1.5741321,0.58646613}},
      {{-0.6254003,0.2744813,-0.16399385,0.061809365,-1.3845214,0.20975284,-0.21042252,0.19542389,1.0091497,-0.59662795,-0.33085853,0.46228424,-1.7556553,0.16897728,0.8128019,1.1923567,0.38382387,-0.062282432,-1.7082256,-0.28090748}},
      {{-1.1440183,-1.0904546,0.35120708,0.4521425,-1.5031196,0.25846756,0.2458701,0.031711854,0.37801567,-0.854746,-1.9826692,0.7872525,-1.5208554,0.13622119,0.45486662,1.0687273,0.33526635,0.7512316,-1.2753148,-2.8487365}},
      {{-2.2211332,-0.21171896,1.3090256,-2.195628,-1.5088762,0.791468,-0.070372045,0.2889677,0.27141598,-0.4236944,-6.0574636,0.55133337,-2.03596,-1.1858982,-0.18245259,0.6922072,0.6721645,1.193126,-0.40405247,-4.6877356}},
      {{-0.608835,1.2327744,-0.8859585,-3.2377675,-1.3229573,1.1894357,-0.29227018,0.37325263,0.8518053,-2.038917,-1.0142375,-1.0325204,1.3086029,-1.5508592,1.3054532,-3.3718665,1.3338442,-2.8019328,-0.47634092,0.14226282}},
      {{-0.8240691,1.8947827,-1.6696402,-1.2210222,-1.1157452,0.66293824,-0.5421259,0.36858243,1.9264845,-3.454783,0.71857125,0.3030626,1.075026,-0.7483735,1.1367209,-3.1913037,1.3100711,-2.3521488,-0.2332196,0.1581982}},
      {{-0.45077083,2.0430436,-2.7340217,-0.7736689,-0.98784906,0.39324528,-0.40220493,0.017106479,2.4947848,-3.1662354,0.64634967,0.3162048,0.30699673,0.07545723,1.3603538,-1.3618598,1.565452,-2.450157,-1.1998758,0.6484122}},
      {{0.49247885,1.8098123,-1.3966498,-0.47049722,0.3233395,-0.2480682,0.29233286,-0.19311553,1.5257895,-2.604226,0.31208277,-0.6002892,-0.92778105,0.45643285,1.3006077,0.50245285,-0.09716853,-0.2676599,-2.2089052,0.64523286}},
      {{0.118760094,1.0631975,-0.49025565,-0.08992891,-1.3092262,0.37924266,-0.08406253,-1.4305215,2.3653758,-1.264058,-0.103240386,0.48030564,-2.4600792,0.24395236,0.2696943,1.1743243,1.1907555,-0.07115891,-3.0064538,-0.53457034}},
      {{-0.76297563,0.711832,0.11904558,-0.77342474,-1.3034573,0.82915527,0.3794293,-1.4468334,1.1965168,-1.7433237,-0.20879324,0.7923177,-3.1380882,0.17181753,0.37421384,1.2097543,1.6699406,0.89684135,-2.5489779,-2.8161685}},
      {{-0.84383595,1.0033993,0.475188,-2.0203085,-2.176719,0.9008957,0.93373895,-1.3007153,0.8628526,-1.526771,-2.9601698,0.6001929,-2.62092,-0.9614624,0.30821288,0.8667064,1.3888488,1.7549518,-2.2498112,-4.284054}}
    }};

    b1 = {
      0.25037968, 0.20290712, -0.14665881, -0.097073704, -0.09537996, -0.26547962, 0.1852267, -0.04062838, 0.043810792, 0.06433547, -0.106621444, 0.07315848, -0.7555203, 0.06782503, 0.2738684, 0.017697485, 0.08004558, 0.278652, -0.060108576, 0.119503886, 0.03450433, -0.26751947
    };

    b2 = {
      -0.10467441, 0.12805368, 0.041697744, 0.20703486, 0.37542754, -0.39945957, 0.5803619, 0.38249627, 0.00668683, 0.2954078, 0.0092570335, -0.098720424, 0.149598, -0.008199046, -0.008609336, 0.033255234, 0.035713375, 0.05660845, -0.06463953, -0.06773267
    };

    bout = {
      -1.5766156, -1.5908558, -1.3749468, -0.29592824, -1.4281673, -1.6792608, -1.7307222, -1.8491104, -0.8940479, -1.2062845, -0.13102682, -1.1630563, -0.9014956, -1.9119219, -1.5035698, -0.86073154, -0.2505247, 0.21771237, -0.3277551, -0.935398, -1.375363, -0.32427156, 0.12973723, 0.5346066, 3.0567946, 0.53212774, 0.09023313, -0.2699642, -1.4399382, -0.88366497, -0.4557406, 0.37767008, -0.13624774, -0.8468824, -1.4928576, -2.100769, -0.9926303, -1.1853242, 0.01678002, -1.0019144, -0.7672894, -1.9140166, -1.8175912, -1.4778086, -1.1241914, -0.28862274, -1.147943, -1.5234417, -1.6648493
    };

    BN_gamma_in = {
      0.8995106, 0.66539246, 0.47651684, 0.9409052, 0.41777682, 0.046827137, 0.8148426, 0.0806784, 0.9291468
    };

    BN_gamma_1 = {
      1.5100473, 0.9562662, 1.4342498, 2.2327135, 1.9428202, 9.958758, 2.3356159, 1.9669002, 1.6185226, 1.2164754, 2.8850148, 2.2082627, 5.1207967, 3.0073895, 2.5938723, 1.8141811, 1.2598965, -0.8885732, 2.0888603, 1.2518244, 2.2383912, 2.1325324
    };

    BN_gamma_2 = {
      2.9595573, 2.4626846, 3.560774, 3.1347895, 1.994193, 0.59177065, 1.5345258, 1.7901393, 4.5392523, 2.081823, 4.4443493, 3.7928963, 3.0128634, 3.4512463, 4.3280087, 2.8201296, 3.2710502, 3.3617022, 1.8835101, 2.450564
    };

    BN_beta_1 = {
      -0.23811659, -0.14072095, -0.045969617, -0.04643639, -0.017391173, -0.0067008594, -0.13896663, -0.04526953, -0.0021633774, -0.1856221, -0.013936011, 0.009455897, -0.008604021, -0.009349757, -0.019795083, -0.06446277, -0.027566738, 0.16940106, -0.09743286, -0.1687296, -0.20903376, -0.10504393
    };

    BN_beta_2 = {
      -0.0039091944, -0.42179474, -0.13110188, -0.51768297, -0.6468897, -0.2759219, -0.8774392, -0.60889864, -0.3610158, -0.510652, -0.041114777, -0.08560129, -0.34603146, -0.08940286, -0.12638412, -0.122308515, -0.24874416, -0.14936818, -0.00944832, -0.030326314
    };
    
    mean = {
      29223.407471849445,14600.866951919108,29272.94240117182,19967.266976795985,1949.4444331751229,19901.714578699426,29096.248171432053,14316.884561710473,28959.737572092774
    };

    stdev = {
      256918.02596158953,160146.3650539718,254317.1246141321,173304.28343234913,32061.73544897406,172500.7364158194,254675.7830968622,159638.17007219797,255961.73313993638
    };
  }
  
  else if(m_pcEncCfg->getQP() == 37){
    
    embs0 = {{
      {{0.36393175,-0.18379894,-0.39901334,0.2912875}},
      {{-0.027204165,0.0077965306,-0.0022674715,0.001978377}},
      {{0.0015339421,-0.0036499132,0.0008495905,-0.0028492087}},
      {{-0.107254066,-0.029625492,-0.0036648754,-0.4469403}},
      {{0.048342627,-0.0047914325,-0.003935941,0.011513743}},
      {{-0.04515327,0.026933467,0.06519415,-0.51191497}},
      {{0.109393135,0.05980036,-0.036786687,-0.013460068}},
      {{0.23038846,0.18571675,0.12578455,-0.026511937}}
    }};

    embs1 = {{
      {{-0.28989965,-0.014653772,-0.33447832,0.3683553}},
      {{-0.030974856,0.0036761507,0.009362312,-0.0027551295}},
      {{0.005889704,-0.002720862,0.0010654905,0.0007868455}},
      {{-0.108049676,0.012697107,0.02183108,0.45413005}},
      {{0.05303175,0.0036646074,-0.0278418,0.0034900417}},
      {{-0.03742066,-0.082056165,0.11272029,0.5231986}},
      {{0.05860017,0.026328323,-0.10195023,-0.0052708345}},
      {{0.057669833,-0.13226953,-0.27609038,-0.011573204}}
    }};

    embs2 = {{
      {{0.39247078,0.0030786395}},
      {{-0.0023249446,-0.000120137345}},
      {{0.0027517597,0.00043203717}}
    }};

    embs3 = {{
      {{0.10268888,0.029708982,0.23102316,-0.03530106,0.081202716,0.015424222,0.0025234818}},
      {{-0.00047972842,-0.0021726897,-0.00208782,-0.0020600718,-7.429629e-05,-0.0015670868,0.0010945061}},
      {{-0.007843931,0.009013135,0.0036037085,0.0026856975,0.000992898,0.0003629158,-0.0038629156}},
      {{0.0035869963,0.000767126,-0.0053727585,0.0026228635,-0.0018186393,0.0014087788,-0.0018217665}},
      {{-0.008341866,-0.013576658,0.008607539,-0.0029838835,-0.010760943,0.003184871,-0.007387267}},
      {{-0.07341365,-0.38021407,0.020453744,0.079827346,0.027721575,-0.09583622,-0.02703484}},
      {{0.016384011,-0.0043898085,0.022200285,-0.006958523,-0.010138469,0.0040940233,0.01692208}},
      {{-0.02788668,-0.41054812,0.035153385,0.09981965,-0.0065793083,-0.057134885,0.015171165}},
      {{0.025953948,0.010417487,0.036877077,0.05900361,0.024130218,-0.026737321,-0.0066331644}},
      {{0.019705458,-0.41399407,0.000456227,0.10956132,0.015462769,0.11930711,0.00018541086}},
      {{-0.010908587,-0.010082275,-0.010168153,0.0063654752,0.04819729,-0.023447588,0.026616072}},
      {{0.0575266,-0.39684352,-0.001485345,0.11158825,-0.032845017,0.060277984,0.102036335}},
      {{0.081493765,-0.029065195,0.020778019,-0.04927019,0.049457043,-0.0430142,-0.050065603}},
      {{0.014515806,-0.035487767,0.04908475,-0.049491376,0.15589805,0.10430638,-0.086850055}}
    }};

    in_h1 = {{
      {{0.2315887,-0.029158996,-0.19147983,0.06865676,0.10484667,0.17407711,-0.18508728,0.008132608,-0.010482944,-0.09527061,0.07592507,0.03197094,-0.019334149,0.09091007,-0.05679117,-0.054297727,0.04528052,-1.9237632,-0.35133934,0.9978527,-1.1705557,-2.0814295,1.6181805,-0.9103609,0.60336465,1.2847}},
      {{0.09821231,0.03062587,-0.037361927,-0.014712958,0.108950995,0.0287107,-0.081779465,-0.009889434,-0.0063070823,-0.05890246,-0.023880068,0.0093342615,0.013596055,0.017683318,-0.0027313589,-0.025344156,0.00071689894,0.26781964,-0.27707484,0.2823546,-2.6744742,0.08186145,3.9375548,0.16802053,-0.34945387,0.40430522}},
      {{-0.85438097,0.7432082,0.5227159,0.84428006,-1.5659673,-0.14293179,-0.12166258,-1.7964195,0.097262114,0.10313799,0.15329787,0.99922675,0.069288276,-0.21281226,-0.38730133,0.39358276,0.027452813,0.35992795,0.3784945,-0.61084354,0.25509194,-2.6056743,0.77696747,-0.030406851,0.2745871,-0.12884969}},
      {{0.02225997,-0.014240019,0.02706643,-0.01186044,0.033034623,-0.026804842,0.0057530547,0.0030759214,-0.023733258,0.022040272,-0.04797759,0.0013229979,0.0014689039,-0.027228173,0.017756615,0.013249771,0.046190836,-0.1925367,2.6539903,-0.053329296,0.13233818,0.17633733,0.037118506,0.03440482,-2.7841315,0.07276634}},
      {{0.7494126,-0.102968946,-0.13806689,0.11752958,0.62362164,-0.17947078,-0.26110783,-0.21706495,0.08539258,-0.08985128,-0.042741418,0.28182274,-0.025007302,-0.12242859,0.14604074,-0.19738427,0.18625878,1.6090615,0.50298476,-0.12562053,-1.3822592,0.07794812,-0.8441823,-0.60447824,1.1302675,0.35216826}},
      {{-0.50630146,-0.19513136,-0.17647338,-0.10109229,-0.2632144,0.10223911,0.48082078,0.05319252,-0.022418812,-0.014691861,0.038752537,-0.17553864,0.010671335,-0.053558253,-0.10151204,0.01578574,0.03909082,-0.9650669,-0.42519724,0.64176095,1.0184066,2.291814,0.68105996,0.07511251,-0.393442,-1.2928525}},
      {{0.0778452,-0.08109842,0.035758246,-0.03880524,0.08091571,-0.048593067,0.027160328,-0.008784604,0.036304016,0.1448737,-0.019320048,0.024085712,-0.055735365,0.057256337,-0.052513734,0.029318219,0.047243625,0.58282834,0.022747716,-0.4113802,-0.80005527,0.3584645,1.2321332,-1.4910731,-1.3025986,0.85126483}},
      {{-0.055418823,-0.08592569,0.010870615,0.04362259,0.061920874,0.08490276,0.1744014,0.00065058365,-0.03650423,0.22232793,0.19114996,-0.06184324,-0.043348268,-0.10963344,0.16019627,-0.0004362282,0.033627715,2.0592737,-1.1627922,-0.5458519,1.5133044,0.2011456,-1.5793871,0.21325076,0.36636943,-1.6632888}},
      {{-0.016668968,-0.02271894,0.039346673,-0.10871938,0.10782881,0.015209661,0.007382214,0.17270112,-0.077987984,0.06273062,-0.03917814,-0.07971598,-0.1562288,-0.094907865,-0.050549354,0.15274736,-0.10007941,0.19406213,2.3711596,0.48390287,-0.5723111,-1.6329037,-1.6379681,0.23449752,1.6040273,0.57417226}},
      {{-0.032380406,0.029608035,-0.011028337,0.0016652668,-0.06516007,0.038602952,-0.013233054,-0.15595345,-0.019611945,-0.25330994,-0.016383795,0.083543755,0.006275077,0.06567998,-0.03696997,0.0075150295,-0.027321223,0.41360956,1.2183639,-1.6317562,-0.31713873,0.23357075,-1.8754544,-1.5660049,0.856502,-0.05918269}},
      {{-0.24842061,-0.34707198,0.06886975,-0.0477457,-0.13141805,-0.0435996,0.61918,0.21933863,-0.08448391,0.35991985,-0.009143687,-0.10957059,-0.07678388,0.023550201,0.15134284,0.07753936,0.034153577,0.68710685,0.89474654,-0.5103328,0.07337231,-3.287812,-0.030051593,0.28286636,0.66961133,0.13913803}},
      {{0.6373997,0.21117106,-0.20176472,-0.030216176,0.6187249,0.07339795,-0.5116383,-0.13376316,-0.030057274,-0.2616777,-0.0957003,0.14199252,-0.08660165,-0.048333198,-0.0429151,-0.20948331,0.07570554,-0.30831018,-0.09255655,1.7985609,1.5178416,-0.4646027,-1.9487919,-0.07933631,-0.074253894,0.030204754}},
      {{-0.0032176329,-0.0015119505,-0.0021658484,0.012046586,-0.0017943087,0.009042872,0.0011517968,0.01649699,0.00083797856,0.03490335,-0.0022599588,0.0014246843,0.00090469915,-0.001159477,-0.00025955678,0.0012511791,0.0006568552,0.79150784,-0.5875589,1.2036844,1.5424247,-0.52250034,0.8322436,1.3571068,-1.2700384,0.98255724}},
      {{-0.03531838,-0.13846782,0.10820004,0.09715369,-0.1145203,-0.09721313,0.13937782,-0.114959694,0.030775433,-0.03198919,0.0007540199,0.12421018,0.046351492,0.05055574,0.030582402,0.05823094,-0.002845756,-1.3227123,0.7834532,1.2606685,-1.831025,0.123524025,1.0410808,1.558346,-0.38418022,-0.7872615}},
      {{0.18835133,-0.015550018,0.007019339,0.022548286,0.20645142,-0.025551967,-0.10429174,0.033211872,0.008727289,0.45153713,-0.04465348,0.02742238,-0.0084885,-0.060250103,-0.012962348,-0.059568845,0.04476531,-1.7656937,0.54579747,-0.60767174,-1.070307,0.32272372,-1.0751858,-0.5211778,1.1993394,-0.91864145}},
      {{0.07696633,-0.14550224,0.063332416,-0.0076906113,0.11102692,-0.08731302,0.06691277,-0.021552535,-0.003972519,0.0049116695,0.001661353,0.0045099943,0.0077572083,-0.042392526,-0.0034035305,0.0312652,0.009926956,-1.1920981,-0.74647987,-1.2157112,-0.828065,-2.272397,-1.3410017,-1.6552914,-1.4519782,-0.8397019}},
      {{-0.00019758644,0.004379987,0.012503317,0.0017358087,-0.0011299382,-0.004514545,-0.0006362769,0.005858215,0.00923095,0.019508893,0.0035395988,-0.0028884122,0.006138972,-0.00745012,0.0076057734,-0.008230151,-0.0076109534,1.104925,-0.081759706,-2.162319,0.23307014,0.18872656,-0.7942862,-1.0577899,-0.3915579,1.8151907}},
      {{-4.826527,-2.6499534,-0.57224643,1.398486,-2.9308975,-0.57831246,4.7992992,0.34777907,0.1828892,0.010106362,-0.07973907,-0.7081418,0.039444856,0.58258754,-0.75042224,0.24955954,0.55428666,0.4545433,0.14924884,0.6949177,0.07627276,1.3697706,0.41423166,0.06991254,0.7239522,0.33722764}},
      {{0.07255033,-0.19134055,0.077789195,0.06740896,0.1342545,-0.038352102,0.11738832,-0.07216922,-0.029631266,-0.021144256,-0.0051477146,0.04582992,-0.0057759746,-0.089946315,-0.021541975,0.022599857,0.0041112835,-0.2625536,0.5774494,-0.25394616,0.6211464,-5.0689273,0.7815639,-0.0031614008,0.24053563,-0.018398525}},
      {{0.065163,-0.004274912,-0.0027676127,0.020704493,0.050072562,-0.025437983,-0.014958674,-0.12493999,-0.002087672,-0.02181428,-0.0063649723,0.037896797,0.007290721,-0.016259545,0.013119967,-0.018318703,0.002206233,-0.29153955,-4.058643,-0.23935544,0.9708222,1.6257517,1.152273,-0.3987843,-1.2384511,-0.1678953}},
      {{-0.012110348,0.023316585,0.0033365856,0.00016865223,-0.010539051,0.013608655,-0.002198587,0.016443143,0.018840848,0.015600895,-0.008488993,0.0028154177,-0.007156555,-0.0032864565,0.012215032,0.020493113,0.013056447,0.2435598,-0.3619508,0.37176797,-0.60158354,-0.29470235,6.0629725,-0.103754066,0.10698863,-0.042344194}},
      {{-0.00010553499,-0.028402487,-0.0012398149,-0.04291256,0.017469773,-0.02123071,-0.00015254143,0.03555907,-0.0079314,0.11794613,0.05527854,-0.035654504,-0.015455876,-0.033579998,-0.031902924,-0.015101757,0.03425297,0.14223832,-2.7417626,-0.074320406,-0.473826,0.22472952,0.589902,0.18598817,1.6918628,-0.09709099}}
    }};

    h1_h2 = {{
      {{-0.047000784,0.0400449,0.090863734,0.069636226,-0.904938,0.11241439,0.40414456,-0.21489817,-0.040838283,-0.16453579,0.015656512,-0.45961937,-0.06054565,-1.1911793,0.13514474,0.12554914,-1.0064664,-0.04897467,-0.42565992,9.7265005,-0.14600447,0.1304184}},
      {{0.76024574,0.7003956,0.07542196,0.14665487,1.253106,-2.6890082,-1.5428865,-0.5128352,-0.3624967,-0.99110794,1.7088646,-0.2385024,0.4364935,-0.7908812,-0.9747602,-1.307973,-0.5696778,-1.310173,0.31730512,-0.5089179,-0.9094775,-0.070583306}},
      {{0.117161244,-5.4430184,-0.55582094,0.01500854,-0.104033776,0.29253298,-0.56823736,-0.3594174,0.18719338,-0.39456382,-0.34948334,1.1725031,0.17076501,-0.6384649,-0.6918855,-1.7186414,0.12794155,-0.13621604,-0.055577885,0.6087391,-0.964476,-0.0032658319}},
      {{0.07648364,-0.26161915,0.1246655,-0.16652642,-0.8099511,0.21021387,-0.27417135,0.05754843,-0.35708854,-1.4104486,0.33369288,0.9595243,-0.055611137,0.26920748,0.7534962,2.7096782,-7.397104,-0.10583201,0.20335181,0.19807523,-0.35963264,-1.100061}},
      {{0.7333197,-1.917295,0.26478818,-0.20923436,-0.09411729,-0.19783665,-1.1142172,-1.2556196,-0.19689728,-0.50295734,0.02081025,1.4425155,-0.11700883,0.9218087,-0.65435666,-5.479542,-2.929256,-0.2218498,0.72161645,-1.1269599,1.5605298,0.037010726}},
      {{-0.25060758,0.03329105,0.23270413,-5.11194,0.9623423,-0.33796,0.121729486,-0.23894714,-0.14989431,0.010123882,-0.47950354,0.21143675,0.09395548,0.18341225,-0.611617,3.3695855,-0.10809514,-0.17002319,0.5024656,-3.9829228,-0.19827709,0.5803314}},
      {{-3.0008588,1.3293182,-0.9550487,-0.111313336,0.33310893,-0.393173,0.34731427,-2.9320862,-0.037996896,-0.3935322,-0.41828406,-1.7436265,-0.12773979,0.7662522,-1.5515271,-1.8240851,-0.6039646,-0.40069428,-2.502872,-0.013132396,0.79541004,-0.15877827}},
      {{1.9716977,-2.1976578,-0.2233007,-0.18550932,-0.9010826,-0.4282073,-0.43079934,-0.109617285,0.20793557,1.9695925,-0.0688093,0.49999213,-0.21409659,-0.71816075,1.2305236,2.4723318,-0.117564194,-0.8426289,1.9319874,0.17935081,0.7372928,-0.47971994}},
      {{-0.38025144,-1.456446,-0.072518885,-0.17132439,0.8961027,-0.22161119,2.147074,-0.87244254,-0.35318393,-0.12020225,0.19599847,-0.08816166,0.38766557,-1.3517206,-1.5346212,-0.40431413,0.18840201,-0.084731445,-0.9585215,-0.42647535,-1.002713,0.0053289128}},
      {{-0.45727047,-1.9551803,0.06018071,0.08836555,0.07236747,-0.012729144,0.58917534,-0.23203826,0.14853974,-0.6585687,0.17672394,0.509871,0.18913245,-0.8949133,-0.31815425,2.6146102,-0.069498464,-0.23690611,0.06172449,0.9986754,2.1564043,-0.0053199385}},
      {{1.5775216,0.10857174,-0.35162368,0.073496416,-0.0867526,0.023511559,1.0493417,1.9920878,0.5826227,-0.73366094,1.5456883,0.86503404,-1.1579015,0.83480096,-0.5017158,-0.76231146,-0.56254977,-2.0327764,1.1479145,0.67360467,-1.0283833,-0.35667634}},
      {{-0.002147084,0.07011607,-3.500984,0.8828883,-0.94755584,0.56451184,-0.049437635,0.19495898,0.6155174,0.19789605,-0.014504077,-0.085718185,-0.023375304,-0.3151062,0.5808839,-0.20656326,0.07437851,-0.27031523,-6.875774,-3.4444056,0.1725169,0.7723014}},
      {{1.8984481,-0.50024444,-0.10497621,-0.18145247,-0.21023321,-0.39658815,-0.46128818,0.5843173,-2.4039245,0.8517792,0.58101946,0.10416468,-1.0869751,-0.44385594,3.7740664,2.2721999,-2.7842646,-1.3006687,1.959069,-2.4239144,-0.25664532,-0.800107}},
      {{0.6474766,-1.2295943,-0.019852297,-1.5035225,0.19183792,-0.9088352,-0.48346764,-1.8421208,-1.6047274,-1.702608,0.30181774,0.72039986,0.023427723,-0.30804765,0.42304882,1.2043326,0.995664,-1.9178302,-0.3601132,-1.2608416,-2.1712353,-1.9245753}},
      {{0.19974528,-1.4555966,-0.08524456,-0.35147318,-0.25952378,0.029092258,-0.6748807,-0.05629394,-2.5947437,0.6450342,-0.115789965,-0.32392904,-11.056587,0.0023904087,3.2639775,0.74556386,-1.3012682,-0.2932062,-1.3670373,-0.4495847,-0.5598484,-1.0787972}},
      {{0.3639356,-1.3665795,0.049495798,-0.019291751,0.49791503,-0.41901404,-0.27056044,-2.3543043,-0.26998308,-1.1027149,-0.0063720564,0.14995122,0.7107009,-0.88916427,-1.1521916,-2.089219,-0.078637324,-1.1295388,-0.40117344,0.12362674,-0.17675345,-0.12547515}},
      {{0.31214005,-0.08270628,0.3144295,0.5977582,-0.45886967,-2.4791727,-0.18409827,0.15554604,-1.7567239,-0.41420153,0.88914835,0.50355804,-0.27438533,-2.2284021,-0.5781135,0.4592816,-2.078204,0.069230825,1.6017079,-1.1250117,0.56017584,0.47411886}},
      {{0.07217704,-0.0840459,0.14003074,-1.2542657,0.7317761,-0.07372341,0.10161175,-0.16978288,1.4700379,-0.21222888,0.78676194,0.38858813,-0.013903516,0.06801145,-0.2424237,5.767703,-0.14675528,-0.17702994,-0.1375425,-1.2238212,-0.054218937,-1.0954858}},
      {{-0.41709706,-0.2575493,0.080303356,-1.7788,1.5277718,-0.59095025,0.8056552,0.17683707,-0.61550176,-0.33136013,0.3835281,-1.3071761,-0.30402657,-1.8090029,-0.7655124,-0.91456723,-0.15915069,-0.17199461,-0.4831118,0.26967385,1.3171421,0.07722016}},
      {{-0.0064876443,0.04561822,0.010523472,0.6315176,0.51216215,-0.13801682,0.16365208,-0.36782452,0.2360094,-0.19000877,-0.43907315,-0.22282661,0.16305944,-0.16999067,-0.15280451,-0.7382266,-0.14249569,-0.16127506,0.003986967,-3.8047533,-0.22050014,-4.0874853}}
    }};

    h2_out = {{
      {{-1.3488911,-2.3254502,0.094656676,1.7570785,0.99178636,0.03734668,0.35941815,-3.115019,-2.8066595,-1.81119,-1.1587259,-0.104227535,0.37583235,1.103194,-3.511476,-2.1111007,-1.5327603,-0.505653,-1.9209046,-1.0082487}},
      {{-0.8092284,-1.5251689,-0.1432624,1.8729955,0.8449031,-0.2343383,1.1091479,-3.1370764,-1.8896561,-0.35802686,-1.5478073,0.5825802,-0.042658713,0.1213145,-1.8212687,-0.3137627,-0.07509559,-1.7600915,-1.410443,-1.7263758}},
      {{-1.0663538,-0.29689333,-0.25532705,1.2115941,0.8911407,0.033668097,0.69071174,-2.1700337,-1.4172518,0.014111671,-1.4202229,0.54814935,1.327349,-0.2527618,-1.6712867,0.8515279,-0.5970342,-4.6614056,-1.1865681,-2.325458}},
      {{-4.5687056,0.618692,-0.46304762,-0.0010564562,0.4430656,0.124632865,-0.3970758,-0.8016459,0.24045834,0.31765682,-0.3435838,-0.39791283,0.8432412,-0.9129011,1.0451838,0.85092896,0.23561996,-6.1567116,-0.07031444,-2.7003927}},
      {{-1.193735,-0.25526887,0.1313061,-1.3920571,-1.8357354,-0.21589482,-1.052194,-1.8077327,0.6573332,0.066179015,-0.9045095,0.36736274,1.7935587,-0.6090298,-0.9028434,0.95915157,-0.51738936,-3.815361,0.5549979,-1.7397021}},
      {{-1.1046906,-1.8176916,0.5079356,-2.0852213,-3.1839094,0.035421602,-0.6224357,-2.4160645,0.8887367,-0.30105934,-0.3388315,-0.09160102,1.1843383,0.7091672,-1.2853919,0.4015069,-0.3036288,-1.3124651,0.31252024,-1.029906}},
      {{-1.7706383,-1.1396239,0.16309382,-2.407639,-3.3779552,0.100617275,-1.6342887,-1.6722091,0.7995301,-1.8806307,-1.1115849,-0.45104507,0.94809234,0.786128,-2.8362343,-1.7255554,-1.7233387,-0.6051282,0.25000155,-0.2830823}},
      {{0.49152753,-1.4503584,0.228319,1.0823283,0.860508,0.4895505,0.6058661,-2.3889482,-3.245448,-2.9593663,0.37665132,0.18284243,-0.38293555,0.8529996,-3.5270352,-4.2458897,-1.2836958,0.05145789,-0.60879576,-0.50687855}},
      {{0.990838,-1.8006797,-0.27597183,1.4464811,0.73192537,0.28828073,1.2194098,0.1764802,-1.9642193,-0.7652982,-1.0081105,0.66265553,-0.5426994,1.2700776,0.90320396,-1.6467165,-0.49536487,-0.30977902,-0.24424075,-1.3633573}},
      {{0.2693848,-0.68055993,-0.36135206,0.9312611,0.5067615,0.4121448,0.709939,-0.11361721,-1.2849824,0.1422411,-1.2097371,0.69484293,0.16067034,0.6964496,0.114549085,0.33459023,-0.6590422,-1.5329937,0.07143338,-1.4660667}},
      {{0.32130656,0.53226155,-0.3226428,0.05179324,0.43938544,0.24256842,-0.5250677,0.015182882,-0.061955296,0.34672388,-0.70259994,0.49314582,0.3581241,-0.8811957,1.1130484,0.834752,0.16531199,-2.8806028,0.39569208,-2.0773697}},
      {{0.20101868,-0.89201206,0.2113485,-0.72050536,-1.2416148,0.48437545,-0.68325824,-0.038578212,0.54934937,0.064501606,-1.0196695,0.59189016,0.94100994,0.20535147,0.17725976,0.6696157,-0.3019005,-0.9183617,0.09000266,-1.334387}},
      {{0.5110251,-1.9221888,0.5448303,-0.81821835,-2.3318896,0.6521028,-0.84481686,-0.23639552,0.8950746,-0.6687681,0.016628694,0.16091257,-0.24714124,0.69075805,-0.17594886,-0.39796552,-0.33248428,-0.40186968,-0.09843586,-0.79515934}},
      {{0.322282,-0.5602962,0.6344841,-1.5246525,-2.9876833,0.5952929,-1.2184122,-0.07907924,0.82171226,-4.0846276,-0.7002822,0.038280804,-0.0314084,0.75395304,-3.2939322,-3.1691,-2.1089997,-0.014805432,0.15528908,-0.45110333}},
      {{1.007178,-0.17150056,-0.029738555,0.43294775,0.17639817,0.2692107,0.9058675,-1.8370204,-2.808747,-3.543168,0.56101316,0.17226487,-0.105056725,0.15748528,-3.8961084,-5.3826246,-0.7439757,0.46768382,-0.07720786,-0.149405}},
      {{0.8552948,-0.7145166,-0.3198842,0.8545049,0.15388303,0.40249062,1.4083476,-0.11075473,-2.1369224,-1.2668254,-0.025379872,0.2771147,-0.26148438,0.36681408,0.24781518,-2.130659,-0.89712584,0.40924028,0.45247266,-0.38791162}},
      {{0.45649666,-0.32306919,-0.4876625,0.6608547,0.43597388,0.20619775,0.65220517,-0.3827558,-0.9940415,0.2530703,0.4262192,0.5767959,-0.47829995,0.30273244,0.55457026,0.4534936,-0.91760546,0.40172413,0.49720594,-0.7205743}},
      {{-1.0465363,0.60581213,-0.43638885,0.088785954,0.43790594,0.12781735,-0.59177256,-0.5405458,0.03594048,0.35223785,0.073654465,0.5575253,-0.434303,-0.7740877,0.67565244,0.813445,0.54171973,0.27677363,0.30741853,-0.99345934}},
      {{0.4300101,-0.41092697,0.29051962,-0.7208985,-0.5571501,0.23302847,-0.8914842,0.53368306,0.37282634,0.13871504,-0.44453543,0.61749,-0.79033756,0.2679015,0.48414117,0.7092767,-0.33857068,0.38384455,-0.0020126877,-0.62082845}},
      {{0.5397393,-0.9090872,1.0971254,-0.9699107,-1.5898674,0.6662766,-0.6500094,0.14548992,0.6119274,-1.3981886,0.1266939,-0.03396006,-0.70044714,0.5418657,-0.7755578,-0.77664125,-0.8523717,0.2545013,-0.5660282,-0.26500875}},
      {{1.2554321,0.054769434,1.022247,-1.2329965,-2.6353712,0.4702034,-1.078754,0.3625218,0.5707855,-4.4265203,0.061393872,0.09427264,-0.44395292,0.855313,-3.8704007,-1.7327803,-2.517382,0.33886552,-1.165755,-0.23026513}},
      {{1.1337687,1.0912688,-0.5509266,-0.05473758,-1.0474036,0.301662,1.1072689,-0.31186518,-0.7732136,-2.6614437,0.57777286,-0.9359808,-0.64480597,0.13667352,-6.604688,-9.547316,-0.9199727,0.57294714,0.24031012,0.37204412}},
      {{1.0467844,0.31933615,-0.86537594,-0.0052334378,-0.72094387,0.21030134,1.3909497,0.37010127,-1.3415946,-1.4019128,0.95103455,-0.3804605,-1.0562551,-0.33365604,0.28320011,-2.7205565,-0.0392537,0.60551864,0.76066506,0.22773343}},
      {{0.67982465,0.46190354,-0.9501023,-0.04862666,0.086297356,0.10758334,0.70707166,0.5066942,-0.5584111,0.15634133,0.74971765,-0.11358254,-0.73919517,-0.2611196,-1.0631505,0.0037307781,-0.32482824,0.6294914,0.60639673,0.19836485}},
      {{-0.5972518,0.6159475,-0.46639,0.05834415,0.48667106,0.2529557,-0.63054407,0.6533496,-0.054335233,0.36249998,0.6389123,-0.9132557,-1.4139274,-0.48210353,2.5297973,0.76825833,1.3396703,0.5752242,0.021831352,0.44279808}},
      {{0.78540516,0.13084757,0.50739014,-0.4591058,0.23428477,0.23999852,-1.0088097,0.57908785,0.19309552,-0.059548803,0.7819671,-0.12840986,-0.83520895,0.08140711,-0.80253756,0.6201844,-0.69210577,0.6084502,-0.6949957,0.2721825}},
      {{1.1495408,-0.038560964,1.5427234,-0.7686495,-0.7846696,0.3384079,-0.7785435,0.47165236,-0.017938767,-2.3504233,1.1838738,-0.5096996,-1.1526734,0.513048,-0.7777727,-0.9112262,-0.37676936,0.59010196,-1.933232,0.27780798}},
      {{1.4884149,0.43451825,1.5135262,-0.47056633,-1.1059171,0.44097984,-1.3681163,-0.16682361,-0.20992501,-4.9401703,1.1717854,-1.127574,0.21048549,0.69053173,-5.9272504,-2.3764706,-1.7136732,0.5601089,-1.679394,0.38882455}},
      {{1.3553656,0.9977545,-0.58241934,-0.7153886,-2.43914,-0.46532533,1.1427807,0.57728386,-0.32807988,-4.715956,-0.42444673,0.42091542,-0.96137166,-0.021067582,-4.8971295,-4.8246727,-1.6382362,0.49932328,0.99639785,0.26360473}},
      {{0.85534155,-0.61041814,-0.73544735,-0.47157183,-1.5391701,-0.38060614,1.1898862,0.7920628,-0.36424834,-0.8977542,-0.94205624,0.12555578,0.17061394,0.1834966,0.03835811,-2.3146653,-0.63557243,0.31799293,1.0403043,0.71244824}},
      {{0.6056973,-0.29183733,-0.7494772,-0.5484879,-0.63387454,-0.61408013,0.6171114,0.7625705,0.04797398,0.28326494,-0.32434037,0.64570796,-0.8536923,0.07610056,0.14785175,0.4518223,-0.24906905,0.402374,0.62173355,0.4235692}},
      {{-0.44067508,0.51222694,-0.42913482,-0.06681902,0.4586974,-0.8594879,-0.4808035,-0.077890694,0.13848676,0.34925917,-0.25132522,0.47664046,-0.73139757,-0.28121185,0.6145852,0.829562,0.34989443,0.31430063,-0.11786822,0.47365102}},
      {{0.621378,-0.45757657,0.44181547,0.22295527,0.5726221,-0.5938703,-0.6653886,-0.074489355,-0.07551322,0.16352224,0.43533993,0.6576752,-0.35788888,-0.036771268,0.5305926,0.57277715,-1.3645879,0.44371906,-0.9182339,0.2693425}},
      {{0.7992105,-1.1978102,1.4872427,0.03949939,0.13947481,-0.022405297,-0.605218,-0.25928813,-0.6343519,-1.4140369,0.4296325,0.030600516,-0.33777148,0.23644032,-0.8952943,-1.0294368,-1.2985386,0.22184925,-1.6159691,0.5960928}},
      {{1.0746324,-0.49191573,1.523942,-0.33070812,0.2593726,-0.098646045,-1.0898046,-1.8692024,-1.3660413,-4.696712,0.7712556,0.011196472,0.5614912,0.89092314,-3.3901172,-1.7826941,-1.6217282,0.38421598,-1.9345503,0.47300667}},
      {{0.715006,-0.8878923,-0.35865146,-1.7543029,-2.5695279,-0.8150253,0.8313327,0.8583453,0.28189316,-3.3240807,-1.4701146,0.24169144,-0.45533985,0.7265172,-3.8647316,-4.7499857,-1.5899669,0.09991155,1.085442,0.64543116}},
      {{1.244016,-1.8999393,-0.68173325,-1.1350583,-1.8909923,-1.0237576,0.906386,0.8662684,0.19134271,-0.22628249,-0.37529975,0.4948515,-0.86858165,0.70620406,-0.9474618,-1.4404197,-0.6621282,-0.16011138,1.0177196,0.6259144}},
      {{0.64288557,-0.8531781,-0.658275,-1.1180636,-1.1854191,-1.4413544,0.57140416,-0.065028116,0.16447003,0.2888256,-0.95508635,0.57402635,-0.031052526,0.32073584,-1.0411566,0.38586658,-0.2913631,-0.9714931,0.59939927,0.6659193}},
      {{0.31285515,0.47795025,-0.3727449,-0.1210431,0.49519494,-1.9020784,-0.4388629,-0.21161349,0.19080734,0.3328482,-0.56696075,0.5508328,0.118599705,-0.14018504,-0.0030670254,0.823711,0.31331205,-4.141035,-0.13625333,0.44984692}},
      {{0.5290957,-0.77675754,0.41705373,0.40630698,0.5945526,-1.1480898,-0.8423088,-0.9847582,-0.5273821,0.10428518,-0.7155946,0.68780416,0.37236103,-0.25383675,-1.1227564,0.44264853,-1.0063785,-1.7475799,-1.189454,0.5532502}},
      {{1.0950783,-1.9731051,1.0598384,0.6629113,0.87258023,-0.6483472,-0.93177825,-0.47477466,-1.0671115,-0.66890717,-0.20810431,0.48230687,-0.19740526,0.4289231,-0.6664151,-1.185379,-1.1459721,-0.55506146,-1.2042179,0.46260548}},
      {{0.73922884,-1.9321065,1.2433813,0.6257306,0.81454223,-0.4387535,-0.817775,-2.4388576,-1.6913749,-4.110835,0.4482066,0.28893515,0.37548324,0.936002,-3.1605566,-2.214134,-1.7855494,0.06528491,-1.8797071,0.51563317}},
      {{-0.80177444,-1.6655796,-0.47030595,-3.0127027,-3.2260954,-0.8972523,0.09704253,0.3685371,0.3860206,-1.3176359,-2.3591554,-0.18215205,0.09801084,1.1822997,-3.5791397,-2.7779696,-1.4210643,-0.6048369,1.03485,0.44210497}},
      {{0.114049524,-1.7369858,-0.6121017,-2.3953745,-2.964711,-1.558514,0.8369276,-1.5991163,0.47006464,-0.093516715,-1.4073889,0.1994608,0.67450184,0.4456353,-2.1655886,-0.2319443,0.12203712,-1.0404556,1.0486404,0.2908336}},
      {{-0.24712865,-0.36753562,-0.5060096,-1.5172484,-1.9830356,-2.3975995,0.5382858,-1.5254061,0.33993787,0.28238755,-1.4978417,0.43036422,1.5858883,0.24846634,-1.5672439,0.69517386,-0.2823839,-3.4479103,0.8718519,0.37753132}},
      {{-2.5802734,0.57892656,-0.3795688,-0.08895187,0.48478356,-3.1103644,-0.55383354,-0.6614209,-0.01318293,0.34701025,-0.97079825,-0.068560034,1.0945983,-0.18646136,0.13451783,0.80183625,0.29311663,-5.8533816,0.14580745,0.1716541}},
      {{-0.5094267,-0.71713406,0.123702325,1.2491754,0.65168047,-1.8243967,-0.5559935,-2.5528743,-0.4116413,0.24494137,-1.5478541,0.8647887,1.6683767,-0.9508973,-1.4328612,0.8371969,-0.8838189,-4.5763016,-2.37128,-0.03254768}},
      {{-0.2603671,-1.7635288,0.69165176,1.5159698,0.8082199,-0.8974314,-0.45483315,-3.2654655,-0.99090135,-0.16878794,-1.5436288,0.64713734,0.5574973,-0.10680687,-2.046669,-0.58163416,-0.5473928,-1.6518987,-2.8494625,-0.25277957}},
      {{-0.57783836,-2.3331895,0.65759546,1.6671747,0.99419415,-0.48325244,-1.2547292,-4.3047333,-1.8872647,-2.404146,-1.0194758,0.17030574,1.6162691,0.29214203,-3.5478942,-1.7814406,-1.8310533,-0.611518,-2.4525464,-0.1699996}}
    }};

    b1 = {
      -0.14019188, 0.047918186, 0.39616776, -0.013631771, 0.33980492, -0.018788107, -0.12933812, -0.010876537, 0.3025141, -0.037111964, 0.13889998, 0.2072676, 0.33321545, 0.1791731, -0.17917475, -0.81319493, -0.029190814, -0.21485917, -0.1433844, -0.23830199, 0.1273309, -0.02314919
    };

    b2 = {
      0.037877522, -0.057000607, 0.27840874, 0.13266505, 0.050438404, -0.10147412, 0.15338662, 0.1706535, 0.2498488, 0.28984913, 0.3750935, -0.2722201, -0.16592851, -0.048961535, 0.022084564, -0.13569447, 0.025033902, -0.03887795, -0.0228067, -0.08778586
    };

    bout = {
      -1.900844, -1.8302661, -1.682561, -0.27748704, -1.5546267, -2.0024743, -2.206885, -2.2545476, -0.85226566, -1.1383343, 0.0034493748, -1.1572598, -1.05418, -2.4126585, -1.7132987, -0.94682235, -0.137818, 0.5578461, -0.22803043, -1.194951, -1.8086926, -0.23696618, 0.2904987, 0.53819525, 3.539387, 0.5865303, 0.124349624, -0.2798548, -1.9082022, -0.9446833, -0.35891098, 0.56239253, -0.13596644, -1.1034236, -1.8084928, -2.5089216, -1.238275, -1.3917662, -0.06426911, -1.2802372, -1.071848, -2.2790134, -2.3931146, -2.088198, -1.6618013, -0.24453993, -1.703841, -1.8430387, -2.0406022
    };

    BN_gamma_in = {
      0.8074746, 0.8058453, 0.64778143, 0.450427, 0.5571459, 0.22673917, 0.9522813, 0.9437699, 0.90540373
    };

    BN_gamma_1 = {
      2.741749, 3.1660407, 0.8069123, 3.1286526, 1.1499922, 1.6109419, 2.4914062, 2.0136156, 1.6583309, 2.2160306, 1.2718241, 1.4444436, 4.232822, 1.78468, 1.6733191, 6.3255916, 4.557998, 2.4902234, 4.1852255, 2.136197, 2.5843964, 3.5646577
    };

    BN_gamma_2 = {
      3.8674707, 1.324359, 1.8748654, 3.0779274, 1.1566107, 1.1573385, 1.1142792, 2.4673724, 1.5770508, 0.9580167, 1.6118345, 0.6503555, 4.0515633, 2.7021103, 6.582779, 1.3705744, 2.6850975, 0.784557, 2.1100092, 1.2183
    };

    BN_beta_1 = {
      -0.01189974, -0.082279444, -0.32558662, -0.08176065, -0.2244379, -0.08459964, -0.065418504, -0.009806265, -0.0003994847, -0.25008434, -0.102065854, -0.16945116, -0.0042054895, -0.29600605, -0.16531499, -0.019656973, -0.004718684, -0.0010879673, -0.0069963206, -0.25574633, -0.0088739265, -0.061823923
    };

    BN_beta_2 = {
      -0.21386676, -0.073124655, -0.6292297, -0.3243026, -0.14683993, -0.14365384, -0.23690791, -0.16438141, -0.4043307, -0.231075, -0.31921676, -0.13782287, -0.03906064, -0.122731, -0.12047341, -0.024139855, -0.19507742, -0.04472373, -0.061501976, -0.16931698
    };
    
    mean = {
      28955.681015315007,14902.50954560286,28940.014606380253,20014.849252586522,2677.1842819445646,19869.25743935637,28867.358366157423,14645.050895432487,28671.11519854698
    };

    stdev = {
      255998.00799224983,159994.32309929,252329.5105373131,173481.3234904553,32801.92579712356,171478.22177757733,253816.3670057548,159375.20891280426,254221.4941030754
    };
  }

  else { // QP=22 and Default
    
    embs0 = {{
      {{-0.08597994,0.31422183,-0.2686347,-0.06372309}},
      {{0.0038140973,-0.00020320185,-0.014296134,0.0017186152}},
      {{-0.0059147184,-0.0017860687,-0.0008319115,-0.0008270455}},
      {{0.047910783,0.03663719,-0.0022914503,-0.062299203}},
      {{-0.008495941,0.005479705,0.018929427,-0.002087375}},
      {{0.0717429,0.06193133,0.014057857,-0.07134845}},
      {{0.023226282,0.013197218,0.058174703,0.010629918}},
      {{0.053846832,-0.102364786,0.15843002,-0.028276397}}
    }};

    embs1 = {{
      {{-0.15468216,0.16425368,-0.2495439,-0.34710595}},
      {{0.014557594,0.0010156455,-0.005401219,-0.00017753549}},
      {{0.000699659,-0.0020803818,0.005471025,-0.00087205874}},
      {{0.019914884,-0.042987432,-0.039680716,0.026877725}},
      {{-0.019741496,0.004100496,0.007496128,0.0034642958}},
      {{0.0025368878,-0.04904257,-0.012509326,-0.029935291}},
      {{-0.06309889,0.008698889,-0.024463879,-3.319126e-05}},
      {{-0.15319687,-0.044282455,-0.07820433,-0.037442382}}
    }};

    embs2 = {{
      {{-0.12287998,-0.19372258}},
      {{-9.0313544e-05,0.0012760957}},
      {{2.135269e-05,-0.0021089832}}
    }};

    embs3 = {{
      {{0.17631885,0.04791659,-0.2306673,0.08846679,0.10186124,-0.023195565,-0.069806665}},
      {{0.00019846635,-0.00048894214,-0.00070081744,0.0003879808,0.0016959775,-2.2516608e-05,0.00032707883}},
      {{-0.0011385189,0.002271972,-0.0014792035,-0.0016865813,-0.0037401621,0.000978791,0.00030373962}},
      {{0.0021029708,-0.0011298902,-0.00115025,-0.00045538123,-8.55921e-05,0.00048454868,-0.0021403222}},
      {{0.006966797,0.0059271324,0.011527392,0.0029503726,0.002222487,-0.001256219,0.005286494}},
      {{-0.0063228416,0.009117542,-0.029016597,0.027365562,-0.01620219,-0.07878856,0.0063343327}},
      {{-0.009126489,-0.0026384888,0.018811492,0.009139659,-0.005879776,-0.005892907,0.0014033668}},
      {{0.00030418645,-0.013205495,-0.014788311,0.03291836,-0.007861402,-0.08134645,0.009430126}},
      {{0.002092384,-0.000101188816,0.01743482,-0.013883205,-0.032764148,0.004956816,0.0055189985}},
      {{0.012304961,0.0235302,0.021683643,-0.03162537,-0.013959699,-0.14372648,-0.02035667}},
      {{-0.019869389,-0.016760351,0.008758776,-0.017018894,-0.013298669,-0.0050550746,-0.0016304324}},
      {{0.007460086,-0.012910209,0.04199375,-0.060188428,0.03554476,-0.1590435,-0.015866654}},
      {{-0.059733685,0.02671157,0.0046310783,-0.00048736105,0.039704382,0.01924424,-0.01508766}},
      {{0.031387296,0.005694586,0.0423999,0.012402546,0.0076741353,0.029580366,-0.052728653}}
    }};

    in_h1 = {{
      {{-0.06443865,-0.010238021,-0.008239817,-0.0077392138,0.005442644,-0.005699528,0.06826007,0.0015513613,0.00058970816,0.0052438728,0.0051169274,0.0033084194,0.012840725,-0.0032445695,0.018466348,0.01628836,0.0053221243,-1.1195202,-0.43073332,-1.4142008,-1.919842,0.43732202,-1.6072412,-0.948603,0.43182236,-0.9942445}},
      {{0.015818808,0.0040514567,0.052235723,-0.010033099,-0.051257834,0.011469231,-0.017694315,0.013652233,0.001445974,-0.0034310143,0.0073931613,0.009230072,-0.013989185,-0.006075323,-0.0018584483,0.0059843147,0.0009405065,0.15960355,-0.7834984,0.06118046,-1.2228255,-9.330955,-0.07502177,0.77345896,2.1304011,0.15576601}},
      {{0.06378966,0.09327364,0.21375985,0.070374705,-0.26023918,0.14812146,0.012827877,0.07754513,-0.0009500286,0.035253257,0.005160162,-0.0010093428,-0.065796845,-0.07004073,0.01179359,0.0442105,-0.010592965,0.49846798,0.28991887,1.4996586,3.311242,3.9339697,-1.1984956,-0.6571107,-0.08304312,0.42400336}},
      {{0.17478842,-0.039553683,0.10280135,0.060101166,-0.15381786,0.01967713,-0.105019644,0.060019333,0.003248394,0.07202382,-0.016222367,-0.0060968124,-0.07476951,-0.052427284,0.033584792,0.029266877,-0.019180937,-0.67894274,-0.26854452,0.052785367,-2.6083217,9.632623,-0.18584293,0.14456445,0.8344173,-0.06627243}},
      {{-0.27815816,0.21774815,0.36626923,-0.04716693,-0.28487659,0.09367584,0.30828637,-0.07373124,-0.011488094,-0.086176105,-0.0500151,-0.055792756,0.14038904,-0.06256646,-0.066581585,0.031725228,0.031174487,-1.531523,0.08307741,-0.3440886,-1.8378483,-5.58915,-0.7007065,0.16799557,0.59415174,-0.19711384}},
      {{0.0019553567,-0.0038785853,0.03227682,-0.004433017,-0.034796804,0.007341719,0.0032563373,-0.0037037686,0.0016397324,0.0039106878,0.013050704,0.0014634801,0.006404699,0.010794402,-0.0006447611,0.00358525,-0.005233544,-0.09785839,0.25977,-0.06191462,0.8475811,8.460455,-1.9443815,-0.254871,0.30438173,-0.39934394}},
      {{-0.00936991,0.04083856,0.19970277,0.02308968,-0.17135401,0.008977568,-0.0113441665,-0.011349763,-0.0017201772,-0.034417804,0.0031547234,0.0018643854,-0.0022370596,0.013527728,-0.020716188,0.03792553,0.0037564712,-0.13304107,1.8785596,0.22862448,-0.469412,-11.544619,-0.2183591,0.9715847,-1.2268575,0.45163986}},
      {{0.31565955,0.081087835,0.5354764,-0.046280194,-0.48941085,0.07322246,-0.3350624,0.076355204,0.010174554,-0.043768216,0.035940554,0.008973759,-0.12179149,0.010701525,0.043889202,0.037157975,-0.0015917656,0.99188447,0.5860983,-0.23367496,0.06260624,-6.982993,1.1619178,0.37104,-0.80276966,0.9208426}},
      {{-0.039951656,0.064148664,0.26767254,0.051596947,-0.25876284,0.031558346,0.0346597,-0.02929982,0.0007684115,-0.02785572,-0.00576207,-0.009833724,-0.007833552,-0.024191352,-0.04335432,0.057914972,0.014372822,0.14414726,-0.4595608,0.47746542,-0.0018465837,-17.82468,-0.0691614,-0.13215084,0.5246905,-0.12793839}},
      {{-0.07978777,0.043688368,-0.07023701,-0.01018229,0.07649356,0.038558155,0.06924581,-0.025370304,-0.0009829643,-0.006586667,-0.008272469,0.008268734,0.010944017,-0.038725123,-0.016204752,-0.007881373,-0.00020554627,0.014304216,0.62930375,-1.9127262,0.77089536,8.587444,-1.02901,-0.44024053,-0.30343,1.1172189}},
      {{0.0051492583,0.007888749,0.014415585,-0.007059214,0.0044692527,0.0044270577,-0.016530005,0.004679355,-0.0017689273,-0.020690758,0.004769769,-0.011817474,0.0076093897,0.014764848,0.009875977,-0.0032064195,-0.0034873122,0.0720578,-3.3995655,-0.7324801,0.77598816,5.3300014,0.047661643,-0.59422266,1.1699151,0.32784036}},
      {{0.0060452837,0.034678888,0.14869337,-0.01989984,-0.15293679,0.051401626,0.005218462,0.011244841,0.0015315468,-0.0005391438,0.010621657,0.011240008,-0.022591446,-0.041424993,-0.0134726,0.023355376,0.024132565,-0.37594938,-3.167016,-0.31943992,0.87332505,12.519154,0.52339923,0.60392946,-1.4767992,-1.1757162}},
      {{0.157336,0.02833388,0.36037773,0.041954596,-0.34054267,0.0025563275,-0.16763014,-0.0049420716,0.0029405071,-0.035241555,-0.0010897071,-0.003286937,-0.054470066,0.013221077,-0.00016919311,0.06434807,-0.00093333656,-0.87359476,-0.35418957,-1.3886424,-1.5235949,0.061186973,-0.6677522,-1.7212751,-0.42070377,0.120982796}},
      {{0.03896802,-0.007858299,0.027936067,0.016165938,-0.033389658,-0.0033301269,-0.036959346,-0.013791191,0.00089323975,-0.0072774636,0.001443474,0.0018467646,-0.010764899,0.00074687414,0.0056358296,0.008719289,0.010304463,-0.0066532865,3.5296102,-0.78400284,-0.1167652,-0.509895,0.34424317,0.12904285,-2.817858,-0.33672574}},
      {{0.008328107,-0.14363724,0.08824897,-0.10050621,-0.054935403,-0.09637986,-0.02275516,-0.02382795,-0.002643868,-0.00079685624,0.017214157,-8.783848e-05,0.03608567,0.03201542,-0.0134996185,0.008018863,0.0065351427,-0.35458362,0.73600954,-0.6310755,1.5250468,-18.439034,-0.034828227,0.19347332,-0.2002002,0.19874562}},
      {{-0.1416513,-0.22080119,-0.68999135,0.13349986,0.617084,0.069792114,0.08298516,-0.03999509,0.005185634,0.005652495,0.06950209,-0.038580384,-0.046454698,-0.06993716,-0.09575678,-0.063836336,-0.0028548148,0.3568637,-2.0011876,-0.10872106,-1.4353563,9.787758,-0.27565968,0.2751068,2.334697,1.9124174}},
      {{-0.011692749,0.007476433,0.10871043,-0.037705813,-0.0916571,0.032996528,0.006162028,-0.015251446,0.0016671312,-0.028069867,0.03603932,0.007486047,-0.004858577,-0.024858434,-0.014892638,0.015550599,0.01723418,0.7819039,1.3306841,-0.2932423,-3.7164044,-3.93075,0.4425489,-1.306799,-0.13248123,0.32368574}},
      {{0.034233596,-0.007149494,0.080457404,-0.00911342,-0.06805025,-0.025485208,-0.0423037,-0.027794516,0.00046901204,-0.0060876515,0.00423794,0.0045149536,-0.0022477047,0.0010957591,-0.011499542,0.012236205,0.00086517615,-1.1436841,-2.5230942,0.5364998,0.26951006,-3.3730426,0.40418097,0.877617,1.3079989,-0.4115221}},
      {{0.14765874,-0.0005110323,0.23710527,-0.054728027,-0.15525079,-0.032713562,-0.21667896,-0.037341062,0.0016404461,-0.037713483,-0.00019355616,-0.018401416,-0.06188611,-0.01706681,0.013199352,0.02530459,0.017993357,-0.037004814,0.7079926,0.8658019,3.1438034,-2.9049315,-1.9886909,0.8620829,0.20555316,-1.0165108}},
      {{0.0672874,-0.018334083,0.09952522,0.017736072,-0.10112725,-0.029764937,-0.05764968,-0.014927495,0.0009605855,0.00043522267,-0.006751108,-0.0032276765,-0.014363804,0.011536683,-0.00010367434,0.020036288,0.0033570724,1.3282324,-1.7609241,-1.0080101,2.4889798,-1.0597215,-1.3425713,0.9674551,-0.7160835,0.631205}},
      {{-0.15599109,0.027708134,-0.27450636,0.0034726406,0.26969767,-0.024568956,0.13093232,0.0002927499,0.002544383,-0.031750113,0.002928407,-0.0010988545,0.07163236,0.020855542,-0.0078456495,-0.043915693,-0.012897024,-0.29306415,0.39293957,2.822981,0.56084836,7.6393237,-0.36897907,1.4173979,0.070275515,-0.64897996}},
      {{-0.06572641,0.003238029,-0.0117078265,0.0018979504,0.008621058,0.0136965485,0.0656736,-0.0033131535,0.0008391157,-0.00066667696,0.008030574,0.0052866586,0.01314666,-0.0021025909,0.016430503,0.015870364,-0.001030068,0.06713714,-0.2251789,0.50163937,-0.22012445,-18.886208,-0.10551387,0.13458061,-0.052493386,0.17124766}}
    }};

    h1_h2 = {{
      {{0.35592228,1.5249355,1.9801495,-1.6341146,0.35319754,-0.40077305,-0.2944097,-0.24570899,-0.4089519,-0.36932546,-0.86572564,-0.8607167,-0.47611153,-0.4316364,0.26308888,-0.76503026,-2.160055,0.6331483,0.09113341,-0.4488635,-0.2995554,-0.4018415}},
      {{-3.159106,0.7691692,-0.9406924,-1.5019889,-2.3149662,-0.76510835,0.69181234,0.40387574,2.2611656,-1.3888793,-0.15836254,0.61714786,-1.8164679,0.030398676,5.1970625,-0.56165224,-0.43901286,-0.31741193,-0.16880569,0.1513259,-1.1242387,5.3867035}},
      {{1.3185794,-0.44969416,0.80386794,-0.5727789,0.09098256,-0.9964958,1.3392524,0.4311183,-0.9773322,0.5088557,-1.93548,-1.4829018,1.1951866,-0.4978906,0.51727426,-0.0940257,0.9744971,-5.48602,-0.30485287,-0.10640105,-0.7737587,-1.5833045}},
      {{2.0422702,-1.0976176,-0.30045062,1.1330099,0.21606371,2.6007385,-0.9720454,-2.162773,-1.2333728,1.0183847,0.23760954,0.124433815,3.4670556,0.33040014,-1.0370706,-0.16915901,0.16410306,0.089347385,0.2692764,-3.9814599,-0.3416191,-4.036105}},
      {{-3.9727576,1.4670373,-0.97486675,-0.9231681,-0.3745739,-0.4032597,-0.8356249,0.12433222,-2.2314572,0.40191695,0.5852186,-1.2118562,-0.018953508,-0.03004289,-0.86217487,-0.61667216,0.2990994,-0.25248948,0.159058,0.2763644,0.0055448506,-6.2671704}},
      {{2.1532931,0.8603945,-0.47093028,-0.7565874,-0.03729433,-0.2946106,-0.31176966,0.8518075,-0.22089218,-1.1618308,-0.43082643,0.16537419,1.445216,0.10506334,-1.2171782,-0.35957345,0.8098561,-0.12442991,-3.0160656,-0.6213975,-0.6168606,-3.6773193}},
      {{1.3624622,-0.16922595,-0.87315345,-0.8961811,0.5869618,-1.1035618,1.6233658,0.620317,-0.8418766,-2.3214421,-6.016474,1.9046708,-0.27061307,-0.46046707,-1.3277967,-1.0194583,-0.8668527,-0.28056744,1.1537647,-0.2787882,0.3976253,-0.39465368}},
      {{1.4197611,1.1601171,1.1927979,-2.1954205,-0.37907884,-5.557575,-0.09223259,1.0515558,1.942883,-1.7131348,0.3346497,0.54032737,-0.7502599,0.07556488,3.5043962,-0.6363647,-1.2095828,-0.17454647,-1.4349214,-0.6301461,-0.54863405,1.2816331}},
      {{-0.15805697,3.4417734,-0.21524999,-0.4545341,-0.43580905,0.7854786,-0.42114896,0.64139235,1.7415446,-0.022196673,-1.8330506,-1.6537048,-0.471649,-0.9795536,0.17670238,-0.63444996,0.7834806,-1.290403,-0.09394393,0.1035,-0.51216775,-1.0390699}},
      {{-7.135658,-2.939864,0.15679803,-0.94864875,-1.141448,-4.5214176,0.1714465,0.06961176,-2.8075135,-0.1483746,-0.2640192,0.07978963,-0.6744272,-0.053712465,-0.13031563,-0.14681315,0.106531315,-0.28569743,0.08007702,-0.0738871,0.0229887,-0.08265064}},
      {{-0.7547618,-1.7193553,1.0593195,-1.4349163,-0.9384468,-2.4850917,-3.126746,0.51309294,3.6062207,1.1194532,2.7790973,-3.1997933,1.2719182,-1.200124,1.5047086,-0.93268955,2.1020727,-2.2721348,-0.34834954,-0.3391858,-1.182956,1.745974}},
      {{-0.091388956,0.9855858,1.0091728,-1.0769459,-0.049071718,-0.28566912,2.0537474,0.329392,-1.0029029,-1.07089,-3.52353,-2.93777,0.06911201,-0.78180623,0.18958262,-0.900166,0.70472616,-0.9449119,0.781946,-0.4880315,-0.06968422,-0.33251852}},
      {{0.6032701,0.0081494255,-0.25160325,0.24324384,-2.2800071,-1.0112784,1.3538663,0.063450485,-0.09883968,-0.021798192,-0.17403303,-2.6658785,-2.805043,-0.12020398,-0.73799735,0.0061168093,0.2213093,0.55185306,-1.8307719,-12.174994,0.0658982,-0.4920119}},
      {{2.7201068,0.36393988,-0.59416604,-1.3781968,0.5033288,0.7859497,-0.6293188,-0.5431871,1.6015273,0.19314542,-0.6764274,-0.7502256,-0.0057396074,0.45706755,3.5482588,-0.54751307,-0.68220705,0.6335482,-0.1668163,0.21761285,-0.4887872,6.3243966}},
      {{-5.5126033,0.8597126,0.75954276,-0.76349235,-1.2547323,-4.2114596,0.032323368,0.1853691,0.9824124,-3.6331913,-0.05808719,0.51562536,-0.046661448,-11.395776,0.10337116,-0.39251956,-0.7781624,0.4557952,-0.07949795,-0.34532043,-0.21754158,-0.09783523}},
      {{-2.2043445,-8.6336775,0.5363376,-0.8106398,-0.37435228,0.12285326,0.09035623,0.34394753,0.6182657,-0.8690784,-1.5723854,-0.5172003,0.1712965,-0.9564162,0.8650741,-0.71184707,1.0267993,-1.0314679,0.34110755,-0.2908636,-0.4353096,-0.71573263}},
      {{-1.4475491,-0.10250793,1.9384779,-2.5958228,-0.4272872,1.2124435,-2.7895792,-1.5875466,2.3477795,-3.6169856,1.146751,-0.46780616,0.17928314,0.046254586,-1.0956534,-2.0045266,-0.490954,-0.22774108,3.3660767,-1.5332433,0.09525173,-0.25551528}},
      {{-1.5576339,0.64913684,0.12106801,0.04405512,-0.3252049,0.817057,-0.4746932,-0.48092338,2.5449693,-0.7184002,-0.022119643,-1.0482216,-0.8704165,0.20310926,6.250125,-0.38470381,0.9903796,-0.2581562,0.04876493,-0.20367536,-0.6684349,4.453647}},
      {{-1.488189,0.22504485,-0.9212026,3.8371882,0.7690761,-2.2956412,0.8885541,-0.2746016,-0.12631927,-1.2105637,-1.2652062,-0.25051916,1.545304,-0.38459393,-0.3464855,-0.24800132,0.93897825,0.42840397,-0.47680268,-6.487578,-0.07316711,-0.8406646}},
      {{-1.6032329,0.96708614,-0.7392402,-0.69473255,0.20840524,-2.2304885,-3.84114,-0.82766014,1.419415,-2.6706707,0.8627005,-1.0491598,0.8943007,-0.124745175,-3.056744,-1.2363279,3.1649375,-1.7705082,0.21840814,-0.27607352,-1.1871525,0.19816151}}
    }};

    h2_out = {{
      {{0.93328613,-1.5281633,-4.3772464,-6.6938334,-0.5926612,-1.1691949,0.6002577,-2.989458,-4.8954983,-0.09869773,-4.9351783,-0.47935,1.0677873,-0.007131079,0.53707254,-1.5433034,0.9154298,-2.177769,2.7139494,0.5112684}},
      {{1.0056597,-3.1359057,-7.2505302,-5.680147,0.16164224,0.9654765,0.7080151,-0.9762976,-8.194429,-0.24689372,-4.2185683,-0.99381447,0.94065243,-0.09126079,-0.54342747,-0.61656874,0.74101454,-1.6224563,1.9557321,0.4034314}},
      {{0.70311964,0.18707412,-5.770072,-5.2400074,0.19023143,0.56891024,0.3954986,0.30445772,-8.465038,-0.4224083,-2.1544657,-5.0552897,0.69425946,-1.4949013,-1.5715162,-0.6500159,1.1700255,-1.2052959,0.35673055,0.26092735}},
      {{0.44684514,1.3194963,-1.6856178,-3.1932273,-0.3537939,0.0804314,0.13000494,0.5194229,-2.5874784,0.16728738,0.66535056,-9.9117,0.22954157,-0.59573776,-1.104919,-0.17337026,0.7744078,-1.6017672,-1.0716492,0.43254665}},
      {{-0.17499407,0.43110505,-1.249505,-4.798868,1.4393635,-1.040758,-4.4433956,0.18087408,-2.4799073,0.08848301,1.1345277,-8.451959,-0.99060076,-2.4703896,-0.2478304,-0.3718046,-2.2182593,-1.2786072,-1.9421434,1.3051906}},
      {{0.03806395,-2.4882684,0.22987205,-5.1662936,1.4883803,-1.8228456,-7.603738,-0.5091462,-1.1766562,0.48827484,1.1357235,-3.882407,-1.3294815,-2.078342,1.9940041,0.25900158,-2.5907347,-2.2290478,-1.862072,1.3713452}},
      {{-0.64385265,-1.5522342,0.30132055,-6.015175,0.58389646,-1.4559369,-8.9597645,-2.3237886,-0.2204382,-0.23787811,0.9020431,-1.8087295,-0.45688832,-3.6456826,3.2487311,0.1493948,-2.566543,-0.6868775,-1.3707384,1.6245799}},
      {{0.49910685,-1.2541667,-3.248429,-4.7031393,0.6808929,-0.9128159,0.45592248,-3.8588831,-0.9736412,-0.95616174,-4.6609635,-0.14013453,0.88052493,0.027422275,1.8495841,-2.873951,1.0283437,-1.766069,3.2016134,2.1693664}},
      {{0.8950196,-3.6597195,-4.6428494,0.7240479,0.8403415,0.91886055,0.64344937,-1.3532319,-2.7570488,-0.6714582,-2.7286592,-0.6730336,1.3084081,2.306466,0.32912794,-1.8565102,0.45814207,-2.58544,2.4232986,1.5773219}},
      {{0.8068185,-0.99503595,-4.4017024,-2.5178938,1.1671591,0.6838314,0.14297143,0.21436034,-2.8131044,-1.1471572,-0.74211186,-2.1602986,1.0096767,0.23206678,-1.0339416,-1.4722704,0.9290804,-2.115973,0.79313403,0.6237291}},
      {{0.6761318,1.2522547,-1.6901342,2.2890828,0.9166584,0.085747086,0.24092087,0.52402616,-2.0689342,-1.1228974,0.7145852,-6.6018233,0.02824128,-0.31710547,-1.50889,-1.3732831,1.1765199,-0.8093528,-1.1075997,1.250828}},
      {{0.2002628,-0.91786987,-1.0723394,-1.8884313,2.01305,-1.8215898,-3.22147,0.33226067,-0.09036613,-0.7003868,0.6409005,-3.218141,-0.84112775,-1.0879893,-0.08265535,-1.2945591,-0.4077951,-2.4349654,-1.7837884,0.64462423}},
      {{0.6217991,-2.9078295,0.5456198,-2.386333,1.9367943,-2.0796788,-5.705175,-0.8383969,0.25716785,-0.39853594,0.4026929,-2.3372564,-1.1464543,-1.142223,2.5494812,-0.64572805,-0.75521076,-1.6611156,-1.8738675,1.2469722}},
      {{0.022912761,-3.4727504,0.5038191,-4.5770736,1.7413613,-1.5719556,-7.410611,-3.6825044,0.40024653,-1.2283133,0.24359867,-0.84257776,-0.71952844,-3.0124607,4.333529,-1.2250781,-0.80337286,0.0024358984,-1.5395036,2.957609}},
      {{-0.8958587,-4.1381564,-1.4534546,-4.4632835,0.4787604,-0.9762399,0.45926395,-3.919903,0.3775777,-0.73719347,-3.6010375,0.24523066,0.73743016,-0.41516593,1.764682,-3.2291512,0.19030656,-0.6833242,2.8703246,3.1929598}},
      {{-0.8544677,-5.192205,-2.9166946,-0.83248067,0.7138783,1.0545143,0.6439821,-1.9245285,0.25930384,-0.66250783,-2.1710892,-0.041803215,1.2200118,0.60818624,1.0161432,-2.2851424,-0.21612443,-1.1878884,2.5662472,3.0842576}},
      {{0.48334062,-0.37278223,-2.9414606,-2.6027808,0.76596355,0.67878467,0.65360826,0.29042763,0.4349153,-0.72331965,0.10896198,-0.21606572,0.9495934,0.7381798,-0.44437656,-1.4497955,0.25954464,-1.8869401,0.5234637,0.8599402}},
      {{0.8187757,1.2710887,-1.1233076,-0.83064,0.020098126,0.13713981,0.4012888,0.569588,0.39726254,-1.0204964,0.6376683,-1.1815927,0.08464182,0.08428337,-1.2643687,-1.9270731,1.005364,-0.60824543,-0.92909193,0.6086569}},
      {{1.1376324,-0.176491,0.49015093,-0.77584374,1.1644373,-1.6486669,-1.9819821,0.49661747,0.58115983,-0.5311159,0.3749824,-0.99105513,-0.42394167,-1.2145517,0.005217639,-1.3739547,0.9813159,-0.5818872,-1.7279564,-0.92430717}},
      {{1.1480212,-4.133158,0.5424085,-2.9964797,1.5832318,-3.2772093,-4.1307497,-2.1242685,0.52547824,-0.61804575,-0.06601149,-0.6520676,-1.2667842,-1.9804176,1.9740053,-1.0036998,0.14753217,-0.7231929,-1.8624154,0.084671386}},
      {{0.280276,-3.4317505,0.46949795,-5.1146603,1.290404,-2.365173,-4.7307563,-6.8500075,0.5720048,-0.9499338,-0.026560307,0.0144724045,-0.7527757,-2.391175,4.0412493,-1.2024957,-0.2246301,0.64950407,-1.5098379,1.8543361}},
      {{-2.1555903,-1.0418999,-0.08684941,-2.653574,0.08123252,0.020752838,-0.85190463,-3.50345,0.5356256,-1.3551052,-1.0595375,0.45301208,0.52612215,-1.3158042,2.0636692,-1.333923,-0.49960285,1.2088842,2.1743116,2.9176872}},
      {{-2.644909,-2.2027874,-0.45133677,1.0474685,0.32848006,1.135121,0.4006744,-2.5410786,0.48269165,-0.9231739,-0.6507695,0.49595624,0.3767437,-0.72304785,1.1124458,-1.8869646,-0.88271207,1.246603,2.1484058,3.09471}},
      {{-0.85547185,-0.44210926,-0.23031417,-2.6802492,0.24296156,0.79372406,0.6853461,0.18512982,0.52883923,-1.2589792,0.064514644,0.4983183,0.50393826,-0.57522744,-0.28176513,-0.6669616,-0.4835527,1.1911554,0.8908221,0.93539935}},
      {{0.7182482,1.3354807,0.29912582,5.607029,-1.7052292,0.13858344,0.57860655,0.56117475,0.52015144,-1.0859272,0.56003016,0.48342487,0.085523345,0.93538564,-0.66778547,-0.70392793,0.22551176,1.2312193,-0.43879247,-0.6970127}},
      {{1.1140441,-0.85636634,0.5289377,-0.8793851,-0.19742431,-2.227131,-0.6003474,0.2997813,0.54464024,-0.5524792,-0.0073390976,0.47514805,-0.6581019,-1.3591894,-0.22700684,-0.48907858,1.0985441,1.1694982,-0.860083,-2.96325}},
      {{1.2107241,-2.4331682,0.4380809,-0.5215404,0.45277342,-2.4035678,-1.541884,-4.0738263,0.51218647,-0.29922515,-0.8356642,0.48998782,-1.1682067,-1.3827109,0.8120019,-0.6796124,1.3368593,1.2011539,-0.9909632,-3.8713486}},
      {{0.96676373,-1.1858234,0.10127686,-2.9939392,-0.14690924,-1.5574652,-1.7273576,-7.8514733,0.53711927,-1.0343044,-0.6017839,0.5085881,-0.22561151,-1.3886219,1.6583781,-0.45125547,1.0845329,1.1595218,-0.59383297,-2.5558617}},
      {{-2.3772235,-5.417306,0.5665882,-4.8276625,0.545137,0.250655,-2.5087223,-3.557357,0.35825443,-0.72893703,0.29675153,0.44553757,1.0527056,-1.7026857,3.7420037,-0.16929471,-3.0161588,0.6368053,1.6785462,3.6617486}},
      {{-2.5530894,-5.148162,0.3120226,0.920812,0.012424444,1.1510754,-0.9803269,-2.3770733,0.1393396,0.0002765411,0.5236569,0.5909641,0.939683,-0.5461555,2.05738,0.16379379,-4.090466,-0.4026777,1.6757929,3.1564145}},
      {{-1.6834768,-0.64672095,0.56941116,-0.606709,-0.3908846,0.6282796,0.5500654,0.11324884,0.1627884,0.2829234,0.7218306,0.59504545,0.5599946,-1.0056752,0.22912289,0.27835155,-2.8784747,-0.36112675,-0.020144591,0.7870608}},
      {{0.61988086,1.3248713,0.5942456,-0.71746665,-1.4218519,-0.06196155,0.7388293,0.57280433,0.016459279,0.5505546,0.57535255,0.5908098,0.25475025,0.1782693,0.63432896,0.1600346,-0.4817692,-0.996857,-0.22897145,-2.0809426}},
      {{1.0672661,-1.2165141,0.6121895,-2.131021,-0.46453822,-2.6795077,0.6140378,0.36342332,-0.095031224,0.82943815,-1.0726036,0.74360555,-0.30205524,0.17911701,-0.45876375,0.0785235,0.8135132,-1.4299003,-0.603599,-4.0746584}},
      {{1.2564701,-6.371849,0.12161726,-2.404292,0.17422971,-4.702565,0.083942704,-2.5793712,-0.22696641,0.32844982,-3.2242827,0.86795956,-0.9273147,-0.5247338,0.49549937,-0.17411573,1.5371631,-1.5404987,-0.8250771,-3.2161448}},
      {{1.0982944,-6.279532,-0.4662349,-5.212792,-0.25373504,-3.734078,0.25612402,-8.279435,0.23413123,-0.3733352,-3.791532,0.7872908,-0.037606765,-0.37714234,1.2566558,-1.0528368,1.636595,-0.49919796,-0.0015117951,-3.3441045}},
      {{-1.9280105,-3.7035427,0.6374633,-5.0398827,9.6889824e-05,0.6650997,-3.0690753,-3.6989374,0.03744648,0.21039107,0.6564279,0.6096818,0.4580797,-2.8014317,4.411944,0.55405647,-4.508103,0.09143014,0.9170646,3.084589}},
      {{-2.8569884,-4.2420745,0.6010311,-2.02297,-0.6503998,1.0863658,-2.0915768,-1.4154099,-0.27053455,0.84976727,0.9688187,0.36110088,0.31662196,-0.42886418,2.2786314,1.4306189,-4.8645077,-1.1738071,0.9221053,2.6628036}},
      {{-2.6106312,-1.5648655,0.71339715,-3.4268155,-0.8635435,0.7830777,-0.69154537,0.02519597,-0.5429806,1.3844272,0.5202744,0.3082685,0.5031307,-0.2034721,1.3112339,2.5919297,-2.8240066,-2.2777348,-0.15511498,1.0052003}},
      {{-0.30097663,1.3453066,0.5517587,-0.0445994,-0.9784915,0.08830114,0.718427,0.5385231,-5.1274996,1.1330116,0.57270515,-0.03900919,0.034950763,-0.39088207,1.3675636,2.4046516,-0.9064404,-1.4757547,-0.18844472,-2.6700299}},
      {{0.7967423,-2.1114774,-0.33221808,-3.3445842,-0.98137504,-2.3164124,0.643357,0.34532773,-2.5817366,1.6803855,-2.7726824,0.8392402,-0.35185364,-0.02069853,0.72684175,1.6671841,0.8727022,-3.0179846,-0.47416213,-3.2986126}},
      {{1.1934578,-4.736448,-0.42371032,-2.8136623,-0.3523251,-3.978917,0.71946293,-1.5991206,-2.6851315,0.8720866,-4.909591,0.78060967,-0.5519164,1.3208036,0.12582383,0.60541886,1.5441978,-3.089574,-0.14081573,-3.2520103}},
      {{0.72323614,-3.7448795,-0.06387365,-5.179328,-0.32597885,-4.8665648,0.628466,-5.065299,-1.1268711,0.1431262,-6.1295586,0.7527398,0.042253006,0.42746902,0.83818555,-0.38613117,1.8596116,-2.6522584,1.0938083,-3.8633196}},
      {{-3.016694,-1.1812663,0.49334016,-5.964154,-0.33702284,-0.17545877,-5.27942,-2.263847,-0.31084794,0.1504701,1.051264,-0.44477677,0.4320523,-4.037068,2.8927968,1.3198568,-5.872543,-0.5553213,0.75504327,2.0874286}},
      {{-3.379001,-2.990762,0.6784906,-4.6646113,-0.6770365,0.9432555,-4.0785036,-0.8708904,-0.39165705,1.3826934,0.9828226,-0.94046587,0.18799534,-1.7371211,1.6792282,2.9620566,-5.925632,-2.0135307,0.1274715,2.5440068}},
      {{-2.6772034,-0.36697707,0.7368278,-4.9447713,-0.5086416,0.5928668,-2.5484982,0.21253148,-1.3099161,1.5834372,0.7714743,-1.5684621,0.43016768,-0.49294496,1.1957366,4.804484,-4.672614,-2.8556767,-0.5157698,0.2849377}},
      {{-0.4314599,1.3352199,0.00689203,-3.3642156,-1.2238737,0.07439375,0.49718964,0.5674331,-6.3681417,1.4405473,0.5426223,-1.6547232,0.09273995,-0.29209355,0.8344957,3.030196,-1.0762572,-2.3721666,-0.50683004,-2.3015563}},
      {{0.72702235,-0.7979824,-2.5216696,-5.0809455,-1.1557057,-1.4213591,0.8815139,0.32198375,-8.645544,1.9156599,-3.85096,0.39831173,-0.415864,-0.9456017,0.4931951,3.2269258,0.31920063,-2.2917345,-0.5792694,-3.3106995}},
      {{1.144037,-4.081185,-3.0567937,-5.7201624,-0.47730446,-2.982128,0.8827371,-0.8199866,-6.0665603,1.3731658,-7.078123,0.61850005,-0.55314815,-0.37964457,-0.1973905,1.7655909,1.294754,-2.3913646,-0.2101416,-2.4464395}},
      {{0.8440498,-1.9273071,-1.1825198,-7.215819,-0.82570326,-4.611149,0.70015484,-2.7511737,-4.26525,0.11912215,-7.573296,0.19881824,0.3591567,-0.22929434,-0.09405904,0.13532706,1.3617301,-3.0302155,0.94426876,-3.0870469}}
    }};

    b1 = {
      -0.53736144, 0.14300789, 0.10114818, 0.06306594, -0.24641837, -0.2014272, 0.027715487, 0.29372072, 0.01692901, -0.07122358, -0.048003223, -0.21642289, -0.3860964, -0.05547588, 0.11260864, 0.18563046, 0.023864074, -0.05753901, -0.03960021, 0.0031384889, 0.10935138, -0.011973358
    };

    b2 = {
      0.060979515, -0.06516118, 0.088760845, -0.119852476, -0.078701735, 0.13269411, 0.03392947, 0.10813809, 0.07522316, -0.017631747, 0.10248142, 0.020095354, 0.6271323, 0.15658525, -0.005920771, 0.038871527, -0.039686903, 0.048705358, 0.029793188, -0.043788563
    };

    bout = {
      -3.080214, -2.1941786, -1.8398525, -1.2712188, -1.9846538, -2.542266, -3.5860813, -2.8740568, -0.765057, -1.0240176, 0.31339508, -1.1847087, -1.4084952, -3.5155938, -2.4018078, -1.2268301, 0.11067444, 0.81291044, 0.11682394, -1.7073166, -3.1639235, -1.4980899, 0.1363878, 0.648101, 3.5395353, 0.8442384, -0.12918732, -1.9174186, -2.75366, -1.2008489, 0.07220775, 1.0790224, 0.14300115, -1.4776306, -2.978043, -3.1800842, -1.235965, -1.2935463, 0.2741569, -1.1355158, -1.0845771, -3.128451, -3.4719372, -2.3572206, -1.8544235, -1.1962647, -1.7535353, -2.1789937, -3.2873461
    };

    BN_gamma_in = {
      0.9581017, 0.49910784, 0.34459865, 0.27873898, 0.034029484, 0.9926283, 0.43863976, 0.7947497, 0.66873324
    };

    BN_gamma_1 = {
      7.4475904, 2.2395482, 2.364648, 1.360378, 1.9800432, 4.7697725, 3.28581, 1.8915988, 3.4520705, 3.2682211, 4.168902, 2.9711754, 4.0858297, 8.014917, 1.4235398, 2.8250008, 2.3592563, 3.905399, 1.7354717, 4.309839, 3.5849824, 5.030817
    };

    BN_gamma_2 = {
      3.25314, 2.6063445, 2.4695292, 9.442299, 2.6526284, 2.4369671, 3.4642375, 2.282881, 1.7902308, 2.2249143, 2.862892, 2.5712743, 1.1794845, 2.0234783, -1.8187549, 4.004393, 5.4144754, 2.8439834, 4.4390545, 3.9568522
    };

    BN_beta_1 = {
      -0.018682823, -0.046651237, -0.01869289, -0.24069741, -0.072131895, -0.0291968, -0.025291568, -0.06068066, -0.047847956, -0.050174594, -0.041862298, -0.093398094, -0.041634254, -0.0056360685, -0.15956882, -0.0011914935, -0.037631176, -0.01273838, -0.08203396, -0.015791412, -0.009362994, -0.013805644
    };

    BN_beta_2 = {
      -0.26909915, -0.055763084, -0.15891987, -0.09708797, -0.14048088, -0.2369725, -0.10642503, -0.16185921, -0.10593925, -0.38450912, -0.117903985, -0.07078113, -0.8465701, -0.27068967, 0.252826, -0.28413063, -0.09546536, -0.22467116, -0.39814448, -0.06147149
    };
    
    mean = {
      29478.590837972668,14340.918614908433,29565.546551296393,20063.353012699004,1495.7724049213077,20063.681285106686,29443.71517738055,14195.534789982776,29364.60882207162
    };

    stdev = {
      255766.5815856325,159393.5065176747,253749.9680236433,171803.43745105917,31666.91446920587,171693.08878344522,254155.79725829588,159502.86929080618,255831.8407704561
    };
  }
  
}


__inline Void TEncSearch::xTZSearchHelp( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const Int iSearchX, const Int iSearchY, const UChar ucPointNr, const UInt uiDistance )
{
  Distortion  uiSad = 0;

  const Pel* const  piRefSrch = rcStruct.piRefY + iSearchY * rcStruct.iYStride + iSearchX;

  //-- jclee for using the SAD function pointer
  m_pcRdCost->setDistParam( pcPatternKey, piRefSrch, rcStruct.iYStride,  m_cDistParam );

  setDistParamComp(COMPONENT_Y);

  // distortion
  m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
  m_cDistParam.m_maximumDistortionForEarlyExit = rcStruct.uiBestSad;

  if((m_pcEncCfg->getRestrictMESampling() == false) && m_pcEncCfg->getMotionEstimationSearchMethod() == MESEARCH_SELECTIVE)
  {
    Int isubShift = 0;
    // motion cost
    Distortion uiBitCost = m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

    // Skip search if bit cost is already larger than best SAD
    if (uiBitCost < rcStruct.uiBestSad)
    {
      if ( m_cDistParam.iRows > 32 )
      {
        m_cDistParam.iSubShift = 4;
      }
      else if ( m_cDistParam.iRows > 16 )
      {
        m_cDistParam.iSubShift = 3;
      }
      else if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 2;
      }
      else
      {
        m_cDistParam.iSubShift = 1;
      }

      Distortion uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
      if((uiTempSad + uiBitCost) < rcStruct.uiBestSad)
      {
        uiSad += uiTempSad >>  m_cDistParam.iSubShift;
        while(m_cDistParam.iSubShift > 0)
        {
          isubShift         = m_cDistParam.iSubShift -1;
          m_cDistParam.pOrg = pcPatternKey->getROIY() + (pcPatternKey->getPatternLStride() << isubShift);
          m_cDistParam.pCur = piRefSrch + (rcStruct.iYStride << isubShift);
          uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
          uiSad += uiTempSad >>  m_cDistParam.iSubShift;
          if(((uiSad << isubShift) + uiBitCost) > rcStruct.uiBestSad)
          {
            break;
          }

          m_cDistParam.iSubShift--;
        }

        if(m_cDistParam.iSubShift == 0)
        {
          uiSad += uiBitCost;
          if( uiSad < rcStruct.uiBestSad )
          {
            rcStruct.uiBestSad      = uiSad;
            rcStruct.iBestX         = iSearchX;
            rcStruct.iBestY         = iSearchY;
            rcStruct.uiBestDistance = uiDistance;
            rcStruct.uiBestRound    = 0;
            rcStruct.ucPointNr      = ucPointNr;
            m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
          }
        }
      }
    }
  }
  else
  {
    // fast encoder decision: use subsampled SAD when rows > 8 for integer ME
    if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE3 )
    {
      if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 1;
      }
    }

    uiSad = m_cDistParam.DistFunc( &m_cDistParam );

    // EMI: Modification "array_e & counter_i"
    array_e[counter_i] = uiSad;
    
    // only add motion cost if uiSad is smaller than best. Otherwise pointless
    // to add motion cost.
    if( uiSad < rcStruct.uiBestSad )
    {
      // motion cost
      uiSad += m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

      if( uiSad < rcStruct.uiBestSad )
      {
        rcStruct.uiBestSad      = uiSad;
        rcStruct.iBestX         = iSearchX;
        rcStruct.iBestY         = iSearchY;
        rcStruct.uiBestDistance = uiDistance;
        rcStruct.uiBestRound    = 0;
        rcStruct.ucPointNr      = ucPointNr;
        m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
      }
    }
  }
  counter_i = counter_i + 1;
}

__inline Void TEncSearch::xTZ2PointSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB )
{
  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 2 point search,                   //   1 2 3
  // check only the 2 untested points  //   4 0 5
  // around the start point            //   6 7 8
  Int iStartX = rcStruct.iBestX;
  Int iStartY = rcStruct.iBestY;
  switch( rcStruct.ucPointNr )
  {
    case 1:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY, 0, 2 );
      }
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
    }
      break;
    case 2:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 3:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
    }
      break;
    case 4:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 5:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 6:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY , 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    case 7:
    {
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 8:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    default:
    {
      assert( false );
    }
      break;
  } // switch( rcStruct.ucPointNr )
}




__inline Void TEncSearch::xTZ8PointSquareSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iTop >= iSrchRngVerTop ) // check top
  {
    if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
    }
    // top middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );

    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
    }
  } // check top
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
  }
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
  }
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
    if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
    }
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );

    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
    }
  } // check bottom
}


//additing other square search

__inline Void TEncSearch::xTZ8PointSquareSearch2( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;
// check top
  if ( iTop >= iSrchRngVerTop ) // check top
  {
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iLeft, iTop, 9, iDist);
    }
	  
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iStartX - 1, iTop, 10, iDist);
    }
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 11, iDist );
	
	if (iRight <= iSrchRngHorRight) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX +1, iTop, 12, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 13, iDist );
    }
  }

  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY-1, 14, iDist );
  }

  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY-1, 15, iDist );
  }
  
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 16, iDist );
  }
  
  
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 17, iDist );
  }
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY+1, 18, iDist );
  }
  
  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY+1, 19, iDist );
  }
  
  
  
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 20, iDist );
    }  
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iBottom, 21, iDist );
    }   
	  
	  
    
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 22, iDist );

	if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iBottom, 23, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 24, iDist );
    }
  } 
  
  // check bottom
}











__inline Void TEncSearch::xTZ8PointDiamondSearch( const TComPattern*const  pcPatternKey,
                                                  IntTZSearchStruct& rcStruct,
                                                  const TComMv*const  pcMvSrchRngLT,
                                                  const TComMv*const  pcMvSrchRngRB,
                                                  const Int iStartX,
                                                  const Int iStartY,
                                                  const Int iDist,
                                                  const Bool bCheckCornersAtDist1 )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert ( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iDist == 1 )
  {
    if ( iTop >= iSrchRngVerTop ) // check top
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
      }
    }
    if ( iLeft >= iSrchRngHorLeft ) // check middle left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
    }
    if ( iRight <= iSrchRngHorRight ) // check middle right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
    }
    if ( iBottom <= iSrchRngVerBottom ) // check bottom
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
      }
    }
  }
  else
  {
    if ( iDist <= 8 )
    {
      const Int iTop_2      = iStartY - (iDist>>1);
      const Int iBottom_2   = iStartY + (iDist>>1);
      const Int iLeft_2     = iStartX - (iDist>>1);
      const Int iRight_2    = iStartX + (iDist>>1);

      if (  iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iTop,      2, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iTop_2,    1, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2,    3, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,    iStartY,   4, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,   iStartY,   5, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iBottom_2, 6, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iBottom,   7, iDist    );
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        }
        if ( iTop_2 >= iSrchRngVerTop ) // check half top
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iTop_2, 1, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2, 3, (iDist>>1) );
          }
        } // check half top
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
        }
        if ( iBottom_2 <= iSrchRngVerBottom ) // check half bottom
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iBottom_2, 6, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, (iDist>>1) );
          }
        } // check half bottom
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        }
      } // check border
    }
    else // iDist > 8
    {
      if ( iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop,    0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,   iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,  iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
        }
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 0, iDist );
        }
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 0, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 0, iDist );
        }
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        }
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);

          if ( iPosYT >= iSrchRngVerTop ) // check top
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
            }
          } // check top
          if ( iPosYB <= iSrchRngVerBottom ) // check bottom
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
            }
          } // check bottom
        } // for ...
      } // check border
    } // iDist <= 8
  } // iDist == 1
}

Distortion TEncSearch::xPatternRefinement( TComPattern* pcPatternKey,
                                           TComMv baseRefMv,
                                           Int iFrac, TComMv& rcMvFrac,
                                           Bool bAllowUseOfHadamard
                                         )
{
  Distortion  uiDist;
  Distortion  uiDistBest  = std::numeric_limits<Distortion>::max();
  UInt        uiDirecBest = 0;

  Pel*  piRefPos;
  Int iRefStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);

  m_pcRdCost->setDistParam( pcPatternKey, m_filteredBlock[0][0].getAddr(COMPONENT_Y), iRefStride, 1, m_cDistParam, m_pcEncCfg->getUseHADME() && bAllowUseOfHadamard );

  const TComMv* pcMvRefine = (iFrac == 2 ? s_acMvRefineH : s_acMvRefineQ);

  for (UInt i = 0; i < 9; i++)
  {
    TComMv cMvTest = pcMvRefine[i];
    cMvTest += baseRefMv;

    Int horVal = cMvTest.getHor() * iFrac;
    Int verVal = cMvTest.getVer() * iFrac;
    piRefPos = m_filteredBlock[ verVal & 3 ][ horVal & 3 ].getAddr(COMPONENT_Y);
    if ( horVal == 2 && ( verVal & 1 ) == 0 )
    {
      piRefPos += 1;
    }
    if ( ( horVal & 1 ) == 0 && verVal == 2 )
    {
      piRefPos += iRefStride;
    }
    cMvTest = pcMvRefine[i];
    cMvTest += rcMvFrac;

    setDistParamComp(COMPONENT_Y);

    m_cDistParam.pCur = piRefPos;
    m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
    uiDist = m_cDistParam.DistFunc( &m_cDistParam );
    uiDist += m_pcRdCost->getCostOfVectorWithPredictor( cMvTest.getHor(), cMvTest.getVer() );

    if ( uiDist < uiDistBest )
    {
      uiDistBest  = uiDist;
      uiDirecBest = i;
      m_cDistParam.m_maximumDistortionForEarlyExit = uiDist;
    }
  }

  rcMvFrac = pcMvRefine[uiDirecBest];

  return uiDistBest;
}



Void
TEncSearch::xEncSubdivCbfQT(TComTU      &rTu,
                            Bool         bLuma,
                            Bool         bChroma )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx         = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth            = rTu.GetTransformDepthRel();
  const UInt uiTrMode             = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt uiSubdiv             = ( uiTrMode > uiTrDepth ? 1 : 0 );
  const UInt uiLog2LumaTrafoSize  = rTu.GetLog2LumaTrSize();

  if( pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_NxN && uiTrDepth == 0 )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize > pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getSlice()->getSPS()->getQuadtreeTULog2MinSize() )
  {
    assert( !uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
  {
    assert( !uiSubdiv );
  }
  else
  {
    assert( uiLog2LumaTrafoSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );
    if( bLuma )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( uiSubdiv, 5 - uiLog2LumaTrafoSize );
    }
  }

  if ( bChroma )
  {
    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if( rTu.ProcessingAllQuadrants(compID) && (uiTrDepth==0 || pcCU->getCbf( uiAbsPartIdx, compID, uiTrDepth-1 ) ))
      {
        m_pcEntropyCoder->encodeQtCbf(rTu, compID, (uiSubdiv == 0));
      }
    }
  }

  if( uiSubdiv )
  {
    TComTURecurse tuRecurse(rTu, false);
    do
    {
      xEncSubdivCbfQT( tuRecurse, bLuma, bChroma );
    } while (tuRecurse.nextSection(rTu));
  }
  else
  {
    //===== Cbfs =====
    if( bLuma )
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }
}




Void
TEncSearch::xEncCoeffQT(TComTU &rTu,
                        const ComponentID  component,
                        Bool         bRealCoeff )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();

  const UInt  uiTrMode        = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt  uiSubdiv        = ( uiTrMode > uiTrDepth ? 1 : 0 );

  if( uiSubdiv )
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xEncCoeffQT( tuRecurseChild, component, bRealCoeff );
    } while (tuRecurseChild.nextSection(rTu) );
  }
  else if (rTu.ProcessComponentSection(component))
  {
    //===== coefficients =====
    const UInt  uiLog2TrafoSize = rTu.GetLog2LumaTrSize();
    UInt    uiCoeffOffset   = rTu.getCoefficientOffset(component);
    UInt    uiQTLayer       = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrafoSize;
    TCoeff* pcCoeff         = bRealCoeff ? pcCU->getCoeff(component) : m_ppcQTTempCoeff[component][uiQTLayer];

    if (isChroma(component) && (pcCU->getCbf( rTu.GetAbsPartIdxTU(), COMPONENT_Y, uiTrMode ) != 0) && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag() )
    {
      m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, component );
    }

    m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeff+uiCoeffOffset, component );
  }
}




Void
TEncSearch::xEncIntraHeader( TComDataCU*  pcCU,
                            UInt         uiTrDepth,
                            UInt         uiAbsPartIdx,
                            Bool         bLuma,
                            Bool         bChroma )
{
  if( bLuma )
  {
    // CU header
    if( uiAbsPartIdx == 0 )
    {
      if( !pcCU->getSlice()->isIntra() )
      {
        if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
        {
          m_pcEntropyCoder->encodeCUTransquantBypassFlag( pcCU, 0, true );
        }
        m_pcEntropyCoder->encodeSkipFlag( pcCU, 0, true );
        m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
      }
      m_pcEntropyCoder  ->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );

      if (pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_2Nx2N )
      {
        m_pcEntropyCoder->encodeIPCMInfo( pcCU, 0, true );

        if ( pcCU->getIPCMFlag (0))
        {
          return;
        }
      }
    }
    // luma prediction mode
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N )
    {
      if (uiAbsPartIdx==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, 0 );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      if (uiTrDepth>0 && (uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiAbsPartIdx );
      }
    }
  }

  if( bChroma )
  {
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N || !enable4ChromaPUsInIntraNxNCU(pcCU->getPic()->getChromaFormat()))
    {
      if(uiAbsPartIdx==0)
      {
         m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      assert(uiTrDepth>0);
      if ((uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
  }
}




UInt
TEncSearch::xGetIntraBitsQT(TComTU &rTu,
                            Bool         bLuma,
                            Bool         bChroma,
                            Bool         bRealCoeff /* just for test */ )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();
  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiTrDepth, uiAbsPartIdx, bLuma, bChroma );
  xEncSubdivCbfQT ( rTu, bLuma, bChroma );

  if( bLuma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Y,      bRealCoeff );
  }
  if( bChroma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Cb,  bRealCoeff );
    xEncCoeffQT   ( rTu, COMPONENT_Cr,  bRealCoeff );
  }
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  return uiBits;
}

UInt TEncSearch::xGetIntraBitsQTChroma(TComTU &rTu,
                                       ComponentID compID,
                                       Bool         bRealCoeff /* just for test */ )
{
  m_pcEntropyCoder->resetBits();
  xEncCoeffQT   ( rTu, compID,  bRealCoeff );
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  return uiBits;
}

Void TEncSearch::xIntraCodingTUBlock(       TComYuv*    pcOrgYuv,
                                            TComYuv*    pcPredYuv,
                                            TComYuv*    pcResiYuv,
                                            Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      const Bool        checkCrossCPrediction,
                                            Distortion& ruiDist,
                                      const ComponentID compID,
                                            TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug)
                                           ,Int         default0Save1Load2
                                     )
{
  if (!rTu.ProcessComponentSection(compID))
  {
    return;
  }
  const Bool           bIsLuma          = isLuma(compID);
  const TComRectangle &rect             = rTu.getRect(compID);
        TComDataCU    *pcCU             = rTu.getCU();
  const UInt           uiAbsPartIdx     = rTu.GetAbsPartIdxTU();
  const TComSPS       &sps              = *(pcCU->getSlice()->getSPS());

  const UInt           uiTrDepth        = rTu.GetTransformDepthRelAdj(compID);
  const UInt           uiFullDepth      = rTu.GetTransformDepthTotal();
  const UInt           uiLog2TrSize     = rTu.GetLog2LumaTrSize();
  const ChromaFormat   chFmt            = pcOrgYuv->getChromaFormat();
  const ChannelType    chType           = toChannelType(compID);
  const Int            bitDepth         = sps.getBitDepth(chType);

  const UInt           uiWidth          = rect.width;
  const UInt           uiHeight         = rect.height;
  const UInt           uiStride         = pcOrgYuv ->getStride (compID);
        Pel           *piOrg            = pcOrgYuv ->getAddr( compID, uiAbsPartIdx );
        Pel           *piPred           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piResi           = pcResiYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piReco           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
  const UInt           uiQTLayer        = sps.getQuadtreeTULog2MaxSize() - uiLog2TrSize;
        Pel           *piRecQt          = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
  const UInt           uiRecQtStride    = m_pcQTTempTComYuv[ uiQTLayer ].getStride(compID);
  const UInt           uiZOrder         = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
        Pel           *piRecIPred       = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
        UInt           uiRecIPredStride = pcCU->getPic()->getPicYuvRec()->getStride  ( compID );
        TCoeff        *pcCoeff          = m_ppcQTTempCoeff[compID][uiQTLayer] + rTu.getCoefficientOffset(compID);
        Bool           useTransformSkip = pcCU->getTransformSkip(uiAbsPartIdx, compID);

#if ADAPTIVE_QP_SELECTION
        TCoeff        *pcArlCoeff       = m_ppcQTTempArlCoeff[compID][ uiQTLayer ] + rTu.getCoefficientOffset(compID);
#endif

  const UInt           uiChPredMode     = pcCU->getIntraDir( chType, uiAbsPartIdx );
  const UInt           partsPerMinCU    = 1<<(2*(sps.getMaxTotalCUDepth() - sps.getLog2DiffMaxMinCodingBlockSize()));
  const UInt           uiChCodedMode    = (uiChPredMode==DM_CHROMA_IDX && !bIsLuma) ? pcCU->getIntraDir(CHANNEL_TYPE_LUMA, getChromasCorrespondingPULumaIdx(uiAbsPartIdx, chFmt, partsPerMinCU)) : uiChPredMode;
  const UInt           uiChFinalMode    = ((chFmt == CHROMA_422)       && !bIsLuma) ? g_chroma422IntraAngleMappingTable[uiChCodedMode] : uiChCodedMode;

  const Int            blkX                                 = g_auiRasterToPelX[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            blkY                                 = g_auiRasterToPelY[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            bufferOffset                         = blkX + (blkY * MAX_CU_SIZE);
        Pel  *const    encoderLumaResidual                  = resiLuma[RESIDUAL_ENCODER_SIDE ] + bufferOffset;
        Pel  *const    reconstructedLumaResidual            = resiLuma[RESIDUAL_RECONSTRUCTED] + bufferOffset;
  const Bool           bUseCrossCPrediction                 = isChroma(compID) && (uiChPredMode == DM_CHROMA_IDX) && checkCrossCPrediction;
  const Bool           bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
        Pel *const     lumaResidualForEstimate              = bUseReconstructedResidualForEstimate ? reconstructedLumaResidual : encoderLumaResidual;

#if DEBUG_STRING
  const Int debugPredModeMask=DebugStringGetPredModeMask(MODE_INTRA);
#endif

  //===== init availability pattern =====
  DEBUG_STRING_NEW(sTemp)

#if !DEBUG_STRING
  if( default0Save1Load2 != 2 )
#endif
  {
    const Bool bUseFilteredPredictions=TComPrediction::filteringIntraReferenceSamples(compID, uiChFinalMode, uiWidth, uiHeight, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

    initIntraPatternChType( rTu, compID, bUseFilteredPredictions DEBUG_STRING_PASS_INTO(sDebug) );

    //===== get prediction signal =====
    predIntraAng( compID, uiChFinalMode, piOrg, uiStride, piPred, uiStride, rTu, bUseFilteredPredictions );

    // save prediction
    if( default0Save1Load2 == 1 )
    {
      Pel*  pPred   = piPred;
      Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
      Int k = 0;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pPredBuf[ k ++ ] = pPred[ uiX ];
        }
        pPred += uiStride;
      }
    }
  }
#if !DEBUG_STRING
  else
  {
    // load prediction
    Pel*  pPred   = piPred;
    Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
    Int k = 0;
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pPred[ uiX ] = pPredBuf[ k ++ ];
      }
      pPred += uiStride;
    }
  }
#endif

  //===== get residual signal =====
  {
    // get residual
    Pel*  pOrg    = piOrg;
    Pel*  pPred   = piPred;
    Pel*  pResi   = piResi;

    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pResi[ uiX ] = pOrg[ uiX ] - pPred[ uiX ];
      }

      pOrg  += uiStride;
      pResi += uiStride;
      pPred += uiStride;
    }
  }

  if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
  {
    if (bUseCrossCPrediction)
    {
      if (xCalcCrossComponentPredictionAlpha( rTu, compID, lumaResidualForEstimate, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride ) == 0)
      {
        return;
      }
      TComTrQuant::crossComponentPrediction ( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, false );
    }
    else if (isLuma(compID) && !bUseReconstructedResidualForEstimate)
    {
      xStoreCrossComponentPredictionResult( encoderLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
    }
  }

  //===== transform and quantization =====
  //--- init rate estimation arrays for RDOQ ---
  if( useTransformSkip ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ() )
  {
    m_pcEntropyCoder->estimateBit( m_pcTrQuant->m_pcEstBitsSbac, uiWidth, uiHeight, chType );
  }

  //--- transform and quantization ---
  TCoeff uiAbsSum = 0;
  if (bIsLuma)
  {
    pcCU       ->setTrIdxSubParts ( uiTrDepth, uiAbsPartIdx, uiFullDepth );
  }

  const QpParam cQP(*pcCU, compID);

#if RDOQ_CHROMA_LAMBDA
  m_pcTrQuant->selectLambda     (compID);
#endif

  m_pcTrQuant->transformNxN     ( rTu, compID, piResi, uiStride, pcCoeff,
#if ADAPTIVE_QP_SELECTION
    pcArlCoeff,
#endif
    uiAbsSum, cQP
    );

  //--- inverse transform ---

#if DEBUG_STRING
  if ( (uiAbsSum > 0) || (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask) )
#else
  if ( uiAbsSum > 0 )
#endif
  {
    m_pcTrQuant->invTransformNxN ( rTu, compID, piResi, uiStride, pcCoeff, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sDebug, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );
  }
  else
  {
    Pel* pResi = piResi;
    memset( pcCoeff, 0, sizeof( TCoeff ) * uiWidth * uiHeight );
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      memset( pResi, 0, sizeof( Pel ) * uiWidth );
      pResi += uiStride;
    }
  }


  //===== reconstruction =====
  {
    Pel* pPred      = piPred;
    Pel* pResi      = piResi;
    Pel* pReco      = piReco;
    Pel* pRecQt     = piRecQt;
    Pel* pRecIPred  = piRecIPred;

    if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
    {
      if (bUseCrossCPrediction)
      {
        TComTrQuant::crossComponentPrediction( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, true );
      }
      else if (isLuma(compID))
      {
        xStoreCrossComponentPredictionResult( reconstructedLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
      }
    }

 #if DEBUG_STRING
    std::stringstream ss(stringstream::out);
    const Bool bDebugPred=((DebugOptionList::DebugString_Pred.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugResi=((DebugOptionList::DebugString_Resi.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugReco=((DebugOptionList::DebugString_Reco.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));

    if (bDebugPred || bDebugResi || bDebugReco)
    {
      ss << "###: " << "CompID: " << compID << " pred mode (ch/fin): " << uiChPredMode << "/" << uiChFinalMode << " absPartIdx: " << rTu.GetAbsPartIdxTU() << "\n";
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        ss << "###: ";
        if (bDebugPred)
        {
          ss << " - pred: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pPred[ uiX ] << ", ";
          }
        }
        if (bDebugResi)
        {
          ss << " - resi: ";
        }
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          if (bDebugResi)
          {
            ss << pResi[ uiX ] << ", ";
          }
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        if (bDebugReco)
        {
          ss << " - reco: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pReco[ uiX ] << ", ";
          }
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
        ss << "\n";
      }
      DEBUG_STRING_APPEND(sDebug, ss.str())
    }
    else
#endif
    {

      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }

  //===== update distortion =====
  ruiDist += m_pcRdCost->getDistPart( bitDepth, piReco, uiStride, piOrg, uiStride, uiWidth, uiHeight, compID );
}




Void
TEncSearch::xRecurIntraCodingLumaQT(TComYuv*    pcOrgYuv,
                                    TComYuv*    pcPredYuv,
                                    TComYuv*    pcResiYuv,
                                    Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                    Distortion& ruiDistY,
#if HHI_RQT_INTRA_SPEEDUP
                                    Bool        bCheckFirst,
#endif
                                    Double&     dRDCost,
                                    TComTU&     rTu
                                    DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU   *pcCU          = rTu.getCU();
  const UInt    uiAbsPartIdx  = rTu.GetAbsPartIdxTU();
  const UInt    uiFullDepth   = rTu.GetTransformDepthTotal();
  const UInt    uiTrDepth     = rTu.GetTransformDepthRel();
  const UInt    uiLog2TrSize  = rTu.GetLog2LumaTrSize();
        Bool    bCheckFull    = ( uiLog2TrSize  <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
        Bool    bCheckSplit   = ( uiLog2TrSize  >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

        Pel     resiLumaSplit [NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];
        Pel     resiLumaSingle[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

#if HHI_RQT_INTRA_SPEEDUP
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // don't check split if TU size is less or equal to max TU size
  Bool noSplitIntraMaxTuSize = bCheckFull;
  if(m_pcEncCfg->getRDpenalty() && ! isIntraSlice)
  {
    // in addition don't check split if TU size is less or equal to 16x16 TU size for non-intra slice
    noSplitIntraMaxTuSize = ( uiLog2TrSize  <= min(maxTuSize,4) );

    // if maximum RD-penalty don't check TU size 32x32
    if(m_pcEncCfg->getRDpenalty()==2)
    {
      bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
    }
  }
  if( bCheckFirst && noSplitIntraMaxTuSize )

  {
    bCheckSplit = false;
  }
#else
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // if maximum RD-penalty don't check TU size 32x32
  if((m_pcEncCfg->getRDpenalty()==2)  && !isIntraSlice)
  {
    bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
  }
#endif
  Double     dSingleCost                        = MAX_DOUBLE;
  Distortion uiSingleDistLuma                   = 0;
  UInt       uiSingleCbfLuma                    = 0;
  Bool       checkTransformSkip  = pcCU->getSlice()->getPPS()->getUseTransformSkip();
  Int        bestModeId[MAX_NUM_COMPONENT] = { 0, 0, 0};
  checkTransformSkip           &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());
  checkTransformSkip           &= (!pcCU->getCUTransquantBypass(0));

  assert (rTu.ProcessComponentSection(COMPONENT_Y));
  const UInt totalAdjustedDepthChan   = rTu.GetTransformDepthTotalAdj(COMPONENT_Y);

  if ( m_pcEncCfg->getUseTransformSkipFast() )
  {
    checkTransformSkip       &= (pcCU->getPartitionSize(uiAbsPartIdx)==SIZE_NxN);
  }

  if( bCheckFull )
  {
    if(checkTransformSkip == true)
    {
      //----- store original entropy coding status -----
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );

      Distortion singleDistTmpLuma                    = 0;
      UInt       singleCbfTmpLuma                     = 0;
      Double     singleCostTmp                        = 0;
      Int        firstCheckId                         = 0;

      for(Int modeId = firstCheckId; modeId < 2; modeId ++)
      {
        DEBUG_STRING_NEW(sModeString)
        Int  default0Save1Load2 = 0;
        singleDistTmpLuma=0;
        if(modeId == firstCheckId)
        {
          default0Save1Load2 = 1;
        }
        else
        {
          default0Save1Load2 = 2;
        }


        pcCU->setTransformSkipSubParts ( modeId, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
        xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, singleDistTmpLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sModeString), default0Save1Load2 );

        singleCbfTmpLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );

        //----- determine rate and r-d cost -----
        if(modeId == 1 && singleCbfTmpLuma == 0)
        {
          //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
          singleCostTmp = MAX_DOUBLE;
        }
        else
        {
          UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );
          singleCostTmp     = m_pcRdCost->calcRdCost( uiSingleBits, singleDistTmpLuma );
        }
        if(singleCostTmp < dSingleCost)
        {
          DEBUG_STRING_SWAP(sDebug, sModeString)
          dSingleCost   = singleCostTmp;
          uiSingleDistLuma = singleDistTmpLuma;
          uiSingleCbfLuma = singleCbfTmpLuma;

          bestModeId[COMPONENT_Y] = modeId;
          if(bestModeId[COMPONENT_Y] == firstCheckId)
          {
            xStoreIntraResultQT(COMPONENT_Y, rTu );
            m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
          }

          if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
          {
            const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
            const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
            for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
            {
              if (bMaintainResidual[storedResidualIndex])
              {
                xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
              }
            }
          }
        }
        if (modeId == firstCheckId)
        {
          m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
        }
      }

      pcCU ->setTransformSkipSubParts ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

      if(bestModeId[COMPONENT_Y] == firstCheckId)
      {
        xLoadIntraResultQT(COMPONENT_Y, rTu );
        pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, rTu.GetTransformDepthTotalAdj(COMPONENT_Y) );

        m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
      }
    }
    else
    {
      //----- store original entropy coding status -----
      if( bCheckSplit )
      {
        m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
      }
      //----- code luma/chroma block with given intra prediction mode and store Cbf-----
      dSingleCost   = 0.0;

      pcCU ->setTransformSkipSubParts ( 0, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
      xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, uiSingleDistLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sDebug));

      if( bCheckSplit )
      {
        uiSingleCbfLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );
      }
      //----- determine rate and r-d cost -----
      UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );

      if(m_pcEncCfg->getRDpenalty() && (uiLog2TrSize==5) && !isIntraSlice)
      {
        uiSingleBits=uiSingleBits*4;
      }

      dSingleCost       = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDistLuma );

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }
    }
  }

  if( bCheckSplit )
  {
    //----- store full entropy coding status, load original entropy coding status -----
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    else
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    //----- code splitted block -----
    Double     dSplitCost      = 0.0;
    Distortion uiSplitDistLuma = 0;
    UInt       uiSplitCbfLuma  = 0;

    TComTURecurse tuRecurseChild(rTu, false);
    DEBUG_STRING_NEW(sSplit)
    do
    {
      DEBUG_STRING_NEW(sChild)
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, bCheckFirst, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#endif
      DEBUG_STRING_APPEND(sSplit, sChild)
      uiSplitCbfLuma |= pcCU->getCbf( tuRecurseChild.GetAbsPartIdxTU(), COMPONENT_Y, tuRecurseChild.GetTransformDepthRel() );
    } while (tuRecurseChild.nextSection(rTu) );

    UInt    uiPartsDiv     = rTu.GetAbsPartIdxNumParts();
    {
      if (uiSplitCbfLuma)
      {
        const UInt flag=1<<uiTrDepth;
        UChar *pBase=pcCU->getCbf( COMPONENT_Y );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
    //----- restore context states -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    
    //----- determine rate and r-d cost -----
    UInt uiSplitBits = xGetIntraBitsQT( rTu, true, false, false );
    dSplitCost       = m_pcRdCost->calcRdCost( uiSplitBits, uiSplitDistLuma );

    //===== compare and set best =====
    if( dSplitCost < dSingleCost )
    {
      //--- update cost ---
      DEBUG_STRING_SWAP(sSplit, sDebug)
      ruiDistY += uiSplitDistLuma;
      dRDCost  += dSplitCost;

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSplit[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }

      return;
    }

    //----- set entropy coding status -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );

    //--- set transform index and Cbf values ---
    pcCU->setTrIdxSubParts( uiTrDepth, uiAbsPartIdx, uiFullDepth );
    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
    pcCU ->setTransformSkipSubParts  ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

    //--- set reconstruction for next intra prediction blocks ---
    const UInt  uiQTLayer   = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt  uiZOrder    = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
    const UInt  uiWidth     = tuRect.width;
    const UInt  uiHeight    = tuRect.height;
    Pel*  piSrc       = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( COMPONENT_Y, uiAbsPartIdx );
    UInt  uiSrcStride = m_pcQTTempTComYuv[ uiQTLayer ].getStride  ( COMPONENT_Y );
    Pel*  piDes       = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
    UInt  uiDesStride = pcCU->getPic()->getPicYuvRec()->getStride  ( COMPONENT_Y );

    for( UInt uiY = 0; uiY < uiHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        piDes[ uiX ] = piSrc[ uiX ];
      }
    }
  }
  ruiDistY += uiSingleDistLuma;
  dRDCost  += dSingleCost;
}


Void
TEncSearch::xSetIntraResultLumaQT(TComYuv* pcRecoYuv, TComTU &rTu)
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiTrDepth    = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====

    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    const UInt coeffOffset = rTu.getCoefficientOffset(COMPONENT_Y);
    const UInt numCoeffInBlock = tuRect.width * tuRect.height;

    if (numCoeffInBlock!=0)
    {
      const TCoeff* srcCoeff = m_ppcQTTempCoeff[COMPONENT_Y][uiQTLayer] + coeffOffset;
      TCoeff* destCoeff      = pcCU->getCoeff(COMPONENT_Y) + coeffOffset;
      ::memcpy( destCoeff, srcCoeff, sizeof(TCoeff)*numCoeffInBlock );
#if ADAPTIVE_QP_SELECTION
      const TCoeff* srcArlCoeff = m_ppcQTTempArlCoeff[COMPONENT_Y][ uiQTLayer ] + coeffOffset;
      TCoeff* destArlCoeff      = pcCU->getArlCoeff (COMPONENT_Y)               + coeffOffset;
      ::memcpy( destArlCoeff, srcArlCoeff, sizeof( TCoeff ) * numCoeffInBlock );
#endif
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Y, pcRecoYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }

  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultLumaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}


Void
TEncSearch::xStoreIntraResultQT(const ComponentID compID, TComTU &rTu )
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff    = tuRect.width * tuRect.height;
      TCoeff* pcCoeffSrc = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffDst = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffDst = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( compID, &m_pcQTTempTransformSkipTComYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }
  }
}


Void
TEncSearch::xLoadIntraResultQT(const ComponentID compID, TComTU &rTu)
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt uiZOrder     = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff = tuRect.width * tuRect.height;
      TCoeff* pcCoeffDst = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffSrc = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffDst = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffSrc = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTransformSkipTComYuv.copyPartToPartComponent( compID, &m_pcQTTempTComYuv[ uiQTLayer ], uiAbsPartIdx, tuRect.width, tuRect.height );

      Pel*    piRecIPred        = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
      UInt    uiRecIPredStride  = pcCU->getPic()->getPicYuvRec()->getStride (compID);
      Pel*    piRecQt           = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
      UInt    uiRecQtStride     = m_pcQTTempTComYuv[ uiQTLayer ].getStride  (compID);
      UInt    uiWidth           = tuRect.width;
      UInt    uiHeight          = tuRect.height;
      Pel* pRecQt               = piRecQt;
      Pel* pRecIPred            = piRecIPred;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pRecIPred[ uiX ] = pRecQt   [ uiX ];
        }
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }
}

Void
TEncSearch::xStoreCrossComponentPredictionResult(       Pel    *pResiDst,
                                                  const Pel    *pResiSrc,
                                                        TComTU &rTu,
                                                  const Int     xOffset,
                                                  const Int     yOffset,
                                                  const Int     strideDst,
                                                  const Int     strideSrc )
{
  const Pel *pSrc = pResiSrc + yOffset * strideSrc + xOffset;
        Pel *pDst = pResiDst + yOffset * strideDst + xOffset;

  for( Int y = 0; y < rTu.getRect( COMPONENT_Y ).height; y++ )
  {
    ::memcpy( pDst, pSrc, sizeof(Pel) * rTu.getRect( COMPONENT_Y ).width );
    pDst += strideDst;
    pSrc += strideSrc;
  }
}

SChar
TEncSearch::xCalcCrossComponentPredictionAlpha(       TComTU &rTu,
                                                const ComponentID compID,
                                                const Pel*        piResiL,
                                                const Pel*        piResiC,
                                                const Int         width,
                                                const Int         height,
                                                const Int         strideL,
                                                const Int         strideC )
{
  const Pel *pResiL = piResiL;
  const Pel *pResiC = piResiC;

        TComDataCU *pCU = rTu.getCU();
  const Int  absPartIdx = rTu.GetAbsPartIdxTU( compID );
  const Int diffBitDepth = pCU->getSlice()->getSPS()->getDifferentialLumaChromaBitDepth();

  SChar alpha = 0;
  Int SSxy  = 0;
  Int SSxx  = 0;

  for( UInt uiY = 0; uiY < height; uiY++ )
  {
    for( UInt uiX = 0; uiX < width; uiX++ )
    {
      const Pel scaledResiL = rightShift( pResiL[ uiX ], diffBitDepth );
      SSxy += ( scaledResiL * pResiC[ uiX ] );
      SSxx += ( scaledResiL * scaledResiL   );
    }

    pResiL += strideL;
    pResiC += strideC;
  }

  if( SSxx != 0 )
  {
    Double dAlpha = SSxy / Double( SSxx );
    alpha = SChar(Clip3<Int>(-16, 16, (Int)(dAlpha * 16)));

    static const SChar alphaQuant[17] = {0, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8};

    alpha = (alpha < 0) ? -alphaQuant[Int(-alpha)] : alphaQuant[Int(alpha)];
  }
  pCU->setCrossComponentPredictionAlphaPartRange( alpha, compID, absPartIdx, rTu.GetAbsPartIdxNumParts( compID ) );

  return alpha;
}

Void
TEncSearch::xRecurIntraChromaCodingQT(TComYuv*    pcOrgYuv,
                                      TComYuv*    pcPredYuv,
                                      TComYuv*    pcResiYuv,
                                      Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      Distortion& ruiDist,
                                      TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU         *pcCU                  = rTu.getCU();
  const UInt          uiTrDepth             = rTu.GetTransformDepthRel();
  const UInt          uiAbsPartIdx          = rTu.GetAbsPartIdxTU();
  const ChromaFormat  format                = rTu.GetChromaFormat();
  UInt                uiTrMode              = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt          numberValidComponents = getNumberValidComponents(format);

  if(  uiTrMode == uiTrDepth )
  {
    if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      return;
    }

    const UInt uiFullDepth = rTu.GetTransformDepthTotal();

    Bool checkTransformSkip = pcCU->getSlice()->getPPS()->getUseTransformSkip();
    checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Cb), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

    if ( m_pcEncCfg->getUseTransformSkipFast() )
    {
      checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

      if (checkTransformSkip)
      {
        Int nbLumaSkip = 0;
        const UInt maxAbsPartIdxSub=uiAbsPartIdx + (rTu.ProcessingAllQuadrants(COMPONENT_Cb)?1:4);
        for(UInt absPartIdxSub = uiAbsPartIdx; absPartIdxSub < maxAbsPartIdxSub; absPartIdxSub ++)
        {
          nbLumaSkip += pcCU->getTransformSkip(absPartIdxSub, COMPONENT_Y);
        }
        checkTransformSkip &= (nbLumaSkip > 0);
      }
    }


    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      DEBUG_STRING_NEW(sDebugBestMode)

      //use RDO to decide whether Cr/Cb takes TS
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[uiFullDepth][CI_QT_TRAFO_ROOT] );

      const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

      TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

      const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

      do
      {
        const UInt subTUAbsPartIdx   = TUIterator.GetAbsPartIdxTU(compID);

        Double     dSingleCost               = MAX_DOUBLE;
        Int        bestModeId                = 0;
        Distortion singleDistC               = 0;
        UInt       singleCbfC                = 0;
        Distortion singleDistCTmp            = 0;
        Double     singleCostTmp             = 0;
        UInt       singleCbfCTmp             = 0;
        SChar      bestCrossCPredictionAlpha = 0;
        Int        bestTransformSkipMode     = 0;

        const Bool checkCrossComponentPrediction =    (pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, subTUAbsPartIdx) == DM_CHROMA_IDX)
                                                   &&  pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                   && (pcCU->getCbf(subTUAbsPartIdx,  COMPONENT_Y, uiTrDepth) != 0);

        const Int  crossCPredictionModesToTest = checkCrossComponentPrediction ? 2 : 1;
        const Int  transformSkipModesToTest    = checkTransformSkip            ? 2 : 1;
        const Int  totalModesToTest            = crossCPredictionModesToTest * transformSkipModesToTest;
              Int  currModeId                  = 0;
              Int  default0Save1Load2          = 0;

        for(Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
        {
          for(Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
          {
            pcCU->setCrossComponentPredictionAlphaPartRange(0, compID, subTUAbsPartIdx, partIdxesPerSubTU);
            DEBUG_STRING_NEW(sDebugMode)
            pcCU->setTransformSkipPartRange( transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU );
            currModeId++;

            const Bool isOneMode  = (totalModesToTest == 1);
            const Bool isLastMode = (currModeId == totalModesToTest); // currModeId is indexed from 1

            if (isOneMode)
            {
              default0Save1Load2 = 0;
            }
            else if (!isOneMode && (transformSkipModeId == 0) && (crossCPredictionModeId == 0))
            {
              default0Save1Load2 = 1; //save prediction on first mode
            }
            else
            {
              default0Save1Load2 = 2; //load it on subsequent modes
            }

            singleDistCTmp = 0;

            xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, (crossCPredictionModeId != 0), singleDistCTmp, compID, TUIterator DEBUG_STRING_PASS_INTO(sDebugMode), default0Save1Load2);
            singleCbfCTmp = pcCU->getCbf( subTUAbsPartIdx, compID, uiTrDepth);

            if (  ((crossCPredictionModeId == 1) && (pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) == 0))
               || ((transformSkipModeId    == 1) && (singleCbfCTmp == 0))) //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
            {
              singleCostTmp = MAX_DOUBLE;
            }
            else if (!isOneMode)
            {
              UInt bitsTmp = xGetIntraBitsQTChroma( TUIterator, compID, false );
              singleCostTmp  = m_pcRdCost->calcRdCost( bitsTmp, singleDistCTmp);
            }

            if(singleCostTmp < dSingleCost)
            {
              DEBUG_STRING_SWAP(sDebugBestMode, sDebugMode)
              dSingleCost               = singleCostTmp;
              singleDistC               = singleDistCTmp;
              bestCrossCPredictionAlpha = (crossCPredictionModeId != 0) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;
              bestTransformSkipMode     = transformSkipModeId;
              bestModeId                = currModeId;
              singleCbfC                = singleCbfCTmp;

              if (!isOneMode && !isLastMode)
              {
                xStoreIntraResultQT(compID, TUIterator);
                m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
              }
            }

            if (!isOneMode && !isLastMode)
            {
              m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
            }
          }
        }

        if(bestModeId < totalModesToTest)
        {
          xLoadIntraResultQT(compID, TUIterator);
          pcCU->setCbfPartRange( singleCbfC << uiTrDepth, compID, subTUAbsPartIdx, partIdxesPerSubTU );

          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
        }

        DEBUG_STRING_APPEND(sDebug, sDebugBestMode)
        pcCU ->setTransformSkipPartRange                ( bestTransformSkipMode,     compID, subTUAbsPartIdx, partIdxesPerSubTU );
        pcCU ->setCrossComponentPredictionAlphaPartRange( bestCrossCPredictionAlpha, compID, subTUAbsPartIdx, partIdxesPerSubTU );
        ruiDist += singleDistC;
      } while (TUIterator.nextSection(rTu));

      if (splitIntoSubTUs)
      {
        offsetSubTUCBFs(rTu, compID);
      }
    }
  }
  else
  {
    UInt    uiSplitCbf[MAX_NUM_COMPONENT] = {0,0,0};

    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiTrDepthChild   = tuRecurseChild.GetTransformDepthRel();
    do
    {
      DEBUG_STRING_NEW(sChild)

      xRecurIntraChromaCodingQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, ruiDist, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );

      DEBUG_STRING_APPEND(sDebug, sChild)
      const UInt uiAbsPartIdxSub=tuRecurseChild.GetAbsPartIdxTU();

      for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
      {
        uiSplitCbf[ch] |= pcCU->getCbf( uiAbsPartIdxSub, ComponentID(ch), uiTrDepthChild );
      }
    } while ( tuRecurseChild.nextSection(rTu) );


    UInt uiPartsDiv = rTu.GetAbsPartIdxNumParts();
    for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      if (uiSplitCbf[ch])
      {
        const UInt flag=1<<uiTrDepth;
        ComponentID compID=ComponentID(ch);
        UChar *pBase=pcCU->getCbf( compID );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
  }
}




Void
TEncSearch::xSetIntraResultChromaQT(TComYuv*    pcRecoYuv, TComTU &rTu)
{
  if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
  {
    return;
  }
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth   = rTu.GetTransformDepthRel();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====
    const TComRectangle &tuRectCb=rTu.getRect(COMPONENT_Cb);
    UInt uiNumCoeffC    = tuRectCb.width*tuRectCb.height;//( pcCU->getSlice()->getSPS()->getMaxCUWidth() * pcCU->getSlice()->getSPS()->getMaxCUHeight() ) >> ( uiFullDepth << 1 );
    const UInt offset = rTu.getCoefficientOffset(COMPONENT_Cb);

    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID component = ComponentID(ch);
      const TCoeff* src           = m_ppcQTTempCoeff[component][uiQTLayer] + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      TCoeff* dest                = pcCU->getCoeff(component) + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      ::memcpy( dest, src, sizeof(TCoeff)*uiNumCoeffC );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[component][ uiQTLayer ] + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      TCoeff* pcArlCoeffDst = pcCU->getArlCoeff(component)                + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeffC );
#endif
    }

    //===== copy reconstruction =====

    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cb, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cr, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultChromaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}



Void
TEncSearch::estIntraPredLumaQT(TComDataCU* pcCU,
                               TComYuv*    pcOrgYuv,
                               TComYuv*    pcPredYuv,
                               TComYuv*    pcResiYuv,
                               TComYuv*    pcRecoYuv,
                               Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                               DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt         uiDepth               = pcCU->getDepth(0);
  const UInt         uiInitTrDepth         = pcCU->getPartitionSize(0) == SIZE_2Nx2N ? 0 : 1;
  const UInt         uiNumPU               = 1<<(2*uiInitTrDepth);
  const UInt         uiQNumParts           = pcCU->getTotalNumPart() >> 2;
  const UInt         uiWidthBit            = pcCU->getIntraSizeIdx(0);
  const ChromaFormat chFmt                 = pcCU->getPic()->getChromaFormat();
  const UInt         numberValidComponents = getNumberValidComponents(chFmt);
  const TComSPS     &sps                   = *(pcCU->getSlice()->getSPS());
  const TComPPS     &pps                   = *(pcCU->getSlice()->getPPS());
        Distortion   uiOverallDistY        = 0;
        UInt         CandNum;
        Double       CandCostList[ FAST_UDI_MAX_RDMODE_NUM ];
        Pel          resiLumaPU[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

  // Lambda calculation at equivalent Qp of 4 is recommended because at that Qp, the quantisation divisor is 1.
#if FULL_NBIT
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#else
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12 - 6 * (sps.getBitDepth(CHANNEL_TYPE_LUMA) - 8)) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#endif

  //===== set QP and clear Cbf =====
  if ( pps.getUseDQP() == true)
  {
    pcCU->setQPSubParts( pcCU->getQP(0), 0, uiDepth );
  }
  else
  {
    pcCU->setQPSubParts( pcCU->getSlice()->getSliceQp(), 0, uiDepth );
  }

  //===== loop over partitions =====
  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);

  do
  {
    const UInt uiPartOffset=tuRecurseWithPU.GetAbsPartIdxTU();
//  for( UInt uiPU = 0, uiPartOffset=0; uiPU < uiNumPU; uiPU++, uiPartOffset += uiQNumParts )
  //{
    //===== init pattern for luma prediction =====
    DEBUG_STRING_NEW(sTemp2)

    //===== determine set of modes to be tested (using prediction signal only) =====
    Int numModesAvailable     = 35; //total number of Intra modes
    UInt uiRdModeList[FAST_UDI_MAX_RDMODE_NUM];
    Int numModesForFullRD = m_pcEncCfg->getFastUDIUseMPMEnabled()?g_aucIntraModeNumFast_UseMPM[ uiWidthBit ] : g_aucIntraModeNumFast_NotUseMPM[ uiWidthBit ];

    // this should always be true
    assert (tuRecurseWithPU.ProcessComponentSection(COMPONENT_Y));
    initIntraPatternChType( tuRecurseWithPU, COMPONENT_Y, true DEBUG_STRING_PASS_INTO(sTemp2) );

    Bool doFastSearch = (numModesForFullRD != numModesAvailable);
    if (doFastSearch)
    {
      assert(numModesForFullRD < numModesAvailable);

      for( Int i=0; i < numModesForFullRD; i++ )
      {
        CandCostList[ i ] = MAX_DOUBLE;
      }
      CandNum = 0;

      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt uiAbsPartIdx=tuRecurseWithPU.GetAbsPartIdxTU();

      Pel* piOrg         = pcOrgYuv ->getAddr( COMPONENT_Y, uiAbsPartIdx );
      Pel* piPred        = pcPredYuv->getAddr( COMPONENT_Y, uiAbsPartIdx );
      UInt uiStride      = pcPredYuv->getStride( COMPONENT_Y );
      DistParam distParam;
      const Bool bUseHadamard=pcCU->getCUTransquantBypass(0) == 0;
      m_pcRdCost->setDistParam(distParam, sps.getBitDepth(CHANNEL_TYPE_LUMA), piOrg, uiStride, piPred, uiStride, puRect.width, puRect.height, bUseHadamard);
      distParam.bApplyWeight = false;
      for( Int modeIdx = 0; modeIdx < numModesAvailable; modeIdx++ )
      {
        UInt       uiMode = modeIdx;
        Distortion uiSad  = 0;

        const Bool bUseFilter=TComPrediction::filteringIntraReferenceSamples(COMPONENT_Y, uiMode, puRect.width, puRect.height, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

        predIntraAng( COMPONENT_Y, uiMode, piOrg, uiStride, piPred, uiStride, tuRecurseWithPU, bUseFilter, TComPrediction::UseDPCMForFirstPassIntraEstimation(tuRecurseWithPU, uiMode) );

        // use hadamard transform here
        uiSad+=distParam.DistFunc(&distParam);

        UInt   iModeBits = 0;

        // NB xModeBitsIntra will not affect the mode for chroma that may have already been pre-estimated.
        iModeBits+=xModeBitsIntra( pcCU, uiMode, uiPartOffset, uiDepth, CHANNEL_TYPE_LUMA );

        Double cost      = (Double)uiSad + (Double)iModeBits * sqrtLambdaForFirstPass;

#if DEBUG_INTRA_SEARCH_COSTS
        std::cout << "1st pass mode " << uiMode << " SAD = " << uiSad << ", mode bits = " << iModeBits << ", cost = " << cost << "\n";
#endif

        CandNum += xUpdateCandList( uiMode, cost, numModesForFullRD, uiRdModeList, CandCostList );
      }

      if (m_pcEncCfg->getFastUDIUseMPMEnabled())
      {
        Int uiPreds[NUM_MOST_PROBABLE_MODES] = {-1, -1, -1};

        Int iMode = -1;
        pcCU->getIntraDirPredictor( uiPartOffset, uiPreds, COMPONENT_Y, &iMode );

        const Int numCand = ( iMode >= 0 ) ? iMode : Int(NUM_MOST_PROBABLE_MODES);

        for( Int j=0; j < numCand; j++)
        {
          Bool mostProbableModeIncluded = false;
          Int mostProbableMode = uiPreds[j];

          for( Int i=0; i < numModesForFullRD; i++)
          {
            mostProbableModeIncluded |= (mostProbableMode == uiRdModeList[i]);
          }
          if (!mostProbableModeIncluded)
          {
            uiRdModeList[numModesForFullRD++] = mostProbableMode;
          }
        }
      }
    }
    else
    {
      for( Int i=0; i < numModesForFullRD; i++)
      {
        uiRdModeList[i] = i;
      }
    }

    //===== check modes (using r-d costs) =====
#if HHI_RQT_INTRA_SPEEDUP_MOD
    UInt   uiSecondBestMode  = MAX_UINT;
    Double dSecondBestPUCost = MAX_DOUBLE;
#endif
    DEBUG_STRING_NEW(sPU)
    UInt       uiBestPUMode  = 0;
    Distortion uiBestPUDistY = 0;
    Double     dBestPUCost   = MAX_DOUBLE;

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
    UInt max=numModesForFullRD;

    if (DebugOptionList::ForceLumaMode.isSet())
    {
      max=0;  // we are forcing a direction, so don't bother with mode check
    }
    for ( UInt uiMode = 0; uiMode < max; uiMode++)
#else
    for( UInt uiMode = 0; uiMode < numModesForFullRD; uiMode++ )
#endif
    {
      // set luma prediction mode
      UInt uiOrgMode = uiRdModeList[uiMode];

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );

      DEBUG_STRING_NEW(sMode)
      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, true, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#endif

#if DEBUG_INTRA_SEARCH_COSTS
      std::cout << "2nd pass [luma,chroma] mode [" << Int(pcCU->getIntraDir(CHANNEL_TYPE_LUMA, uiPartOffset)) << "," << Int(pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, uiPartOffset)) << "] cost = " << dPUCost << "\n";
#endif

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sMode)
#if HHI_RQT_INTRA_SPEEDUP_MOD
        uiSecondBestMode  = uiBestPUMode;
        dSecondBestPUCost = dBestPUCost;
#endif
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();

        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
#if HHI_RQT_INTRA_SPEEDUP_MOD
      else if( dPUCost < dSecondBestPUCost )
      {
        uiSecondBestMode  = uiOrgMode;
        dSecondBestPUCost = dPUCost;
      }
#endif
    } // Mode loop

#if HHI_RQT_INTRA_SPEEDUP
#if HHI_RQT_INTRA_SPEEDUP_MOD
    for( UInt ui =0; ui < 2; ++ui )
#endif
    {
#if HHI_RQT_INTRA_SPEEDUP_MOD
      UInt uiOrgMode   = ui ? uiSecondBestMode  : uiBestPUMode;
      if( uiOrgMode == MAX_UINT )
      {
        break;
      }
#else
      UInt uiOrgMode = uiBestPUMode;
#endif

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
      if (DebugOptionList::ForceLumaMode.isSet())
      {
        uiOrgMode = DebugOptionList::ForceLumaMode.getInt();
      }
#endif

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );
      DEBUG_STRING_NEW(sModeTree)

      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;

      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, false, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sModeTree));

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sModeTree)
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );

        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
    } // Mode loop
#endif

    DEBUG_STRING_APPEND(sDebug, sPU)

    //--- update overall distortion ---
    uiOverallDistY += uiBestPUDistY;

    //--- update transform index and cbf ---
    const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
    ::memcpy( pcCU->getTransformIdx()       + uiPartOffset, m_puhQTTempTrIdx,  uiQPartNum * sizeof( UChar ) );
    for (UInt component = 0; component < numberValidComponents; component++)
    {
      const ComponentID compID = ComponentID(component);
      ::memcpy( pcCU->getCbf( compID  ) + uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
      ::memcpy( pcCU->getTransformSkip( compID  ) + uiPartOffset, m_puhQTTempTransformSkipFlag[compID ], uiQPartNum * sizeof( UChar ) );
    }

    //--- set reconstruction for next intra prediction blocks ---
    if( !tuRecurseWithPU.IsLastSection() )
    {
      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt  uiCompWidth   = puRect.width;
      const UInt  uiCompHeight  = puRect.height;

      const UInt  uiZOrder      = pcCU->getZorderIdxInCtu() + uiPartOffset;
            Pel*  piDes         = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
      const UInt  uiDesStride   = pcCU->getPic()->getPicYuvRec()->getStride( COMPONENT_Y);
      const Pel*  piSrc         = pcRecoYuv->getAddr( COMPONENT_Y, uiPartOffset );
      const UInt  uiSrcStride   = pcRecoYuv->getStride( COMPONENT_Y);

      for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
      {
        for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
        {
          piDes[ uiX ] = piSrc[ uiX ];
        }
      }
    }

    //=== update PU data ====
    pcCU->setIntraDirSubParts     ( CHANNEL_TYPE_LUMA, uiBestPUMode, uiPartOffset, uiDepth + uiInitTrDepth );
	
  } while (tuRecurseWithPU.nextSection(tuRecurseCU));


  if( uiNumPU > 1 )
  { // set Cbf for all blocks
    UInt uiCombCbfY = 0;
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfY |= pcCU->getCbf( uiPartIdx, COMPONENT_Y,  1 );
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Y  )[ uiOffs ] |= uiCombCbfY;
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  //===== reset context models =====
  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  //===== set distortion (rate and r-d costs are determined later) =====
  pcCU->getTotalDistortion() = uiOverallDistY;
}




Void
TEncSearch::estIntraPredChromaQT(TComDataCU* pcCU,
                                 TComYuv*    pcOrgYuv,
                                 TComYuv*    pcPredYuv,
                                 TComYuv*    pcResiYuv,
                                 TComYuv*    pcRecoYuv,
                                 Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                                 DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt    uiInitTrDepth  = pcCU->getPartitionSize(0) != SIZE_2Nx2N && enable4ChromaPUsInIntraNxNCU(pcOrgYuv->getChromaFormat()) ? 1 : 0;

  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);
  const UInt    uiQNumParts    = tuRecurseWithPU.GetAbsPartIdxNumParts();
  const UInt    uiDepthCU=tuRecurseWithPU.getCUDepth();
  const UInt    numberValidComponents = pcCU->getPic()->getNumberValidComponents();

  do
  {
    UInt       uiBestMode  = 0;
    Distortion uiBestDist  = 0;
    Double     dBestCost   = MAX_DOUBLE;

    //----- init mode list -----
    if (tuRecurseWithPU.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      UInt uiModeList[FAST_UDI_MAX_RDMODE_NUM];
      const UInt  uiQPartNum     = uiQNumParts;
      const UInt  uiPartOffset   = tuRecurseWithPU.GetAbsPartIdxTU();
      {
        UInt  uiMinMode = 0;
        UInt  uiMaxMode = NUM_CHROMA_MODE;

        //----- check chroma modes -----
        pcCU->getAllowedChromaDir( uiPartOffset, uiModeList );

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
        if (DebugOptionList::ForceChromaMode.isSet())
        {
          uiMinMode=DebugOptionList::ForceChromaMode.getInt();
          if (uiModeList[uiMinMode]==34)
          {
            uiMinMode=4; // if the fixed mode has been renumbered because DM_CHROMA covers it, use DM_CHROMA.
          }
          uiMaxMode=uiMinMode+1;
        }
#endif

        DEBUG_STRING_NEW(sPU)

        for( UInt uiMode = uiMinMode; uiMode < uiMaxMode; uiMode++ )
        {
          //----- restore context models -----
          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          
          DEBUG_STRING_NEW(sMode)
          //----- chroma coding -----
          Distortion uiDist = 0;
          pcCU->setIntraDirSubParts  ( CHANNEL_TYPE_CHROMA, uiModeList[uiMode], uiPartOffset, uiDepthCU+uiInitTrDepth );
          xRecurIntraChromaCodingQT       ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );

          if( pcCU->getSlice()->getPPS()->getUseTransformSkip() )
          {
            m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          }

          UInt    uiBits = xGetIntraBitsQT( tuRecurseWithPU, false, true, false );
          Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );

          //----- compare -----
          if( dCost < dBestCost )
          {
            DEBUG_STRING_SWAP(sPU, sMode);
            dBestCost   = dCost;
            uiBestDist  = uiDist;
            uiBestMode  = uiModeList[uiMode];

            xSetIntraResultChromaQT( pcRecoYuv, tuRecurseWithPU );
            for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
            {
              const ComponentID compID = ComponentID(componentIndex);
              ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_puhQTTempTransformSkipFlag[compID], pcCU->getTransformSkip( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_phQTTempCrossComponentPredictionAlpha[compID], pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, uiQPartNum * sizeof( SChar ) );
            }
          }
        }

        DEBUG_STRING_APPEND(sDebug, sPU)

        //----- set data -----
        for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
        {
          const ComponentID compID = ComponentID(componentIndex);
          ::memcpy( pcCU->getCbf( compID )+uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getTransformSkip( compID )+uiPartOffset, m_puhQTTempTransformSkipFlag[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, m_phQTTempCrossComponentPredictionAlpha[compID], uiQPartNum * sizeof( SChar ) );
        }
      }

      if( ! tuRecurseWithPU.IsLastSection() )
      {
        for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
        {
          const ComponentID compID    = ComponentID(ch);
          const TComRectangle &tuRect = tuRecurseWithPU.getRect(compID);
          const UInt  uiCompWidth     = tuRect.width;
          const UInt  uiCompHeight    = tuRect.height;
          const UInt  uiZOrder        = pcCU->getZorderIdxInCtu() + tuRecurseWithPU.GetAbsPartIdxTU();
                Pel*  piDes           = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
          const UInt  uiDesStride     = pcCU->getPic()->getPicYuvRec()->getStride( compID);
          const Pel*  piSrc           = pcRecoYuv->getAddr( compID, uiPartOffset );
          const UInt  uiSrcStride     = pcRecoYuv->getStride( compID);

          for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
          {
            for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
            {
              piDes[ uiX ] = piSrc[ uiX ];
            }
          }
        }
      }

      pcCU->setIntraDirSubParts( CHANNEL_TYPE_CHROMA, uiBestMode, uiPartOffset, uiDepthCU+uiInitTrDepth );
      pcCU->getTotalDistortion      () += uiBestDist;
    }

  } while (tuRecurseWithPU.nextSection(tuRecurseCU));

  //----- restore context models -----

  if( uiInitTrDepth != 0 )
  { // set Cbf for all blocks
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
}




/** Function for encoding and reconstructing luma/chroma samples of a PCM mode CU.
 * \param pcCU pointer to current CU
 * \param uiAbsPartIdx part index
 * \param pOrg pointer to original sample arrays
 * \param pPCM pointer to PCM code arrays
 * \param pPred pointer to prediction signal arrays
 * \param pResi pointer to residual signal arrays
 * \param pReco pointer to reconstructed sample arrays
 * \param uiStride stride of the original/prediction/residual sample arrays
 * \param uiWidth block width
 * \param uiHeight block height
 * \param compID texture component type
 */
Void TEncSearch::xEncPCM (TComDataCU* pcCU, UInt uiAbsPartIdx, Pel* pOrg, Pel* pPCM, Pel* pPred, Pel* pResi, Pel* pReco, UInt uiStride, UInt uiWidth, UInt uiHeight, const ComponentID compID )
{
  const UInt uiReconStride   = pcCU->getPic()->getPicYuvRec()->getStride(compID);
  const UInt uiPCMBitDepth   = pcCU->getSlice()->getSPS()->getPCMBitDepth(toChannelType(compID));
  const Int  channelBitDepth = pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
  Pel* pRecoPic = pcCU->getPic()->getPicYuvRec()->getAddr(compID, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu()+uiAbsPartIdx);

  const Int pcmShiftRight=(channelBitDepth - Int(uiPCMBitDepth));

  assert(pcmShiftRight >= 0);

  for( UInt uiY = 0; uiY < uiHeight; uiY++ )
  {
    for( UInt uiX = 0; uiX < uiWidth; uiX++ )
    {
      // Reset pred and residual
      pPred[uiX] = 0;
      pResi[uiX] = 0;
      // Encode
      pPCM[uiX] = (pOrg[uiX]>>pcmShiftRight);
      // Reconstruction
      pReco   [uiX] = (pPCM[uiX]<<(pcmShiftRight));
      pRecoPic[uiX] = pReco[uiX];
    }
    pPred += uiStride;
    pResi += uiStride;
    pPCM += uiWidth;
    pOrg += uiStride;
    pReco += uiStride;
    pRecoPic += uiReconStride;
  }
}


//!  Function for PCM mode estimation.
Void TEncSearch::IPCMSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv )
{
  UInt              uiDepth      = pcCU->getDepth(0);
  const Distortion  uiDistortion = 0;
  UInt              uiBits;

  Double dCost;

  for (UInt ch=0; ch < pcCU->getPic()->getNumberValidComponents(); ch++)
  {
    const ComponentID compID  = ComponentID(ch);
    const UInt width  = pcCU->getWidth(0)  >> pcCU->getPic()->getComponentScaleX(compID);
    const UInt height = pcCU->getHeight(0) >> pcCU->getPic()->getComponentScaleY(compID);
    const UInt stride = pcPredYuv->getStride(compID);

    Pel * pOrig    = pcOrgYuv->getAddr  (compID, 0, width);
    Pel * pResi    = pcResiYuv->getAddr(compID, 0, width);
    Pel * pPred    = pcPredYuv->getAddr(compID, 0, width);
    Pel * pReco    = pcRecoYuv->getAddr(compID, 0, width);
    Pel * pPCM     = pcCU->getPCMSample (compID);

    xEncPCM ( pcCU, 0, pOrig, pPCM, pPred, pResi, pReco, stride, width, height, compID );

  }

  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiDepth, 0, true, false);
  uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  dCost = m_pcRdCost->calcRdCost( uiBits, uiDistortion );

  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  pcCU->getTotalBits()       = uiBits;
  pcCU->getTotalCost()       = dCost;
  pcCU->getTotalDistortion() = uiDistortion;

  pcCU->copyToPic(uiDepth);
}




Void TEncSearch::xGetInterPredictionError( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, Distortion& ruiErr, Bool /*bHadamard*/ )
{
  motionCompensation( pcCU, &m_tmpYuvPred, REF_PIC_LIST_X, iPartIdx );

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;
  pcCU->getPartIndexAndSize( iPartIdx, uiAbsPartIdx, iWidth, iHeight );

  DistParam cDistParam;

  cDistParam.bApplyWeight = false;


  m_pcRdCost->setDistParam( cDistParam, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA),
                            pcYuvOrg->getAddr( COMPONENT_Y, uiAbsPartIdx ), pcYuvOrg->getStride(COMPONENT_Y),
                            m_tmpYuvPred .getAddr( COMPONENT_Y, uiAbsPartIdx ), m_tmpYuvPred.getStride(COMPONENT_Y),
                            iWidth, iHeight, m_pcEncCfg->getUseHADME() && (pcCU->getCUTransquantBypass(iPartIdx) == 0) );

  ruiErr = cDistParam.DistFunc( &cDistParam );
}

//! estimation of best merge coding
Void TEncSearch::xMergeEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPUIdx, UInt& uiInterDir, TComMvField* pacMvField, UInt& uiMergeIndex, Distortion& ruiCost, TComMvField* cMvFieldNeighbours, UChar* uhInterDirNeighbours, Int& numValidMergeCand )
{

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;

 
  pcCU->getPartIndexAndSize( iPUIdx, uiAbsPartIdx, iWidth, iHeight );
  UInt uiDepth = pcCU->getDepth( uiAbsPartIdx );

  PartSize partSize = pcCU->getPartitionSize( 0 );
  if ( pcCU->getSlice()->getPPS()->getLog2ParallelMergeLevelMinus2() && partSize != SIZE_2Nx2N && pcCU->getWidth( 0 ) <= 8 )
  {
    if ( iPUIdx == 0 )
    {
      pcCU->setPartSizeSubParts( SIZE_2Nx2N, 0, uiDepth ); // temporarily set
      pcCU->getInterMergeCandidates( 0, 0, cMvFieldNeighbours,uhInterDirNeighbours, numValidMergeCand );
      pcCU->setPartSizeSubParts( partSize, 0, uiDepth ); // restore
    }
  }
  else
  {
    pcCU->getInterMergeCandidates( uiAbsPartIdx, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );
  }

  xRestrictBipredMergeCand( pcCU, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );

  ruiCost = std::numeric_limits<Distortion>::max();
  for( UInt uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )
  {
    Distortion uiCostCand = std::numeric_limits<Distortion>::max();
    UInt       uiBitsCand = 0;

    PartSize ePartSize = pcCU->getPartitionSize( 0 );

    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( cMvFieldNeighbours[0 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( cMvFieldNeighbours[1 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );

    xGetInterPredictionError( pcCU, pcYuvOrg, iPUIdx, uiCostCand, m_pcEncCfg->getUseHADME() );
    uiBitsCand = uiMergeCand + 1;
    if (uiMergeCand == m_pcEncCfg->getMaxNumMergeCand() -1)
    {
        uiBitsCand--;
    }
    uiCostCand = uiCostCand + m_pcRdCost->getCost( uiBitsCand );
    if ( uiCostCand < ruiCost )
    {
      ruiCost = uiCostCand;
      pacMvField[0] = cMvFieldNeighbours[0 + 2*uiMergeCand];
      pacMvField[1] = cMvFieldNeighbours[1 + 2*uiMergeCand];
      uiInterDir = uhInterDirNeighbours[uiMergeCand];
      uiMergeIndex = uiMergeCand;
    }
  }
 
}

/** convert bi-pred merge candidates to uni-pred
 * \param pcCU
 * \param puIdx
 * \param mvFieldNeighbours
 * \param interDirNeighbours
 * \param numValidMergeCand
 * \returns Void
 */
Void TEncSearch::xRestrictBipredMergeCand( TComDataCU* pcCU, UInt puIdx, TComMvField* mvFieldNeighbours, UChar* interDirNeighbours, Int numValidMergeCand )
{
	
  if ( pcCU->isBipredRestriction(puIdx) )
  {
    for( UInt mergeCand = 0; mergeCand < numValidMergeCand; ++mergeCand )
    {
      if ( interDirNeighbours[mergeCand] == 3 )
      {
        interDirNeighbours[mergeCand] = 1;
        mvFieldNeighbours[(mergeCand << 1) + 1].setMvField(TComMv(0,0), -1);
      }
    }
  }
}

//! search of the best candidate for inter prediction
#if AMP_MRG
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv DEBUG_STRING_FN_DECLARE(sDebug), Bool bUseRes, Bool bUseMRG )
#else
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv, Bool bUseRes )
#endif
{
  for(UInt i=0; i<NUM_REF_PIC_LIST_01; i++)
  {
    m_acYuvPred[i].clear();
  }
  m_cYuvPredTemp.clear();
  pcPredYuv->clear();

  if ( !bUseRes )
  {
    pcResiYuv->clear();
  }

  pcRecoYuv->clear();
  
  TComMv       cMvSrchRngLT;
  TComMv       cMvSrchRngRB;

  TComMv       cMvZero;
  TComMv       TempMv; //kolya

  TComMv       cMv[2];
  TComMv       cMvBi[2];
  TComMv       cMvTemp[2][33];

  Int          iNumPart    = pcCU->getNumPartitions();
  Int          iNumPredDir = pcCU->getSlice()->isInterP() ? 1 : 2;

  TComMv       cMvPred[2][33];

  TComMv       cMvPredBi[2][33];
  Int          aaiMvpIdxBi[2][33];

  Int          aaiMvpIdx[2][33];
  Int          aaiMvpNum[2][33];

  AMVPInfo     aacAMVPInfo[2][33];

  Int          iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
  Int          iRefIdxBi[2];

  UInt         uiPartAddr;
  Int          iRoiWidth, iRoiHeight;

  UInt         uiMbBits[3] = {1, 1, 0};

  UInt         uiLastMode = 0;
  Int          iRefStart, iRefEnd;

  PartSize     ePartSize = pcCU->getPartitionSize( 0 );

  Int          bestBiPRefIdxL1 = 0;
  Int          bestBiPMvpL1 = 0;
  Distortion   biPDistTemp = std::numeric_limits<Distortion>::max();

  TComMvField cMvFieldNeighbours[MRG_MAX_NUM_CANDS << 1]; // double length for mv of both lists
  UChar uhInterDirNeighbours[MRG_MAX_NUM_CANDS];
  Int numValidMergeCand = 0 ;

  for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
  {
    Distortion   uiCost[2] = { std::numeric_limits<Distortion>::max(), std::numeric_limits<Distortion>::max() };
    Distortion   uiCostBi  =   std::numeric_limits<Distortion>::max();
    Distortion   uiCostTemp;

    UInt         uiBits[3];
    UInt         uiBitsTemp;
    Distortion   bestBiPDist = std::numeric_limits<Distortion>::max();

    Distortion   uiCostTempL0[MAX_NUM_REF];
    for (Int iNumRef=0; iNumRef < MAX_NUM_REF; iNumRef++)
    {
      uiCostTempL0[iNumRef] = std::numeric_limits<Distortion>::max();
    }
    UInt         uiBitsTempL0[MAX_NUM_REF];

    TComMv       mvValidList1;
    Int          refIdxValidList1 = 0;
    UInt         bitsValidList1 = MAX_UINT;
    Distortion   costValidList1 = std::numeric_limits<Distortion>::max();

    xGetBlkBits( ePartSize, pcCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);

    pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
	
	
#if AMP_MRG
    Bool bTestNormalMC = true;

    if ( bUseMRG && pcCU->getWidth( 0 ) > 8 && iNumPart == 2 )
    {
      bTestNormalMC = false;
    }

    if (bTestNormalMC)
    {
#endif

    //  Uni-directional prediction
    for ( Int iRefList = 0; iRefList < iNumPredDir; iRefList++ )
    {
      RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

      for ( Int iRefIdxTemp = 0; iRefIdxTemp < pcCU->getSlice()->getNumRefIdx(eRefPicList); iRefIdxTemp++ )
      {
        uiBitsTemp = uiMbBits[iRefList];
        if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
        {
          uiBitsTemp += iRefIdxTemp+1;
          if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
          {
            uiBitsTemp--;
          }
        }
        xEstimateMvPredAMVP( pcCU, pcOrgYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
        aaiMvpIdx[iRefList][iRefIdxTemp] = pcCU->getMVPIdx(eRefPicList, uiPartAddr);
        aaiMvpNum[iRefList][iRefIdxTemp] = pcCU->getMVPNum(eRefPicList, uiPartAddr);

        if(pcCU->getSlice()->getMvdL1ZeroFlag() && iRefList==1 && biPDistTemp < bestBiPDist)
        {
          bestBiPDist = biPDistTemp;
          bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
          bestBiPRefIdxL1 = iRefIdxTemp;
        }

        uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];

        if ( m_pcEncCfg->getFastMEForGenBLowDelayEnabled() && iRefList == 1 )    // list 1
        {
          if ( pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) >= 0 )
          {
            cMvTemp[1][iRefIdxTemp] = cMvTemp[0][pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            uiCostTemp = uiCostTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            /*first subtract the bit-rate part of the cost of the other list*/
            uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )] );
            /*correct the bit-rate part of the current ref*/
            m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
            uiBitsTemp += m_pcRdCost->getBitsOfVectorWithPredictor( cMvTemp[1][iRefIdxTemp].getHor(), cMvTemp[1][iRefIdxTemp].getVer() );
            /*calculate the correct cost*/
            uiCostTemp += m_pcRdCost->getCost( uiBitsTemp );
          }
          else
          {
            xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
          }
        }
        else
        {
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
        }
        xCopyAMVPInfo(pcCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
        xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

        if ( iRefList == 0 )
        {
          uiCostTempL0[iRefIdxTemp] = uiCostTemp;
          uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
        }
        if ( uiCostTemp < uiCost[iRefList] )
        {
          uiCost[iRefList] = uiCostTemp;
          uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

          // set motion
          cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
          iRefIdx[iRefList] = iRefIdxTemp;
        }

        if ( iRefList == 1 && uiCostTemp < costValidList1 && pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
        {
          costValidList1 = uiCostTemp;
          bitsValidList1 = uiBitsTemp;

          // set motion
          mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
          refIdxValidList1 = iRefIdxTemp;
        }
      }
    }

    //  Bi-predictive Motion estimation
    if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )
    {

      cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
      iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];

      ::memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
      ::memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));

      UInt uiMotBits[2];

      if(pcCU->getSlice()->getMvdL1ZeroFlag())
      {
        xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
        pcCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
        cMvPredBi[1][bestBiPRefIdxL1]   = pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo()->m_acMvCand[bestBiPMvpL1];

        cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
        iRefIdxBi[1] = bestBiPRefIdxL1;
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        TComYuv* pcYuvPred = &m_acYuvPred[REF_PIC_LIST_1];
        motionCompensation( pcCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );

        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiMbBits[1];

        if ( pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1) > 1 )
        {
          uiMotBits[1] += bestBiPRefIdxL1+1;
          if ( bestBiPRefIdxL1 == pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1)-1 )
          {
            uiMotBits[1]--;
          }
        }

        uiMotBits[1] += m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][AMVP_MAX_NUM_CANDS];

        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

        cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
      }
      else
      {
        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiBits[1] - uiMbBits[1];
        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
      }

      // 4-times iteration (default)
      Int iNumIter = 4;

      // fast encoder setting: only one iteration
      if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 || pcCU->getSlice()->getMvdL1ZeroFlag() )
      {
        iNumIter = 1;
      }

      for ( Int iIter = 0; iIter < iNumIter; iIter++ )
      {
        Int         iRefList    = iIter % 2;

        if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 )
        {
          if( uiCost[0] <= uiCost[1] )
          {
            iRefList = 1;
          }
          else
          {
            iRefList = 0;
          }
        }
        else if ( iIter == 0 )
        {
          iRefList = 0;
        }
        if ( iIter == 0 && !pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllMv( cMv[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllRefIdx( iRefIdx[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          TComYuv*  pcYuvPred = &m_acYuvPred[1-iRefList];
          motionCompensation ( pcCU, pcYuvPred, RefPicList(1-iRefList), iPartIdx );
        }

        RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

        if(pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          iRefList = 0;
          eRefPicList = REF_PIC_LIST_0;
        }

        Bool bChanged = false;

        iRefStart = 0;
        iRefEnd   = pcCU->getSlice()->getNumRefIdx(eRefPicList)-1;

        for ( Int iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
        {
          uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
          if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
          {
            uiBitsTemp += iRefIdxTemp+1;
            if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
            {
              uiBitsTemp--;
            }
          }
          uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];
          // call ME
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );

          xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], pcCU->getCUMvField(eRefPicList)->getAMVPInfo());
          xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

          if ( uiCostTemp < uiCostBi )
          {
            bChanged = true;

            cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
            iRefIdxBi[iRefList] = iRefIdxTemp;

            uiCostBi            = uiCostTemp;
            uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
            uiBits[2]           = uiBitsTemp;

            if(iNumIter!=1)
            {
              //  Set motion
              pcCU->getCUMvField( eRefPicList )->setAllMv( cMvBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
              pcCU->getCUMvField( eRefPicList )->setAllRefIdx( iRefIdxBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );

              TComYuv* pcYuvPred = &m_acYuvPred[iRefList];
              motionCompensation( pcCU, pcYuvPred, eRefPicList, iPartIdx );
            }
          }
        } // for loop-iRefIdxTemp

        if ( !bChanged )
        {
          if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
          {
            xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
            xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
            if(!pcCU->getSlice()->getMvdL1ZeroFlag())
            {
              xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
              xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
            }
          }
          break;
        }
      } // for loop-iter
    } // if (B_SLICE)

#if AMP_MRG
    } //end if bTestNormalMC
#endif
    //  Clear Motion Field
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );

    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

    UInt uiMEBits = 0;
    // Set Motion Field_
    cMv[1] = mvValidList1;
	
    iRefIdx[1] = refIdxValidList1;
    uiBits[1] = bitsValidList1;
    uiCost[1] = costValidList1;

#if AMP_MRG
    if (bTestNormalMC)
    {
#endif
    if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
    {
      uiLastMode = 2;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMvBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdxBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 3, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[2];
    }
    else if ( uiCost[0] <= uiCost[1] )
    {
      uiLastMode = 0;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[0];
    }
    else
    {
      uiLastMode = 1;
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMv[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdx[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 2, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[1];
    }
#if AMP_MRG
    } // end if bTestNormalMC
#endif

    if ( pcCU->getPartitionSize( uiPartAddr ) != SIZE_2Nx2N )
    {
      UInt uiMRGInterDir = 0;
      TComMvField cMRGMvField[2];
      UInt uiMRGIndex = 0;

      UInt uiMEInterDir = 0;
      TComMvField cMEMvField[2];

      m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

#if AMP_MRG
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      Distortion uiMECost  = std::numeric_limits<Distortion>::max();

      if (bTestNormalMC)
      {
        xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
        uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
      }
#else
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
      Distortion uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
#endif
      // save ME result.
      uiMEInterDir = pcCU->getInterDir( uiPartAddr );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

      // find Merge result
      Distortion uiMRGCost = std::numeric_limits<Distortion>::max();

      xMergeEstimation( pcCU, pcOrgYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);

      if ( uiMRGCost < uiMECost )
      {
        // set Merge result
        pcCU->setMergeFlagSubParts ( true,          uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setMergeIndexSubParts( uiMRGIndex,    uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts  ( uiMRGInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMRGMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMRGMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      }
      else
      {
        // set ME result
        pcCU->setMergeFlagSubParts( false,        uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts ( uiMEInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMEMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMEMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );
      }
    }

    //  MC
    motionCompensation ( pcCU, pcPredYuv, REF_PIC_LIST_X, iPartIdx );

  } //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )

  setWpScalingDistParam( pcCU, -1, REF_PIC_LIST_X );
 // CTUW = iRoiWidth;
 // CTUH = iRoiHeight;
 // myfile << CTUH << ',' << CTUW << endl;
  return;
}


// AMVP
Void TEncSearch::xEstimateMvPredAMVP( TComDataCU* pcCU, TComYuv* pcOrgYuv, UInt uiPartIdx, RefPicList eRefPicList, Int iRefIdx, TComMv& rcMvPred, Bool bFilled, Distortion* puiDistBiP )
{

  AMVPInfo*  pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();

  TComMv     cBestMv;
  Int        iBestIdx   = 0;
  TComMv     cZeroMv;
  TComMv     cMvPred;
  Distortion uiBestCost = std::numeric_limits<Distortion>::max();
  UInt       uiPartAddr = 0;
  Int        iRoiWidth, iRoiHeight;
  Int        i;
 
  pcCU->getPartIndexAndSize( uiPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
 

  // Fill the MV Candidates
  if (!bFilled)
  {
    pcCU->fillMvpCand( uiPartIdx, uiPartAddr, eRefPicList, iRefIdx, pcAMVPInfo );
  }

  // initialize Mvp index & Mvp
  iBestIdx = 0;
  cBestMv  = pcAMVPInfo->m_acMvCand[0];
  if (pcAMVPInfo->iN <= 1)
  {
    rcMvPred = cBestMv;

    pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));

    if(pcCU->getSlice()->getMvdL1ZeroFlag() && eRefPicList==REF_PIC_LIST_1)
    {
      (*puiDistBiP) = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, rcMvPred, 0, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    }
    return;
  }

  if (bFilled)
  {
    assert(pcCU->getMVPIdx(eRefPicList,uiPartAddr) >= 0);
    rcMvPred = pcAMVPInfo->m_acMvCand[pcCU->getMVPIdx(eRefPicList,uiPartAddr)];
    return;
  }

  m_cYuvPredTemp.clear();
  //-- Check Minimum Cost.
  for ( i = 0 ; i < pcAMVPInfo->iN; i++)
  {
    Distortion uiTmpCost;
    uiTmpCost = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, pcAMVPInfo->m_acMvCand[i], i, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    if ( uiBestCost > uiTmpCost )
    {
      uiBestCost = uiTmpCost;
      cBestMv   = pcAMVPInfo->m_acMvCand[i];
      iBestIdx  = i;
      (*puiDistBiP) = uiTmpCost;
    }
  }

  m_cYuvPredTemp.clear();

  // Setting Best MVP
  rcMvPred = cBestMv;
  pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  return;
  
}

UInt TEncSearch::xGetMvpIdxBits(Int iIdx, Int iNum)
{
  assert(iIdx >= 0 && iNum >= 0 && iIdx < iNum);

  if (iNum == 1)
  {
    return 0;
  }

  UInt uiLength = 1;
  Int iTemp = iIdx;
  if ( iTemp == 0 )
  {
    return uiLength;
  }

  Bool bCodeLast = ( iNum-1 > iTemp );

  uiLength += (iTemp-1);

  if( bCodeLast )
  {
    uiLength++;
  }

  return uiLength;
}

Void TEncSearch::xGetBlkBits( PartSize eCUMode, Bool bPSlice, Int iPartIdx, UInt uiLastMode, UInt uiBlkBit[3])
{
  if ( eCUMode == SIZE_2Nx2N )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else if ( (eCUMode == SIZE_2NxN || eCUMode == SIZE_2NxnU) || eCUMode == SIZE_2NxnD )
  {
    UInt aauiMbBits[2][3][3] = { { {0,0,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7,5,7}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( (eCUMode == SIZE_Nx2N || eCUMode == SIZE_nLx2N) || eCUMode == SIZE_nRx2N )
  {
    UInt aauiMbBits[2][3][3] = { { {0,2,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7-2,7-2,9-2}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( eCUMode == SIZE_NxN )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else
  {
    printf("Wrong!\n");
    assert( 0 );
  }
}

Void TEncSearch::xCopyAMVPInfo (AMVPInfo* pSrc, AMVPInfo* pDst)
{
  pDst->iN = pSrc->iN;
  for (Int i = 0; i < pSrc->iN; i++)
  {
    pDst->m_acMvCand[i] = pSrc->m_acMvCand[i];
  }
}

Void TEncSearch::xCheckBestMVP ( TComDataCU* pcCU, RefPicList eRefPicList, TComMv cMv, TComMv& rcMvPred, Int& riMVPIdx, UInt& ruiBits, Distortion& ruiCost )
{
  AMVPInfo* pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();
  
  assert(pcAMVPInfo->m_acMvCand[riMVPIdx] == rcMvPred);

  if (pcAMVPInfo->iN < 2)
  {
    return;
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(0) );
  m_pcRdCost->setCostScale ( 0    );

  Int iBestMVPIdx = riMVPIdx;

  m_pcRdCost->setPredictor( rcMvPred );
  Int iOrgMvBits  = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
  iOrgMvBits += m_auiMVPIdxCost[riMVPIdx][AMVP_MAX_NUM_CANDS];
  Int iBestMvBits = iOrgMvBits;

  for (Int iMVPIdx = 0; iMVPIdx < pcAMVPInfo->iN; iMVPIdx++)
  {
    if (iMVPIdx == riMVPIdx)
    {
      continue;
    }

    m_pcRdCost->setPredictor( pcAMVPInfo->m_acMvCand[iMVPIdx] );

    Int iMvBits = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
    iMvBits += m_auiMVPIdxCost[iMVPIdx][AMVP_MAX_NUM_CANDS];

    if (iMvBits < iBestMvBits)
    {
      iBestMvBits = iMvBits;
      iBestMVPIdx = iMVPIdx;
    }
  }

  if (iBestMVPIdx != riMVPIdx)  //if changed
  {
    rcMvPred = pcAMVPInfo->m_acMvCand[iBestMVPIdx];

    riMVPIdx = iBestMVPIdx;
    UInt uiOrgBits = ruiBits;
    ruiBits = uiOrgBits - iOrgMvBits + iBestMvBits;
    ruiCost = (ruiCost - m_pcRdCost->getCost( uiOrgBits ))  + m_pcRdCost->getCost( ruiBits );
  }
  
}


Distortion TEncSearch::xGetTemplateCost( TComDataCU* pcCU,
                                         UInt        uiPartAddr,
                                         TComYuv*    pcOrgYuv,
                                         TComYuv*    pcTemplateCand,
                                         TComMv      cMvCand,
                                         Int         iMVPIdx,
                                         Int         iMVPNum,
                                         RefPicList  eRefPicList,
                                         Int         iRefIdx,
                                         Int         iSizeX,
                                         Int         iSizeY
                                         )
{
  Distortion uiCost = std::numeric_limits<Distortion>::max();

  TComPicYuv* pcPicYuvRef = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdx )->getPicYuvRec();

  pcCU->clipMv( cMvCand );

  // prediction pattern
  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, true, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }
  else
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, false, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }

  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xWeightedPredictionUni( pcCU, pcTemplateCand, uiPartAddr, iSizeX, iSizeY, eRefPicList, pcTemplateCand, iRefIdx );
  }

  // calc distortion

  uiCost = m_pcRdCost->getDistPart( pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA), pcTemplateCand->getAddr(COMPONENT_Y, uiPartAddr), pcTemplateCand->getStride(COMPONENT_Y), pcOrgYuv->getAddr(COMPONENT_Y, uiPartAddr), pcOrgYuv->getStride(COMPONENT_Y), iSizeX, iSizeY, COMPONENT_Y, DF_SAD );
  uiCost = (UInt) m_pcRdCost->calcRdCost( m_auiMVPIdxCost[iMVPIdx][iMVPNum], uiCost, DF_SAD );
  return uiCost;
}


Void TEncSearch::xMotionEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, RefPicList eRefPicList, TComMv* pcMvPred, Int iRefIdxPred, TComMv& rcMv, UInt& ruiBits, Distortion& ruiCost, Bool bBi  )
{
  UInt          uiPartAddr;
  Int           iRoiWidth;
  Int           iRoiHeight;

  TComMv        cMvHalf, cMvQter;
  TComMv        cMvSrchRngLT;
  TComMv        cMvSrchRngRB;
  // Distortion   INTCOST=0;
  TComYuv*      pcYuv = pcYuvOrg;
   
  assert(eRefPicList < MAX_NUM_REF_LIST_ADAPT_SR && iRefIdxPred<Int(MAX_IDX_ADAPT_SR));
  m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];

  Int           iSrchRng      = ( bBi ? m_bipredSearchRange : m_iSearchRange );
  TComPattern   tmpPattern;
  TComPattern*  pcPatternKey  = &tmpPattern;

  Double        fWeight       = 1.0;

  pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );

  if ( bBi ) // Bipredictive ME
  {
    TComYuv*  pcYuvOther = &m_acYuvPred[1-(Int)eRefPicList];
    pcYuv                = &m_cYuvPredTemp;

    pcYuvOrg->copyPartToPartYuv( pcYuv, uiPartAddr, iRoiWidth, iRoiHeight );

    pcYuv->removeHighFreq( pcYuvOther, uiPartAddr, iRoiWidth, iRoiHeight, pcCU->getSlice()->getSPS()->getBitDepths().recon, m_pcEncCfg->getClipForBiPredMeEnabled() );

    fWeight = 0.5;
  }
  m_cDistParam.bIsBiPred = bBi;

  //  Search key pattern initialization
  pcPatternKey->initPattern( pcYuv->getAddr  ( COMPONENT_Y, uiPartAddr ),
                             iRoiWidth,
                             iRoiHeight,
                             pcYuv->getStride(COMPONENT_Y),
                             pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );

  Pel*        piRefY      = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu() + uiPartAddr );
  Int         iRefStride  = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getStride(COMPONENT_Y);

  TComMv      cMvPred = *pcMvPred;

  if ( bBi )
  {
	  
    xSetSearchRange   ( pcCU, rcMv   , iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }
  else
  {
	  
    xSetSearchRange   ( pcCU, cMvPred, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }

  m_pcRdCost->selectMotionLambda(true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setPredictor  ( *pcMvPred );
  m_pcRdCost->setCostScale  ( 2 );

  setWpScalingDistParam( pcCU, iRefIdxPred, eRefPicList );
  //  Do integer search
  if ( (m_motionEstimationSearchMethod==MESEARCH_FULL) || bBi )
  {
    xPatternSearch      ( pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost );
  }
  else
  {
    rcMv = *pcMvPred;
    const TComMv *pIntegerMv2Nx2NPred=0;
    if (pcCU->getPartitionSize(0) != SIZE_2Nx2N || pcCU->getDepth(0) != 0)
    {
      pIntegerMv2Nx2NPred = &(m_integerMv2Nx2N[eRefPicList][iRefIdxPred]);
    }
    
    // EMI: Save Block width and height in global variables, to use in our NN
    PUHeight = iRoiHeight;
    PUWidth = iRoiWidth;
    PIdx = iPartIdx;
    PAddr = uiPartAddr;

    xPatternSearchFast  ( pcCU, pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost, pIntegerMv2Nx2NPred );
    if (pcCU->getPartitionSize(0) == SIZE_2Nx2N)
    {
      m_integerMv2Nx2N[eRefPicList][iRefIdxPred] = rcMv;
    }
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );
  m_pcRdCost->setCostScale ( 1 );
  
  const Bool bIsLosslessCoded = pcCU->getCUTransquantBypass(uiPartAddr) != 0;
  xPatternSearchFracDIF( bIsLosslessCoded, pcPatternKey, piRefY, iRefStride, &rcMv, cMvHalf, cMvQter, ruiCost );

  m_pcRdCost->setCostScale( 0 );

  
  
  // EMI: Modification
  
  /* 
  Fractional Motion Estimation values computed by standard are stored in TComMv variables cMvHalf & cMvQter
  We create other TComMv variables, and replace the standard values with our NN predicted values
  Our NN modifies global variables MVX_HALF & MVX_QRTER, which in return are set used to set our new Mv
  */
  TComMv MV_HALF, MV_QRTER;
  MV_HALF.setHor(MVX_HALF);
  MV_HALF.setVer(MVY_HALF);
  MV_QRTER.setHor(MVX_QRTER);
  MV_QRTER.setVer(MVY_QRTER);

  // For finding Integer Motion Estimation, Set Horizontal and Vertical values to zero:

  // MV_HALF.setHor(0);
  // MV_HALF.setVer(0);
  // MV_QRTER.setHor(0);
  // MV_QRTER.setVer(0);

  /* 
  EMI: To Write the errors and output MV in a CSV file:
  Real values for errors: U,V,H           - NN values for errors: IN[]
  Real values for MV: cMvHalf, cMvQter    - NN values for MV: MV_HALF, MV_QRTER
  Block Width and Hight: iRoiWidth, iRoiHeight
  */
  
  // ofstream mv_nn;
  // ofstream errors;
  // errors.open("/home/emi/git-repos/data/HM16.9/extract_data/SSE_errors.csv", ios::app);
  // mv_nn.open("/home/emi/git-repos/data/HM16.9/extract_data/mv_nn.csv", ios::app);
  // mv_nn << NN_out << endl;
  // mv_nn << MV_HALF.getHor() << ',' << MV_QRTER.getHor() << ',' << MV_HALF.getVer() << ',' << MV_QRTER.getVer() << endl;
  // mv_nn << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer()  << endl;
  // errors << IN[8] << ',' << IN[9] << ',' << IN[10] << ',' << IN[11] << ',' << IN[12] << ',' << IN[13] << ',' << IN[14] << ',' << IN[15] << ',' << IN[16] << endl;
  // errors << IN[0] << ',' << IN[1] << ',' << IN[2] << ',' << IN[3] << ',' << IN[4] << ',' << IN[5] << ',' << IN[6] << ',' << IN[7] << endl;

  // errors << U1 << ',' << V1 << ',' << U2 << ',' << H1 << ',' << C << ',' << H2 << ',' << U3 << ',' << V2 << ',' << U4 << ',' << iRoiHeight << ',' << iRoiWidth;
  // errors << ',' << uiPartAddr << ',' << iPartIdx << endl;
  
  /*
  EXPERIMENTAL -> Write the values of the output class directly instead of coordinates "Works quite well":
  Half * 0.5 + Quarter * 0.25:  results in range from -0.75->0.75
  Add both X & Y + 0.75:        range is now 0->1.5
  Multiply X by 4:              X values are now [0, 1, 2, 3, 4, 5, 6]
  Multiply Y by 4*7=28:         Y values are now [0, 7, 14, 21, 28, 35, 42]
  Adding X+Y results in the desired output class, given that the mapping starts from 
  0 for top left corner, 24 center, and 48 for bottom right corner
  */
  
  // int MV_X = (((cMvHalf.getHor() * 0.5) + (cMvQter.getHor() * 0.25)) + 0.75) * 4;
  // int MV_Y = (((cMvHalf.getVer() * 0.5) + (cMvQter.getVer() * 0.25)) + 0.75) * 28;
  // int OUT_CLASS = MV_Y + MV_X;
  // mv_nn << OUT_CLASS << endl;
  // mv_nn << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer()  << endl;
  

  // Replace Motion Vector with values computed by our NN

  rcMv <<= 2;
  // rcMv += (cMvHalf <<= 1);
  // rcMv += cMvQter;
  rcMv += (MV_HALF <<= 1);
  rcMv += MV_QRTER;
  
  // End of modification

  UInt uiMvBits = m_pcRdCost->getBitsOfVectorWithPredictor( rcMv.getHor(), rcMv.getVer() );

  ruiBits      += uiMvBits;
  ruiCost       = (Distortion)( floor( fWeight * ( (Double)ruiCost - (Double)m_pcRdCost->getCost( uiMvBits ) ) ) + (Double)m_pcRdCost->getCost( ruiBits ) );
}


Void TEncSearch::xSetSearchRange ( const TComDataCU* const pcCU, const TComMv& cMvPred, const Int iSrchRng,
                                   TComMv& rcMvSrchRngLT, TComMv& rcMvSrchRngRB )
{
  Int  iMvShift = 2;
  TComMv cTmpMvPred = cMvPred;
  pcCU->clipMv( cTmpMvPred );

  rcMvSrchRngLT.setHor( cTmpMvPred.getHor() - (iSrchRng << iMvShift) );
  rcMvSrchRngLT.setVer( cTmpMvPred.getVer() - (iSrchRng << iMvShift) );

  rcMvSrchRngRB.setHor( cTmpMvPred.getHor() + (iSrchRng << iMvShift) );
  rcMvSrchRngRB.setVer( cTmpMvPred.getVer() + (iSrchRng << iMvShift) );
  pcCU->clipMv        ( rcMvSrchRngLT );
  pcCU->clipMv        ( rcMvSrchRngRB );

#if ME_ENABLE_ROUNDING_OF_MVS
  rcMvSrchRngLT.divideByPowerOf2(iMvShift);
  rcMvSrchRngRB.divideByPowerOf2(iMvShift);
#else
  rcMvSrchRngLT >>= iMvShift;
  rcMvSrchRngRB >>= iMvShift;
#endif
}


Void TEncSearch::xPatternSearch(const TComPattern* const pcPatternKey,
	const Pel*               piRefY,
	const Int                iRefStride,
	const TComMv* const      pcMvSrchRngLT,
	const TComMv* const      pcMvSrchRngRB,
	TComMv&      rcMv,
	Distortion&  ruiSAD)
{
	Int   iSrchRngHorLeft = pcMvSrchRngLT->getHor();
	Int   iSrchRngHorRight = pcMvSrchRngRB->getHor();
	Int   iSrchRngVerTop = pcMvSrchRngLT->getVer();
	Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

	Distortion  uiSad;
	Distortion  uiSadBest = std::numeric_limits<Distortion>::max();
	Int         iBestX = 0;
	Int         iBestY = 0;


	m_pcRdCost->setDistParam(pcPatternKey, piRefY, iRefStride, m_cDistParam);

	// fast encoder decision: use subsampled SAD for integer ME
	if (m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE3)
	{
		if (m_cDistParam.iRows > 8)
		{
			m_cDistParam.iSubShift = 1;
		}
	}

	piRefY += (iSrchRngVerTop * iRefStride);

	for (Int y = iSrchRngVerTop; y <= iSrchRngVerBottom; y++)
	{
		for (Int x = iSrchRngHorLeft; x <= iSrchRngHorRight; x++)
		{
			//  find min. distortion position
			m_cDistParam.pCur = piRefY + x;

			setDistParamComp(COMPONENT_Y);

			m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
			uiSad = m_cDistParam.DistFunc(&m_cDistParam);

			// motion cost
			uiSad += m_pcRdCost->getCostOfVectorWithPredictor(x, y);

			if (uiSad < uiSadBest)
			{
				uiSadBest = uiSad;
				iBestX = x;
				iBestY = y;
				m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
			}
		}
		piRefY += iRefStride;
	}




		rcMv.set(iBestX, iBestY);


		ruiSAD = uiSadBest - m_pcRdCost->getCostOfVectorWithPredictor(iBestX, iBestY);

		//getchar();
		return;
	}


Void TEncSearch::xPatternSearchFast( const TComDataCU* const  pcCU,
                                     const TComPattern* const pcPatternKey,
                                     const Pel* const         piRefY,
                                     const Int                iRefStride,
                                     const TComMv* const      pcMvSrchRngLT,
                                     const TComMv* const      pcMvSrchRngRB,
                                     TComMv&                  rcMv,
                                     Distortion&              ruiSAD,
                                     const TComMv* const      pIntegerMv2Nx2NPred )
{
  assert (MD_LEFT < NUM_MV_PREDICTORS);
  pcCU->getMvPredLeft       ( m_acMvPredictors[MD_LEFT] );
  assert (MD_ABOVE < NUM_MV_PREDICTORS);
  pcCU->getMvPredAbove      ( m_acMvPredictors[MD_ABOVE] );
  assert (MD_ABOVE_RIGHT < NUM_MV_PREDICTORS);
  pcCU->getMvPredAboveRight ( m_acMvPredictors[MD_ABOVE_RIGHT] );

  switch ( m_motionEstimationSearchMethod )
  {
    case MESEARCH_DIAMOND:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, false );
	  
      C = array_e[0];
      for (int i = 1; i <=index_ref - 1; i++)
      {
        if (array_e[i] < C)
          C = array_e[i];

      }
	 
      // index_ref = index_ref + 1;
      U1 = array_e[index_ref];
      V1 = array_e[index_ref + 1];
      U2 = array_e[index_ref + 2];
      H1 = array_e[index_ref + 3];	  
      H2 = array_e[index_ref + 4];
      U3 = array_e[index_ref + 5];
      V2 = array_e[index_ref + 6];
      U4 = array_e[index_ref + 7];
      	  
      // EMI: neural network implementation
      
      // Reset all values of arrays

      memset(IN, 0, sizeof(IN));
      memset(X1, 0, sizeof(X1));
      memset(X2, 0, sizeof(X2));
      memset(OUT, 0, sizeof(OUT));
      memset(array_e, 0, sizeof(array_e));
      N = 0; NN_out = 0; counter_i = 0; index_ref = 0;


      // Normalize input values using the computed mean and standard deviations

      IN[17] = (U1 - mean[0]) / stdev[0];
      IN[18] = (V1 - mean[1]) / stdev[1];
      IN[19] = (U2 - mean[2]) / stdev[2];
      IN[20] = (H1 - mean[3]) / stdev[3];
      IN[21] = (C - mean[4]) / stdev[4];
      IN[22] = (H2 - mean[5]) / stdev[5];
      IN[23] = (U3 - mean[6]) / stdev[6];
      IN[24] = (V2 - mean[7]) / stdev[7];
      IN[25] = (U4 - mean[8]) / stdev[8];

      // Input layer also consists of categorical variables, in which we will use embedding matrices depending on block Height and Width

      switch (PUHeight) {
        case 4:   IN[0] = embs0[1][0];  IN[1] = embs0[1][1];   IN[2] = embs0[1][2];   IN[3] = embs0[1][3];		break;
        case 8:   IN[0] = embs0[2][0];  IN[1] = embs0[2][1];   IN[2] = embs0[2][2];   IN[3] = embs0[2][3];		break;
        case 12:  IN[0] = embs0[3][0];  IN[1] = embs0[3][1];   IN[2] = embs0[3][2];   IN[3] = embs0[3][3];	  break;
        case 16:  IN[0] = embs0[4][0];  IN[1] = embs0[4][1];   IN[2] = embs0[4][2];   IN[3] = embs0[4][3];		break;
        case 24:  IN[0] = embs0[5][0];  IN[1] = embs0[5][1];   IN[2] = embs0[5][2];   IN[3] = embs0[5][3];	  break;
        case 32:  IN[0] = embs0[6][0];  IN[1] = embs0[6][1];   IN[2] = embs0[6][2];   IN[3] = embs0[6][3];		break;
        case 64:  IN[0] = embs0[7][0];  IN[1] = embs0[7][1];   IN[2] = embs0[7][2];   IN[3] = embs0[7][3];		break;
        default:  IN[0] = embs0[0][0];  IN[1] = embs0[0][1];   IN[2] = embs0[0][2];   IN[3] = embs0[0][3];		break;
      }

      switch (PUWidth) {
        case 4:   IN[4] = embs1[1][0];  IN[5] = embs1[1][1];   IN[6] = embs1[1][2];   IN[7] = embs1[1][3];		break;
        case 8:   IN[4] = embs1[2][0];  IN[5] = embs1[2][1];   IN[6] = embs1[2][2];   IN[7] = embs1[2][3];		break;
        case 12:  IN[4] = embs1[3][0];  IN[5] = embs1[3][1];   IN[6] = embs1[3][2];   IN[7] = embs1[3][3];	  break;
        case 16:  IN[4] = embs1[4][0];  IN[5] = embs1[4][1];   IN[6] = embs1[4][2];   IN[7] = embs1[4][3];		break;
        case 24:  IN[4] = embs1[5][0];  IN[5] = embs1[5][1];   IN[6] = embs1[5][2];   IN[7] = embs1[5][3];	  break;
        case 32:  IN[4] = embs1[6][0];  IN[5] = embs1[6][1];   IN[6] = embs1[6][2];   IN[7] = embs1[6][3];		break;
        case 64:  IN[4] = embs1[7][0];  IN[5] = embs1[7][1];   IN[6] = embs1[7][2];   IN[7] = embs1[7][3];		break;
        default:  IN[4] = embs1[0][0];  IN[5] = embs1[0][1];   IN[6] = embs1[0][2];   IN[7] = embs1[0][3];		break;
      }

      switch (PIdx) {
        case 0:   IN[8] = embs2[1][0];  IN[9] = embs2[1][1];   break;
        case 1:   IN[8] = embs2[2][0];  IN[9] = embs2[2][1];   break;
        default:  IN[8] = embs2[0][0];  IN[9] = embs2[0][1];   break;
      }
      
      switch (PAddr) {
        case 0:   IN[10] = embs3[1][0];   IN[11] = embs3[1][1];   IN[12] = embs3[1][2];   IN[13] = embs3[1][3];		
                  IN[14] = embs3[1][4];	  IN[15] = embs3[1][5];	  IN[16] = embs3[1][6];		break;
        case 1:   IN[10] = embs3[2][0];   IN[11] = embs3[2][1];   IN[12] = embs3[2][2];   IN[13] = embs3[2][3];		
                  IN[14] = embs3[2][4];	  IN[15] = embs3[2][5];	  IN[16] = embs3[2][6];		break;
        case 2:   IN[10] = embs3[3][0];   IN[11] = embs3[3][1];   IN[12] = embs3[3][2];   IN[13] = embs3[3][3];
                  IN[14] = embs3[3][4];	  IN[15] = embs3[3][5];	  IN[16] = embs3[3][6];		break;
        case 4:   IN[10] = embs3[4][0];   IN[11] = embs3[4][1];   IN[12] = embs3[4][2];   IN[13] = embs3[4][3];
                  IN[14] = embs3[4][4];	  IN[15] = embs3[4][5];	  IN[16] = embs3[4][6];		break;
        case 5:   IN[10] = embs3[5][0];   IN[11] = embs3[5][1];   IN[12] = embs3[5][2];   IN[13] = embs3[5][3];
                  IN[14] = embs3[5][4];	  IN[15] = embs3[5][5];	  IN[16] = embs3[5][6];		break;
        case 8:   IN[10] = embs3[6][0];   IN[11] = embs3[6][1];   IN[12] = embs3[6][2];   IN[13] = embs3[6][3];
                  IN[14] = embs3[6][4];	  IN[15] = embs3[6][5];	  IN[16] = embs3[6][6];		break;
        case 10:  IN[10] = embs3[7][0];   IN[11] = embs3[7][1];   IN[12] = embs3[7][2];   IN[13] = embs3[7][3];
                  IN[14] = embs3[7][4];	  IN[15] = embs3[7][5];	  IN[16] = embs3[7][6];		break;
        case 16:  IN[10] = embs3[8][0];   IN[11] = embs3[8][1];   IN[12] = embs3[8][2];   IN[13] = embs3[8][3];
                  IN[14] = embs3[8][4];	  IN[15] = embs3[8][5];	  IN[16] = embs3[8][6];		break;
        case 20:  IN[10] = embs3[9][0];   IN[11] = embs3[9][1];   IN[12] = embs3[9][2];   IN[13] = embs3[9][3];
                  IN[14] = embs3[9][4];	  IN[15] = embs3[9][5];	  IN[16] = embs3[9][6];		break;
        case 32:  IN[10] = embs3[10][0];  IN[11] = embs3[10][1];  IN[12] = embs3[10][2];  IN[13] = embs3[10][3];
                  IN[14] = embs3[10][4];  IN[15] = embs3[10][5];	IN[16] = embs3[10][6];	break;
        case 40:  IN[10] = embs3[11][0];  IN[11] = embs3[11][1];  IN[12] = embs3[11][2];  IN[13] = embs3[11][3];
                  IN[14] = embs3[11][4];	IN[15] = embs3[11][5];	IN[16] = embs3[11][6];	break;
        case 64:  IN[10] = embs3[12][0];  IN[11] = embs3[12][1];  IN[12] = embs3[12][2];  IN[13] = embs3[12][3];
                  IN[14] = embs3[12][4];	IN[15] = embs3[12][5];	IN[16] = embs3[12][6];	break;
        case 128: IN[10] = embs3[13][0];  IN[11] = embs3[13][1];  IN[12] = embs3[13][2];  IN[13] = embs3[13][3];
                  IN[14] = embs3[13][4];	IN[15] = embs3[13][5];	IN[16] = embs3[13][6];	break;
        default:  IN[10] = embs3[0][0];   IN[11] = embs3[0][1];   IN[12] = embs3[0][2];   IN[13] = embs3[0][3];
                  IN[14] = embs3[0][4];	  IN[15] = embs3[0][5];	  IN[16] = embs3[0][6];		break;
      }

      // Input Layer
      for(int i=0;i<9;i++){
        IN[i+17] = (IN[i+17] * BN_gamma_in[i]);	  
      }

      
      // First Hidden Layer
      for (int i = 0; i < 22; i++) {
        for (int j = 0; j < 26; j++) {
          X1[i] += (in_h1[i][j] * IN[j]);
        }
        X1[i] += b1[i];
        X1[i] = (relu(X1[i]) * BN_gamma_1[i]) + BN_beta_1[i];
      }

      // Second Hidden Layer
      for (int i = 0; i < 20; i++) {
        for (int j = 0; j < 22; j++) {
          X2[i] += (h1_h2[i][j] * X1[j]);
        }
        X2[i] += b2[i];
        X2[i] = (relu(X2[i]) * BN_gamma_2[i]) + BN_beta_2[i];
      }

      // OUTPUT LAYER
      for (int i = 0; i < 49; i++) {
        for (int j = 0; j < 20; j++) {
          OUT[i] += (h2_out[i][j] * X2[j]);
        }
        OUT[i] += bout[i];
      }
      
      // Decision: NN_out holds the index of the maximum element

      N = sizeof(OUT) / sizeof(float); // Size of OUT[] array, used in next step
      NN_out = std::distance(OUT, std::max_element(OUT, OUT + N));
      
      switch (NN_out) {
        case 0: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 1: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 2: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 3: MVX_HALF = 0;   MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 4: MVX_HALF = 0;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 5: MVX_HALF = 1;   MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 6: MVX_HALF = 1;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;

        case 7: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 8: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 9: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 10: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 11: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 12: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 13: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;

        case 14: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 15: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 16: MVX_HALF = 0;  MVX_QRTER = -1;   MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 17: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 18: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 19: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 20: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;

        case 21: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 22: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 23: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 24: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 25: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 26: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 27: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;

        case 28: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 29: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 30: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 31: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 32: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 33: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 34: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;

        case 35: MVX_HALF = -1; MVX_QRTER = -1;   MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 36: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 37: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 38: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 0;		break;
        case 39: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 40: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 41: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;

        case 42: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 43: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 44: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 45: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 1;	  break;
        case 46: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 47: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 48: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        default: MVX_HALF = 0;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
      }


      //end of neural network code

      break;



    case MESEARCH_SELECTIVE:
      xTZSearchSelective( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred );
      break;

    case MESEARCH_DIAMOND_ENHANCED:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, true );
      break;

    case MESEARCH_FULL: // shouldn't get here.
    default:
      break;
  }
}


Void TEncSearch::xTZSearch( const TComDataCU* const pcCU,
                            const TComPattern* const pcPatternKey,
                            const Pel* const         piRefY,
                            const Int                iRefStride,
                            const TComMv* const      pcMvSrchRngLT,
                            const TComMv* const      pcMvSrchRngRB,
                            TComMv&                  rcMv,
                            Distortion&              ruiSAD,
                            const TComMv* const      pIntegerMv2Nx2NPred,
                            const Bool               bExtendedSettings)
{
  const Bool bUseAdaptiveRaster                      = bExtendedSettings;
  const Int  iRaster                                 = 5;
  const Bool bTestOtherPredictedMV                   = bExtendedSettings;
  const Bool bTestZeroVector                         = true;
  const Bool bTestZeroVectorStart                    = bExtendedSettings;
  const Bool bTestZeroVectorStop                     = false;
  const Bool bFirstSearchDiamond                     = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bFirstCornersForDiamondDist1            = bExtendedSettings;
  const Bool bFirstSearchStop                        = m_pcEncCfg->getFastMEAssumingSmootherMVEnabled();
  const UInt uiFirstSearchRounds                     = 3;     // first search stop X rounds after best match (must be >=1)
  const Bool bEnableRasterSearch                     = true;
  const Bool bAlwaysRasterSearch                     = bExtendedSettings;  // true: BETTER but factor 2 slower
  const Bool bRasterRefinementEnable                 = false; // enable either raster refinement or star refinement
  const Bool bRasterRefinementDiamond                = false; // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bRasterRefinementCornersForDiamondDist1 = bExtendedSettings;
  const Bool bStarRefinementEnable                   = true;  // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond                  = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementCornersForDiamondDist1   = bExtendedSettings;
  const Bool bStarRefinementStop                     = false;
  const UInt uiStarRefinementRounds                  = 2;  // star refinement stop X rounds after best match (must be >=1)
  const Bool bNewZeroNeighbourhoodTest               = bExtendedSettings;

  UInt uiSearchRange = m_iSearchRange;
  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;

  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      if (cMv != rcMv && (cMv.getHor() != cStruct.iBestX && cMv.getVer() != cStruct.iBestY))
      {
        // only test cMV if not obviously previously tested.
        xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
      }
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    if ((rcMv.getHor() != 0 || rcMv.getVer() != 0) &&
        (0 != cStruct.iBestX || 0 != cStruct.iBestY))
    {
      // only test 0-vector if not obviously previously tested.
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
    }
  }

  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  if (pIntegerMv2Nx2NPred != 0)
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    if ((rcMv != integerMv2Nx2NPred) &&
        (integerMv2Nx2NPred.getHor() != cStruct.iBestX || integerMv2Nx2NPred.getVer() != cStruct.iBestY))
    {
      // only test integerMv2Nx2NPred if not obviously previously tested.
      xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);
    }

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // start search
  Int  iDist = 0;
  Int  iStartX = cStruct.iBestX;
  Int  iStartY = cStruct.iBestY;

  const Bool bBestCandidateZero = (cStruct.iBestX == 0) && (cStruct.iBestY == 0);

  // first search around best position up to now.
  // The following works as a "subsampled/log" window search around the best candidate
  for (iDist = 1; iDist <= (Int)uiSearchRange; iDist *= 2)
	  
  {
    if ( bFirstSearchDiamond == 1 )
    {
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bFirstCornersForDiamondDist1 );
    }
    else
    {
      xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
    }

    if ( bFirstSearchStop && ( cStruct.uiBestRound >= uiFirstSearchRounds ) ) // stop criterion
    {
      break;
    }
  }

  if (!bNewZeroNeighbourhoodTest)
  {
    // test whether zero Mv is a better start point than Median predictor
    if ( bTestZeroVectorStart && ((cStruct.iBestX != 0) || (cStruct.iBestY != 0)) )
    {
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
      if ( (cStruct.iBestX == 0) && (cStruct.iBestY == 0) )
      {
        // test its neighborhood
        for ( iDist = 1; iDist <= (Int)uiSearchRange; iDist*=2 )
        {
          xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
          if ( bTestZeroVectorStop && (cStruct.uiBestRound > 0) ) // stop criterion
          {
            break;
          }
        }
      }
    }
  }
  else
  {
    // Test also zero neighbourhood but with half the range
    // It was reported that the original (above) search scheme using bTestZeroVectorStart did not
    // make sense since one would have already checked the zero candidate earlier
    // and thus the conditions for that test would have not been satisfied
    if (bTestZeroVectorStart == true && bBestCandidateZero != true)
    {
      for ( iDist = 1; iDist <= ((Int)uiSearchRange >> 1); iDist*=2 )
      {
        xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
        if ( bTestZeroVectorStop && (cStruct.uiBestRound > 2) ) // stop criterion
        {
          break;
        }
      }
    }
  }

  // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
  if ( cStruct.uiBestDistance == 1 )
  {
    cStruct.uiBestDistance = 0;
    xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
  }

  // raster search if distance is too big
  if (bUseAdaptiveRaster)
  {
    int iWindowSize = iRaster;
    Int   iSrchRngRasterLeft   = iSrchRngHorLeft;
    Int   iSrchRngRasterRight  = iSrchRngHorRight;
    Int   iSrchRngRasterTop    = iSrchRngVerTop;
    Int   iSrchRngRasterBottom = iSrchRngVerBottom;

    if (!(bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster))))
    {
      iWindowSize ++;
      iSrchRngRasterLeft /= 2;
      iSrchRngRasterRight /= 2;
      iSrchRngRasterTop /= 2;
      iSrchRngRasterBottom /= 2;
    }
    cStruct.uiBestDistance = iWindowSize;
    for ( iStartY = iSrchRngRasterTop; iStartY <= iSrchRngRasterBottom; iStartY += iWindowSize )
    {
      for ( iStartX = iSrchRngRasterLeft; iStartX <= iSrchRngRasterRight; iStartX += iWindowSize )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iWindowSize );
      }
    }
  }
  else
  {
    if ( bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster) || bAlwaysRasterSearch ) )
    {
      cStruct.uiBestDistance = iRaster;
      for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += iRaster )
      {
        for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += iRaster )
        {
          xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iRaster );
        }
      }
    }
  }

  // raster refinement

  if ( bRasterRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      if ( cStruct.uiBestDistance > 1 )
      {
        iDist = cStruct.uiBestDistance >>= 1;
        if ( bRasterRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bRasterRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
      }

      // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // star refinement
  if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bStarRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }


  // EMI: BIG DIFFERENCE!
  // getting the 8 SAD points
  iDist = 1;
  iStartX = cStruct.iBestX;
  iStartY = cStruct.iBestY;
  index_ref = counter_i;
  
  xTZ8PointSquareSearch(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  iDist = 2;
  xTZ8PointSquareSearch2(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );
}


Void TEncSearch::xTZSearchSelective( const TComDataCU* const   pcCU,
                                     const TComPattern* const  pcPatternKey,
                                     const Pel* const          piRefY,
                                     const Int                 iRefStride,
                                     const TComMv* const       pcMvSrchRngLT,
                                     const TComMv* const       pcMvSrchRngRB,
                                     TComMv                   &rcMv,
                                     Distortion               &ruiSAD,
                                     const TComMv* const       pIntegerMv2Nx2NPred )
{
  const Bool bTestOtherPredictedMV    = true;
  const Bool bTestZeroVector          = true;
  const Bool bEnableRasterSearch      = true;
  const Bool bAlwaysRasterSearch      = false;  // 1: BETTER but factor 15x slower
  const Bool bStarRefinementEnable    = true;   // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond   = true;   // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementStop      = false;
  const UInt uiStarRefinementRounds   = 2;  // star refinement stop X rounds after best match (must be >=1)
  const UInt uiSearchRange            = m_iSearchRange;
  const Int  uiSearchRangeInitial     = m_iSearchRange >> 2;
  const Int  uiSearchStep             = 4;
  const Int  iMVDistThresh            = 8;

  Int   iSrchRngHorLeft         = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight        = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop          = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom       = pcMvSrchRngRB->getVer();
  Int   iFirstSrchRngHorLeft    = 0;
  Int   iFirstSrchRngHorRight   = 0;
  Int   iFirstSrchRngVerTop     = 0;
  Int   iFirstSrchRngVerBottom  = 0;
  Int   iStartX                 = 0;
  Int   iStartY                 = 0;
  Int   iBestX                  = 0;
  Int   iBestY                  = 0;
  Int   iDist                   = 0;

  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;
  cStruct.iBestX = 0;
  cStruct.iBestY = 0;


  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
  }

  if ( pIntegerMv2Nx2NPred != 0 )
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // Initial search
  iBestX = cStruct.iBestX;
  iBestY = cStruct.iBestY; 
  iFirstSrchRngHorLeft    = ((iBestX - uiSearchRangeInitial) > iSrchRngHorLeft)   ? (iBestX - uiSearchRangeInitial) : iSrchRngHorLeft;
  iFirstSrchRngVerTop     = ((iBestY - uiSearchRangeInitial) > iSrchRngVerTop)    ? (iBestY - uiSearchRangeInitial) : iSrchRngVerTop;
  iFirstSrchRngHorRight   = ((iBestX + uiSearchRangeInitial) < iSrchRngHorRight)  ? (iBestX + uiSearchRangeInitial) : iSrchRngHorRight;  
  iFirstSrchRngVerBottom  = ((iBestY + uiSearchRangeInitial) < iSrchRngVerBottom) ? (iBestY + uiSearchRangeInitial) : iSrchRngVerBottom;    

  for ( iStartY = iFirstSrchRngVerTop; iStartY <= iFirstSrchRngVerBottom; iStartY += uiSearchStep )
  {
    for ( iStartX = iFirstSrchRngHorLeft; iStartX <= iFirstSrchRngHorRight; iStartX += uiSearchStep )
    {
      xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 0 );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 1, false );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 2, false );
    }
  }

  Int iMaxMVDistToPred = (abs(cStruct.iBestX - iBestX) > iMVDistThresh || abs(cStruct.iBestY - iBestY) > iMVDistThresh);

  //full search with early exit if MV is distant from predictors
  if ( bEnableRasterSearch && (iMaxMVDistToPred || bAlwaysRasterSearch) )
  {
    for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += 1 )
    {
      for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += 1 )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 1 );
      }
    }
  }
  //Smaller MV, refine around predictor
  else if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    // start refinement
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, false );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );

}


Void TEncSearch::xPatternSearchFracDIF(
                                       Bool         bIsLosslessCoded,
                                       TComPattern* pcPatternKey,
                                       Pel*         piRefY,
                                       Int          iRefStride,
                                       TComMv*      pcMvInt,
                                       TComMv&      rcMvHalf,
                                       TComMv&      rcMvQter,
                                       Distortion&  ruiCost
                                      )
{
  //  Reference pattern initialization (integer scale)
	
  TComPattern cPatternRoi;
  Int         iOffset    = pcMvInt->getHor() + pcMvInt->getVer() * iRefStride;
  cPatternRoi.initPattern(piRefY + iOffset,
                          pcPatternKey->getROIYWidth(),
                          pcPatternKey->getROIYHeight(),
                          iRefStride,
                          pcPatternKey->getBitDepthY());

  //  Half-pel refinement
  xExtDIFUpSamplingH ( &cPatternRoi );

  rcMvHalf = *pcMvInt;   rcMvHalf <<= 1;    // for mv-cost
  TComMv baseRefMv(0, 0);
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 2, rcMvHalf, !bIsLosslessCoded );

  m_pcRdCost->setCostScale( 0 );

  xExtDIFUpSamplingQ ( &cPatternRoi, rcMvHalf );
  baseRefMv = rcMvHalf;
  baseRefMv <<= 1;

  rcMvQter = *pcMvInt;   rcMvQter <<= 1;    // for mv-cost
  rcMvQter += rcMvHalf;  rcMvQter <<= 1;
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 1, rcMvQter, !bIsLosslessCoded );
}


//! encode residual and calculate rate-distortion for a CU block
Void TEncSearch::encodeResAndCalcRdInterCU( TComDataCU* pcCU, TComYuv* pcYuvOrg, TComYuv* pcYuvPred,
                                            TComYuv* pcYuvResi, TComYuv* pcYuvResiBest, TComYuv* pcYuvRec,
                                            Bool bSkipResidual DEBUG_STRING_FN_DECLARE(sDebug) )
{
  assert ( !pcCU->isIntra(0) );

  const UInt cuWidthPixels      = pcCU->getWidth ( 0 );
  const UInt cuHeightPixels     = pcCU->getHeight( 0 );
  const Int  numValidComponents = pcCU->getPic()->getNumberValidComponents();
  const TComSPS &sps=*(pcCU->getSlice()->getSPS());

  // The pcCU is not marked as skip-mode at this point, and its m_pcTrCoeff, m_pcArlCoeff, m_puhCbf, m_puhTrIdx will all be 0.
  // due to prior calls to TComDataCU::initEstData(  );

  if ( bSkipResidual ) //  No residual coding : SKIP mode
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    pcYuvResi->clear();

    pcYuvPred->copyToPartYuv( pcYuvRec, 0 );
    Distortion distortion = 0;

    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID compID=ComponentID(comp);
      const UInt csx=pcYuvOrg->getComponentScaleX(compID);
      const UInt csy=pcYuvOrg->getComponentScaleY(compID);
      distortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID), pcYuvRec->getStride(compID), pcYuvOrg->getAddr(compID),
                                               pcYuvOrg->getStride(compID), cuWidthPixels >> csx, cuHeightPixels >> csy, compID);
    }

    m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST]);
    m_pcEntropyCoder->resetBits();

    if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex( pcCU, 0, true );

    UInt uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    pcCU->getTotalBits()       = uiBits;
    pcCU->getTotalDistortion() = distortion;
    pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( uiBits, distortion );

    m_pcRDGoOnSbacCoder->store(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_TEMP_BEST]);

#if DEBUG_STRING
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif

    return;
  }

  //  Residual coding.

   pcYuvResi->subtract( pcYuvOrg, pcYuvPred, 0, cuWidthPixels );

  TComTURecurse tuLevel0(pcCU, 0);

  Double     nonZeroCost       = 0;
  UInt       nonZeroBits       = 0;
  Distortion nonZeroDistortion = 0;
  Distortion zeroDistortion    = 0;

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_CURR_BEST ] );

  xEstimateInterResidualQT( pcYuvResi,  nonZeroCost, nonZeroBits, nonZeroDistortion, &zeroDistortion, tuLevel0 DEBUG_STRING_PASS_INTO(sDebug) );

  // -------------------------------------------------------
  // set the coefficients in the pcCU, and also calculates the residual data.
  // If a block full of 0's is efficient, then just use 0's.
  // The costs at this point do not include header bits.

  m_pcEntropyCoder->resetBits();
  m_pcEntropyCoder->encodeQtRootCbfZero( );
  const UInt   zeroResiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  const Double zeroCost     = (pcCU->isLosslessCoded( 0 )) ? (nonZeroCost+1) : (m_pcRdCost->calcRdCost( zeroResiBits, zeroDistortion ));

  if ( zeroCost < nonZeroCost || !pcCU->getQtRootCbf(0) )
  {
    const UInt uiQPartNum = tuLevel0.GetAbsPartIdxNumParts();
    ::memset( pcCU->getTransformIdx()     , 0, uiQPartNum * sizeof(UChar) );
    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID component = ComponentID(comp);
      ::memset( pcCU->getCbf( component ) , 0, uiQPartNum * sizeof(UChar) );
      ::memset( pcCU->getCrossComponentPredictionAlpha(component), 0, ( uiQPartNum * sizeof(SChar) ) );
    }
    static const UInt useTS[MAX_NUM_COMPONENT]={0,0,0};
    pcCU->setTransformSkipSubParts ( useTS, 0, pcCU->getDepth(0) );
#if DEBUG_STRING
    sDebug.clear();
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif
  }
  else
  {
    xSetInterResidualQTData( NULL, false, tuLevel0); // Call first time to set coefficients.
  }

  // all decisions now made. Fully encode the CU, including the headers:
  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST] );

  UInt finalBits = 0;
  xAddSymbolBitsInter( pcCU, finalBits );
  // we've now encoded the pcCU, and so have a valid bit cost

  if ( !pcCU->getQtRootCbf( 0 ) )
  {
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
  }
  else
  {
    xSetInterResidualQTData( pcYuvResiBest, true, tuLevel0 ); // else set the residual image data pcYUVResiBest from the various temp images.
  }
  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_TEMP_BEST ] );

  pcYuvRec->addClip ( pcYuvPred, pcYuvResiBest, 0, cuWidthPixels, sps.getBitDepths() );

  // update with clipped distortion and cost (previously unclipped reconstruction values were used)

  Distortion finalDistortion = 0;
  for(Int comp=0; comp<numValidComponents; comp++)
  {
    const ComponentID compID=ComponentID(comp);
    finalDistortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID ), pcYuvRec->getStride(compID ), pcYuvOrg->getAddr(compID ), pcYuvOrg->getStride(compID), cuWidthPixels >> pcYuvOrg->getComponentScaleX(compID), cuHeightPixels >> pcYuvOrg->getComponentScaleY(compID), compID);
  }

  pcCU->getTotalBits()       = finalBits;
  pcCU->getTotalDistortion() = finalDistortion;
  pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( finalBits, finalDistortion );
}



Void TEncSearch::xEstimateInterResidualQT( TComYuv    *pcResi,
                                           Double     &rdCost,
                                           UInt       &ruiBits,
                                           Distortion &ruiDist,
                                           Distortion *puiZeroDist,
                                           TComTU     &rTu
                                           DEBUG_STRING_FN_DECLARE(sDebug) )
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiDepth      = rTu.GetTransformDepthTotal();
  const UInt uiTrMode     = rTu.GetTransformDepthRel();
  const UInt subTUDepth   = uiTrMode + 1;
  const UInt numValidComp = pcCU->getPic()->getNumberValidComponents();
  DEBUG_STRING_NEW(sSingleStringComp[MAX_NUM_COMPONENT])

  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  UInt SplitFlag = ((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && pcCU->isInter(uiAbsPartIdx) && ( pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N ));
#if DEBUG_STRING
  const Int debugPredModeMask = DebugStringGetPredModeMask(pcCU->getPredictionMode(uiAbsPartIdx));
#endif

  Bool bCheckFull;

  if ( SplitFlag && uiDepth == pcCU->getDepth(uiAbsPartIdx) && ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) ) )
  {
    bCheckFull = false;
  }
  else
  {
    bCheckFull =  ( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
  }

  const Bool bCheckSplit  = ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

  assert( bCheckFull || bCheckSplit );

  // code full block
  Double     dSingleCost = MAX_DOUBLE;
  UInt       uiSingleBits                                                                                                        = 0;
  Distortion uiSingleDistComp            [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  Distortion uiSingleDist                                                                                                        = 0;
  TCoeff     uiAbsSum                    [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  UInt       uiBestTransformMode         [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  //  Stores the best explicit RDPCM mode for a TU encoded without split
  UInt       bestExplicitRdpcmModeUnSplit[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{3,3}, {3,3}, {3,3}};
  SChar      bestCrossCPredictionAlpha   [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};

  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );

  if( bCheckFull )
  {
    Double minCost[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/];
    Bool checkTransformSkip[MAX_NUM_COMPONENT];
    pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

    m_pcEntropyCoder->resetBits();

    memset( m_pTempPel, 0, sizeof( Pel ) * rTu.getRect(COMPONENT_Y).width * rTu.getRect(COMPONENT_Y).height ); // not necessary needed for inside of recursion (only at the beginning)

    const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    TCoeff *pcCoeffCurr[MAX_NUM_COMPONENT];
#if ADAPTIVE_QP_SELECTION
    TCoeff *pcArlCoeffCurr[MAX_NUM_COMPONENT];
#endif

    for(UInt i=0; i<numValidComp; i++)
    {
      minCost[i][0] = MAX_DOUBLE;
      minCost[i][1] = MAX_DOUBLE;
    }

    Pel crossCPredictedResidualBuffer[ MAX_TU_SIZE * MAX_TU_SIZE ];

    for(UInt i=0; i<numValidComp; i++)
    {
      checkTransformSkip[i]=false;
      const ComponentID compID=ComponentID(i);
      const Int channelBitDepth=pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
      pcCoeffCurr[compID]    = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
#if ADAPTIVE_QP_SELECTION
      pcArlCoeffCurr[compID] = m_ppcQTTempArlCoeff[compID ][uiQTTempAccessLayer] +  rTu.getCoefficientOffset(compID);
#endif

      if(rTu.ProcessComponentSection(compID))
      {
        const QpParam cQP(*pcCU, compID);

        checkTransformSkip[compID] = pcCU->getSlice()->getPPS()->getUseTransformSkip() &&
                                     TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(compID), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize()) &&
                                     (!pcCU->isLosslessCoded(0));

        const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

        TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

        const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

        do
        {
          const UInt           subTUIndex             = TUIterator.GetSectionNumber();
          const UInt           subTUAbsPartIdx        = TUIterator.GetAbsPartIdxTU(compID);
          const TComRectangle &tuCompRect             = TUIterator.getRect(compID);
          const UInt           subTUBufferOffset      = tuCompRect.width * tuCompRect.height * subTUIndex;

                TCoeff        *currentCoefficients    = pcCoeffCurr[compID] + subTUBufferOffset;
#if ADAPTIVE_QP_SELECTION
                TCoeff        *currentARLCoefficients = pcArlCoeffCurr[compID] + subTUBufferOffset;
#endif
          const Bool isCrossCPredictionAvailable      =    isChroma(compID)
                                                         && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                         && (pcCU->getCbf(subTUAbsPartIdx, COMPONENT_Y, uiTrMode) != 0);

          SChar preCalcAlpha = 0;
          const Pel *pLumaResi = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( COMPONENT_Y, rTu.getRect( COMPONENT_Y ).x0, rTu.getRect( COMPONENT_Y ).y0 );

          if (isCrossCPredictionAvailable)
          {
            const Bool bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
            const Pel  *const lumaResidualForEstimate       = bUseReconstructedResidualForEstimate ? pLumaResi                                                     : pcResi->getAddrPix(COMPONENT_Y, tuCompRect.x0, tuCompRect.y0);
            const UInt        lumaResidualStrideForEstimate = bUseReconstructedResidualForEstimate ? m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y) : pcResi->getStride(COMPONENT_Y);

            preCalcAlpha = xCalcCrossComponentPredictionAlpha(TUIterator,
                                                              compID,
                                                              lumaResidualForEstimate,
                                                              pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                              tuCompRect.width,
                                                              tuCompRect.height,
                                                              lumaResidualStrideForEstimate,
                                                              pcResi->getStride(compID));
          }

          const Int transformSkipModesToTest    = checkTransformSkip[compID] ? 2 : 1;
          const Int crossCPredictionModesToTest = (preCalcAlpha != 0)        ? 2 : 1; // preCalcAlpha cannot be anything other than 0 if isCrossCPredictionAvailable is false

          const Bool isOneMode                  = (crossCPredictionModesToTest == 1) && (transformSkipModesToTest == 1);

          for (Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
          {
            pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);

            for (Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
            {
              const Bool isFirstMode          = (transformSkipModeId == 0) && (crossCPredictionModeId == 0);
              const Bool bUseCrossCPrediction = crossCPredictionModeId != 0;

              m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
              m_pcEntropyCoder->resetBits();

              pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);
              pcCU->setCrossComponentPredictionAlphaPartRange((bUseCrossCPrediction ? preCalcAlpha : 0), compID, subTUAbsPartIdx, partIdxesPerSubTU );

              if ((compID != COMPONENT_Cr) && ((transformSkipModeId == 1) ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ()))
              {
                m_pcEntropyCoder->estimateBit(m_pcTrQuant->m_pcEstBitsSbac, tuCompRect.width, tuCompRect.height, toChannelType(compID));
              }

#if RDOQ_CHROMA_LAMBDA
              m_pcTrQuant->selectLambda(compID);
#endif

              Pel *pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
              UInt resiStride     = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);

              TCoeff bestCoeffComp   [MAX_TU_SIZE*MAX_TU_SIZE];
              Pel    bestResiComp    [MAX_TU_SIZE*MAX_TU_SIZE];

#if ADAPTIVE_QP_SELECTION
              TCoeff bestArlCoeffComp[MAX_TU_SIZE*MAX_TU_SIZE];
#endif
              TCoeff     currAbsSum   = 0;
              UInt       currCompBits = 0;
              Distortion currCompDist = 0;
              Double     currCompCost = 0;
              UInt       nonCoeffBits = 0;
              Distortion nonCoeffDist = 0;
              Double     nonCoeffCost = 0;

              if(!isOneMode && !isFirstMode)
              {
                memcpy(bestCoeffComp,    currentCoefficients,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(bestArlCoeffComp, currentARLCoefficients, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for(Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy(&bestResiComp[y * tuCompRect.width], (pcResiCurrComp + (y * resiStride)), (sizeof(Pel) * tuCompRect.width));
                }
              }

              if (bUseCrossCPrediction)
              {
                TComTrQuant::crossComponentPrediction(TUIterator,
                                                      compID,
                                                      pLumaResi,
                                                      pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                      crossCPredictedResidualBuffer,
                                                      tuCompRect.width,
                                                      tuCompRect.height,
                                                      m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                      pcResi->getStride(compID),
                                                      tuCompRect.width,
                                                      false);

                m_pcTrQuant->transformNxN(TUIterator, compID, crossCPredictedResidualBuffer, tuCompRect.width, currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }
              else
              {
                m_pcTrQuant->transformNxN(TUIterator, compID, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ), pcResi->getStride(compID), currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }

              if(isFirstMode || (currAbsSum == 0))
              {
                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pTempPel,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        tuCompRect.width,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        true);

                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride( compID ), pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }
                else
                {
                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pTempPel, tuCompRect.width, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }

                m_pcEntropyCoder->encodeQtCbfZero( TUIterator, toChannelType(compID) );

                if ( isCrossCPredictionAvailable )
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                nonCoeffBits = m_pcEntropyCoder->getNumberOfWrittenBits();
                nonCoeffCost = m_pcRdCost->calcRdCost( nonCoeffBits, nonCoeffDist );
              }

              if((puiZeroDist != NULL) && isFirstMode)
              {
                *puiZeroDist += nonCoeffDist; // initialized with zero residual distortion
              }

              DEBUG_STRING_NEW(sSingleStringTest)

              if( currAbsSum > 0 ) //if non-zero coefficients are present, a residual needs to be derived for further prediction
              {
                if (isFirstMode)
                {
                  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
                  m_pcEntropyCoder->resetBits();
                }

                m_pcEntropyCoder->encodeQtCbf( TUIterator, compID, true );

                if (isCrossCPredictionAvailable)
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                m_pcEntropyCoder->encodeCoeffNxN( TUIterator, currentCoefficients, compID );
                currCompBits = m_pcEntropyCoder->getNumberOfWrittenBits();

                pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 );

                m_pcTrQuant->invTransformNxN( TUIterator, compID, pcResiCurrComp, m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID), currentCoefficients, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sSingleStringTest, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );

                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        true);
                }

                currCompDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        pcResi->getStride(compID),
                                                        tuCompRect.width, tuCompRect.height, compID);

                currCompCost = m_pcRdCost->calcRdCost(currCompBits, currCompDist);
                  
                if (pcCU->isLosslessCoded(0))
                {
                  nonCoeffCost = MAX_DOUBLE;
                }
              }
              else if ((transformSkipModeId == 1) && !bUseCrossCPrediction)
              {
                currCompCost = MAX_DOUBLE;
              }
              else
              {
                currCompBits = nonCoeffBits;
                currCompDist = nonCoeffDist;
                currCompCost = nonCoeffCost;
              }

              // evaluate
              if ((currCompCost < minCost[compID][subTUIndex]) || ((transformSkipModeId == 1) && (currCompCost == minCost[compID][subTUIndex])))
              {
                bestExplicitRdpcmModeUnSplit[compID][subTUIndex] = pcCU->getExplicitRdpcmMode(compID, subTUAbsPartIdx);

                if(isFirstMode) //check for forced null
                {
                  if((nonCoeffCost < currCompCost) || (currAbsSum == 0))
                  {
                    memset(currentCoefficients, 0, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));

                    currAbsSum   = 0;
                    currCompBits = nonCoeffBits;
                    currCompDist = nonCoeffDist;
                    currCompCost = nonCoeffCost;
                  }
                }

#if DEBUG_STRING
                if (currAbsSum > 0)
                {
                  DEBUG_STRING_SWAP(sSingleStringComp[compID], sSingleStringTest)
                }
                else
                {
                  sSingleStringComp[compID].clear();
                }
#endif

                uiAbsSum                 [compID][subTUIndex] = currAbsSum;
                uiSingleDistComp         [compID][subTUIndex] = currCompDist;
                minCost                  [compID][subTUIndex] = currCompCost;
                uiBestTransformMode      [compID][subTUIndex] = transformSkipModeId;
                bestCrossCPredictionAlpha[compID][subTUIndex] = (crossCPredictionModeId == 1) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;

                if (uiAbsSum[compID][subTUIndex] == 0)
                {
                  if (bUseCrossCPrediction)
                  {
                    TComTrQuant::crossComponentPrediction(TUIterator,
                                                          compID,
                                                          pLumaResi,
                                                          m_pTempPel,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                          tuCompRect.width,
                                                          tuCompRect.height,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                          tuCompRect.width,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                          true);
                  }
                  else
                  {
                    pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
                    const UInt uiStride = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);
                    for(UInt uiY = 0; uiY < tuCompRect.height; uiY++)
                    {
                      memset(pcResiCurrComp, 0, (sizeof(Pel) * tuCompRect.width));
                      pcResiCurrComp += uiStride;
                    }
                  }
                }
              }
              else
              {
                // reset
                memcpy(currentCoefficients,    bestCoeffComp,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(currentARLCoefficients, bestArlCoeffComp, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for (Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy((pcResiCurrComp + (y * resiStride)), &bestResiComp[y * tuCompRect.width], (sizeof(Pel) * tuCompRect.width));
                }
              }
            }
          }

          pcCU->setExplicitRdpcmModePartRange            (   bestExplicitRdpcmModeUnSplit[compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU);
          pcCU->setTransformSkipPartRange                (   uiBestTransformMode         [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCbfPartRange                          ((((uiAbsSum                    [compID][subTUIndex] > 0) ? 1 : 0) << uiTrMode), compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCrossComponentPredictionAlphaPartRange(   bestCrossCPredictionAlpha   [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
        } while (TUIterator.nextSection(rTu)); //end of sub-TU loop
      } // processing section
    } // component loop

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      if (rTu.ProcessComponentSection(compID) && (rTu.getRect(compID).width != rTu.getRect(compID).height))
      {
        offsetSubTUCBFs(rTu, compID); //the CBFs up to now have been defined for two sub-TUs - shift them down a level and replace with the parent level CBF
      }
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    if( uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( 0, 5 - uiLog2TrSize );
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const UInt chOrderChange = ((ch + 1) == numValidComp) ? 0 : (ch + 1);
      const ComponentID compID=ComponentID(chOrderChange);
      if( rTu.ProcessComponentSection(compID) )
      {
        m_pcEntropyCoder->encodeQtCbf( rTu, compID, true );
      }
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if (rTu.ProcessComponentSection(compID))
      {
        if(isChroma(compID) && (uiAbsSum[COMPONENT_Y][0] != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, compID );
        }

        m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr[compID], compID );
        for (UInt subTUIndex = 0; subTUIndex < 2; subTUIndex++)
        {
          uiSingleDist += uiSingleDistComp[compID][subTUIndex];
        }
      }
    }

    uiSingleBits = m_pcEntropyCoder->getNumberOfWrittenBits();

    dSingleCost = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDist );
  } // check full

  // code sub-blocks
  if( bCheckSplit )
  {
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    Distortion uiSubdivDist = 0;
    UInt       uiSubdivBits = 0;
    Double     dSubdivCost = 0.0;

    //save the non-split CBFs in case we need to restore them later

    UInt bestCBF     [MAX_NUM_COMPONENT];
    UInt bestsubTUCBF[MAX_NUM_COMPONENT][2];
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);

      if (rTu.ProcessComponentSection(compID))
      {
        bestCBF[compID] = pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode);

        const TComRectangle &tuCompRect = rTu.getRect(compID);
        if (tuCompRect.width != tuCompRect.height)
        {
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

          for (UInt subTU = 0; subTU < 2; subTU++)
          {
            bestsubTUCBF[compID][subTU] = pcCU->getCbf ((uiAbsPartIdx + (subTU * partIdxesPerSubTU)), compID, subTUDepth);
          }
        }
      }
    }


    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiQPartNumSubdiv = tuRecurseChild.GetAbsPartIdxNumParts();

    DEBUG_STRING_NEW(sSplitString[MAX_NUM_COMPONENT])

    do
    {
      DEBUG_STRING_NEW(childString)
      xEstimateInterResidualQT( pcResi, dSubdivCost, uiSubdivBits, uiSubdivDist, bCheckFull ? NULL : puiZeroDist,  tuRecurseChild DEBUG_STRING_PASS_INTO(childString));
#if DEBUG_STRING
      // split the string by component and append to the relevant output (because decoder decodes in channel order, whereas this search searches by TU-order)
      std::size_t lastPos=0;
      const std::size_t endStrng=childString.find(debug_reorder_data_inter_token[MAX_NUM_COMPONENT], lastPos);
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        if (lastPos!=std::string::npos && childString.find(debug_reorder_data_inter_token[ch], lastPos)==lastPos)
        {
          lastPos+=strlen(debug_reorder_data_inter_token[ch]); // skip leading string
        }
        std::size_t pos=childString.find(debug_reorder_data_inter_token[ch+1], lastPos);
        if (pos!=std::string::npos && pos>endStrng)
        {
          lastPos=endStrng;
        }
        sSplitString[ch]+=childString.substr(lastPos, (pos==std::string::npos)? std::string::npos : (pos-lastPos) );
        lastPos=pos;
      }
#endif
    } while ( tuRecurseChild.nextSection(rTu) ) ;

    UInt uiCbfAny=0;
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      UInt uiYUVCbf = 0;
      for( UInt ui = 0; ui < 4; ++ui )
      {
        uiYUVCbf |= pcCU->getCbf( uiAbsPartIdx + ui * uiQPartNumSubdiv, ComponentID(ch),  uiTrMode + 1 );
      }
      UChar *pBase=pcCU->getCbf( ComponentID(ch) );
      const UInt flags=uiYUVCbf << uiTrMode;
      for( UInt ui = 0; ui < 4 * uiQPartNumSubdiv; ++ui )
      {
        pBase[uiAbsPartIdx + ui] |= flags;
      }
      uiCbfAny|=uiYUVCbf;
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    // when compID isn't a channel, code Cbfs:
    xEncodeInterResidualQT( MAX_NUM_COMPONENT, rTu );
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      xEncodeInterResidualQT( ComponentID(ch), rTu );
    }

    uiSubdivBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    dSubdivCost  = m_pcRdCost->calcRdCost( uiSubdivBits, uiSubdivDist );

    if (!bCheckFull || (uiCbfAny && (dSubdivCost < dSingleCost)))
    {
      rdCost += dSubdivCost;
      ruiBits += uiSubdivBits;
      ruiDist += uiSubdivDist;
#if DEBUG_STRING
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        DEBUG_STRING_APPEND(sDebug, sSplitString[ch])
      }
#endif
    }
    else
    {
      rdCost  += dSingleCost;
      ruiBits += uiSingleBits;
      ruiDist += uiSingleDist;

      //restore state to unsplit

      pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        const ComponentID compID=ComponentID(ch);

        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        if (rTu.ProcessComponentSection(compID))
        {
          DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])

          const Bool splitIntoSubTUs   = rTu.getRect(compID).width != rTu.getRect(compID).height;
          const UInt numberOfSections  = splitIntoSubTUs ? 2 : 1;
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> (splitIntoSubTUs ? 1 : 0);

          for (UInt subTUIndex = 0; subTUIndex < numberOfSections; subTUIndex++)
          {
            const UInt  uisubTUPartIdx = uiAbsPartIdx + (subTUIndex * partIdxesPerSubTU);

            if (splitIntoSubTUs)
            {
              const UChar combinedCBF = (bestsubTUCBF[compID][subTUIndex] << subTUDepth) | (bestCBF[compID] << uiTrMode);
              pcCU->setCbfPartRange(combinedCBF, compID, uisubTUPartIdx, partIdxesPerSubTU);
            }
            else
            {
              pcCU->setCbfPartRange((bestCBF[compID] << uiTrMode), compID, uisubTUPartIdx, partIdxesPerSubTU);
            }

            pcCU->setCrossComponentPredictionAlphaPartRange(bestCrossCPredictionAlpha[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setTransformSkipPartRange(uiBestTransformMode[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setExplicitRdpcmModePartRange(bestExplicitRdpcmModeUnSplit[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
          }
        }
      }

      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
    }
  }
  else
  {
    rdCost  += dSingleCost;
    ruiBits += uiSingleBits;
    ruiDist += uiSingleDist;
#if DEBUG_STRING
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[compID])

      if (rTu.ProcessComponentSection(compID))
      {
        DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])
      }
    }
#endif
  }
  DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[MAX_NUM_COMPONENT])
}



Void TEncSearch::xEncodeInterResidualQT( const ComponentID compID, TComTU &rTu )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  const UInt uiCurrTrMode = rTu.GetTransformDepthRel();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );

  const Bool bSubdiv = uiCurrTrMode != uiTrMode;

  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  if (compID==MAX_NUM_COMPONENT)  // we are not processing a channel, instead we always recurse and code the CBFs
  {
    if( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() && uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      if((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && (pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N))
      {
        assert(bSubdiv); // Inferred splitting rule - see derivation and use of interSplitFlag in the specification.
      }
      else
      {
        m_pcEntropyCoder->encodeTransformSubdivFlag( bSubdiv, 5 - uiLog2TrSize );
      }
    }

    assert( !pcCU->isIntra(uiAbsPartIdx) );

    const Bool bFirstCbfOfCU = uiCurrTrMode == 0;

    for (UInt ch=COMPONENT_Cb; ch<pcCU->getPic()->getNumberValidComponents(); ch++)
    {
      const ComponentID compIdInner=ComponentID(ch);
      if( bFirstCbfOfCU || rTu.ProcessingAllQuadrants(compIdInner) )
      {
        if( bFirstCbfOfCU || pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) )
        {
          m_pcEntropyCoder->encodeQtCbf( rTu, compIdInner, !bSubdiv );
        }
      }
      else
      {
        assert( pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode ) == pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) );
      }
    }

    if (!bSubdiv)
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }

  if( !bSubdiv )
  {
    if (compID != MAX_NUM_COMPONENT) // we have already coded the CBFs, so now we code coefficients
    {
      if (rTu.ProcessComponentSection(compID))
      {
        if (isChroma(compID) && (pcCU->getCbf(uiAbsPartIdx, COMPONENT_Y, uiTrMode) != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction(rTu, compID);
        }

        if (pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode) != 0)
        {
          const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
          TCoeff *pcCoeffCurr = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
          m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr, compID );
        }
      }
    }
  }
  else
  {
    if( compID==MAX_NUM_COMPONENT || pcCU->getCbf( uiAbsPartIdx, compID, uiCurrTrMode ) )
    {
      TComTURecurse tuRecurseChild(rTu, false);
      do
      {
        xEncodeInterResidualQT( compID, tuRecurseChild );
      } while (tuRecurseChild.nextSection(rTu));
    }
  }
}




Void TEncSearch::xSetInterResidualQTData( TComYuv* pcResi, Bool bSpatial, TComTU &rTu ) // TODO: turn this into two functions for bSpatial=true and false.
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiCurrTrMode=rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );
  const TComSPS *sps=pcCU->getSlice()->getSPS();

  if( uiCurrTrMode == uiTrMode )
  {
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTTempAccessLayer = sps->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if( bSpatial )
    {
      // Data to be copied is in the spatial domain, i.e., inverse-transformed.

      for(UInt i=0; i<pcResi->getNumberValidComponents(); i++)
      {
        const ComponentID compID=ComponentID(i);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          m_pcQTTempTComYuv[uiQTTempAccessLayer].copyPartToPartComponentMxN    ( compID, pcResi, rectCompTU );
        }
      }
    }
    else
    {
      for (UInt ch=0; ch < getNumberValidComponents(sps->getChromaFormatIdc()); ch++)
      {
        const ComponentID compID   = ComponentID(ch);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          const UInt numCoeffInBlock    = rectCompTU.width * rectCompTU.height;
          const UInt offset             = rTu.getCoefficientOffset(compID);
          TCoeff* dest                  = pcCU->getCoeff(compID)                        + offset;
          const TCoeff* src             = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + offset;
          ::memcpy( dest, src, sizeof(TCoeff)*numCoeffInBlock );

#if ADAPTIVE_QP_SELECTION
          TCoeff* pcArlCoeffSrc            = m_ppcQTTempArlCoeff[compID][uiQTTempAccessLayer] + offset;
          TCoeff* pcArlCoeffDst            = pcCU->getArlCoeff(compID)                        + offset;
          ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * numCoeffInBlock );
#endif
        }
      }
    }
  }
  else
  {

    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetInterResidualQTData( pcResi, bSpatial, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}




UInt TEncSearch::xModeBitsIntra( TComDataCU* pcCU, UInt uiMode, UInt uiPartOffset, UInt uiDepth, const ChannelType chType )
{
  // Reload only contexts required for coding intra mode information
  m_pcRDGoOnSbacCoder->loadIntraDirMode( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST], chType );

  // Temporarily set the intra dir being tested, and only
  // for absPartIdx, since encodeIntraDirModeLuma/Chroma only use
  // the entry at absPartIdx.

  UChar &rIntraDirVal=pcCU->getIntraDir( chType )[uiPartOffset];
  UChar origVal=rIntraDirVal;
  rIntraDirVal = uiMode;
  //pcCU->setIntraDirSubParts ( chType, uiMode, uiPartOffset, uiDepth + uiInitTrDepth );

  m_pcEntropyCoder->resetBits();
  if (isLuma(chType))
  {
    m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiPartOffset);
  }
  else
  {
    m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiPartOffset);
  }

  rIntraDirVal = origVal; // restore

  return m_pcEntropyCoder->getNumberOfWrittenBits();
}




UInt TEncSearch::xUpdateCandList( UInt uiMode, Double uiCost, UInt uiFastCandNum, UInt * CandModeList, Double * CandCostList )
{
  UInt i;
  UInt shift=0;

  while ( shift<uiFastCandNum && uiCost<CandCostList[ uiFastCandNum-1-shift ] )
  {
    shift++;
  }

  if( shift!=0 )
  {
    for(i=1; i<shift; i++)
    {
      CandModeList[ uiFastCandNum-i ] = CandModeList[ uiFastCandNum-1-i ];
      CandCostList[ uiFastCandNum-i ] = CandCostList[ uiFastCandNum-1-i ];
    }
    CandModeList[ uiFastCandNum-shift ] = uiMode;
    CandCostList[ uiFastCandNum-shift ] = uiCost;
    return 1;
  }

  return 0;
}





/** add inter-prediction syntax elements for a CU block
 * \param pcCU
 * \param uiQp
 * \param uiTrMode
 * \param ruiBits
 * \returns Void
 */
Void  TEncSearch::xAddSymbolBitsInter( TComDataCU* pcCU, UInt& ruiBits )
{
  if(pcCU->getMergeFlag( 0 ) && pcCU->getPartitionSize( 0 ) == SIZE_2Nx2N && !pcCU->getQtRootCbf( 0 ))
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    m_pcEntropyCoder->resetBits();
    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }
    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex(pcCU, 0, true);

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
  else
  {
    m_pcEntropyCoder->resetBits();

    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag ( pcCU, 0, true );
    m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
    m_pcEntropyCoder->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );
    m_pcEntropyCoder->encodePredInfo( pcCU, 0 );

    Bool codeDeltaQp = false;
    Bool codeChromaQpAdj = false;
    m_pcEntropyCoder->encodeCoeff   ( pcCU, 0, pcCU->getDepth(0), codeDeltaQp, codeChromaQpAdj );

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
}





/**
 * \brief Generate half-sample interpolated block
 *
 * \param pattern Reference picture ROI
 * \param biPred    Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingH( TComPattern* pattern )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;
  Int halfFilterSize = (filterSize>>1);
  Pel *srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[0].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 0, false, chFmt, pattern->getBitDepthY());
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[2].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 2, false, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + halfFilterSize * intStride + 1;
  dstPtr = m_filteredBlock[0][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
  dstPtr = m_filteredBlock[2][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+1, 2, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
  dstPtr = m_filteredBlock[0][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[2][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+1, 2, false, true, chFmt, pattern->getBitDepthY());
}





/**
 * \brief Generate quarter-sample interpolated blocks
 *
 * \param pattern    Reference picture ROI
 * \param halfPelRef Half-pel mv
 * \param biPred     Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingQ( TComPattern* pattern, TComMv halfPelRef )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Pel *srcPtr;
  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;

  Int halfFilterSize = (filterSize>>1);

  Int extHeight = (halfPelRef.getVer() == 0) ? height + filterSize : height + filterSize-1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  // Horizontal filter 1/4
  srcPtr = pattern->getROIY() - halfFilterSize * srcStride - 1;
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() >= 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 1, false, chFmt, pattern->getBitDepthY());

  // Horizontal filter 3/4
  srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() > 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 3, false, chFmt, pattern->getBitDepthY());

  // Generate @ 1,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][1].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());

  if (halfPelRef.getVer() != 0)
  {
    // Generate @ 2,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][1].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 2,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][3].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 0,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][1].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 0,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][3].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());
  }

  if (halfPelRef.getHor() != 0)
  {
    // Generate @ 1,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[1][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[3][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 1,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[1][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[3][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }

  // Generate @ 1,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][3].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
}





//! set wp tables
Void  TEncSearch::setWpScalingDistParam( TComDataCU* pcCU, Int iRefIdx, RefPicList eRefPicListCur )
{
  if ( iRefIdx<0 )
  {
    m_cDistParam.bApplyWeight = false;
    return;
  }

  TComSlice       *pcSlice  = pcCU->getSlice();
  WPScalingParam  *wp0 , *wp1;

  m_cDistParam.bApplyWeight = ( pcSlice->getSliceType()==P_SLICE && pcSlice->testWeightPred() ) || ( pcSlice->getSliceType()==B_SLICE && pcSlice->testWeightBiPred() ) ;

  if ( !m_cDistParam.bApplyWeight )
  {
    return;
  }

  Int iRefIdx0 = ( eRefPicListCur == REF_PIC_LIST_0 ) ? iRefIdx : (-1);
  Int iRefIdx1 = ( eRefPicListCur == REF_PIC_LIST_1 ) ? iRefIdx : (-1);

  getWpScaling( pcCU, iRefIdx0, iRefIdx1, wp0 , wp1 );

  if ( iRefIdx0 < 0 )
  {
    wp0 = NULL;
  }
  if ( iRefIdx1 < 0 )
  {
    wp1 = NULL;
  }

  m_cDistParam.wpCur  = NULL;

  if ( eRefPicListCur == REF_PIC_LIST_0 )
  {
    m_cDistParam.wpCur = wp0;
  }
  else
  {
    m_cDistParam.wpCur = wp1;
  }
}



//! \}
