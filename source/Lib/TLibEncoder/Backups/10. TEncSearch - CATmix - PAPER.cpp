/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2016, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     TEncSearch.cpp
 \brief    encoder search class
 */

#include "TLibCommon/CommonDef.h"
#include "TLibCommon/TComRom.h"
#include "TLibCommon/TComMotionInfo.h"
#include "TEncSearch.h"
#include "TLibCommon/TComTU.h"
#include "TLibCommon/Debug.h"
#include <math.h>
#include <limits>
#include <fstream>
#include <iostream>
#include <algorithm>


// EMI: Parameters declaration

signed short MVX_HALF, MVX_QRTER, MVY_HALF, MVY_QRTER = 0;
float  C, H1, H2, V1, V2, U1, U2, U3, U4;
long int array_e[100000];

float IN[17] = {};
float X1[22] = {};
float X2[20] = {};
float OUT[49] = {};
int N, NN_out, index_ref, counter_i, PUHeight, PUWidth, PIdx, PAddr;

/*
The next group of variables are all 1D and 2D arrays. The reason why I declared them as std::array is because that
way they can be assigned in a cleaner manner. These arrays are assigned values in TEncSearch::init() function depending
on the chosen Quantization Parameter
https://stackoverflow.com/questions/16059781/2d-array-value-assign-after-declaration-in-c for more info on 2D array assignment
*/
std::array<std::array<float,4>,8> embs0, embs1;
std::array<std::array<float,2>,3> embs2;
std::array<std::array<float,7>,14> embs3;
std::array<std::array<float,17>,22> in_h1;
std::array<std::array<float,22>,20> h1_h2;
std::array<std::array<float,20>,49> h2_out;
std::array<float ,22> b1, BN_gamma_1, BN_beta_1;
std::array<float ,20> b2, BN_gamma_2, BN_beta_2;
std::array<float ,49> bout;
std::array<float ,9> BN_gamma_in, mean, stdev;

// Helper Functions

float relu(float x){
	if (x>0)	{	return x; }
	else { return 0; }
}

float sigmoid(float x){
  return (1 / (1 + std::exp(-x)));
}

//end of modification


//! \ingroup TLibEncoder
//! \{

static const TComMv s_acMvRefineH[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static const TComMv s_acMvRefineQ[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static Void offsetSubTUCBFs(TComTU &rTu, const ComponentID compID)
{
        TComDataCU *pcCU              = rTu.getCU();
  const UInt        uiTrDepth         = rTu.GetTransformDepthRel();
  const UInt        uiAbsPartIdx      = rTu.GetAbsPartIdxTU(compID);
  const UInt        partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

  //move the CBFs down a level and set the parent CBF

  UChar subTUCBF[2];
  UChar combinedSubTUCBF = 0;

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);

    subTUCBF[subTU]   = pcCU->getCbf(subTUAbsPartIdx, compID, uiTrDepth);
    combinedSubTUCBF |= subTUCBF[subTU];
  }

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);
    const UChar compositeCBF = (subTUCBF[subTU] << 1) | combinedSubTUCBF;

    pcCU->setCbfPartRange((compositeCBF << uiTrDepth), compID, subTUAbsPartIdx, partIdxesPerSubTU);
  }
}


TEncSearch::TEncSearch()
: m_puhQTTempTrIdx(NULL)
, m_pcQTTempTComYuv(NULL)
, m_pcEncCfg (NULL)
, m_pcTrQuant (NULL)
, m_pcRdCost (NULL)
, m_pcEntropyCoder (NULL)
, m_iSearchRange (0)
, m_bipredSearchRange (0)
, m_motionEstimationSearchMethod (MESEARCH_FULL)
, m_pppcRDSbacCoder (NULL)
, m_pcRDGoOnSbacCoder (NULL)
, m_pTempPel (NULL)
, m_isInitialized (false)
{
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    m_ppcQTTempCoeff[ch]                           = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]                        = NULL;
#endif
    m_puhQTTempCbf[ch]                             = NULL;
    m_phQTTempCrossComponentPredictionAlpha[ch]    = NULL;
    m_pSharedPredTransformSkip[ch]                 = NULL;
    m_pcQTTempTUCoeff[ch]                          = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = NULL;
#endif
    m_puhQTTempTransformSkipFlag[ch]               = NULL;
  }

  for (Int i=0; i<MAX_NUM_REF_LIST_ADAPT_SR; i++)
  {
    memset (m_aaiAdaptSR[i], 0, MAX_IDX_ADAPT_SR * sizeof (Int));
  }
  for (Int i=0; i<AMVP_MAX_NUM_CANDS+1; i++)
  {
    memset (m_auiMVPIdxCost[i], 0, (AMVP_MAX_NUM_CANDS+1) * sizeof (UInt) );
  }

  setWpScalingDistParam( NULL, -1, REF_PIC_LIST_X );
}


Void TEncSearch::destroy()
{
  assert (m_isInitialized);
  if ( m_pTempPel )
  {
    delete [] m_pTempPel;
    m_pTempPel = NULL;
  }

  if ( m_pcEncCfg )
  {
    const UInt uiNumLayersAllocated = m_pcEncCfg->getQuadtreeTULog2MaxSize()-m_pcEncCfg->getQuadtreeTULog2MinSize()+1;

    for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
    {
      for (UInt layer = 0; layer < uiNumLayersAllocated; layer++)
      {
        delete[] m_ppcQTTempCoeff[ch][layer];
#if ADAPTIVE_QP_SELECTION
        delete[] m_ppcQTTempArlCoeff[ch][layer];
#endif
      }
      delete[] m_ppcQTTempCoeff[ch];
      delete[] m_puhQTTempCbf[ch];
#if ADAPTIVE_QP_SELECTION
      delete[] m_ppcQTTempArlCoeff[ch];
#endif
    }

    for( UInt layer = 0; layer < uiNumLayersAllocated; layer++ )
    {
      m_pcQTTempTComYuv[layer].destroy();
    }
  }

  delete[] m_puhQTTempTrIdx;
  delete[] m_pcQTTempTComYuv;

  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    delete[] m_pSharedPredTransformSkip[ch];
    delete[] m_pcQTTempTUCoeff[ch];
#if ADAPTIVE_QP_SELECTION
    delete[] m_ppcQTTempTUArlCoeff[ch];
#endif
    delete[] m_phQTTempCrossComponentPredictionAlpha[ch];
    delete[] m_puhQTTempTransformSkipFlag[ch];
  }
  m_pcQTTempTransformSkipTComYuv.destroy();

  m_tmpYuvPred.destroy();
  m_isInitialized = false;
}

TEncSearch::~TEncSearch()
{
  if (m_isInitialized)
  {
    destroy();
  }
}




Void TEncSearch::init(TEncCfg*       pcEncCfg,
                      TComTrQuant*   pcTrQuant,
                      Int            iSearchRange,
                      Int            bipredSearchRange,
                      MESearchMethod motionEstimationSearchMethod,
                      const UInt     maxCUWidth,
                      const UInt     maxCUHeight,
                      const UInt     maxTotalCUDepth,
                      TEncEntropy*   pcEntropyCoder,
                      TComRdCost*    pcRdCost,
                      TEncSbac***    pppcRDSbacCoder,
                      TEncSbac*      pcRDGoOnSbacCoder
                      )
{
  assert (!m_isInitialized);
  m_pcEncCfg                     = pcEncCfg;
  m_pcTrQuant                    = pcTrQuant;
  m_iSearchRange                 = iSearchRange;
  m_bipredSearchRange            = bipredSearchRange;
  m_motionEstimationSearchMethod = motionEstimationSearchMethod;
  m_pcEntropyCoder               = pcEntropyCoder;
  m_pcRdCost                     = pcRdCost;

  m_pppcRDSbacCoder              = pppcRDSbacCoder;
  m_pcRDGoOnSbacCoder            = pcRDGoOnSbacCoder;
  
  for (UInt iDir = 0; iDir < MAX_NUM_REF_LIST_ADAPT_SR; iDir++)
  {
    for (UInt iRefIdx = 0; iRefIdx < MAX_IDX_ADAPT_SR; iRefIdx++)
    {
      m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange;
    }
  }

  // initialize motion cost
  for( Int iNum = 0; iNum < AMVP_MAX_NUM_CANDS+1; iNum++)
  {
    for( Int iIdx = 0; iIdx < AMVP_MAX_NUM_CANDS; iIdx++)
    {
      if (iIdx < iNum)
      {
        m_auiMVPIdxCost[iIdx][iNum] = xGetMvpIdxBits(iIdx, iNum);
      }
      else
      {
        m_auiMVPIdxCost[iIdx][iNum] = MAX_INT;
      }
    }
  }

  const ChromaFormat cform=pcEncCfg->getChromaFormatIdc();
  initTempBuff(cform);

  m_pTempPel = new Pel[maxCUWidth*maxCUHeight];

  const UInt uiNumLayersToAllocate = pcEncCfg->getQuadtreeTULog2MaxSize()-pcEncCfg->getQuadtreeTULog2MinSize()+1;
  const UInt uiNumPartitions = 1<<(maxTotalCUDepth<<1);
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    const UInt csx=::getComponentScaleX(ComponentID(ch), cform);
    const UInt csy=::getComponentScaleY(ComponentID(ch), cform);
    m_ppcQTTempCoeff[ch] = new TCoeff* [uiNumLayersToAllocate];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]  = new TCoeff*[uiNumLayersToAllocate];
#endif
    m_puhQTTempCbf[ch] = new UChar  [uiNumPartitions];

    for (UInt layer = 0; layer < uiNumLayersToAllocate; layer++)
    {
      m_ppcQTTempCoeff[ch][layer] = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy)];
#if ADAPTIVE_QP_SELECTION
      m_ppcQTTempArlCoeff[ch][layer]  = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy) ];
#endif
    }

    m_phQTTempCrossComponentPredictionAlpha[ch]    = new SChar  [uiNumPartitions];
    m_pSharedPredTransformSkip[ch]                 = new Pel   [MAX_CU_SIZE*MAX_CU_SIZE];
    m_pcQTTempTUCoeff[ch]                          = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#endif
    m_puhQTTempTransformSkipFlag[ch]               = new UChar [uiNumPartitions];
  }
  m_puhQTTempTrIdx   = new UChar  [uiNumPartitions];
  m_pcQTTempTComYuv  = new TComYuv[uiNumLayersToAllocate];
  for( UInt ui = 0; ui < uiNumLayersToAllocate; ++ui )
  {
    m_pcQTTempTComYuv[ui].create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  }
  m_pcQTTempTransformSkipTComYuv.create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  m_tmpYuvPred.create(MAX_CU_SIZE, MAX_CU_SIZE, pcEncCfg->getChromaFormatIdc());
  m_isInitialized = true;

  // EMI: Weights and Bias Initialization based on QP

  if(m_pcEncCfg->getQP() == 27){
    
    embs0 = {{
      {{-0.37097245,-0.106178135,-0.19224782,-0.14515942}},
      {{-0.0026317714,0.012032771,0.00086457474,-0.00056622416}},
      {{0.003517439,-0.0031147976,-0.001128248,-0.00025921207}},
      {{-0.0372901,0.007304559,0.014551475,0.045877576}},
      {{0.00054253626,-0.018990906,0.0029823643,4.647454e-05}},
      {{-0.054719128,0.009346026,0.032819297,0.08774422}},
      {{-0.026058124,-0.03054604,0.0041380823,-0.008103357}},
      {{-0.079574354,-0.037556496,-0.08290433,-0.00072756445}}
    }};

    embs1 = {{
      {{0.021720827,0.27805212,-0.2549324,-0.23387657}},
			{{-0.0038531967,0.00027970856,-0.0006901146,0.010007415}},
			{{0.0031298783,0.0015147628,0.0016200199,-0.0039605754}},
			{{0.023144662,-0.06626499,-0.01189962,0.022450019}},
			{{-0.00179091,0.0020972039,0.00094718504,-0.019226829}},
			{{-0.040027875,-0.11334519,0.04316448,0.008398782}},
			{{-0.019041926,-0.0033160069,-0.026552204,-0.031205768}},
			{{-0.019107716,-0.011630693,-0.096039824,-0.041261557}}
    }};

    in_h1 = {{
      {{-0.07208016,-0.3089439,0.11342101,-0.029149912,-0.21166092,0.17003086,0.016666304,-0.1917479,1.2610638,-0.9932825,-0.6046478,-0.45318708,1.3443073,-0.12783968,-3.6239622,-0.846384,1.1407037}},
			{{0.026565606,-0.39369756,-0.027152877,0.1499096,0.11968308,-0.25954717,0.017051972,-0.36535305,-0.20306346,0.18085773,0.036857482,0.794771,-3.4883678,0.4528415,-0.30319452,0.73393774,0.4919009}},
			{{-0.097667985,-0.2589406,0.023639426,0.060613886,-0.0051835324,-0.16776185,-0.02494515,-0.20620652,-0.020106321,3.9247036,0.418017,0.57040703,-0.19165175,-0.1417526,0.1964507,-3.606901,0.5560792}},
			{{0.0039640493,-0.12202443,0.059103712,-0.06505769,-0.117703915,0.069379054,0.03664461,-0.061232865,0.099534184,-0.0025834495,0.14652386,-0.019391568,-4.603345,1.0615996,0.77501625,-0.14964277,-0.1719434}},
			{{0.012269455,0.038641576,-0.022655403,-0.00026542207,0.04219741,-0.00024820433,-0.012586868,0.032851785,0.07838207,-0.044306505,0.04499839,0.010180163,-4.516718,-0.2705242,0.008810947,0.20285682,0.24915986}},
			{{0.07811177,-0.24309713,0.091591,0.06287047,-0.062083136,-0.22867015,0.1643781,-0.19058496,0.10258534,1.198297,-0.13308825,-0.42119557,-1.8606032,-2.2476475,-0.9206221,0.52999216,0.17122583}},
			{{0.32809827,0.53304315,-0.091429114,0.012578183,0.14584675,0.3222786,0.05430537,0.60139656,0.48558754,-0.026951937,0.36649758,-0.2583292,1.4678464,-0.71718824,1.4593259,-0.9893135,-0.7478747}},
			{{-0.7345244,-0.2230007,0.3056684,0.5814767,-0.47992224,-0.45175713,0.022279957,-0.15489742,-0.31452772,0.059301306,-0.7016151,-0.1407664,0.17038728,-0.2397774,-0.5299684,-0.30206048,-0.13735192}},
			{{0.05781648,0.11544195,-0.02930829,-0.0071267365,0.082169674,-0.05020096,0.02111625,0.025280073,1.4242997,-0.8392557,0.33185044,0.7198143,-0.35634047,-2.5846405,-1.7092427,0.31547222,0.73282915}},
			{{-0.050830916,0.21966346,-0.03706917,0.030291857,0.0626969,-0.22033292,-0.07299964,0.3047535,0.5278881,1.0738261,1.1285679,-0.096244946,-0.1597392,3.212545,-0.69283366,-0.64072174,0.3823672}},
			{{0.0032313513,-0.0012419125,-0.012548616,0.007558408,0.024017481,-0.034537278,0.0069030197,-0.014591529,0.36464486,-0.4955325,-1.5444216,0.44313142,0.7458376,-1.5045084,-1.659839,0.22705415,1.190071}},
			{{-0.37299076,-0.23658055,0.059570212,0.08810899,-0.15084335,-0.072024934,-0.26330602,0.18737604,-0.46338305,-1.325099,0.96386915,0.56825703,0.6963549,-2.1458461,0.6458929,0.82843965,0.63154095}},
			{{0.020231254,0.28927958,-0.12767115,-0.09017082,0.0042288015,-0.04647697,-0.034036495,0.24870977,-1.4793143,-0.6020174,-0.36384517,0.7593471,-1.1989063,3.1959248,-0.23708405,-0.24075443,0.3415382}},
			{{-0.014541772,-0.03547879,-0.0068981745,0.0057334932,0.02324509,-0.042225342,-0.008522128,-0.047724903,-1.3485672,1.3072821,-0.004384814,-1.731072,1.0448318,1.9606704,-1.0295774,0.2990916,-0.025471447}},
			{{0.179812,0.48463234,0.1215668,-0.06908184,0.13831663,-0.1706914,0.12871014,0.745197,1.1394804,0.7830482,0.26382804,-0.43000796,-0.22234516,-2.7390418,0.25365347,2.59754,2.2557905}},
			{{0.011927705,-0.004954388,-0.00014518079,0.014649822,-0.009637297,-0.026688257,0.016638163,-0.002574066,0.7624867,-0.015894199,0.2919082,-0.9881148,0.08655682,3.2916124,-2.0074754,-1.1544383,1.1841733}},
			{{0.0013433885,-0.015854776,0.0011013113,0.009820969,0.00016956044,-0.011975203,0.006132433,-0.006282692,-0.057668224,-4.935096,-0.12630884,-0.012394371,0.050659057,0.4969473,0.28484577,1.4639045,-0.2389795}},
			{{0.02379621,-0.04007175,-0.018370088,0.022965457,0.012411174,-0.06845959,0.03018989,-0.047860492,-0.079335414,0.37418425,-0.7887806,-0.0838211,1.5789684,-2.4981499,-0.28269315,0.12616618,-1.0893806}},
			{{0.016054219,-0.01400255,-0.006550821,0.005323934,0.0063318205,0.0067362715,0.018367698,-0.039790243,0.92368376,1.0750852,0.74166435,-0.5303573,-2.2660346,0.6657305,2.2528489,2.9690595,1.5596722}},
			{{-0.030229548,-0.024778105,-0.017455943,0.00080603117,0.046770383,-0.08562906,-0.033239402,-0.0711512,-0.5751945,-4.2791796,0.4224571,0.08746816,-0.357844,2.2367432,0.23094015,-0.76335746,1.3032548}},
			{{-0.1455281,-0.4063611,-0.030151078,-0.03574652,-0.06343504,0.055421688,-0.13479356,-0.43925235,0.94655883,1.7627006,0.1870216,-0.38203928,-3.4906132,0.5450195,-0.22162087,-0.26825568,0.053645987}},
			{{0.015040547,0.027148886,0.011427354,-0.0215119,0.016376637,-0.026988527,0.010987056,-0.029418204,-3.193345,-0.5969687,1.0514028,0.2379255,-0.07641338,-1.0588839,2.238833,0.63048536,-1.4898105}}
    }};

    h1_h2 = {{
      {{-0.1863322,-0.4440598,3.346255,0.14914535,0.85423505,0.8538583,0.81292075,0.003553719,-0.88656944,-0.2588889,-1.0672252,-1.114166,-1.0391363,-0.52438223,-3.4772954,0.24425392,-1.733136,-1.8498218,-1.6587722,2.0587332,-0.43773717,-0.108201586}},
      {{-2.1200473,1.0926609,0.9680373,2.5646756,0.017749978,-2.43972,-0.90611696,0.0022505454,-1.4014896,0.7020099,-1.7017641,-0.46965796,-0.78685313,-2.0092032,-0.29765084,-0.9482275,-0.31257603,-1.526847,0.2653651,0.82236296,-0.30164972,-0.10981456}},
      {{-2.9221027,0.47355008,0.7714674,0.49181142,-0.4965476,-0.6982569,-0.5888848,-0.000552478,-4.226631,0.66630477,-3.6217058,-1.1231973,-0.58640015,0.20255534,-0.19274104,-1.5031116,-1.7007673,-0.15431203,0.40128592,0.06255122,-0.3416322,0.3370415}},
      {{-0.925425,1.3038611,-0.3138043,1.9078765,2.808209,0.6133065,-0.2211201,0.00061260373,-0.22702534,0.19084504,-0.5952921,-0.90712154,-0.5319198,-0.20839404,-0.8665029,0.14185344,0.389069,-1.7003751,0.03038383,-0.73074603,0.58123624,-0.18770549}},
      {{0.40297177,0.95864594,-0.5744214,2.2320187,0.7812172,-2.5308197,-1.4491783,-7.900529e-05,0.7829016,0.90241456,-0.30764484,-0.47093454,-1.1115615,-1.0122744,-0.48878938,-0.6419917,0.64540327,0.059488267,-0.031388145,1.3415267,0.3000574,-1.3410879}},
      {{-1.9322559,0.47277614,-1.6061956,0.73520464,-0.59137374,1.198767,-0.9459165,-0.0010903599,0.59109277,-0.62481874,-0.6031659,0.8531111,-0.37020192,-0.17772996,-2.1795459,0.19008715,-3.7091348,0.018638518,0.9029067,-0.47595114,-0.080550544,-0.96603537}},
      {{-2.7854474,0.5302327,0.055324372,0.57245374,0.01000025,0.95887184,-1.916246,0.000652952,0.27820095,-0.11018163,-5.1454105,0.19350895,-0.7213466,-0.5500856,-1.4355255,-3.3505092,-1.5477351,-0.29976308,-0.47164512,-3.3114066,-0.6929355,1.9738281}},
      {{-2.742757,0.6971793,-0.44478664,-0.39868027,-9.185185,1.6553688,0.2540093,0.0046412186,0.9482424,-0.024036637,-1.2627252,-0.041966524,-0.64152,-2.1001892,-0.47382885,-0.12854554,0.7367443,-1.6495631,-0.087228,0.18998069,-3.1919444,0.120459765}},
      {{-0.3410901,0.3919086,-1.3433373,0.07871851,-0.47920716,0.53236294,-2.2240407,0.0008577557,1.3440194,1.0746995,-0.20786475,-1.0608356,-0.36604342,-0.47583905,-0.9758354,0.21904542,-1.291324,-2.1577573,0.05075011,-0.49788213,-0.46842983,-5.4139495}},
      {{0.3786127,-0.0038984432,-0.17949934,2.2665105,7.166935,0.38210446,0.019076264,-0.00014312378,-0.6255534,-2.4308207,0.804725,-0.8063795,-0.17198858,1.7680732,-0.19531798,-0.2067047,0.009162458,1.1022159,-7.0886545,-0.677113,0.29397547,-0.07728228}},
      {{0.4358621,-1.8997374,-1.1474403,-0.64259267,-1.177041,0.64938015,0.77655846,-0.00069851044,-0.5938121,-0.17815223,2.1984243,0.004453016,-0.06958561,4.8376546,0.21197785,-1.5302442,0.6172033,1.0675089,-3.8987837,-1.613704,1.7756772,-0.042080235}},
      {{0.7665928,-0.13387693,0.11092418,-0.94920075,1.7771627,0.4239046,0.37350094,-2.4633642e-05,-0.5522132,-3.471943,1.0508654,-0.91591525,0.40798998,2.320513,0.53073084,-0.08151978,0.8175205,2.5689895,-11.658544,-0.4226587,-0.3214086,0.49068198}},
      {{-1.209284,0.5303451,-0.5872432,0.4832919,-1.7026501,1.2432799,-1.6200945,-0.0012908446,1.1789726,-0.77777356,-0.16248398,0.978412,-1.1880164,-5.5648947,-0.24616313,-7.5736237,-0.19017284,1.7639995,-0.14496854,1.255149,-0.9916153,-1.2955502}},
      {{-1.2004158,1.3808452,1.0908417,0.11614449,-0.3041304,-0.063709244,-1.1985639,-0.0024526715,0.8828586,0.07223787,-1.0622094,-0.1105932,-1.3276718,-7.776404,-0.034970883,-1.6923174,-0.39967254,-1.5576061,-0.18979143,1.1318802,-0.31757295,0.1605713}},
      {{0.040372495,-0.15699059,0.013983712,2.2860675,5.423833,-0.1475397,-0.18357703,8.248475e-05,-0.28894845,-0.029497301,-0.061071843,-0.23772115,-0.116908684,0.07733437,-0.27969113,-0.04275177,0.0464136,-0.32181305,-0.3461569,-0.16854358,0.22846553,0.014893592}},
      {{-0.60053056,0.6528401,-0.87956876,0.07778459,3.2928581,0.6014042,-0.8208956,0.0050968793,0.5023187,-0.4170934,-0.37935278,0.6898071,-0.35596865,-0.30384547,-1.8393192,0.17406005,-2.458673,-0.5552438,1.4369951,-1.3398896,0.644947,-0.7242538}},
      {{-0.8274845,0.62873775,-2.0759902,0.36493665,-3.3324764,1.5905038,-1.8045467,0.003912743,-0.59262544,-0.64071035,-1.6131004,0.67074746,-1.290513,0.022625886,-0.63895476,-0.6936427,-0.48139834,-3.3273802,0.30003065,2.6752596,-1.8370891,0.0045869774}},
      {{-1.7695923,0.81449395,-0.2708108,-0.19914174,-3.247071,0.53966105,-1.6045225,-0.0029184008,-1.7664307,1.7584755,-2.7973785,-1.6425242,-1.7428697,-1.0107626,-0.572114,0.19386296,0.36807293,-2.8838487,0.24782768,-0.120482944,-1.184668,-1.2456602}},
      {{-0.13666804,2.3116317,0.008709665,4.2474465,2.2414072,-0.97750777,0.35691744,-0.0019262517,0.5546799,-0.69094914,-0.5616298,-1.0015371,-1.5295445,-0.43318358,-0.3639482,0.77158386,-0.38070118,-3.7538707,-0.23928961,0.038703583,-0.8884369,-0.1287874}},
      {{-0.5420171,0.3295914,1.4893969,0.075131804,-2.2421825,0.8143346,-0.44872865,0.0013297139,-0.38810828,0.077416174,-0.35024017,-0.02538042,-0.39929795,-0.082859285,-0.23320484,0.12134943,-11.082839,-0.5571477,0.18317197,-0.84984756,-1.0931748,-0.6542627}}
    }};

    h2_out = {{
      {{-0.0753902,-0.7915369,1.1743563,-1.0264103,-4.630259,-2.2206273,1.2370201,-0.7746965,-5.002482,1.7823368,-2.2807972,-6.360621,-1.4311888,-1.0430144,-8.1290455,-2.549439,1.1087364,-0.6937984,1.5159688,-2.138197}},
      {{2.2176948,0.6288754,0.63553447,-0.020771597,-2.4719112,-4.19775,0.6534494,-0.06987776,-4.8318243,-0.25049594,-2.126602,-3.9846945,-2.1979616,-0.23440711,-7.3880253,-3.9976513,1.3065314,0.8837121,-1.9562507,-3.363099}},
      {{2.9452965,0.8418855,-0.31527856,-0.18050218,0.046500288,-7.822287,0.5746009,0.6400342,-3.0668583,-0.004294989,-2.462428,-3.9407816,-1.4117535,0.109514855,-7.4019732,-6.035938,1.074615,0.5009701,-0.24754031,-4.100986}},
      {{1.9107623,0.4771512,-1.0215598,0.16748695,0.6162099,-7.1596885,-0.7328626,0.2544616,0.10609146,1.6055007,-0.23829572,-4.370703,-0.17092985,0.4322917,-2.9504998,-3.486563,0.10935768,-0.19926348,1.4225066,-3.299845}},
      {{1.971877,-0.30723742,-3.345556,0.18813752,0.928475,-7.220281,-2.2136817,0.5535054,2.0853884,-0.45415363,-1.5218846,-3.9056315,0.9284945,0.55713403,-6.1408687,-6.2170124,0.26963565,-0.82373357,-0.50090975,-3.415968}},
      {{2.0087907,-2.577009,-4.7115674,-2.2161014,0.7401521,-3.8451593,-3.2598052,-0.10494314,2.214509,-1.0106018,-2.329962,-4.0987926,1.6434679,0.32424697,-7.315001,-3.7588482,-1.0985692,-0.5531673,-2.2982912,-2.5280254}},
      {{-0.7724926,-5.400755,-5.111525,-3.07757,-0.988267,-1.8914678,-2.867941,-0.61516577,1.624866,1.4875035,-2.3169165,-6.525164,1.619459,-1.2625816,-6.6208487,-1.7457972,-0.5030918,-1.6061121,0.48546576,-0.8266119}},
      {{-1.9775,-1.3612177,1.299045,-0.094446525,-4.1158805,-0.99295026,1.0438027,-0.2628856,-4.612854,-1.1204329,-1.730576,-2.8140674,-1.4484606,-2.150659,-7.179742,-0.220692,1.6491238,-0.66622645,-1.460043,-1.9092422}},
      {{-0.050898213,0.19215772,0.90659237,-0.6282912,-2.328115,-1.7624214,0.55755264,-0.41561347,-3.5313692,3.493933,0.63730603,0.63912445,-2.1724842,-1.1070975,2.074284,-1.0983124,1.7775412,0.6752356,-1.8141755,-2.9538054}},
      {{0.3403083,0.7209953,-0.20325741,-1.5739576,0.14045379,-3.244321,0.29805574,0.81004107,-2.1231148,4.6579804,-0.87529796,-0.7987538,-1.3773161,-0.4044358,0.34765622,-1.6610092,1.487616,0.5456811,-1.2069131,-3.6919131}},
      {{0.7816964,0.42309454,-1.2093598,-0.11493891,0.8003181,-5.16625,-0.2369281,1.0296676,0.10808144,0.7264065,1.6824337,1.6353085,-0.16021353,0.34284255,2.5314622,-1.739984,1.0441151,-0.19116421,1.1353171,-4.0309887}},
      {{-0.035138562,-0.67894375,-2.961902,-1.7355326,1.0962293,-2.874132,-1.4286278,1.0147408,0.8777612,3.2337139,-0.9138708,-0.7086795,1.2895832,0.35708082,-1.3317987,-0.90706915,0.39044204,-0.97901344,-1.807318,-3.1379}},
      {{-0.9493172,-4.0421968,-3.5999107,-2.3962474,0.16464542,-1.3202461,-1.6823021,0.26651728,1.3231101,-4.3007665,-1.7385939,-0.82690114,2.2886274,-0.34699365,-3.097862,-0.26862666,-0.29647565,-1.9125266,-1.694285,-1.7852716}},
      {{-3.7655375,-5.9867563,-5.164275,-2.1334229,-2.1818218,-0.36448827,-1.1968437,-0.21292661,1.6591719,0.15937614,-3.0263681,-3.2844718,2.1598957,-2.3630996,-5.9252405,0.24131292,0.46360797,-2.914475,-1.6938033,-0.091888286}},
      {{-2.8358092,-2.035019,1.3723675,-0.32975873,-4.5118785,0.35478154,0.95134014,-0.46013224,-2.790715,-0.5098544,-1.23259,-3.4386632,-1.3245475,-4.794749,-6.304602,0.18517098,1.3711118,-0.51018125,-1.3142011,-1.2439222}},
      {{-1.3459617,-0.5327118,1.1066653,-0.8337296,-2.24728,0.13788608,-0.06597794,-0.9399099,-1.8992611,2.0157182,-0.6954622,0.60813624,-2.399456,-1.9458853,-0.05097786,0.27305305,1.4580054,1.0502292,-3.6447384,-1.8994573}},
      {{-0.51729965,0.73437995,0.43647736,-1.3301965,0.34746322,0.33457166,0.042371083,0.00084207265,-0.85518473,2.582613,-0.48993438,-0.14184068,-1.5512704,-0.42127573,0.442246,0.35241854,0.97771055,0.6907977,-0.91203266,-2.2519898}},
      {{-0.080099784,0.50439703,-0.21515945,-0.52564037,0.7251324,0.32692102,-0.12049068,0.5079536,0.059511892,1.2225635,0.052361965,0.479282,-0.427405,0.45295876,1.1389699,0.4170924,0.70885074,-0.32542118,1.0373511,-2.715726}},
      {{-1.1732323,-0.31208652,-2.434199,-1.692582,0.65117913,0.45835447,0.21720655,0.9797415,0.3984145,2.1905146,-0.24616683,-0.20462044,0.6688961,0.7280565,-0.99554235,0.56047124,0.18631697,-1.180506,-0.8569428,-1.5088282}},
      {{-2.6040823,-3.6785526,-3.4493272,-0.78251344,-1.1893904,0.68140054,0.21562053,1.0519382,0.4052007,-2.2450678,-1.5180249,0.026888289,2.2872832,0.29702717,-3.0911987,0.5383061,-0.19939643,-2.50307,-4.8682146,-0.7035128}},
      {{-4.7125063,-6.0280538,-3.8152218,-0.22108333,-3.6679118,0.79688346,0.35188568,-0.104742534,0.8390018,-0.52475965,-0.7656205,-3.2197406,2.1973794,-1.261895,-5.79505,0.46504328,0.34835795,-2.4493093,-2.4864898,0.24512789}},
      {{-2.4960744,-1.7709645,0.21410708,1.3821689,-1.5736997,0.9596032,0.31602257,-0.44546175,-0.13005361,-1.3202068,-0.8675146,-3.6175506,-1.057806,-5.4205337,-2.9940035,0.5846006,0.4155497,-0.72579914,-1.843589,-0.035158064}},
      {{-1.386084,-1.1984826,0.94955015,0.7376338,-1.5055456,0.8959399,-0.3963794,-1.5779046,0.0468785,4.0080156,1.4778785,0.16312478,-1.9782227,-3.409398,2.7053096,0.5856181,0.6047298,1.1531801,-3.7744126,-0.4867883}},
      {{-0.88665324,0.63097566,0.63077384,1.1496032,0.44357133,0.99083227,-0.3820477,-0.64661443,0.009133325,2.0002322,-0.41763264,-0.9305988,-1.4498173,-0.8150154,0.45490423,0.58993995,0.3085946,0.7443443,-1.761783,-0.46058953}},
      {{-0.44809097,0.55228007,0.26201937,2.1743221,0.5837528,0.93205047,-0.15852045,-1.5171609,-0.1153337,-5.3154263,3.4967813,6.0102973,-0.37335652,0.62559867,7.9826736,0.59978783,0.17617293,-0.7420197,1.1543385,-0.30299652}},
      {{-1.4693377,0.16709088,-0.8383596,1.1143252,0.21426196,1.0092986,0.550282,0.44348195,-0.20283104,2.3592954,-0.013458785,-1.3789752,0.55398226,0.924889,0.32056502,0.5765239,-0.09956152,-1.7334144,-1.5667949,-0.02757523}},
      {{-2.1989422,-2.7174575,-1.5368607,1.6436561,-1.9621212,0.989134,1.1380732,0.9931518,-0.39689612,-3.415142,1.0855851,-0.7491324,1.7373518,0.74495476,-1.1419139,0.5564351,-0.32468012,-3.5262496,-3.8835924,0.41622713}},
      {{-3.4729586,-2.6983604,-0.646182,1.5901151,-2.0829737,0.97167665,0.81446683,0.61827314,-0.54588413,2.392841,-0.46416634,-3.343559,1.5591501,-1.0643476,-0.79092354,0.5880907,-0.29798216,-3.124047,-1.52466,0.40048108}},
      {{-2.4439902,-4.1731944,-2.7758677,-0.3747103,-2.2787366,1.0896461,0.44711518,-0.7640234,0.73547536,-0.24630174,-2.4451442,-3.6988275,-2.0561252,-4.9099565,-6.8703623,0.44212535,0.077694446,-0.013043872,-3.2891014,0.97831726}},
      {{-0.94188446,-1.8214382,-0.0941416,-1.6860878,-0.4255189,0.7339132,-1.369742,-1.4443895,0.7815621,3.7190807,-0.87609005,0.7193382,-2.0980089,-2.9924376,1.1829369,0.40819374,-0.3428957,1.181658,-4.034114,0.8403262}},
      {{0.15284729,0.43837386,0.38515705,-1.9689568,0.6168465,0.65891606,-1.187052,-0.5728576,0.41865975,1.7794311,-1.0530646,0.3383672,-1.1745433,-0.6869726,-0.5245205,0.55809474,-1.0386997,0.6765395,-0.5772986,0.82780874}},
      {{0.84852946,0.6699037,0.5342511,-1.1070828,0.51625913,0.67788166,-0.31785816,-0.6162371,-0.19073643,1.8163232,-0.3073252,0.87101096,-0.58117193,0.4976393,1.0620478,0.5349222,-1.2020544,-0.28803435,1.0605173,0.98781574}},
      {{-0.20625879,0.43617514,0.35732195,-1.6153653,-0.142955,0.49745354,0.5358179,0.4211142,-0.88043576,0.53268707,-0.8720443,0.58353585,0.2331478,0.98647684,-0.36284116,0.50315523,-1.3322382,-1.3757896,-1.0465608,0.9153592}},
      {{-1.1214569,-1.8289683,-0.31029877,-1.5168326,-2.1655846,0.42285025,1.4624767,0.92252386,-1.9317244,-3.5499215,-1.5038391,0.6378276,1.0517569,0.9358809,-3.360098,0.482826,-1.2480503,-2.8673248,-3.4460473,0.9870201}},
      {{-2.9812388,-3.0868564,-0.012426851,-0.98161215,-3.6987197,0.50255126,1.8415189,0.48796272,-3.039985,-0.76575077,-1.7972679,-2.9137335,0.8909208,-0.49330834,-6.7049227,0.54217315,-0.6430518,-2.8077652,-2.0468419,0.7646023}},
      {{-0.9292137,-7.5741167,-3.1953592,-0.7934951,-1.5347346,0.06551035,-1.320776,-0.3291747,1.6686697,-1.2974559,-2.5395164,-3.2490432,-1.0092473,-3.3238769,-7.812777,0.064610496,-0.91020405,0.09252205,-1.3278608,1.5150611}},
      {{1.3980668,-2.0108395,-2.122565,-1.9551513,0.088970564,-0.72610754,-1.7460278,-0.8857919,1.5440558,-4.422586,-0.92596275,-0.4069041,-1.355314,-2.0960977,-3.261675,-0.2282362,-1.5487437,1.0714657,-1.543957,1.418551}},
      {{2.505006,0.20077549,-0.75715613,-2.5711832,0.6838035,-1.6137846,-1.4443281,-0.041908704,0.8962678,-2.9702446,-1.7489719,-0.82732195,-1.409738,-0.47937608,-4.812079,-0.69623506,-2.713736,0.66545117,-1.6039255,1.7410356}},
      {{2.7754836,0.6725854,0.43698335,-1.6098344,0.46637735,-2.6674676,-0.3775328,-0.1372856,-0.18826787,-3.735921,0.91891444,1.2152717,-0.63261044,0.4189689,-3.0852869,-0.579959,-2.821707,-0.14601547,1.0919857,1.6832542}},
      {{2.3469868,0.5964105,0.6243184,-2.5726006,-0.32793987,-2.6390436,0.79440904,0.7550739,-2.0854213,-4.1050625,-1.2640978,-0.0013433765,0.080603845,0.82325196,-5.17997,-0.357387,-3.206105,-0.526298,-1.5481644,1.4822925}},
      {{0.55961585,-0.73538285,0.80747116,-0.95642954,-2.6762302,-2.1759923,1.5211713,0.880158,-3.3928545,-4.0492053,-0.26413357,-0.20394477,0.5916671,0.94398016,-3.3029757,-0.2226821,-2.0529537,-2.0710592,-1.817196,1.264032}},
      {{-2.0817297,-1.9530255,0.9285068,-1.2125506,-4.133494,-1.2968364,2.1347651,0.5503301,-4.949979,0.88388,-2.072086,-3.1166637,0.8732656,-0.9552159,-6.8459206,0.048220146,-1.1819476,-2.357092,-0.921485,1.3325598}},
      {{0.8135008,-4.467613,-2.639472,-3.640998,-1.098267,-0.6374634,-3.2331395,-1.4197116,1.6312956,1.1674241,-2.10357,-6.4518733,-0.9747636,-1.8665798,-7.584246,-1.6014138,-0.9451971,-0.6112662,1.2627198,1.0413569}},
      {{2.985311,-1.3631693,-2.6889796,-1.9665023,0.4172099,-2.6632838,-3.657339,-1.1178414,2.3028321,-0.7339346,-2.354696,-3.9339485,-0.93515164,-1.1391546,-8.281228,-2.9508479,-1.9743843,0.9277034,-1.4797473,0.89457285}},
      {{3.1650386,0.21641918,-2.2811809,0.05388963,0.6871569,-4.3934608,-2.248625,-0.5070337,1.8574378,-0.938051,-2.1264887,-3.9194243,-0.98175085,-0.20997852,-8.4195175,-5.517873,-2.3071146,0.4281523,-0.23876503,1.6800746}},
      {{2.6426115,0.48744044,-0.43372902,-0.25589177,0.57824194,-5.38875,-0.5955153,-0.0829988,-0.3328642,0.41059795,-0.6091246,-3.7878509,-0.74046123,0.45217746,-3.291102,-3.922133,-1.712601,-0.547352,1.4368088,1.0695665}},
      {{3.2879558,0.5759186,0.711292,-0.016334306,-0.23678245,-5.052693,0.29344726,0.6202095,-3.130718,-0.4378181,-2.135049,-3.304478,0.2083866,0.9293431,-7.3198695,-6.4157677,-2.4366746,-0.6036921,-0.4498392,1.1720123}},
      {{2.2026346,0.28150618,0.84933436,-0.6803201,-2.2860036,-4.380616,1.3266951,0.8535645,-4.846739,0.16810673,-1.7666616,-3.596774,0.59821784,1.0856719,-7.5725565,-3.6023173,-2.241774,-1.0750527,-2.1139333,0.42547068}},
      {{0.21440123,-0.91036534,1.1759776,-1.5571893,-4.3634543,-2.1451647,1.6472651,0.1459177,-6.032573,3.305151,-2.2371297,-6.1831656,0.597543,-0.14661667,-8.234248,-2.5193896,-1.1079413,-2.4710262,1.0171142,0.33411056}}
    }};

    b1 = {
      -0.05238925, 0.0777193, 0.072053045, -0.054098133, -0.11132927, -0.08529611, 0.04752966, -0.26924568, 0.07619324, 0.2121524, -0.102770396, 0.16141334, 0.045009874, -0.1008789, 0.10613461, 0.013248461, -0.009975493, -0.15321888, 0.24096183, 0.1089967, -0.07000216, 0.026792279
    };

    b2 = {
      0.053126603, 0.019911068, -0.016635263, 0.06193257, 0.06294187, -0.012485854, 0.0482929, 0.03171482, -9.9660516e-05, -0.060102984, -0.034743972, -0.03843988, 0.058325157, 0.03906811, -0.0015463468, 0.09951234, 0.06526385, -0.013420428, 0.01899958, 0.003593954
    };

    bout = {
      -2.277786, -1.695094, -1.5513902, -1.0391362, -1.5757113, -2.0423422, -2.5503895, -1.7910959, -0.06208686, -0.38294938, 0.5336366, -0.42895934, -0.80593985, -2.0597737, -1.6635497, -0.19853447, 0.58988476, 0.7677995, 0.51638514, -0.5709612, -1.4514914, -1.1812856, 0.5565981, 0.83660233, 2.8963072, 0.7995933, 0.16112128, -0.81376797, -1.6705737, -0.28279626, 0.4650199, 0.87509114, 0.43417653, -0.6793882, -1.5889102, -2.0383132, -0.6967935, -1.0259093, 0.008232487, -0.96360475, -0.78782994, -2.0550482, -2.659792, -1.9317179, -1.6182808, -1.0975848, -1.5679585, -1.8614335, -2.516168
    };

    BN_gamma_in = {
      0.15894133, 0.13070726, 0.74166197, 0.9210259, 0.7816224, 0.26307172, 0.10955119, 0.39914232, 0.28595978
    };

    BN_gamma_1 = {
      1.510249, 2.2920866, 2.0512428, 2.1915538, 4.844636, 1.2697867, 1.418374, 0.27115932, 2.9242446, 1.8482326, 4.405639, 1.4395356, 3.1213837, 4.4608393, 2.0127683, 4.0988574, 5.2844396, 4.004297, 3.7141418, 2.513479, 2.7242305, 3.4359486
    };

    BN_gamma_2 = {
      5.7038116, 3.3277116, 6.638627, 4.27514, 3.7245762, 5.957299, 6.579102, 2.2492304, 6.384251, 9.73388, 4.462975, 10.164485, 4.1989355, 4.2392387, 8.428726, 2.5736692, 4.688321, 4.3558846, 5.223332, 6.5598745
    };

    BN_beta_1 = {
      -0.08031843, -0.0842867, -0.11976613, -0.076303296, -0.01971319, -0.06660545, -0.07987866, -0.00015015963, -0.064908, -0.021956401, -0.0061341627, -0.011391753, -0.002186436, -0.015571047, -0.0013068393, -0.007941305, -0.0070044375, -0.013400455, -0.0105283335, -0.13325255, -0.0041882773, -0.017953973
    };

    BN_beta_2 = {
      -0.20604733, -0.056955244, -0.07988903, -0.19021778, -0.12598033, -0.029463084, -0.2113103, -0.2778402, -0.1553737, -0.029384295, -0.04354368, -0.09853766, -0.35000834, -0.1378141, -0.034901682, -0.19749586, -0.5286109, -0.26554024, -0.019914081, -0.26887265
    };
    
    mean = {
      97825.3686954008,65253.44363231531,98162.98493563493,66354.94664140657,18646.729895659624,67174.18186546562,97563.03008884033,65279.81499411754,98255.52660210732
    };

    stdev = {
      702690.4591240727,590878.6404533506,699276.0079510808,589047.6001139466,493000.6365594268,589434.4824931775,699805.277602277,591381.000492914,702836.5659241129
    };
  }

  else if(m_pcEncCfg->getQP() == 32){
    
    embs0 = {{
      {{0.04540652,-0.30233708,0.33763054,0.33438125}},
      {{-0.0018621151,0.022864744,-0.10345805,0.0033677907}},
      {{0.0016409674,-0.00424159,-0.10210725,0.0010434123}},
      {{-0.06175155,0.07271518,-0.09844444,-0.10257542}},
      {{0.0009822918,-0.033489257,-0.100297995,-0.005893496}},
      {{-0.10546607,0.109732546,-0.094743684,-0.18700063}},
      {{-0.05336821,-0.06417359,-0.0988986,0.00029775433}},
      {{-0.12325874,-0.17870358,-0.099159904,0.10179592}}
    }};

    embs1 = {{
      {{0.13028005,0.2717701,-0.08759251,-0.22893715}},
      {{-0.0009564598,-0.006918157,-0.0037386625,-0.020369705}},
      {{-6.4091706e-05,0.0038105063,9.487274e-05,0.003998693}},
      {{-0.07769991,0.0030139545,0.01715248,-0.07240689}},
      {{0.0036947227,0.016854078,0.009148259,0.027922282}},
      {{-0.06494041,0.0051403986,-0.015886687,-0.03799569}},
      {{-0.0026330992,-0.022176677,0.060294367,0.049862664}},
      {{-0.003692818,-0.15813096,0.13806275,0.11955894}}
    }};

    in_h1 = {{
      {{0.016237034,-0.033616874,0.1461559,-0.021396857,-0.028183635,-0.015599521,-0.025660574,0.058289457,-0.25174105,0.5194227,0.10410481,-1.5363486,1.6041569,0.49130052,-1.0535938,0.35757622,0.56683385}},
      {{0.10317367,0.012833551,0.035361093,-0.04103695,0.022521326,0.21413356,-0.16261315,-0.06424315,-1.9607677,0.30748698,-2.480627,0.5613699,-0.4435613,0.35914266,-0.5572923,1.1326665,-0.5506947}},
      {{-0.007606566,-0.03116022,-0.21073003,-0.017835818,0.021803083,0.05311998,0.07799246,0.0014366462,0.024631498,2.4137745,1.2824448,-0.20843832,-0.37888426,-0.4807135,0.2393051,-0.892468,0.4944179}},
      {{0.07890174,0.5399452,-0.6828613,0.33553717,-0.11587495,-0.34584913,-0.5170833,-0.37701035,1.5044537,-0.28132197,-1.3786188,-0.4149548,0.22831427,0.84945536,-0.7028237,-0.20597559,0.79304314}},
      {{0.026559265,-0.080587946,-0.2923863,-0.011940379,0.04564273,0.029112222,0.009106969,0.05325452,0.1897781,0.14180751,0.11520194,-0.034493953,-6.0242243,0.045021996,0.03623724,-0.04608442,0.0451224}},
      {{-0.06280209,-0.040734135,0.34716064,-0.030097265,-0.034311768,0.090759054,0.105304666,0.035999686,-0.3023595,0.41700643,0.52933383,0.2995089,-4.898352,-0.33028895,0.16147374,0.3628427,0.34210303}},
      {{0.022320952,0.06555338,-0.2241592,0.02133207,-0.015719393,-0.15441214,-0.30506858,0.061697762,-0.15255536,0.19016576,1.4463418,2.053702,-2.1456304,-1.0188094,0.056915335,-0.08625203,0.15748492}},
      {{-0.0066666254,-0.049453884,0.02789932,-0.03328318,0.0035310811,-0.0036128208,-0.026899371,0.08198371,-1.3843746,0.9181026,-0.061624076,-0.34660605,2.3507476,-0.9381528,0.5312533,0.22895132,-1.4856542}},
      {{0.017138664,0.08112735,-0.24648711,0.050018515,0.13766645,-0.056690097,-0.06585897,-0.11297199,-0.68311495,-0.77955544,2.73652,-0.37595537,-0.42071018,-0.4124303,1.0864643,1.5130364,-0.18956491}},
      {{0.2236091,1.2057983,0.92405355,1.2658271,-0.22860573,-0.7751254,-0.78568065,-0.7046644,-0.29503402,-1.2227608,1.8718054,-0.62477124,-1.9584708,1.7535899,1.0540262,-0.18204366,0.43299502}},
      {{-0.035519544,-0.04656179,0.09329884,-0.026693707,-0.006356957,0.029860904,0.029535558,0.0638269,-0.9456815,-0.5938506,0.24260534,-1.2818978,-1.3712379,1.4929458,0.046578467,0.8214096,-0.10337236}},
      {{-0.0790714,-0.20413367,-0.17163648,-0.16913463,0.07816996,0.07082353,0.045093566,0.16426007,1.0464897,0.5157739,-1.0968045,-0.9977557,-0.7257506,-1.3761015,-1.0114843,0.53150165,0.61075854}},
      {{0.015812835,-0.0013315933,0.06126013,-0.0069637396,-0.08959558,-0.005795165,-0.032317866,0.03805366,-0.28055754,-2.254372,-0.1113846,0.59238404,0.007806543,-1.1260248,0.33467138,1.3159441,0.5998925}},
      {{0.016753927,-0.047813494,1.0700784,-0.0124546345,0.027439663,0.016207978,0.0036897534,0.0793096,-0.25049117,0.9847573,0.46021917,0.58979654,1.5971665,0.3191751,-0.6730821,-1.9868174,-0.6487125}},
      {{0.015640786,-0.021546649,0.08310001,0.0021523265,-0.004543795,0.003943182,-0.009899293,0.031430896,-0.39268017,-0.8028739,-0.5639711,-1.3205953,-2.5715227,-0.76313895,-1.1218376,-1.176831,-1.2982187}},
      {{-0.0287084,-0.18721907,0.33108407,-0.09699943,0.131174,0.09580528,0.13888603,0.1546384,1.6327534,0.58916396,-2.379001,0.067896284,-1.1446334,-0.41144234,-0.6641926,0.97468454,1.0330671}},
      {{0.0026535424,-0.083620936,-0.16491845,-0.066038445,0.08580706,0.11669253,0.12978852,0.008619524,-1.6096547,-2.525341,1.4098823,0.31484982,2.0376453,0.10245329,0.16128269,-0.49338543,0.34387416}},
      {{-0.07740052,-0.10112292,-0.007232596,0.03908845,0.067060135,-0.060333755,0.05725728,0.11300387,-0.42062962,-0.78368866,-0.6293557,-1.3380405,-2.6080317,-1.741612,0.17401968,0.49054983,0.13934873}},
      {{-0.009687442,-0.17272723,0.0402578,-0.12759425,-0.009714977,-0.010833779,-0.054157887,0.20509037,0.28615776,-0.30848536,1.0190599,-0.21533704,-2.9693096,1.7531962,0.34475958,0.13731399,0.1527734}},
      {{-0.16982226,-0.18818021,-0.08087063,-0.07156265,0.08313517,0.029541517,0.18793589,0.17782563,0.9216057,-1.232625,-1.7717541,0.42690018,-1.9368361,-0.27763313,-0.71948856,-1.2976688,0.8445561}},
      {{0.05954066,0.0672659,0.49229518,0.11994155,0.08875126,-0.2067934,-0.26260096,0.07431796,-0.029149681,0.45517203,-0.004547375,-2.0744913,-3.5591242,-1.8440442,0.31472108,0.01496431,-0.61404324}},
      {{0.007534494,-0.029715918,-0.48761725,-0.046642885,0.03522874,0.025692314,0.01305844,-0.013274449,1.1554824,-0.69808865,-2.544001,-0.97003084,1.0990956,0.30937463,2.1408324,-0.50550485,-0.79307497}}
    }};

    h1_h2 = {{
      {{-0.024233503,0.08381205,-0.45845646,0.595093,-5.736981,1.8974656,-0.2869032,-0.48397204,-0.37371343,-0.15814586,0.18988435,-0.38829973,0.34718746,-0.27371305,-3.0226753,-0.6518823,-0.7919334,-0.1386764,-0.4219911,-0.44001105,0.15756667,-0.25023723}},
      {{-0.20981692,-2.1849136,-1.629656,-1.2113974,1.7601376,1.0437374,-0.61474407,-0.4407058,1.1096494,-0.3114136,0.14338684,0.122747935,-0.40334007,-2.2968903,2.5607893,-0.0017379815,-0.71384,-2.081077,1.0564933,-0.03843538,0.43554008,-1.5460166}},
      {{-0.27311745,-0.44764274,0.16811457,-1.0204699,-3.4099844,2.3858397,-0.3696684,-0.67412657,-0.44227445,-0.009270652,0.46856356,0.033506162,-0.14596406,-1.0767252,-1.6392137,0.11147306,-1.4718971,0.24269633,0.3310338,-2.7218904,0.33837494,-0.4046253}},
      {{-1.8561898,-1.4278795,0.69021195,-1.5424036,0.104609065,0.5550262,0.7587397,-0.7516283,0.5324786,-1.1056304,1.4216133,-0.84034795,-0.6603397,-0.4911432,4.520764,-1.4294032,-1.2774584,-0.76612383,1.909899,-0.16872323,-1.1829364,-1.1429242}},
      {{0.06370641,-2.6176064,-0.1672037,-0.36928758,0.3620065,0.34112236,-1.804331,0.81903166,-0.048532534,-0.44270927,0.16961983,0.42636105,-1.2536522,-1.752253,-6.130673,0.3418479,-3.087507,-2.0546794,0.83646256,-0.3364743,-6.5428457,-0.17780574}},
      {{-1.2794887,-1.708512,-2.9929345,-0.41185308,2.4185033,-0.1031052,-0.32296747,-4.077831,-0.9638215,-0.7782991,0.59852606,0.07835675,0.98110145,-0.63118863,-1.566868,0.15248527,-0.9532002,-1.7605338,1.6084585,-0.15027796,-0.19908738,-0.58363277}},
      {{-0.5406147,-2.3469868,-2.970738,-0.33719838,0.01862464,-0.33673358,-0.17707612,0.23000617,-0.95119625,-0.17735806,0.17332192,-0.02160044,0.15247309,-0.91030204,-4.816864,-0.053671777,1.7115288,-4.6472006,-0.21445417,0.5924926,-3.4619482,0.08916018}},
      {{-0.059092112,-0.18979135,-0.019031052,0.45475492,3.8016715,0.48839134,0.13679306,-1.1530142,0.017220391,-0.3309415,0.06384439,-0.20927712,0.16991225,-0.07932072,-8.887859,-0.21600027,0.01197701,-0.4206629,0.19453076,-2.0157626,-3.7531035,0.034212977}},
      {{-0.05473828,-0.9993299,0.23241648,-1.2053245,0.4945553,-0.49387452,0.56631774,0.29456207,0.36718678,-0.32221684,1.5811487,0.9829706,0.31257212,-0.7061017,-5.0134215,-0.6643446,-1.0008469,-4.5612454,-0.9610366,-0.79554427,-0.95628023,-1.0292604}},
      {{-0.6819485,-1.6239467,-0.28014368,-0.69443196,-3.050899,1.3002806,-0.4091364,-2.1936147,-0.5453295,-0.5805268,-0.48908076,-1.5165684,-0.0842643,-0.19948131,-2.5992548,-0.062439132,-0.09584431,-1.5938107,1.4040861,0.054803707,-2.8790128,-0.013219194}},
      {{-2.5624664,-2.1662714,0.3147541,-0.993852,2.2802634,0.75272346,1.3914211,-0.6813468,-0.7922703,-0.38401404,-5.4949775,1.1765816,0.4325429,-0.17596614,-1.0860647,-0.436995,-0.38039476,-3.0446196,0.0713366,1.3085515,-3.2957087,-1.2934033}},
      {{0.33789903,-2.1455617,-3.4991024,-1.8068705,-0.31871176,1.1087626,-0.2501546,0.22295003,1.6993701,-0.6566871,-0.1351434,-1.7633904,0.2552032,-0.7262757,3.4770393,-1.6517509,2.3075426,-0.29549512,0.62447125,0.9237296,-0.92098016,-2.6605442}},
      {{-0.02543324,-0.2388215,-0.12688543,0.21667458,2.1738222,-0.6459402,-2.740561,-1.6269761,0.33171767,-0.7342658,0.121146716,1.4576311,-0.09053387,-0.08358724,6.9221554,-0.4175033,0.13941032,-0.08457133,0.7446026,-1.4792444,-2.7765648,0.34414595}},
      {{-0.29074824,-2.1185994,0.4989946,-0.26603585,2.1055818,1.3511018,-0.97888136,-0.7930773,-1.2811564,-0.5546519,-0.07702897,-0.14025225,-3.8665216,-0.31225005,-1.7970203,-0.49001497,-1.0207559,-2.1321821,1.2717222,-0.039313808,-3.9525604,0.22935997}},
      {{-1.8627597,-1.5613815,-0.66118187,-1.7027375,0.41891968,0.8100509,1.0088962,0.45772198,0.4328668,-0.42656264,-1.1389966,0.25461778,0.029569365,-2.158864,-2.2351484,-0.10690451,-0.9250125,-2.7023375,0.83097005,-0.63485056,-4.267349,-1.5013007}},
      {{-2.2680507,-2.0225806,-0.7381901,-3.2118552,-0.9040668,0.66164476,2.4505496,0.37728813,-0.3319751,-0.53888613,1.2800522,-0.92604774,-2.195944,-0.3916625,-2.8777685,-2.2052252,-2.4500475,0.091868155,0.56564516,-0.91020054,-3.594251,-0.61094385}},
      {{0.13435502,-1.253206,0.5580035,-1.4080253,1.625491,0.9423245,1.0700737,-1.7762381,-0.65893734,0.1926743,-1.1822096,0.50749886,-1.0973263,-1.3143787,0.1248408,0.0007350678,-2.034062,-0.5522738,-0.27206933,-0.40813518,-2.006554,-0.23205042}},
      {{-0.94230795,-1.6889826,-1.7769172,-0.7462606,-0.13787232,0.7187991,-0.16643801,-1.9692168,-0.89805925,-0.33694118,-1.0164725,0.6378149,0.36831072,-1.4516971,3.3246505,1.5745969,-2.2590628,-0.717804,-1.111941,-0.4109444,-4.2627435,-0.054835938}},
      {{1.916879,0.8065129,-1.1634549,0.36000198,0.31681576,-4.4206004,-2.0052547,3.9715269,-0.49502492,0.08228124,0.2820521,2.5973935,-0.58789533,1.38662,1.2689606,-1.1882027,1.4632053,-0.11227116,-6.837544,1.2645806,-1.324373,0.20375861}},
      {{-0.6724051,-1.9460266,-0.49120706,0.47557682,-0.52703863,0.9263594,0.3372778,-2.9782565,-1.1574723,-0.9362419,-0.3418818,0.27723983,0.13492809,-0.42490366,1.4758264,0.62714565,-1.9510467,-0.48320696,1.9885877,1.6476164,-0.13844167,-0.7412915}}
    }};

    h2_out = {{
      {{-2.9698641,0.36797267,-0.73606735,0.102956735,-2.1612809,-1.225626,2.249327,-0.044960324,2.396762,-0.28301644,-2.1476762,0.7314253,0.6554901,-0.57868224,-1.0578333,1.320689,-1.9805359,-2.5649493,-4.7200847,-5.585055}},
      {{-2.2551725,0.4071008,-1.1493503,0.6748294,-5.0733237,-0.028135909,3.31078,0.28723025,0.87914467,-1.0087095,-1.7393521,1.5735866,0.85796666,-0.43577152,-1.2067238,1.3127891,-0.97302574,-3.3766732,-3.790495,-2.7027395}},
      {{-2.4252646,0.43756172,-2.142018,0.36752316,-5.9238443,0.3394109,4.4928513,0.8263207,0.0062483167,0.7502251,-1.4480593,1.6729056,0.04087918,-0.86660683,-0.8259413,0.39349467,-0.8354411,-2.7154143,-3.1873078,-1.622315}},
      {{0.70018166,-0.039265394,-2.1250894,-0.6369625,-2.0949814,0.50749046,2.8727944,0.49060327,-0.43025625,1.4580308,-0.42685735,1.2969772,-0.025400009,-1.391501,-0.9013423,-0.3325332,-1.8236051,-1.0823764,-1.77107,0.42814702}},
      {{-2.520147,-0.63353735,-4.069656,-2.1150541,-0.4853207,1.6648939,4.7855673,1.0650921,-3.6277764,0.5913108,0.44055027,0.0059756683,-0.12705076,-1.4492419,-0.5080633,-3.3477962,-2.2245872,0.5292,-2.3213584,0.54222727}},
      {{-2.6402857,-1.2728919,-4.3482203,-4.0908375,-0.98390347,1.5327827,2.9795933,0.8071844,-3.2786918,-0.6670808,0.9171586,-0.8270452,-0.48574507,-0.43739232,-0.1755564,-4.1308503,-1.2401217,1.3313823,-2.707074,0.53375125}},
      {{-2.7582068,-0.94367594,-2.5392954,-6.2546663,-0.22682403,-0.2948228,2.5907185,0.45870602,-1.1247177,-0.08399823,0.7187399,-2.7647305,0.3123983,-0.8669518,-0.20673507,-5.5648355,-0.7583297,1.7255952,-4.1439896,0.12900539}},
      {{-1.2785636,1.0622028,-1.2183985,0.2052432,-0.43336985,-0.47360083,0.23820756,-0.69644326,4.2190685,-0.79047483,-2.9648454,-0.41863894,0.74493384,-0.98090047,-1.0998365,0.80465645,-1.3554646,-0.8860406,-2.8656774,-6.244452}},
      {{-2.0985866,1.3477817,-1.3043091,0.5794049,-1.6592938,0.30970448,0.46113762,-0.6680823,2.0997844,-0.7310168,-2.4078863,0.8425903,1.340924,-0.65106857,-0.82273823,0.98778796,-1.6485188,-1.1368389,1.5133538,-2.068105}},
      {{-2.1951647,1.3087486,-2.941373,0.35509536,-2.8918827,1.3499357,1.647442,0.44404978,0.8514528,0.11536583,-2.1418893,1.162386,0.15690242,-1.4554088,-0.30670586,0.32575738,-0.61270946,-1.2958987,-0.45349103,-0.2902438}},
      {{0.29053426,1.0251218,-3.1704822,-0.9014437,-1.5875933,1.6597899,1.8707346,0.005880532,-0.72145766,1.4565691,-1.2001363,1.372971,-0.010985213,-1.6606665,0.24670406,0.1971784,-1.8936725,0.16058616,1.6832142,0.37571144}},
      {{-2.0191894,0.4658183,-3.0350313,-1.7878846,-0.564447,1.8357081,1.489398,0.7466277,-1.5708597,0.26401913,0.24219275,0.7455667,-0.60882705,-1.7380799,0.5307561,-2.3383749,-1.6161637,0.99124444,0.23643602,0.3847815}},
      {{-2.5625815,-0.46729615,-2.3159306,-3.73989,-0.85012746,1.0690602,0.14511359,0.2996353,-0.43601227,-1.0806139,0.93151194,-0.085074835,-0.8503189,-1.6683816,0.31204832,-3.2441003,-0.7212717,1.9549667,0.3851439,0.21368682}},
      {{-1.8062172,0.03247685,-2.1709185,-6.5844965,-0.2780131,-0.20649831,-0.04907864,0.14410207,0.9774715,-2.5152593,0.65622795,-1.8086002,0.005390995,-1.4569267,-0.32919952,-3.9262733,-0.12947409,2.4968567,-2.6374066,-0.25855872}},
      {{-3.1340714,0.5628133,0.50012094,0.15075341,1.543842,-1.2406805,0.30223733,-0.28714558,3.7001755,-2.1032946,-3.1837637,-2.2418756,0.88812673,-0.15814869,-1.3548528,-0.074123725,-1.4438921,0.005525734,-1.5342588,-4.4042153}},
      {{-1.6642557,1.3510146,-0.019509867,0.5156938,1.109927,0.055126812,0.08749982,-0.30775455,2.1887157,-0.92896897,-2.6559877,-0.51644844,1.5676361,-0.0548301,-1.1793362,0.21409066,-1.3346537,-1.0711805,0.45290363,-1.0838513}},
      {{-1.9461728,1.3969904,0.24060227,0.6478113,0.42165247,0.7886195,0.38007244,0.3216467,0.23458622,0.7653413,-1.6530375,0.0376157,0.16691965,-0.83888745,-0.24414487,0.55379236,-0.98523533,-0.7880887,0.8359312,0.32488802}},
      {{0.44179198,1.2571663,0.31407577,0.03139137,-0.28275383,0.6327058,0.44425315,-0.03761427,-0.81249434,1.380471,-0.8574675,0.64539087,-0.5945745,-1.0037463,0.55813175,0.2215634,-0.8199004,0.22321191,0.062439207,0.63114154}},
      {{-2.3026974,0.6148546,0.06797135,-0.6210065,-0.38743144,0.22797595,-0.63844633,0.6944065,-0.38760155,0.49323758,0.57959664,0.71679074,-1.1766193,-1.0617694,0.96761864,-1.1693894,-0.7153552,0.8741224,1.02545,0.6301253}},
      {{-2.7833524,-0.10545987,-0.47185248,-2.0875711,-2.0021226,-0.636712,-0.89144945,0.8397043,1.190572,-2.7641277,1.2248262,-0.28073284,-1.8364204,-1.6786995,0.8621662,-2.1676593,0.26035014,1.8669463,-0.22921768,-0.10590236}},
      {{-3.2247238,0.09936078,-0.05649846,-4.733165,-0.7867379,-1.8764799,-0.31980836,0.38937664,1.4911891,-3.7602205,1.1943499,-2.5271802,-0.20762382,-1.7706213,0.14805005,-2.1730206,0.40474203,2.2248504,-1.3668667,-0.81628007}},
      {{0.34094256,0.036220815,1.1433372,-0.6448979,1.6398687,-1.0647408,0.49795774,-0.7436033,1.8315358,-3.0282192,-2.415186,-1.8144059,0.44899133,0.11818379,-1.2245536,-1.1084853,-0.13120955,-0.34437424,-1.9497669,-0.85786504}},
      {{0.181696,0.49569955,1.1160101,0.32154,2.2720926,0.09390689,-0.124827534,-0.7571774,0.7516,-2.755208,-2.8434863,-0.44401184,1.415555,0.582293,-1.7555614,-0.17688794,-0.39747038,-0.5015953,1.8822049,-0.24700715}},
      {{-0.01020064,0.7095834,1.1376415,0.6751876,1.2773299,0.3667945,0.064113826,-0.24369463,-0.6960953,0.48689625,-1.7412319,-0.9177118,-0.18029065,0.42945284,-0.4639731,0.24349159,-0.20877817,-0.27897808,0.016752034,0.6093688}},
      {{3.8468535,0.5707038,1.1338974,0.35777462,-0.05206491,-0.12786274,-1.6282899,-2.0002675,-1.7337534,1.4241607,-0.6628763,0.20558327,-0.8869976,-0.31662342,0.6161627,0.38409436,0.257749,-0.11776523,2.8389976,0.6062272}},
      {{0.11424415,0.0017715389,1.120596,0.3039014,-0.42984173,-0.6788577,-1.1171885,0.24779007,-0.25075936,0.11879007,0.9005667,0.47114426,-1.4956207,-1.0341685,0.90100425,0.14779904,0.29735613,0.3439021,0.5546478,0.43302608}},
      {{-0.14282931,-0.6846143,1.0784045,-0.4167217,-1.8589653,-1.4098089,-1.6807629,0.41793507,1.4955664,-4.28121,1.640619,0.3511523,-2.1751697,-1.783656,0.83696723,-0.6083045,0.67758447,0.9868128,0.8489292,-0.6053905}},
      {{0.5588283,-0.41333318,1.1367332,-0.71944135,0.2700591,-2.3741393,-0.67299193,-0.31423602,0.87341946,-5.1774526,1.4623735,-0.63560176,-0.81839025,-1.9749588,0.32992294,-1.1794847,0.17859751,0.6342995,-1.7921846,-1.2883039}},
      {{-2.9827645,-1.118538,0.29467902,-3.0831506,2.230677,-0.47648633,-0.25104505,-0.44741637,2.408671,-3.372248,-1.846963,-2.7228365,1.0777198,0.73692983,-1.5666031,-3.3209481,0.6645132,0.03708531,-1.9203131,0.19629177}},
      {{-1.6311641,-0.77130026,-0.23964417,-0.18872388,2.5552857,0.26054397,-0.23486191,-0.4505829,-0.21864857,-2.5030289,-2.0292845,-0.8013661,1.1785877,1.3967185,-1.6042954,-2.3506289,0.42905858,-0.0006646255,0.7719952,0.47458205}},
      {{-3.0320437,-1.0981485,0.5054882,0.65523666,1.2760208,0.45426634,-0.22484244,-0.10244039,-0.9669058,0.7543706,-1.0601977,-1.321359,0.046703752,1.2170058,-0.89640814,-0.32018116,0.58524287,0.013692368,0.97904426,0.8147682}},
      {{0.16233046,-1.0716014,0.51077586,0.7008405,0.07777335,-0.44359085,-1.0321723,-0.59140766,-0.64630836,1.3618952,0.12541716,0.053009793,-0.22657943,0.6640057,-0.13821611,0.5793574,0.82677686,-0.35290286,0.32335714,0.7122532}},
      {{-2.0392954,-1.0624837,0.41860822,0.7178728,0.015644044,-1.3835382,-1.3234503,0.51836604,-0.15806514,0.21784621,1.2200314,0.88951737,-0.45933586,-0.49225417,0.29852608,0.9569861,0.83076775,-0.56961167,1.1797758,0.30875784}},
      {{-2.9153888,-1.2562178,0.07397201,0.36996615,-0.7050868,-1.7965378,-1.9112228,0.7586267,1.5175999,-3.6113875,1.6681532,0.6062003,-2.0021775,-1.200538,0.55730546,0.7130364,0.916304,-0.0345309,0.22736749,-1.314679}},
      {{-3.62057,-0.90445423,0.5647728,-0.06452774,0.6634295,-3.6375902,-1.2387546,0.07161174,2.1299365,-5.0545893,1.2463607,0.27011767,-1.1103748,-1.3895535,0.6012422,-0.296516,0.70821494,-0.01532297,-2.3348398,-4.8899984}},
      {{-2.1152916,-1.5530502,-2.240577,-4.8208866,1.7322233,-0.41294777,-0.870237,-0.17852736,2.1167233,-2.4144466,-1.5821514,-3.3201318,0.27715126,1.464693,-3.2131035,-5.538484,0.89934164,0.92650473,-2.369715,0.4399893}},
      {{-1.8501015,-2.6070855,-2.7034752,-1.3888614,1.2963811,0.5743441,0.35078603,-0.39049202,-1.005048,-0.61642337,-1.4122545,-2.28299,0.7134061,2.1971369,-2.2780461,-3.5207262,0.68725544,0.5872938,0.44606027,0.7724326}},
      {{-2.858477,-2.9289374,-2.720126,0.075916596,-0.19169192,-0.02539486,0.13297398,0.6220314,-1.4609245,0.6966893,-0.40196592,-1.3723649,-0.33631137,2.21778,-2.1676335,-1.3491541,0.8412187,0.046500597,-0.41966432,0.77631366}},
      {{0.0858859,-2.9716659,-2.2645137,0.59941953,-1.2350101,-0.8994882,-0.9011791,-0.102871604,-0.08550294,1.4258238,0.76540977,0.12733676,-0.42814717,1.2986596,-1.901299,0.5702906,0.825622,-1.2009809,0.38860863,0.59087074}},
      {{-2.500251,-2.253715,-2.51221,0.79807967,-0.5516871,-1.4213803,-0.94674706,0.6402282,-0.311575,-0.0065577603,1.4307239,0.27796647,-0.7581418,0.62978244,-0.8007181,1.5780439,0.76911724,-2.4012473,-0.2778269,-0.12805142}},
      {{-2.290665,-1.3833878,-1.6008198,0.6879296,-0.9301018,-1.8908517,-1.9067175,0.35210574,0.9001221,-1.8448485,1.6345077,1.1654044,-1.4352336,-0.34274375,-0.37770107,1.6847287,0.7316555,-1.1964731,0.64959186,-2.6039932}},
      {{-2.1652873,-1.0091746,-1.5678433,0.5098882,0.30657688,-4.0190144,-1.6033295,-0.2476922,2.3414693,-3.7117426,0.97673744,0.33860424,-1.3220896,-0.5766002,-0.15011889,0.96205974,0.5363916,0.026551716,-2.7007167,-7.8251433}},
      {{-2.6581972,-2.2387204,-3.204906,-4.146175,0.25655404,0.17422728,1.1090212,0.07672541,-0.11598193,-0.38035658,-0.58750314,-4.796414,0.48051798,1.3158112,-3.4457555,-5.9024663,-0.31794983,1.4686682,-3.3928306,0.28878656}},
      {{-1.266073,-3.6727548,-5.444984,-1.8136854,-0.07606626,1.295205,2.3243978,0.36258292,-3.1778228,-0.05774808,-0.3193546,-2.1987941,0.5769377,2.129607,-2.562916,-4.606568,-0.5666293,0.9215332,-3.099241,0.70339715}},
      {{-2.2022774,-4.006289,-4.0054603,-0.41962445,-3.0539224,0.86585176,1.5320112,0.5810787,-1.7172772,0.9560801,0.51870924,-1.3625757,-0.23618156,2.0019193,-4.460277,-2.3810537,-0.29595318,0.2602272,-2.9068801,0.6996999}},
      {{0.9254826,-3.2038758,-4.7304406,0.19646265,-1.7282766,-0.42014,-0.1382785,0.4029207,0.20985004,1.5075755,0.7766094,0.6665675,-0.23273648,0.6852529,-2.6896122,0.32964945,-0.5899093,-1.312082,-1.5590205,0.44441938}},
      {{-3.1178718,-3.5179923,-3.3906183,0.55034727,-1.9336121,-0.28742403,0.013041533,0.9580549,-0.19164547,0.8656697,1.3760432,0.6931378,-0.47346255,0.33528715,-2.119491,1.9608097,-0.96906537,-3.068625,-2.3642654,-1.0579144}},
      {{-3.1795201,-1.4490453,-1.5666558,0.50169855,-2.9778569,-0.72645193,0.036741313,0.96235985,-0.39574975,-1.3593277,1.3672129,1.2472547,-0.9688098,0.056889404,-1.0536059,2.3613343,-0.36793903,-2.5307524,-2.191684,-3.0551646}},
      {{-3.2967184,-1.0674818,-1.1715114,0.21257505,-1.2264001,-3.1620293,-0.2408024,0.23942126,1.5387484,-1.0677314,0.9670879,0.836771,-0.31572095,-0.47963172,-0.7270937,1.7077299,-1.104383,-1.837802,-4.080242,-6.474795}}
    }};

    b1 = {
      -0.06936215, -0.045252744, 0.06966655, 0.10109662, -0.10880835, 0.07742897, 0.20785484, -0.14570536, 0.10257834, 0.10403927, 0.0026701859, -0.2010774, 0.032467753, 0.0064590597, -0.6591795, 0.158258, -0.05549442, -0.36699584, 0.21044299, -0.15678535, -0.43058562, -0.044336572
    };

    b2 = {
      -0.07603949, 0.025004009, -0.030940874, 0.04816474, 0.06565503, 0.049334962, 0.0562584, 0.20947285, 0.073508985, -0.015847841, 0.08028312, 0.05334453, 0.08208619, 0.059666626, 0.017404754, -0.013760483, -0.023540728, 0.033953678, -0.1170621, 0.078015715
    };

    bout = {
      -1.8136779, -1.5390208, -1.4704537, -0.6057662, -1.3387967, -1.435859, -1.8026544, -1.5781673, -0.15218772, -0.75135803, 0.21167928, -0.7077575, -0.5316266, -1.7009797, -1.166435, -0.3334714, 0.380249, 0.6800719, 0.30621222, -0.7922983, -1.2942514, -0.28321373, 0.56644887, 0.885375, 3.015986, 0.58491236, -0.052671783, -0.47495276, -1.0214798, -0.053163078, 0.4783353, 0.92994684, 0.29241168, -0.8048986, -1.4537255, -1.7028993, -0.22017969, -0.7122738, 0.17237605, -0.90271604, -0.6658988, -1.9079267, -1.7586706, -1.3086224, -1.2820292, -0.748555, -1.5647436, -1.678817, -1.9841217
    };

    BN_gamma_in = {
      0.29495734, 0.46356273, 0.16206539, 0.97286254, 0.52931684, 0.89277035, 0.74622625, 0.7508067, 0.68344736
    };

    BN_gamma_1 = {
      3.130443, 4.076846, 2.6404939, 1.2824336, -2.6918197, 1.7424613, 1.0213305, 2.8895838, 1.9921613, 1.7959096, 2.6122649, 2.0323434, 2.9210596, 3.1559658, 13.729561, 2.5686016, 2.0950375, 6.066113, 1.5730636, 1.7449378, 10.93091, 2.4512024
    };

    BN_gamma_2 = {
      6.1101866, 4.1743555, 3.5850978, 3.4934168, 2.4630682, 2.3150942, 4.897571, 2.7742634, 3.5160291, 4.4167504, 4.0981903, 3.515562, 3.185743, 4.419861, 4.7190704, 4.345189, 4.4957695, 4.1448073, 5.0111933, 3.4899366
    };

    BN_beta_1 = {
      -0.02032527, 0.0011460232, -0.05889522, -0.17048724, 0.035193913, -0.07153142, -0.11269017, -0.03228176, -0.025624737, 0.0052767647, -0.02331626, -0.05832557, -0.016994363, -0.03142436, -0.0025160033, -0.084232025, -0.060961038, -0.000986372, -0.06596194, -0.051171485, 0.002688188, -0.0019883623
    };

    BN_beta_2 = {
      -0.029644364, -0.1343027, -0.030925922, -0.13833955, -0.13673705, -0.16354175, -0.25387713, -0.5031288, -0.25352678, -0.027952885, -0.28460583, -0.15934254, -0.34268647, -0.3214064, -0.11573647, -0.059307426, -0.08091178, -0.19351865, -0.11066587, -0.16389202
    };
    
    mean = {
      97311.09375,65074.5859375,97515.0234375,66286.7734375,19156.431640625,66971.6015625,96993.9453125,65026.8203125,97612.171875
    };

    stdev = {
      710986.1826618011,600667.4644759777,707120.6587167426,600187.4548772242,508032.7578729545,600129.4435303104,708248.0473054621,600780.7596386556,710227.7210923268
    };
  }
  
  else if(m_pcEncCfg->getQP() == 37){
    
    embs0 = {{
      {{-0.048027992,0.31085774,0.2672229,0.39352277}},
      {{-0.0027005195,-0.021388043,0.0005271044,-0.0060001467}},
      {{0.0019126198,0.006205772,0.00083378115,0.004120766}},
      {{0.078902796,-0.03035313,-0.044329185,-0.11131548}},
      {{0.0015411053,0.04194997,-0.017032485,-0.0004707901}},
      {{0.07471044,-0.008848557,-0.07307353,-0.20467588}},
      {{-0.04064323,0.10635697,-0.013243592,-0.03299148}},
      {{0.10309758,0.18563914,0.21571103,-0.089609906}}
    }};

    embs1 = {{
      {{-0.061768055,-0.37075526,-0.37363553,0.22958592}},
      {{0.009787399,0.0012547033,-0.22921966,0.015719345}},
      {{-0.006018801,6.4197857e-06,-0.22666103,-0.0032225342}},
      {{0.00054245314,-0.11465056,-0.23543042,0.036882147}},
      {{-0.0011663326,-0.005705879,-0.222776,-0.038500533}},
      {{-0.039294235,-0.10897655,-0.2387341,0.08055986}},
      {{0.018297134,-0.014090239,-0.21810564,-0.09836131}},
      {{0.0723794,-0.008282249,-0.21108703,-0.2051557}}
    }};

    in_h1 = {{
      {{0.02123932,0.012354998,-0.0026488232,-0.00096754223,-0.03818278,0.018402487,0.20314613,0.020893808,-0.43804067,-1.6012006,-0.31816038,1.0367725,1.5344706,2.1037345,-0.29752788,-1.6018789,-0.74208826}},
      {{0.012667655,-0.012237609,0.013792143,0.09029957,-0.059311245,0.0103099765,0.118278965,0.035618294,0.10416985,0.049308795,0.049440593,0.030539172,-5.2571125,-0.07743297,0.073483184,2.7469387,0.23174071}},
      {{-0.05810149,0.07829113,-0.10046425,-0.0118751405,0.05864713,0.009285001,0.32448363,-0.10391428,-0.8388707,-0.4694721,-1.1128659,-0.74163145,-1.7237538,-1.5317482,-1.2847779,0.23086824,-0.98827565}},
      {{-0.021436902,0.039883174,0.048917323,-0.06639189,0.029329889,-0.045624156,-0.024552178,-0.053592138,0.59900975,-1.6124467,0.36469936,0.7552775,-0.17351778,0.6881357,-0.0050406936,15.7531185,0.88574207}},
      {{-0.05429453,-0.117501594,0.0033897052,-0.0038778035,0.11323625,-0.20849226,0.0052651833,0.09090212,-1.3340693,-0.23624624,1.4673014,0.56395346,-0.3567728,0.44435838,0.59222555,-8.305696,-1.7099919}},
      {{-0.14304338,-0.20803805,0.16168272,0.028001072,0.36435372,0.24818553,0.48840347,0.19669977,-1.1630769,0.078579195,0.08763476,-0.10882367,1.187213,1.5124384,-1.4438977,-7.7088566,0.92305}},
      {{-0.016337546,0.030306736,0.029310206,-0.022998137,-0.023960669,-0.020378686,-0.18843448,-0.046047803,0.118238196,0.04464875,1.0617744,-1.5918747,0.1298646,2.469778,-1.011714,-8.450981,-0.03895119}},
      {{0.055705972,-0.021848727,0.10301417,0.09589962,-0.10277191,0.04635642,0.013953455,0.08699609,-0.7831303,-0.78502923,-1.2743074,-1.7313275,-2.8030279,-0.9313956,-0.7451437,0.051141,-1.0313575}},
      {{0.058399044,-1.6019884,0.25008312,0.7562986,-0.15918365,0.5793792,0.16551714,1.8230038,0.64977974,1.000095,-0.9430584,-0.97452986,-1.4022814,2.7708576,1.1567973,13.851937,0.074305356}},
      {{-0.0054073343,0.007032745,-0.037434727,0.076821975,0.00758406,0.0458473,0.57021576,0.030627336,1.5983496,-0.030608958,-1.4168988,-0.11896994,0.9659579,0.4750275,-1.3453376,-1.2141132,0.95574695}},
      {{0.027667198,0.03898873,-0.022327403,0.0082149785,-0.0390952,0.015957452,-0.2644647,-0.065025106,-1.4954188,-0.11250766,1.0951755,1.2129418,-0.054503214,-3.4412944,-0.17126992,22.847958,0.86398417}},
      {{0.0041787676,0.014790849,-0.0076376987,-0.005434229,0.08710016,-0.073306106,1.8447,0.19157444,1.6780668,-0.25769085,0.48066956,-0.28560555,0.23972124,-0.48135898,-0.428406,-7.4926276,-1.3273169}},
      {{-0.0047574523,0.02761271,-0.013232636,0.008987417,-0.0042945724,0.0024688009,0.35016575,0.008380103,-1.1319212,-0.6829557,-0.8787956,-1.3193526,-2.8627195,-1.7730308,-1.2317095,-1.2311412,-0.6544994}},
      {{0.03247339,-0.005670194,-0.031040343,-0.018439822,0.002854752,-0.009002481,-0.25098234,-0.030926034,-0.30115667,0.41784403,-0.22517344,-0.28152698,-0.9005588,4.632831,0.0024058179,-16.045832,-0.25909126}},
      {{0.025928516,0.09072359,0.03218122,-0.05733671,0.0026983293,-0.038041424,0.022206813,-0.07527505,1.413802,0.040631935,1.0721589,-0.22306657,-2.818531,2.3669717,-0.1270779,6.822268,0.04088238}},
      {{0.05706774,0.06887664,-0.00033575957,-0.03597693,-0.03677416,0.11876379,-0.15874308,-0.103151545,-0.6652938,1.3483905,-0.33601195,0.6164044,0.1446003,-2.7011003,-0.10955843,-3.0937006,-0.7321341}},
      {{0.09765562,-0.015315507,-0.12896472,-0.11257182,0.0024431478,-0.1678433,0.06841337,0.097527705,0.7458905,0.08617435,0.12202001,-0.65836865,3.3279428,-0.23049797,0.23690058,-2.5101023,0.4611618}},
      {{-0.0036227999,-0.12999173,0.020695716,-0.08794624,0.14977592,-0.23179284,-0.2127085,0.06658168,1.5007676,0.33254445,0.022442926,0.9998223,-2.232453,-1.071804,-0.6218878,6.099821,2.0871575}},
      {{0.050369825,0.11587155,-0.008564646,-0.027388336,-0.07748334,0.02137733,-0.00016905434,-0.082706615,-0.19364543,0.62463546,0.72643834,2.1693192,-1.9540004,-0.13602552,-1.2041348,-31.91498,-0.38843444}},
      {{0.024799265,0.01869703,0.0013615589,-0.038177602,-0.011143013,-0.041763306,-0.20323895,-0.030100605,-0.19542071,-0.03772937,0.07610899,-1.4137789,-0.45931724,3.8904207,0.03225253,3.1386578,0.8520081}},
      {{0.040544294,-0.0032219947,-0.07169158,-0.021349266,0.029657595,-0.10154483,-0.34747764,0.024223432,-1.6386526,0.66134083,-0.67463416,0.6057317,-0.11789143,1.0431539,0.11037894,25.592045,2.2842116}},
      {{-0.016807105,-0.6336215,-0.24542138,0.22399478,0.005046056,0.01893779,0.53718644,0.84781414,1.2013197,-0.32549393,0.08404748,-0.11200978,1.8718432,-1.2816671,-0.059542723,3.9606094,2.3897183}}
    }};

    h1_h2 = {{
      {{-1.6807213,-0.5601491,-0.7847148,-0.63416964,-0.18607074,0.15612763,-0.29083103,0.10833914,-0.99077296,-0.50995684,-1.2786638,-1.0719761,-1.4528004,-0.4301787,-0.044334102,-0.61389303,0.32837227,0.7332268,2.1727855,-0.03563599,-1.0227633,-0.18471794}},
      {{-0.6275341,-0.23004568,1.4932253,0.27065042,-0.6750864,-0.43751904,-1.002392,1.3693526,-0.3363838,-0.9746912,0.90718883,-0.2814246,-6.3478665,-4.846558,0.04259944,0.10327678,0.9522952,0.45658055,-0.33613196,0.4269691,-1.252053,-0.69737965}},
      {{-1.7847306,-4.7635727,-2.5788183,0.48850563,-0.8541561,0.45503533,-1.802893,0.70917606,-0.25121722,-2.2973034,1.206008,-1.1868674,-2.8339038,-0.64865094,1.214722,-0.35957977,0.19195572,-0.37272382,-0.70189255,-1.0567461,0.43845138,-0.012379182}},
      {{-2.229009,2.4668946,-0.115286775,-1.1691391,-0.90881026,-1.3426211,0.22579207,-0.2722931,-0.7632224,-0.43390614,0.4089084,-0.855678,-2.7740662,-0.006270154,1.526935,-0.37393558,-1.2748746,1.0790248,-1.3010998,-0.22302364,0.5097517,-1.4333527}},
      {{-2.116927,-2.7635088,-2.6043408,-0.9998271,-1.0287379,-0.9894425,1.8816109,0.9378928,-0.6077997,-0.14026746,-3.7134821,-0.66240555,-6.7014966,0.4332408,-0.44842583,-0.48318934,0.29986158,0.66413987,0.3004854,-0.5515689,-0.26891997,-0.10567367}},
      {{-1.3891028,-3.233427,1.3245574,-1.4306123,0.667278,-0.6577985,-0.63704824,2.5121157,-1.3355151,-1.2093331,-2.4913235,-0.4305899,-0.3006872,1.4992363,0.9435826,-0.89277154,-0.26068783,-0.5007828,0.35649285,0.60295314,-1.2950429,-0.5134001}},
      {{-1.1724919,-1.4533594,0.96652365,-0.55049235,-2.5378723,-0.7207854,-0.07174452,1.6535113,-1.4480096,1.1102129,-4.2819476,-1.526247,1.7728773,0.36717477,0.8304484,-2.2437332,-0.76378864,1.2363417,0.82352823,0.41274604,-0.35808888,-0.24116744}},
      {{-0.47373578,1.9180925,0.8374987,0.39723495,-0.85021836,-1.0329752,-0.08265028,0.04651618,-0.95693505,0.4842613,-0.047056716,-0.5563305,-3.470718,-0.35621932,0.6387992,-2.3055844,-2.4108078,0.95659626,0.4853208,0.71470976,-0.4049054,-2.7678237}},
      {{-1.1949787,3.7531347,1.2256408,-0.33057,-0.5836738,-0.06172458,0.3764532,0.46625468,0.29598558,-1.197527,-0.3716045,0.01670334,-0.40925294,0.17607014,-0.089508034,-0.87502205,-3.003278,-0.19964577,0.9679072,-0.15200081,0.16188684,-0.5512169}},
      {{-0.34266308,-2.6851437,-0.21802202,-1.2695171,-0.42050928,-0.56070864,-0.17740144,0.71587145,-0.64513326,-0.26981342,-0.67391264,-1.5966345,-0.04914978,0.28671253,1.872135,-0.06320805,0.110597745,0.5848886,-0.5559029,-0.6454306,-0.68022805,-0.08175028}},
      {{-1.2915014,-2.1626472,-0.11273453,0.16373868,-1.0170193,-1.6967049,0.20196268,1.6833218,-0.5280541,0.5163903,0.22011015,-0.9509506,1.6031158,-0.5582588,0.92784405,-1.5699027,0.50056344,-0.067691915,-2.9086506,1.216488,-1.3348672,-0.28741843}},
      {{-1.8773466,-1.7070844,-1.7629397,-1.1688292,-0.065317415,-0.47686026,-0.031086715,1.2329006,-0.40720537,-0.27088422,0.14266397,0.06128179,-7.086565,-0.29073095,-0.03526425,0.4096689,0.09696096,-0.42334348,-0.57891303,1.4125065,-0.6052868,-0.14812092}},
      {{0.019293131,-1.1553537,-2.4198482,0.14073303,-0.36493358,0.25669107,-0.18993837,0.77508646,-0.07545974,-0.40494373,0.30050907,-0.29304484,-9.948659,0.7336187,-0.006966716,-1.4965972,0.10452623,0.20518635,-0.41329867,-0.02560887,-0.7500471,-0.15563396}},
      {{-0.19711633,-1.3724245,-1.9702973,0.19192119,-0.36940512,-0.47978023,-2.2361119,0.4300003,-0.15638736,0.10199822,-0.37103176,-0.8016522,-4.9497824,-0.9596559,-0.3721777,-0.009779792,0.16229665,0.9165738,-0.041438635,-0.8717847,-0.0039821,-0.14629127}},
      {{-1.2138933,-3.4196312,0.6229583,-0.088233404,0.7453708,-1.3821119,0.26858795,-1.0451397,-0.4227217,-3.4748657,0.57312953,0.11787282,-0.3508761,-0.24982786,-0.50913805,-0.19297244,-0.09007479,1.0031542,-0.2119473,0.13335884,0.21909572,0.049291033}},
      {{-0.8589057,0.34669104,-1.1211357,-0.07983959,-0.18357342,-0.6517024,-2.316447,0.076031595,-1.044676,-1.1758096,0.32509857,0.17739335,-7.3883605,0.33512026,1.8191322,-0.974017,-0.89020747,-0.2765884,-0.28113797,0.87441766,0.30954152,-1.0415313}},
      {{-0.75958526,-1.9804869,0.765063,-0.952304,0.022526786,0.25486106,-0.17067504,1.7576177,-0.639215,-0.19090812,0.47733626,-1.053829,1.4056959,-1.529286,1.0296671,0.35320693,0.33038038,0.8413255,-0.5033535,-1.3063246,-0.44314715,-0.01689219}},
      {{0.5060502,1.2903749,0.7397108,-0.7285916,1.5057598,-0.31636223,-0.47969908,-0.3465356,-0.92700064,-2.8062243,-0.14493786,-0.10624142,-0.28247386,0.22957894,0.542902,0.5575675,-1.7099215,-1.2791176,0.42660505,0.14454693,-0.5875085,-0.82741964}},
      {{-0.6598315,-1.918287,0.45757115,0.4825282,-0.4883301,-1.3892322,-0.95244926,2.353466,-0.47057533,-0.58367825,0.10121558,-1.0763808,0.9631597,0.20064852,0.9176018,-1.996853,0.09213465,0.6744135,-0.19562288,-1.9508077,-0.5036521,-0.5654334}},
      {{-0.577378,-1.7847221,-1.0353041,-0.41803175,0.90985817,-0.6639909,-0.7803121,1.3919548,-0.60774106,-0.08360236,-1.5715543,-0.73600394,-4.1873,-0.6755449,0.15474474,0.6492001,0.26808217,0.09325305,0.84829473,-1.0573328,-1.6177224,-0.13031346}}
    }};

    h2_out = {{
      {{-3.9342232,-0.53617656,0.52481675,-2.0112417,0.2168413,0.103670605,-3.623246,-2.921032,0.4304381,-6.003468,-0.847546,2.8545988,0.855167,-0.7415852,0.36418205,0.14957619,-0.7808724,0.7927088,-2.8303373,1.0046642}},
      {{-3.427979,-0.80792904,-0.05119548,-2.557909,-0.7723594,0.69702905,-3.196538,-2.0623686,-0.13117842,-6.148502,-0.047329523,-0.19158225,2.5013747,-1.2047596,0.99430203,0.32028902,-2.0033782,0.50818866,-1.1382908,1.2951902}},
      {{-4.414242,0.087172754,0.052803874,-3.7669206,-0.6197286,-0.49129167,-2.0151708,-0.21912402,-1.5723631,-1.856881,-0.6428641,-1.3522823,3.1945462,-0.7565793,0.67190325,0.5376506,-0.9798011,0.45951122,-0.27783293,-0.36940363}},
      {{-3.5021832,-0.14517973,0.63085806,-2.3108625,-0.50647575,-0.9967835,-0.071880765,0.8305309,-0.33855852,-0.7811052,-0.47110856,-0.9636475,1.5148022,0.2573634,-0.7478304,0.46249932,-1.9248353,-0.043765295,0.6199264,-0.26813856}},
      {{-2.6549134,-0.10001543,0.085131444,-3.1886353,-0.25735623,-1.9652214,0.6918854,0.40736347,-0.30767387,-1.2528827,-0.050586324,-1.702267,1.9318836,1.5539693,-0.11921299,-0.19803044,-2.8418863,-2.6065073,1.0639634,-0.06727452}},
      {{-0.82587385,1.3818879,-0.020867905,-1.5637022,0.75679535,-1.5743538,0.8029233,0.020573966,-0.24628386,-1.5672221,-0.08751329,-2.4047704,1.4045168,2.6722333,-0.100541815,-2.3341,-3.5757134,-3.6106732,0.62165904,-0.3657097}},
      {{-0.96934247,1.0088319,0.39167634,-0.7753021,1.3316841,-2.9579277,0.7617992,0.6683973,-0.48798054,-1.870968,0.24663106,0.16245309,-0.8419261,3.0034018,-0.6748116,-2.7436967,-2.065138,-4.51763,-1.3581619,0.3311916}},
      {{-2.9749386,1.1569544,0.19867288,-1.1221744,0.13158523,-0.21320558,-2.8198645,-2.224559,-0.21340333,-3.0280616,0.89932543,3.7528994,-0.6129,-1.2433412,0.65165395,0.12752028,-0.14798522,0.46760345,-4.232503,0.12671015}},
      {{-3.2873762,-0.7466459,-0.26639676,-1.9628682,-0.84974027,0.808249,-1.2518137,-3.207345,0.04551893,-3.2464063,1.4905049,1.0910068,0.46052563,-1.4181557,0.86629754,0.41971606,0.6186261,0.30288038,-1.0911103,-1.2071098}},
      {{-1.9048986,-0.5336727,0.62602115,-2.6509993,-1.4745413,0.12666771,-0.5130922,-1.257395,-0.46895152,-1.0701355,1.2355173,-1.0420767,1.7457603,-0.75357217,0.9244396,0.61998105,0.114745654,0.12874337,-0.4638819,-1.473118}},
      {{-2.2452545,-0.48866498,1.3110175,-2.6594596,-1.1130617,-1.0236917,0.29432762,0.48924902,0.13272436,-0.5500545,1.0600221,-1.0930095,0.90454936,-0.17560054,-0.0828388,0.55640787,0.08153317,0.07342249,0.6334373,-0.8924495}},
      {{-0.5414224,0.012572107,1.1508443,-1.9288982,-0.68915963,-1.0553991,0.5597309,-0.5627993,0.27862957,-0.845213,1.0056242,-2.0241623,0.5723079,1.5539428,0.3265625,-0.18777089,-0.77684665,-1.4214429,1.15058,-0.93262714}},
      {{-0.2818282,1.907165,0.6606887,-0.74693286,0.4905783,-1.3159592,0.5965435,-0.1838149,-0.48677608,-1.0315683,0.7617931,-1.617832,-0.45801356,2.733567,0.23805732,-2.4540875,-0.8210232,-1.9250922,0.41985846,-0.71720123}},
      {{-0.43860734,2.4325368,0.5125228,-0.2935988,1.3389528,-3.1222043,0.59490836,-0.44353083,-0.20940243,-1.138584,0.85921377,0.97541624,-1.796466,2.905283,-0.20490685,-2.486532,-0.26488122,-3.8739638,-1.693452,-0.6761578}},
      {{-2.9441466,0.82889616,0.117429204,0.19521478,0.6911982,-0.123027585,-2.1634328,-2.1196191,-0.40312162,-0.45647463,1.0552931,3.213995,-0.32236537,-1.065773,0.08877218,-0.7896237,0.145659,0.37092236,-3.872307,-0.7623025}},
      {{-2.3880908,-0.059058502,-0.41328356,-0.4880417,-0.111297175,0.77548337,-0.6297406,-2.5431883,0.06043932,-0.30647632,1.4999663,1.3771163,0.5479872,-1.4227562,0.7668384,-0.044868205,0.11947325,0.051617328,-1.983547,-1.7839538}},
      {{-0.9822265,-0.2489766,0.3669447,-0.28767785,-0.7126037,0.3885828,0.052002516,-0.48935208,-0.8002285,0.2958112,0.9538754,-0.6133642,1.1026851,-1.117024,0.73880917,0.54118186,-0.2986099,0.33117622,-0.80701876,-0.6846935}},
      {{-0.10466771,-0.414482,1.1010203,-0.18127665,-0.914674,-0.67942977,0.25566682,0.6674169,-0.30563435,0.35429004,0.57380193,-0.7796426,0.2931291,-0.25283358,0.19481935,0.50949883,-0.5102611,0.3482352,0.4310602,-0.62842524}},
      {{0.35655254,-0.06253894,0.7805507,-0.017945115,-0.533931,-1.6823169,0.36422297,0.049449198,-0.9750106,-0.1550427,0.22674455,-1.1306207,-0.11597991,0.94537985,0.70470846,-0.10623178,0.3481865,-0.19321634,1.0375915,-0.16528232}},
      {{0.5283587,2.0699093,0.4084566,-0.0656366,0.3786122,-2.151118,0.045203265,-1.1079069,-0.43513322,-0.33546376,0.086441,-0.7177538,-0.886672,2.1935601,0.76755023,-1.4098303,0.5287696,-1.4080392,0.24368683,0.030565891}},
      {{-0.052471545,2.896917,0.66523737,0.34925532,1.2242211,-2.3180885,0.18612371,-1.4289565,-0.3983677,-0.5100176,0.19542572,0.6049168,-1.9733284,2.3283002,-0.20471711,-1.5144278,0.5227504,-2.4593275,-2.3962898,-0.051252257}},
      {{-0.8570348,1.0030556,-0.24850288,0.59087276,0.6778228,-0.61068994,-0.8044645,-0.7912225,0.21775652,0.40373695,0.82570434,1.9128952,0.08378074,-1.1935743,-0.8266823,-0.6540193,0.14957364,-0.38169238,-3.9815428,-0.71726954}},
      {{-1.4251816,-0.2601688,-0.71873546,0.5560125,0.4331134,0.926906,-0.2018341,-2.3351068,0.3382256,0.24296251,1.1580224,0.82215124,0.42132726,-1.6687148,-0.8709112,-0.91274905,0.33015054,0.11479259,-1.1438048,-2.194369}},
      {{0.15850325,-0.82208246,-0.16023558,0.55837715,-0.3466468,0.6970964,0.29074883,-0.65804595,-0.17205206,0.5725582,0.27698204,-0.33808804,0.9401766,-1.0069987,-0.25167084,0.2878193,-0.27426428,0.25906846,-0.8634097,-1.1236689}},
      {{0.623724,-0.32473636,1.061729,0.57466626,-0.9947229,0.34175715,0.10652152,0.63436913,1.358094,0.49688193,-0.02451917,-1.5384039,-1.7007122,-0.895133,-1.7833039,0.51683074,-0.0642023,0.49819255,0.51500267,-0.28853437}},
      {{0.8905944,-0.58898133,0.33231324,0.58869207,-0.7155173,-1.1280262,-0.05599914,-0.31475025,-0.0009504785,0.09469874,-0.60830337,-0.93155783,-0.6614913,0.6272585,0.37705106,0.15045136,0.66277874,0.2331671,0.83858055,0.871859}},
      {{0.7449373,1.8048385,0.051043496,0.58962226,-0.38468176,-1.8861562,-0.3130013,-1.6828673,0.2201884,-0.35835788,-0.9383683,-0.41620237,-1.4858975,1.2869809,0.68363875,-1.1577296,1.0947434,-0.032229554,0.06521094,1.2932379}},
      {{0.03891077,1.6289378,0.052853137,0.6010582,-0.052284706,-1.9042298,-0.48059356,-2.0501351,0.53874713,0.071138784,-0.3587058,0.49874762,-1.9717281,1.493795,-0.049840666,-0.7796963,0.6687894,-0.20113544,-2.3809838,1.3427691}},
      {{0.0333576,1.1365294,-1.2468309,0.52464706,1.3196049,-0.9089886,0.14067003,-0.44114622,-1.1266263,-0.03353988,0.6992731,2.5658479,-0.46016484,-1.2015836,-0.21294509,-2.0826957,0.8683923,-1.7126335,-4.939228,-0.84501505}},
      {{0.08458363,-0.20946306,-1.5041913,0.19195832,1.1863842,0.6979696,0.48889932,-1.2452008,-1.0369502,0.21614237,0.1964014,0.90763944,0.6133741,-1.8651736,-0.2960445,-1.7273293,0.18553236,-0.9158456,-1.0397667,-1.7848539}},
      {{0.6186081,-1.2099121,-1.5066208,0.017818158,0.44043005,0.7595169,0.50877124,0.29331028,-1.7218205,0.47138035,-0.78931826,-0.07487242,0.41851774,-0.800539,-0.012235494,0.15473756,0.039878827,-0.06438181,-0.55586296,-0.9394315}},
      {{0.9368237,-1.3240889,-0.80546415,-0.090503305,0.25912845,0.458955,0.07634279,0.6453353,-0.31870636,0.4465454,-1.5575846,-0.3030537,-0.5153923,-0.14639531,-0.22490609,0.49909016,0.18266283,0.4007149,0.5170179,-0.040253963}},
      {{1.0135548,-1.1340986,-0.7895384,-0.22112806,-0.43475062,-0.0918411,-0.20091087,-0.31139466,-0.4654227,0.21134874,-1.2785139,-0.4318439,-0.9967684,0.40415803,0.630127,0.13420814,0.46545127,0.54554933,0.82373446,1.4574611}},
      {{0.69794434,0.91617113,-0.66822046,-0.44917557,-0.20542838,-0.8760316,-1.1501266,-1.7965765,-0.7955316,-0.5044692,-1.7057781,0.32379493,-1.9662335,0.8094677,1.1177721,-0.37017375,1.1107972,0.35693002,-0.06899484,2.352605}},
      {{-0.4350123,1.8616971,-0.109164655,0.16339296,0.61754215,-1.3499616,-2.5655289,-2.338314,-0.952083,-0.28336927,-1.37468,1.5854255,-2.1317089,0.52838707,0.43725193,-1.0758663,1.199977,0.4693794,-2.452805,2.5597453}},
      {{0.70182943,0.7408126,-1.6249247,-0.2691663,1.5194477,-0.9471097,0.5161761,0.6145592,-1.562224,-0.23459825,0.15897775,2.3448188,-0.8952997,-0.64852816,-0.6320362,-5.2906394,0.54725283,-3.6621444,-4.194776,-0.89194506}},
      {{0.88981897,0.0598446,-2.1934845,-1.0526327,1.5197084,0.7970496,0.6831415,0.40243188,-2.0093842,-0.2858562,-0.7477222,-0.0006440381,0.73405325,-1.2389133,-0.84557617,-2.7701957,0.0073554134,-1.7899853,-1.2533224,-0.9535323}},
      {{1.194688,-0.7685228,-1.9516145,-1.457821,1.0609988,0.80965316,0.43231532,0.27645144,-1.403918,0.08660294,-1.9246485,-0.5717526,0.8313119,-0.8897197,-0.2710051,0.1483466,-0.3953358,-1.4158258,-0.56127876,-0.067145534}},
      {{1.3137994,-0.7606817,-1.3313161,-1.9523602,0.7305444,0.7031238,-0.0450208,0.7273384,-0.3422485,0.1284661,-2.376919,-0.2903707,-0.25079632,-0.251069,-0.6112347,0.46114048,-0.3623572,0.3701186,0.3885083,0.5021905}},
      {{1.2443687,-1.2772946,-0.9870989,-2.2063167,-0.085644804,0.60196775,-0.7672291,-0.12670875,-0.5771512,0.0340702,-2.3423617,-0.037490856,-0.6214968,0.098244876,0.64001876,-0.0842107,-0.63670146,0.44152734,0.61666363,2.1192687}},
      {{0.5953276,-0.0896416,-1.1590182,-1.9946866,-0.077197075,0.17704502,-1.8730072,-2.2598174,-0.35143045,-1.2704666,-1.514868,0.0022474616,-1.6307874,0.22089136,0.92838967,-0.47285,0.07079995,0.87748194,-0.20335908,3.4177964}},
      {{-0.38442972,0.7971463,-0.5097452,-1.460499,0.66490424,-0.7209526,-3.6691663,-2.6216893,-0.20723897,-0.9438315,-0.7544544,1.8484055,-2.4672647,-0.031235054,0.5038699,-0.72455966,0.42625326,0.93867594,-2.6588252,3.7279353}},
      {{0.80439305,-0.294495,-0.9302768,-0.9924073,1.5220115,-1.0760056,0.681262,0.7997541,-0.7657703,-1.2369606,-0.9692364,1.0760347,0.6433866,0.22327115,-0.87118405,-5.5511837,-1.3547871,-5.2739334,-2.4683628,-0.75172615}},
      {{1.1181588,-0.21971309,-2.0271714,-2.1387315,1.2589685,0.39580464,0.753229,0.42168826,-1.0222176,-0.97158927,-1.9152927,-1.5412536,2.447626,-0.3706082,-0.6658783,-2.3165712,-2.3659952,-4.0525208,-1.0609853,-0.35370517}},
      {{1.2799667,-1.4271885,-1.6575562,-2.8035767,0.68886346,0.14924398,0.4357869,0.44978422,-0.52928925,-0.33651006,-2.685793,-1.1028104,2.2858822,-0.14733711,-0.54004055,0.15669923,-1.3220186,-2.7841773,-0.5154908,-0.1777046}},
      {{0.47961348,-1.345573,-0.36777067,-2.7691097,0.5953873,0.23261695,-0.32770374,0.78355986,0.0435615,-0.08966257,-2.7050173,-0.29575944,0.75562066,-0.12605129,-1.1551405,0.47627306,-1.087093,0.0048164804,0.52767193,0.32253745}},
      {{0.25911894,-1.6481143,-0.7524875,-2.7046876,0.3506001,0.844044,-2.217474,-0.055936646,-0.22292727,-0.4114281,-2.8389544,-0.17968096,0.5970269,0.5911964,0.28916535,0.13610303,-2.4780662,0.4439638,0.9017377,2.0382614}},
      {{0.03914672,-0.76859784,-0.81631935,-2.55337,-0.042605754,0.85354775,-3.3596013,-2.0325162,0.04972666,-2.1257043,-2.396118,-0.62947863,0.07043239,0.17115542,0.8444548,-0.35834867,-2.3418927,0.76029116,0.08214238,3.8956704}},
      {{-0.82180005,-0.6975193,-0.022355132,-2.1846313,0.36709553,0.20927168,-3.6859014,-3.5609138,0.54032373,-3.2155802,-2.1541731,1.2448095,-1.2713736,0.40682903,0.35246795,-0.36846834,-0.8826004,0.93839926,-2.019594,4.0030856}}
    }};

    b1 = {
      -0.065612525, -0.06640197, -0.485257, 0.07494271, 0.100116685, 0.17004848, -0.066400185, -0.61074424, 0.066388294, 0.06905227, -0.061317712, 0.4236858, -0.55735004, 0.013619493, 0.18908536, -0.021821469, 0.17194349, 0.17977244, 0.070748076, -0.00039873336, -0.004139863, 0.28498086
    };

    b2 = {
      -0.007017112, 0.075101696, 0.02799472, -0.007773669, 0.14956602, 0.07283449, 0.14828981, 0.065112926, 0.19786687, 0.006257049, 0.07317664, 0.07352033, 0.12054034, 0.09438811, -0.03401796, 0.010090655, 0.085384734, 0.050687134, 0.07769949, 0.051559437
    };

    bout = {
      -1.551657, -1.3583901, -1.4648268, -0.37886995, -1.187098, -1.4401128, -1.6993438, -1.4990665, -0.40557268, -0.7679198, 0.15360244, -0.6442605, -0.67651415, -1.6347761, -1.1802738, -0.43025777, 0.19511038, 0.42845947, -0.05033193, -0.6521129, -1.1057553, -0.19440185, 0.5600873, 0.6503572, 2.7320602, 0.693073, 0.43979907, -0.04493271, -1.3013847, -0.73257595, -0.17856517, 0.5354918, 0.3267901, -0.55168325, -1.2510332, -1.9987179, -0.9753493, -0.9040307, 0.16444007, -0.6888726, -0.4819544, -1.4656824, -1.9970208, -1.592359, -1.2176099, -0.36603054, -1.0124531, -1.151832, -1.4060144
    };

    BN_gamma_in = {
      0.6004234, 0.98965204, 0.7849627, 0.6893427, 0.68748575, 0.2807514, 0.88676584, 0.0007801056, 0.4054265
    };

    BN_gamma_1 = {
      3.482361, 4.9642434, 5.669153, 2.3228457, 2.2706869, 1.135419, 3.0246847, 6.017017, 2.0042396, 2.0471208, 3.5932837, 4.0875278, 16.537088, 2.460659, 2.2578406, 1.7035755, 1.3950632, 1.8146487, 2.4688103, 2.6976933, 1.5711815, 1.4790993
    };

    BN_gamma_2 = {
      3.8874507, 3.0725129, 2.066745, 4.0434947, 1.9653393, 3.211181, 2.6142023, 3.1286469, 2.1879268, 2.6201568, 3.161895, 3.4416137, 3.2524862, 3.1927772, 1.4550778, 2.9767017, 3.0226128, 3.2897859, 2.4582255, 3.7330735
    };

    BN_beta_1 = {
      -0.03214401, -0.017826641, -0.006731448, -0.108973525, -0.13276443, -0.19436032, -0.030348347, -0.039680682, 0.0035322276, -0.06725559, -0.010488339, -0.00033158113, -0.0026688017, -0.011627373, -0.012781152, -0.08099024, -0.011085573, -0.11863412, -0.041067734, -0.028579803, -0.022619992, -0.006052734
    };

    BN_beta_2 = {
      -0.040987484, -0.34394965, -0.12646073, -0.060817655, -0.36661655, -0.2835196, -0.2595263, -0.16734116, -0.43927372, -0.069007725, -0.28951633, -0.32839495, -0.39993453, -0.3611426, -0.13448071, -0.08340715, -0.23299143, -0.13577849, -0.16624917, -0.29113066
    };
    
    mean = {
      98350.65210813307,66513.09573882757,98282.67381778109,67819.86232621982,22151.44820764074,68132.90517306661,97974.82369675123,66440.9355038745,98456.05967028829
    };

    stdev = {
      764827.6667799093,662547.7091349724,759845.821161109,662641.7707570207,577000.1769705102,661275.5518843866,761880.3867064698,662573.1792941819,763072.9205731258
    };
  }

  else { // QP=22 and Default
    
    embs0 = {{
      {{0.15673539,-0.085407495,0.022961766,-0.13818875}},
      {{-0.0011599616,0.003081343,-0.2067934,0.012520848}},
      {{0.00049574417,-0.002942818,-0.20462793,-0.0031240385}},
      {{0.07075531,0.046935905,-0.20908102,0.008978276}},
      {{-0.0061136954,-0.001806236,-0.20200588,-0.021341009}},
      {{0.09920207,0.070386164,-0.20872961,-0.00042727523}},
      {{-0.0003080616,0.029550672,-0.20098956,-0.032917973}},
      {{-0.05018766,0.09640975,-0.199245,-0.04962535}}
    }};

    embs1 = {{
      {{0.10865566,-0.17074227,-0.30583182,-0.009175867}},
      {{0.0017460139,-0.014247787,0.00089064665,0.0026367018}},
      {{0.0013326356,0.0032478715,-0.00037306247,-0.0023784966}},
      {{-0.043785404,-0.029613934,0.0013666613,-0.0040698643}},
      {{0.000801291,0.024774976,0.0017722734,0.0013899946}},
      {{-0.0673392,-0.032136455,-0.0061991536,0.011524255}},
      {{-0.010026949,0.035452083,0.0023257083,0.03377887}},
      {{-0.014157415,0.056768376,0.020205002,0.107257105}}
    }};

    in_h1 = {{
      {{0.00803302,-0.00054360006,0.059685417,-0.0112951435,-0.00798311,0.021182533,-0.18424904,0.016021037,-0.13966253,2.0537598,0.47712228,3.267555,0.30044106,-1.2013434,1.3326107,-0.22534117,-0.89019656}},
      {{-0.0022885303,-0.022481853,0.3533015,-0.00532789,-0.017800713,0.044936586,-0.018594945,-0.014924847,0.05262798,-0.10108809,0.027190162,0.0888511,-4.5964584,0.0661767,0.059560288,0.07379748,0.33771104}},
      {{-0.0019229152,-0.005221303,-0.15469895,-0.01342464,-0.0036359474,-0.0073484676,0.0040619317,-0.0034122556,-0.7778222,-0.120815314,1.2051531,1.0159334,0.05799068,-0.41346538,2.0996823,-0.11905257,-1.2032654}},
      {{0.11005631,-0.13541275,-0.20495327,-0.10486376,-0.21109541,0.079186805,-0.09011634,-0.16646488,0.00013993743,1.4732792,0.3744819,1.5129858,-2.9935884,-0.13244767,0.32269892,-0.51221687,0.021238705}},
      {{0.0636282,-0.024780089,0.008050152,0.08529095,0.0496597,-0.069472186,-0.043008994,-0.036127806,-0.34195888,-0.70808715,-0.43780836,-0.29052198,-2.9972312,-0.9729295,-0.016077619,0.4279237,0.33739036}},
      {{-0.49648744,0.18780541,0.49167386,1.7209737,0.3276887,-1.344518,-0.11126289,0.5507871,0.7344367,-0.93451524,-0.2010796,-1.4192888,-1.1132559,1.6844447,-0.11403819,0.5100292,3.006281}},
      {{-0.008132828,-0.024925303,-0.12098992,0.055247523,-0.0051739197,-0.012712202,0.02948049,-0.05138905,1.301688,-0.43620571,0.9782555,-3.1559258,0.022731066,-0.5473841,-0.22258866,-0.26902682,-2.712682}},
      {{0.0426186,0.006380221,0.7918151,-0.020337177,-0.075094365,0.10906352,-0.16320881,0.0077959234,-1.1936448,-0.50302064,-0.95577484,-1.5306808,1.5337261,-1.4937962,-0.7706565,-0.20493785,-1.9723362}},
      {{0.035380308,0.1859633,-0.29406565,-0.6317853,-0.3337396,0.56435317,-0.6661538,0.18196033,0.43772054,-1.4116422,1.1176918,2.1505702,-4.182833,-0.04223873,1.8261942,0.6390983,0.71368563}},
      {{-0.19867499,-0.12232925,-0.54851836,1.1320634,0.57052135,-1.0661206,0.3897168,-0.017610252,-0.28535333,0.2759042,0.757143,-0.5952605,-0.06608486,0.0017118464,1.5261079,0.39017576,-2.705424}},
      {{0.009204151,0.018157925,0.5947243,0.06523658,-0.010133996,0.015552811,-0.005999643,0.0048263837,0.03096995,0.6556003,-0.13514443,0.29500076,1.2527533,0.38607866,-0.5578442,-1.8832463,-1.2016255}},
      {{0.07099118,-0.025470775,1.7686945,0.2241051,-0.0046021696,-0.06420468,0.21967213,-0.0050655813,-0.052768067,-3.623146,0.5265564,3.4483333,-0.3732669,0.12665902,1.7242901,-0.5236077,0.14641143}},
      {{-0.026481314,0.0344082,0.31881514,-0.0009290997,-0.0101627465,0.04231693,0.103593074,0.00699392,0.42085025,1.3412186,0.8653262,0.24068771,-2.7492337,-0.84734493,-0.40178925,-1.1318051,-0.4022427}},
      {{-0.018575663,-0.014420356,0.2814823,-0.03262234,0.03159627,0.067538634,0.0077271536,-0.003627977,-1.148859,-0.60281885,-0.7153834,-1.3625091,-2.4992306,-0.59071666,-0.76985466,-1.5262146,-0.82995695}},
      {{0.019076668,-0.011418952,0.07755684,-0.007414439,-0.022534195,0.01798548,-0.20734736,0.012272345,0.6969663,7.616888,0.35164988,-3.5840669,-0.46367475,0.7731998,0.4993098,-0.692916,0.23637818}},
      {{0.0013978962,0.0023415745,-0.095360346,-0.02632634,-0.009584034,0.020255256,-0.10102414,0.0064892014,-0.011072796,-12.858321,-0.08348401,0.39431763,-0.0543364,0.1684212,0.21204737,0.16765164,0.2864328}},
      {{-0.0124093685,0.08406624,-0.5987939,-0.37245622,-0.08113107,0.34393921,-0.1332661,-0.0008016445,-0.2757181,-0.7014317,0.27621815,-0.9325752,-0.40946013,-0.111347586,2.7213855,1.2892452,-0.88648504}},
      {{-0.055096462,0.0237022,0.00077092374,0.22377028,0.13800308,-0.19086705,-0.018671624,0.045306176,1.1366042,-0.2631337,0.6880618,0.51394033,-1.3066113,-0.82076067,-1.0437051,0.8152742,2.269064}},
      {{0.000666817,-0.0060559153,-0.14238885,-0.03118353,-0.02233375,0.016047915,-0.016749326,-0.008803719,0.81733805,-0.80074555,-0.9965792,4.031995,0.8602476,-1.8473322,1.1645154,-0.09868058,-0.36559963}},
      {{-0.015666064,0.0053141774,-0.4491932,-0.048101407,0.031914093,0.026097447,-0.0447348,-0.01988203,0.5731849,3.2451735,0.020608783,3.9794865,-0.07921921,-0.47084555,1.090807,-0.5893946,0.028009793}},
      {{-0.044257738,0.016667128,0.44235155,0.18401712,-0.16872962,-0.020765409,-0.21170974,-0.27191868,0.14685947,4.2444553,-0.75934094,-1.9258724,-0.48619163,-0.810224,-1.787251,2.1155186,0.90892357}},
      {{-0.033987954,0.07265973,-0.08656028,-0.12559319,-0.06481294,0.09134958,0.051211815,0.06588427,0.12408817,-0.0021105101,-0.23419125,1.0379661,-3.4163754,0.5285173,0.7079537,0.14843336,-0.3783371}}
    }};

    h1_h2 = {{
      {{-0.95703894,-2.1681664,-0.27711987,-0.25447083,-0.05307122,-1.1458586,-0.86722094,1.5924201,-0.18514559,-0.0585629,-1.9347187,-0.39605302,-1.3676469,3.7666135,0.75879574,2.5119102,-0.00812112,1.9457875,0.25352287,-0.3838241,0.93881184,0.41936412}},
      {{-1.2032682,-0.36261967,-0.39481828,-0.7923726,-3.080912,-0.91783214,-1.1893305,-0.36146072,-1.4565741,-0.6457757,0.76371586,-0.19047901,-0.5893512,-1.9901935,-1.3864712,-2.368479,-1.322665,1.7062995,-0.8327173,1.8432027,0.82416683,-0.2854442}},
      {{0.36576885,2.0285115,-0.2846673,0.0048993956,1.3074669,-0.28465357,-0.82432234,-0.08545807,-0.59509736,0.020862484,-1.4174858,-0.08693486,0.046824854,-0.9329949,0.45853028,-4.454807,0.46461296,1.4026234,0.09544895,-0.36767766,0.77201605,0.6027541}},
      {{-2.9051995,-4.0694027,0.053709537,-1.2641561,-0.95795393,-0.81721324,-1.209707,0.4873905,-0.5788815,0.42886224,0.24052072,-0.36656815,-2.4172559,-5.2862163,0.4783725,4.4394727,-0.40148664,-0.24728297,1.8739364,-1.0407399,0.8216278,-5.14159}},
      {{-1.2858765,0.28827965,0.23826174,-0.79408306,-0.20083903,-0.71370065,-0.18127173,-1.5437665,0.27214012,-0.8766926,-2.2753515,-3.6645708,-0.6841919,1.6591734,1.256203,-5.8177423,-0.62220526,0.2872689,-0.28195423,-3.1758761,0.5025576,-2.4054983}},
      {{0.25157085,-0.98455733,0.013000604,-0.12649101,-0.94446886,-0.5143771,-1.1082222,0.73296195,-0.6436137,-0.074178085,-0.64378107,-0.44999143,-0.61105156,1.1585348,1.8036454,-6.60027,-0.37805,0.3933129,-0.08638813,0.8111229,0.5528126,0.04991062}},
      {{0.5100461,2.3313785,-0.9011087,-1.00617,0.25774008,-1.6050351,-1.2838492,-1.098194,-1.8468816,0.40537614,-4.7604494,-0.5012951,-0.40661287,-4.2524643,0.1913533,-5.069958,0.18199147,1.1797166,0.17481408,-0.6424741,0.90289927,-0.42616782}},
      {{-0.94965076,4.2918053,1.3794054,-0.13094752,1.2580633,-1.0856603,-0.6797902,-2.8935812,0.5907638,-0.5289268,0.20250638,-1.0825554,0.3952517,1.5020393,0.33570713,3.8515067,-2.3463821,-0.6779375,-0.10170252,1.4177046,1.7636461,-0.0850669}},
      {{1.3958852,1.7122592,-0.26977095,-3.9133618,0.66367924,0.029914573,-0.5563429,1.4620246,-0.23470539,-0.27294776,0.045096736,-1.0797324,-1.4003344,-0.18924789,-0.6821327,-3.1376824,0.5807022,0.062025826,0.35260808,0.08752914,0.56129074,-2.514456}},
      {{-0.080239676,6.308614,-0.13230273,-1.3231372,0.6445801,-0.2970244,0.00062125496,-2.0540583,0.30368713,1.576855,-1.0189048,-1.4029796,0.024190404,1.6160631,-0.42314088,-0.8721369,-0.46251282,-0.26331154,0.021190025,0.059829485,0.7478738,1.1234514}},
      {{1.2964479,-0.9515662,-0.07256126,-1.3682799,0.4624261,-0.74922603,-0.6816584,-0.07139967,-3.657284,1.4340336,-5.2282195,0.10636258,-1.45743,4.558155,-0.8891372,-1.755573,0.5605917,-0.5409717,-0.92507714,0.11501525,1.7028973,-0.37171417}},
      {{-2.5209744,-1.7713337,-2.3280225,-1.0475572,-0.38557258,-1.0730953,-0.092274085,-1.0482813,-0.7968686,-0.8251793,1.8470533,-1.6402535,-0.47204128,2.6602082,2.5269306,1.0033516,-1.9530864,0.90232307,-3.9954836,-1.1110775,0.32388446,-1.5878007}},
      {{-8.016755,-0.72919154,-1.0048395,1.5594891,-0.5791302,-0.086455144,-0.53170156,1.2752656,-0.7969515,0.4933107,-0.6320648,-0.73282826,-0.37477326,-3.7520702,1.9121236,-2.7838683,0.18038334,-0.4985407,-0.6591523,0.17585844,0.4380405,1.430163}},
      {{-1.2218479,-1.9530879,-0.053088263,-1.5351299,-1.6755654,-0.3945512,-0.46337432,3.4086208,-0.77109605,0.38162476,-0.89025986,-0.60774827,-0.31584084,-6.3382483,0.8557095,-0.66661566,1.0130191,-0.22744888,-9.714669,-0.6066756,0.5404675,-0.6343125}},
      {{2.0169878,-4.6994753,-0.29231685,1.446847,0.24691461,-0.08646836,-0.0059228037,6.104922,0.20852467,1.0059742,-3.4967399,-0.4070733,0.31504855,0.8719819,-3.047912,-1.0781119,0.028272491,-1.5917574,-0.14560848,-0.11829329,-0.1668679,-1.6118301}},
      {{-2.0498724,0.40425795,-11.084431,-1.3470467,-0.269352,-0.22765873,-0.8448161,-0.15053487,-0.5546743,-0.5257474,-2.955041,-0.79499376,-0.23186125,-5.4691677,-0.4606373,1.3614345,-1.8198705,0.9613621,0.22248605,0.0018570364,0.42033407,-0.18018366}},
      {{0.7275422,-4.0190654,-0.061085466,-2.3318486,-1.5548036,-1.3204732,-0.29394847,0.556521,-0.60255283,-1.042624,-5.0791354,0.09524977,-0.45912978,-5.7546654,-2.627711,3.775242,-1.0250341,2.1289968,-0.66152483,-1.0130297,0.88298035,-3.4568205}},
      {{1.3053503,-1.5704415,-0.5611502,-0.68853813,-0.3619735,-1.99415,-1.5705466,0.052289303,-1.0459894,-0.11335271,0.34473294,-0.7105479,-1.3692107,-1.9132794,1.6301956,-6.9035926,-1.0239563,0.2571539,-0.38754395,0.5197051,0.18598048,-1.7479429}},
      {{0.9247709,-2.6440265,-0.24069348,0.09134501,-1.2441005,-0.48490745,-0.21337593,0.46329477,-0.3417568,0.8071764,0.019002821,0.14823471,-0.5427223,-12.074512,0.34009725,-1.3776911,-0.30533627,-0.10548234,-0.18401816,0.24570842,-0.059615687,0.2699794}},
      {{-1.8913933,-0.0030526232,-0.34422857,-4.936409,-0.21791328,-0.7181097,-0.27191636,-5.1266556,-1.3869876,0.049687594,-0.79058456,0.57470256,-0.7774934,0.8903043,0.23346949,1.2530065,-0.079864174,0.23068114,-0.51942027,0.3309098,0.49458677,0.9797681}}
    }};

    h2_out = {{
      {{-4.83649,-4.4916,-2.5872297,1.1946914,2.4725037,-1.9750022,-2.684583,0.25528762,0.68302304,-3.228468,0.46689186,-2.0544634,-0.77776164,2.5500152,0.6499,-3.0238612,1.522716,-3.3202436,1.3554778,-2.8316772}},
      {{-2.7630277,-1.8848602,-4.4011464,2.3711078,-0.22451414,-3.1362996,-5.19247,-1.0707664,-0.8092087,-4.5207515,0.8373572,-1.0333248,-1.2118949,2.3412068,0.8101377,-3.1940587,0.63177615,-5.3039937,1.5953317,-0.5232603}},
      {{-0.24251541,-0.6499671,-5.6839566,1.0800095,-2.3603523,-4.6720166,-5.0134544,-1.2296879,-0.8014973,-5.3131046,0.56093466,-0.3780966,-0.2986135,0.90719324,0.7292005,-2.5914748,1.2669976,-4.765247,1.335486,0.5903923}},
      {{-0.21308571,0.19109382,-1.7061783,0.23776112,-3.077663,-4.8392653,-4.613907,-1.6748035,-1.087623,-0.8683038,0.059511654,0.5542025,0.11942456,-0.67116636,-0.9016118,0.24136484,0.66704077,-2.6510115,0.54563487,0.49192825}},
      {{1.2354593,0.6666287,-6.0967693,0.5544033,-2.528676,-4.419211,-4.8514977,-1.1182197,-0.1525097,-4.87499,-1.0214192,0.5285201,-0.19615239,-1.9732196,0.54806286,2.953898,0.9351559,-4.4308414,0.62762094,0.17141898}},
      {{1.1591043,0.9538519,-4.1474996,1.9373076,-2.4608715,-1.7718792,-3.6988258,-0.39073023,0.5330193,-3.7520647,-3.1172073,0.100556366,-0.36301148,-2.7955453,0.7890767,3.4399798,1.0085235,-3.798446,-0.59055924,-0.9144896}},
      {{-0.21470979,0.24383703,-1.8762488,1.5292308,0.98999864,-1.1300777,-1.7476294,1.803607,1.3627864,-0.8543608,-4.8279204,-0.6194182,0.044807743,-2.8122761,-0.19773763,4.0314593,1.1978287,-2.532247,-1.6768231,-3.223758}},
      {{-1.6512622,-5.6137605,-0.44157442,0.8637958,4.2305684,-1.3004602,-0.7194933,3.245705,0.5690669,-4.507377,0.39652264,-3.0947719,-1.2137359,3.0657094,0.5329072,-2.7414541,1.2267188,-3.4537227,1.2204654,-2.8976212}},
      {{-0.54800916,-4.4813232,-1.5896388,1.9168786,1.8422184,-1.87432,-2.2575667,-0.21813895,-0.58019197,2.3179226,0.7839238,-0.969771,-1.0084171,3.0190434,-0.53259313,-2.4579158,0.8401455,-5.584399,0.11881021,-1.3713894}},
      {{1.1603856,-1.270921,-2.3490193,1.0987092,-0.13995068,-4.3627048,-3.5010817,0.8151751,-1.7422967,1.6242583,0.70572793,-0.3839683,-0.41938165,1.4944264,-0.14035648,-1.4844642,1.3080534,-6.3430586,0.4034363,0.5097264}},
      {{1.4897739,0.04275746,-1.9584385,-0.24283087,-2.49391,-4.2462234,-3.51844,-1.5907704,-0.5174483,1.1967939,0.552473,0.5359781,-0.23534574,-0.43756196,-1.4254225,0.45693663,1.703742,-5.778554,-0.43296918,0.5363518}},
      {{1.6776135,0.77816254,-2.1104605,1.3178924,-2.3877637,-3.5139964,-2.7628846,0.69792324,-0.8472278,1.4518325,-0.17132485,0.025776837,-0.78123945,-2.3030233,0.013284109,1.8397518,1.9562881,-5.847279,-0.28250524,-0.037223812}},
      {{1.547672,0.7818841,-1.082118,1.8937967,-1.5675074,-1.3737979,-1.2863181,0.5788609,1.0202136,-2.1835206,-2.4945166,-0.7619382,-0.8186334,-2.9828753,-0.6297761,2.94116,1.7152269,-4.211787,-1.2985251,-2.0394597}},
      {{1.0644224,-1.281349,-0.03441195,1.1234764,2.1081738,-0.027332129,0.07497062,2.9696527,1.9779257,-3.9316962,-3.8239086,-1.9750137,-0.50652546,-3.3399444,-0.36484072,3.8663447,1.9405476,-2.2028165,-1.411287,-4.386104}},
      {{-1.336236,-5.069253,0.13698323,0.18581744,5.1997094,-0.8082954,1.0518613,2.9415262,0.33108407,-5.0960593,0.13394399,-2.2705767,-0.19527493,2.8875914,0.7986528,-1.8670268,0.4337785,-1.2269713,0.64238775,-3.703343}},
      {{0.3161351,-5.004266,-0.11372768,1.122815,3.2943373,-0.8503831,0.7930328,1.8097886,-1.1041996,-0.5743255,0.17534415,-0.38961253,0.4626918,3.0600452,1.1771333,-1.6725082,-0.110851295,-2.5879824,0.1039791,-1.7591314}},
      {{0.8014062,-1.491673,0.1428398,0.06403737,-0.46041238,-1.9215144,0.47709984,0.2215261,-2.3626926,-2.3336122,0.5376833,0.15239316,0.2888717,1.5469131,0.16938438,-0.8307809,0.45353168,-3.777442,0.20513618,0.53881633}},
      {{0.8902287,0.07276962,0.23746221,-1.1791953,-2.8083746,-2.8461864,0.28619003,-1.4803644,-1.3194238,-0.6148018,0.59572786,0.31347325,0.03485959,-0.0053218403,-0.39272392,0.17807674,1.007197,-3.0639422,-0.44655243,0.5449034}},
      {{0.9734161,0.8200909,0.35540363,-0.13046968,-2.9387913,-1.4268405,0.48122054,0.09060356,-1.1956828,-1.5617796,0.220622,-0.2872443,-0.60404795,-2.4516149,-0.3004386,0.64447755,1.7033261,-2.756003,0.09256744,-0.014735088}},
      {{1.1610925,0.82928246,0.35620543,0.91694826,-1.1549438,-0.56153184,0.98283243,2.2862961,2.0912595,-4.098039,-1.1509205,-3.1704652,-1.9147987,-3.6193936,0.6035001,1.2805138,1.7527814,-1.1327786,-0.0052111163,-2.9914634}},
      {{0.7347654,-0.5084882,0.279689,0.020220337,2.5502648,0.05568311,1.3804563,3.3029175,2.301024,-4.509568,-2.6704006,-3.9502745,-0.76639384,-3.3992841,-0.3620547,1.9347711,1.5053545,0.28714323,-0.66658723,-4.258985}},
      {{-0.48965633,-2.0926049,0.57466555,-0.3930883,3.9634702,-0.27939552,1.312788,4.6444535,0.13245492,0.42222345,-1.0974633,-0.47713086,0.5411523,0.8833068,0.5377257,-0.12534359,-0.7501273,-0.8455665,-0.34295678,-2.5361512}},
      {{0.37365705,-4.000365,0.47165674,0.50551593,3.6968734,-0.056220863,1.2788996,1.5861976,-0.54459053,1.323208,-0.18895392,0.6502334,1.188369,2.1181526,-0.959484,-0.18964483,-1.8509073,-0.28893477,-1.157542,-2.0123281}},
      {{0.26616874,-1.4616452,0.5878247,-0.80615157,0.30599397,-0.20676784,1.2162788,2.2131414,-1.4232271,0.5904186,0.28553933,0.35633,1.1258684,1.0944198,1.781227,0.026159488,-1.2379866,-0.92766106,-0.25362134,0.31498834}},
      {{-0.14242661,0.20135218,0.6538785,-2.4431725,-2.005364,-0.16546951,1.26782,-1.5734994,0.65329105,3.9059393,0.6518527,0.22345228,0.3410036,-0.3585391,-3.3732734,-0.3264493,-0.9394905,-1.3264627,-2.5937622,0.5171551}},
      {{0.15633781,0.78131825,0.61036414,-1.658517,-2.397352,-0.20566516,1.1588264,1.6698369,-0.03466987,0.45926845,0.6473706,-1.3129967,-0.91550946,-1.8802257,0.3677179,-0.1719077,0.5794654,-0.2039155,0.35172662,0.046297744}},
      {{0.1068029,0.73760027,0.6082242,-0.17113194,-0.72493106,-0.31080303,1.1815437,2.3619199,2.2961485,0.27862656,0.49015227,-3.4472535,-2.3245914,-2.9282162,-0.40769956,-0.44711775,0.71308553,0.59003484,0.7546009,-2.8412273}},
      {{-0.1871876,-0.7440396,0.6103818,0.084339276,1.7985096,-0.1969396,1.1638539,4.135727,1.3380427,0.60501665,0.008003185,-3.2875168,-1.2393547,-2.0881765,-0.14084081,-0.3732391,0.23542413,0.36876753,-0.20791957,-2.9496799}},
      {{-0.19855864,-2.5532534,0.5687308,-1.2981708,5.6080666,0.1440742,0.8469824,3.988567,0.6366089,-4.7021055,-3.5710878,1.1604632,0.568117,-0.42408133,0.7572862,1.5604993,-0.70286596,1.3070396,0.213877,-3.283189}},
      {{0.5316991,-2.9391065,0.33788076,0.21673134,3.8204865,0.53916544,0.37544253,1.2180014,-1.0653479,0.5156569,-1.4746585,1.152745,1.2724959,1.1213558,1.2311002,1.0379629,-2.0030715,1.8687143,-0.75777644,-2.109721}},
      {{0.03849842,-0.8937177,0.37384444,-0.41443977,0.5339558,0.6712128,0.43186924,0.56319493,-2.1711702,-1.0315478,-0.4999241,0.51676315,1.0912598,0.48792228,1.4122233,0.6043931,-1.9164683,1.953831,-0.035491623,0.31170708}},
      {{-1.0198948,0.1604417,0.453485,-1.2508779,-2.2526524,0.6969191,0.520744,-1.5026228,-0.9368432,-1.1350956,0.3059374,0.10390797,0.32980555,-0.2784573,1.2034498,-0.18358307,-1.2695564,1.8586906,-0.22996095,0.5268637}},
      {{-0.960808,0.5996393,0.3137043,-0.6304368,-2.444686,0.50359666,0.2586566,0.17463732,-0.6193558,-2.0026088,0.64742434,-1.591433,-1.2439486,-1.0565794,1.8975679,-1.3985212,-0.33225015,2.1561897,1.0592407,0.10788427}},
      {{-1.9589001,0.4114312,0.4346085,-0.08598794,-0.59097487,0.1332182,0.11534334,3.1811512,1.7121607,-3.9110653,0.6485041,-3.93634,-2.7517965,-2.4951708,1.2477766,-2.3744793,0.5757978,1.7584302,2.1104813,-2.0620193}},
      {{-2.8087208,-1.936615,0.44992995,0.04041991,1.83269,-0.024014212,0.546569,4.299743,2.0779204,-4.481505,0.58270955,-5.3898816,-2.0252736,-1.5476087,0.4415134,-2.85736,0.8784888,1.7582922,1.4710219,-2.9956472}},
      {{0.047635864,-1.3171517,0.36841297,-1.5166495,4.8066826,0.60527027,-0.65604156,3.314072,0.8071784,-3.3166804,-4.783312,1.1307999,0.79091483,-0.99616116,1.3116652,2.598851,-0.6852573,2.7761936,-0.2832346,-3.3174722}},
      {{0.17049156,-0.91128224,-0.09121475,0.4158304,2.6242588,0.8044939,-1.2308713,1.7754923,-0.20698771,-1.4795527,-3.5356598,1.2191279,1.2388064,0.1509562,1.2031049,2.0572674,-2.6574938,3.2470489,-0.8736765,-1.7228297}},
      {{-0.98731947,-0.039116684,-0.70640045,-0.08209593,0.078728534,1.1549212,-2.0512242,2.3014383,-0.8336815,-2.995139,-2.3434284,0.9033691,0.95929605,-0.48027068,2.6417198,0.77904063,-2.6679263,3.552967,0.16954859,0.1835589}},
      {{-2.1527162,0.15602255,-0.92435765,-0.87081426,-2.0159817,1.3388869,-3.14673,-1.7118118,-0.2546303,-2.0245087,-0.42138925,0.012696649,0.2009325,-0.53618425,-0.28690752,-0.35405144,-2.70157,3.7212827,0.7371844,0.49346367}},
      {{-2.8380196,0.24432692,-1.3563486,-0.6607713,-2.2535193,1.1957839,-3.3625135,1.371301,-0.1743061,-3.7446706,0.43769825,-1.7129841,-0.8279355,-0.89222133,3.2174563,-2.6833951,-1.1744863,3.5730152,2.1607177,0.16549492}},
      {{-3.1771996,-0.009122173,-0.6960562,-0.31938213,-0.71464705,0.69883454,-2.942241,1.8073181,1.2624168,-0.7252239,0.85677373,-4.0254083,-2.3104243,-0.84898496,1.5939057,-3.536976,-0.3661262,2.7736435,2.8029432,-1.0305933}},
      {{-3.3680089,-2.3551505,-0.09059942,0.036690515,1.4584198,0.4913041,-1.2892976,4.2030897,1.9420466,-3.2297287,0.75987804,-5.515302,-2.0772917,-0.30288634,1.5240737,-4.0170193,0.36830366,2.5875587,1.9923552,-2.3467925}},
      {{-0.9860315,-0.2858764,-0.84147674,-0.046358753,3.2715073,0.2177276,-1.556786,1.9062886,0.45179045,-0.3569417,-5.964219,0.85791814,1.077331,-0.6629401,0.9363789,2.9384942,-0.62370515,1.8710395,-1.1916009,-2.971535}},
      {{-0.1992996,0.12398565,-1.7638439,0.9659792,0.60120475,0.7483315,-2.5485554,0.8670824,-0.42372206,-2.7125764,-4.3852425,1.3741369,0.99552035,-0.1670359,2.400609,2.3106284,-2.0844715,2.133776,-0.8169024,-1.0860333}},
      {{-1.6840112,0.45412055,-2.1072419,0.2826045,-1.0767493,0.9489321,-5.102198,0.03147147,0.16710116,-3.9258912,-4.913529,1.2675836,0.59434664,-0.72066224,1.7857544,1.6395675,-2.2830603,3.0196772,-0.17533815,0.25640443}},
      {{-2.4634037,0.17679918,-1.5007807,0.023964815,-2.9396117,0.26006198,-5.1795063,-1.6739107,-0.36926058,-1.2086321,-1.2879663,0.41559082,0.0035403382,-1.0979732,0.35248393,-0.7670688,-1.4462384,1.9474788,0.7445719,0.49465165}},
      {{-4.068218,0.22422937,-4.6730433,0.019074589,-3.1420262,0.9758495,-7.831298,-0.983393,0.4599543,-4.775735,0.16680644,-1.6930674,-1.099538,-0.41331857,2.523418,-3.429257,-1.5661116,3.0909543,2.4502375,0.3064089}},
      {{-4.0253134,0.14417125,-3.3718214,1.010164,-2.6693752,0.68890935,-5.3213277,0.47402316,0.53923315,-2.4703224,0.8119171,-3.3501155,-2.193439,-0.28445855,2.8593285,-4.1378765,-0.3934194,1.4420046,2.818947,-0.5235871}},
      {{-5.488307,-1.8984272,-1.9410653,0.8274235,-0.16567177,0.101926036,-2.7446425,1.5457368,1.5179185,-2.192856,0.61389804,-4.533429,-1.570064,-0.012773205,1.8758982,-4.245911,0.64154834,1.6897956,1.7415413,-2.2995353}}
    }};

    b1 = {
      -0.009089184, -0.048563343, -0.023968013, -0.10972691, -0.23696963, 0.25920197, 0.03530995, -0.24603905, 0.13540234, 0.030090792, -0.0041832486, 0.47146285, -0.09093635, -0.4844414, 0.09612564, 0.024240512, 0.059220847, 0.19678721, -0.09834317, -0.015902141, 0.085849814, -0.044197045
    };

    b2 = {
      0.0594116, 0.07340035, 0.07174841, 0.020248607, 0.013690698, 0.03264762, -0.010917311, 0.031720918, 0.459117, -0.050098527, 0.18013544, 0.041336507, 0.17348741, 0.019052092, -0.034949493, 0.007457202, 0.021704042, -0.012929535, 0.088126585, 0.18914847
    };

    bout = {
      -2.359231, -1.7286592, -1.463405, -1.1916454, -1.4694695, -1.6924415, -2.357515, -1.9253132, -0.1722285, -0.36632976, 0.40245613, -0.49056587, -0.7213035, -2.2250614, -1.5453241, -0.30834836, 0.533671, 0.7833572, 0.40766707, -0.8866428, -1.6889476, -1.0575418, 0.5159542, 0.8823465, 2.51291, 0.77985764, 0.049493413, -1.1735952, -1.4389367, -0.13758428, 0.6008119, 0.95153236, 0.64361566, -0.792939, -1.7169048, -1.753878, -0.37662175, -0.533241, 0.33100322, -0.49695918, -0.4342409, -1.870033, -2.064506, -1.3279053, -1.362287, -1.0814897, -1.4567418, -1.4997239, -2.2265525
    };

    BN_gamma_in = {
      0.87941, 0.024019599, 0.69968814, 0.17900348, 0.9491728, 0.904316, 0.115897, 0.91344166, 0.10641807
    };

    BN_gamma_1 = {
      2.9204407, 5.144902, 5.5841684, -2.5824885, 6.377081, 1.6006563, 4.528056, 3.375227, -1.4203408, 1.4769131, 4.3977737, 2.6686258, 8.1096115, 11.252057, 2.657679, 3.1476588, 1.6474657, 2.191273, 4.8668947, 3.399002, -2.3555198, 2.3381839
    };

    BN_gamma_2 = {
      4.2120147, 4.050036, 3.849934, 4.6001506, 5.8996453, 5.3862553, 7.0414047, -4.038737, 1.9384124, 5.3945456, 3.5476825, 5.960166, 2.865949, 5.645224, -5.374974, 6.487847, 6.0952992, 9.965039, 3.6413982, 3.4422917
    };

    BN_beta_1 = {
      -0.009946241, -0.008921382, -0.0055301837, 0.044628657, -0.00279072, -0.0009947143, -0.0045953556, -0.013561535, 0.064755, -0.14965117, -0.007882362, -0.08235385, -9.611692e-07, -0.003983723, -0.02701153, -0.12606747, -0.13632965, -0.045420572, -0.009539404, -0.03966837, -0.00094499876, -0.0072204038
    };

    BN_beta_2 = {
      -0.24248256, -0.28900343, -0.22885437, -0.19097248, -0.22231586, -0.24171022, -0.041445896, 0.1300386, -0.8017785, -0.050471134, -0.4524779, -0.1923693, -0.461322, -0.26948288, 0.06744218, -0.20420028, -0.29321897, -0.10936939, -0.35454926, -0.5244448
    };
    
    mean = {
      98051.65911500143,65587.26015414993,98429.51536065711,66590.66496892601,18812.80411394546,67476.2684316608,97794.95941620687,65611.99789217707,98488.53991433381
    };

    stdev = {
      728896.8738250975,622548.8142916987,725791.7622679387,620531.0097650237,530931.1936739072,621147.6931487389,726227.7152519036,622997.3680329637,729148.9188032853
    };
  }
  
}


__inline Void TEncSearch::xTZSearchHelp( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const Int iSearchX, const Int iSearchY, const UChar ucPointNr, const UInt uiDistance )
{
  Distortion  uiSad = 0;

  const Pel* const  piRefSrch = rcStruct.piRefY + iSearchY * rcStruct.iYStride + iSearchX;

  //-- jclee for using the SAD function pointer
  m_pcRdCost->setDistParam( pcPatternKey, piRefSrch, rcStruct.iYStride,  m_cDistParam );

  setDistParamComp(COMPONENT_Y);

  // distortion
  m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
  m_cDistParam.m_maximumDistortionForEarlyExit = rcStruct.uiBestSad;

  if((m_pcEncCfg->getRestrictMESampling() == false) && m_pcEncCfg->getMotionEstimationSearchMethod() == MESEARCH_SELECTIVE)
  {
    Int isubShift = 0;
    // motion cost
    Distortion uiBitCost = m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

    // Skip search if bit cost is already larger than best SAD
    if (uiBitCost < rcStruct.uiBestSad)
    {
      if ( m_cDistParam.iRows > 32 )
      {
        m_cDistParam.iSubShift = 4;
      }
      else if ( m_cDistParam.iRows > 16 )
      {
        m_cDistParam.iSubShift = 3;
      }
      else if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 2;
      }
      else
      {
        m_cDistParam.iSubShift = 1;
      }

      Distortion uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
      if((uiTempSad + uiBitCost) < rcStruct.uiBestSad)
      {
        uiSad += uiTempSad >>  m_cDistParam.iSubShift;
        while(m_cDistParam.iSubShift > 0)
        {
          isubShift         = m_cDistParam.iSubShift -1;
          m_cDistParam.pOrg = pcPatternKey->getROIY() + (pcPatternKey->getPatternLStride() << isubShift);
          m_cDistParam.pCur = piRefSrch + (rcStruct.iYStride << isubShift);
          uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
          uiSad += uiTempSad >>  m_cDistParam.iSubShift;
          if(((uiSad << isubShift) + uiBitCost) > rcStruct.uiBestSad)
          {
            break;
          }

          m_cDistParam.iSubShift--;
        }

        if(m_cDistParam.iSubShift == 0)
        {
          uiSad += uiBitCost;
          if( uiSad < rcStruct.uiBestSad )
          {
            rcStruct.uiBestSad      = uiSad;
            rcStruct.iBestX         = iSearchX;
            rcStruct.iBestY         = iSearchY;
            rcStruct.uiBestDistance = uiDistance;
            rcStruct.uiBestRound    = 0;
            rcStruct.ucPointNr      = ucPointNr;
            m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
          }
        }
      }
    }
  }
  else
  {
    // fast encoder decision: use subsampled SAD when rows > 8 for integer ME
    if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE3 )
    {
      if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 1;
      }
    }

    uiSad = m_cDistParam.DistFunc( &m_cDistParam );

    // EMI: Modification "array_e & counter_i"
    array_e[counter_i] = uiSad;
    
    // only add motion cost if uiSad is smaller than best. Otherwise pointless
    // to add motion cost.
    if( uiSad < rcStruct.uiBestSad )
    {
      // motion cost
      uiSad += m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

      if( uiSad < rcStruct.uiBestSad )
      {
        rcStruct.uiBestSad      = uiSad;
        rcStruct.iBestX         = iSearchX;
        rcStruct.iBestY         = iSearchY;
        rcStruct.uiBestDistance = uiDistance;
        rcStruct.uiBestRound    = 0;
        rcStruct.ucPointNr      = ucPointNr;
        m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
      }
    }
  }
  counter_i = counter_i + 1;
}

__inline Void TEncSearch::xTZ2PointSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB )
{
  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 2 point search,                   //   1 2 3
  // check only the 2 untested points  //   4 0 5
  // around the start point            //   6 7 8
  Int iStartX = rcStruct.iBestX;
  Int iStartY = rcStruct.iBestY;
  switch( rcStruct.ucPointNr )
  {
    case 1:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY, 0, 2 );
      }
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
    }
      break;
    case 2:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 3:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
    }
      break;
    case 4:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 5:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 6:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY , 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    case 7:
    {
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 8:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    default:
    {
      assert( false );
    }
      break;
  } // switch( rcStruct.ucPointNr )
}




__inline Void TEncSearch::xTZ8PointSquareSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iTop >= iSrchRngVerTop ) // check top
  {
    if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
    }
    // top middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );

    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
    }
  } // check top
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
  }
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
  }
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
    if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
    }
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );

    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
    }
  } // check bottom
}


//additing other square search

__inline Void TEncSearch::xTZ8PointSquareSearch2( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;
// check top
  if ( iTop >= iSrchRngVerTop ) // check top
  {
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iLeft, iTop, 9, iDist);
    }
	  
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iStartX - 1, iTop, 10, iDist);
    }
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 11, iDist );
	
	if (iRight <= iSrchRngHorRight) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX +1, iTop, 12, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 13, iDist );
    }
  }

  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY-1, 14, iDist );
  }

  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY-1, 15, iDist );
  }
  
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 16, iDist );
  }
  
  
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 17, iDist );
  }
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY+1, 18, iDist );
  }
  
  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY+1, 19, iDist );
  }
  
  
  
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 20, iDist );
    }  
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iBottom, 21, iDist );
    }   
	  
	  
    
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 22, iDist );

	if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iBottom, 23, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 24, iDist );
    }
  } 
  
  // check bottom
}











__inline Void TEncSearch::xTZ8PointDiamondSearch( const TComPattern*const  pcPatternKey,
                                                  IntTZSearchStruct& rcStruct,
                                                  const TComMv*const  pcMvSrchRngLT,
                                                  const TComMv*const  pcMvSrchRngRB,
                                                  const Int iStartX,
                                                  const Int iStartY,
                                                  const Int iDist,
                                                  const Bool bCheckCornersAtDist1 )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert ( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iDist == 1 )
  {
    if ( iTop >= iSrchRngVerTop ) // check top
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
      }
    }
    if ( iLeft >= iSrchRngHorLeft ) // check middle left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
    }
    if ( iRight <= iSrchRngHorRight ) // check middle right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
    }
    if ( iBottom <= iSrchRngVerBottom ) // check bottom
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
      }
    }
  }
  else
  {
    if ( iDist <= 8 )
    {
      const Int iTop_2      = iStartY - (iDist>>1);
      const Int iBottom_2   = iStartY + (iDist>>1);
      const Int iLeft_2     = iStartX - (iDist>>1);
      const Int iRight_2    = iStartX + (iDist>>1);

      if (  iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iTop,      2, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iTop_2,    1, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2,    3, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,    iStartY,   4, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,   iStartY,   5, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iBottom_2, 6, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iBottom,   7, iDist    );
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        }
        if ( iTop_2 >= iSrchRngVerTop ) // check half top
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iTop_2, 1, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2, 3, (iDist>>1) );
          }
        } // check half top
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
        }
        if ( iBottom_2 <= iSrchRngVerBottom ) // check half bottom
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iBottom_2, 6, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, (iDist>>1) );
          }
        } // check half bottom
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        }
      } // check border
    }
    else // iDist > 8
    {
      if ( iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop,    0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,   iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,  iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
        }
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 0, iDist );
        }
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 0, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 0, iDist );
        }
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        }
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);

          if ( iPosYT >= iSrchRngVerTop ) // check top
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
            }
          } // check top
          if ( iPosYB <= iSrchRngVerBottom ) // check bottom
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
            }
          } // check bottom
        } // for ...
      } // check border
    } // iDist <= 8
  } // iDist == 1
}

Distortion TEncSearch::xPatternRefinement( TComPattern* pcPatternKey,
                                           TComMv baseRefMv,
                                           Int iFrac, TComMv& rcMvFrac,
                                           Bool bAllowUseOfHadamard
                                         )
{
  Distortion  uiDist;
  Distortion  uiDistBest  = std::numeric_limits<Distortion>::max();
  UInt        uiDirecBest = 0;

  Pel*  piRefPos;
  Int iRefStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);

  m_pcRdCost->setDistParam( pcPatternKey, m_filteredBlock[0][0].getAddr(COMPONENT_Y), iRefStride, 1, m_cDistParam, m_pcEncCfg->getUseHADME() && bAllowUseOfHadamard );

  const TComMv* pcMvRefine = (iFrac == 2 ? s_acMvRefineH : s_acMvRefineQ);

  for (UInt i = 0; i < 9; i++)
  {
    TComMv cMvTest = pcMvRefine[i];
    cMvTest += baseRefMv;

    Int horVal = cMvTest.getHor() * iFrac;
    Int verVal = cMvTest.getVer() * iFrac;
    piRefPos = m_filteredBlock[ verVal & 3 ][ horVal & 3 ].getAddr(COMPONENT_Y);
    if ( horVal == 2 && ( verVal & 1 ) == 0 )
    {
      piRefPos += 1;
    }
    if ( ( horVal & 1 ) == 0 && verVal == 2 )
    {
      piRefPos += iRefStride;
    }
    cMvTest = pcMvRefine[i];
    cMvTest += rcMvFrac;

    setDistParamComp(COMPONENT_Y);

    m_cDistParam.pCur = piRefPos;
    m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
    uiDist = m_cDistParam.DistFunc( &m_cDistParam );
    uiDist += m_pcRdCost->getCostOfVectorWithPredictor( cMvTest.getHor(), cMvTest.getVer() );

    if ( uiDist < uiDistBest )
    {
      uiDistBest  = uiDist;
      uiDirecBest = i;
      m_cDistParam.m_maximumDistortionForEarlyExit = uiDist;
    }
  }

  rcMvFrac = pcMvRefine[uiDirecBest];

  return uiDistBest;
}



Void
TEncSearch::xEncSubdivCbfQT(TComTU      &rTu,
                            Bool         bLuma,
                            Bool         bChroma )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx         = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth            = rTu.GetTransformDepthRel();
  const UInt uiTrMode             = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt uiSubdiv             = ( uiTrMode > uiTrDepth ? 1 : 0 );
  const UInt uiLog2LumaTrafoSize  = rTu.GetLog2LumaTrSize();

  if( pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_NxN && uiTrDepth == 0 )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize > pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getSlice()->getSPS()->getQuadtreeTULog2MinSize() )
  {
    assert( !uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
  {
    assert( !uiSubdiv );
  }
  else
  {
    assert( uiLog2LumaTrafoSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );
    if( bLuma )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( uiSubdiv, 5 - uiLog2LumaTrafoSize );
    }
  }

  if ( bChroma )
  {
    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if( rTu.ProcessingAllQuadrants(compID) && (uiTrDepth==0 || pcCU->getCbf( uiAbsPartIdx, compID, uiTrDepth-1 ) ))
      {
        m_pcEntropyCoder->encodeQtCbf(rTu, compID, (uiSubdiv == 0));
      }
    }
  }

  if( uiSubdiv )
  {
    TComTURecurse tuRecurse(rTu, false);
    do
    {
      xEncSubdivCbfQT( tuRecurse, bLuma, bChroma );
    } while (tuRecurse.nextSection(rTu));
  }
  else
  {
    //===== Cbfs =====
    if( bLuma )
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }
}




Void
TEncSearch::xEncCoeffQT(TComTU &rTu,
                        const ComponentID  component,
                        Bool         bRealCoeff )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();

  const UInt  uiTrMode        = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt  uiSubdiv        = ( uiTrMode > uiTrDepth ? 1 : 0 );

  if( uiSubdiv )
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xEncCoeffQT( tuRecurseChild, component, bRealCoeff );
    } while (tuRecurseChild.nextSection(rTu) );
  }
  else if (rTu.ProcessComponentSection(component))
  {
    //===== coefficients =====
    const UInt  uiLog2TrafoSize = rTu.GetLog2LumaTrSize();
    UInt    uiCoeffOffset   = rTu.getCoefficientOffset(component);
    UInt    uiQTLayer       = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrafoSize;
    TCoeff* pcCoeff         = bRealCoeff ? pcCU->getCoeff(component) : m_ppcQTTempCoeff[component][uiQTLayer];

    if (isChroma(component) && (pcCU->getCbf( rTu.GetAbsPartIdxTU(), COMPONENT_Y, uiTrMode ) != 0) && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag() )
    {
      m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, component );
    }

    m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeff+uiCoeffOffset, component );
  }
}




Void
TEncSearch::xEncIntraHeader( TComDataCU*  pcCU,
                            UInt         uiTrDepth,
                            UInt         uiAbsPartIdx,
                            Bool         bLuma,
                            Bool         bChroma )
{
  if( bLuma )
  {
    // CU header
    if( uiAbsPartIdx == 0 )
    {
      if( !pcCU->getSlice()->isIntra() )
      {
        if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
        {
          m_pcEntropyCoder->encodeCUTransquantBypassFlag( pcCU, 0, true );
        }
        m_pcEntropyCoder->encodeSkipFlag( pcCU, 0, true );
        m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
      }
      m_pcEntropyCoder  ->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );

      if (pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_2Nx2N )
      {
        m_pcEntropyCoder->encodeIPCMInfo( pcCU, 0, true );

        if ( pcCU->getIPCMFlag (0))
        {
          return;
        }
      }
    }
    // luma prediction mode
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N )
    {
      if (uiAbsPartIdx==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, 0 );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      if (uiTrDepth>0 && (uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiAbsPartIdx );
      }
    }
  }

  if( bChroma )
  {
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N || !enable4ChromaPUsInIntraNxNCU(pcCU->getPic()->getChromaFormat()))
    {
      if(uiAbsPartIdx==0)
      {
         m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      assert(uiTrDepth>0);
      if ((uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
  }
}




UInt
TEncSearch::xGetIntraBitsQT(TComTU &rTu,
                            Bool         bLuma,
                            Bool         bChroma,
                            Bool         bRealCoeff /* just for test */ )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();
  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiTrDepth, uiAbsPartIdx, bLuma, bChroma );
  xEncSubdivCbfQT ( rTu, bLuma, bChroma );

  if( bLuma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Y,      bRealCoeff );
  }
  if( bChroma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Cb,  bRealCoeff );
    xEncCoeffQT   ( rTu, COMPONENT_Cr,  bRealCoeff );
  }
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  return uiBits;
}

UInt TEncSearch::xGetIntraBitsQTChroma(TComTU &rTu,
                                       ComponentID compID,
                                       Bool         bRealCoeff /* just for test */ )
{
  m_pcEntropyCoder->resetBits();
  xEncCoeffQT   ( rTu, compID,  bRealCoeff );
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  return uiBits;
}

Void TEncSearch::xIntraCodingTUBlock(       TComYuv*    pcOrgYuv,
                                            TComYuv*    pcPredYuv,
                                            TComYuv*    pcResiYuv,
                                            Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      const Bool        checkCrossCPrediction,
                                            Distortion& ruiDist,
                                      const ComponentID compID,
                                            TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug)
                                           ,Int         default0Save1Load2
                                     )
{
  if (!rTu.ProcessComponentSection(compID))
  {
    return;
  }
  const Bool           bIsLuma          = isLuma(compID);
  const TComRectangle &rect             = rTu.getRect(compID);
        TComDataCU    *pcCU             = rTu.getCU();
  const UInt           uiAbsPartIdx     = rTu.GetAbsPartIdxTU();
  const TComSPS       &sps              = *(pcCU->getSlice()->getSPS());

  const UInt           uiTrDepth        = rTu.GetTransformDepthRelAdj(compID);
  const UInt           uiFullDepth      = rTu.GetTransformDepthTotal();
  const UInt           uiLog2TrSize     = rTu.GetLog2LumaTrSize();
  const ChromaFormat   chFmt            = pcOrgYuv->getChromaFormat();
  const ChannelType    chType           = toChannelType(compID);
  const Int            bitDepth         = sps.getBitDepth(chType);

  const UInt           uiWidth          = rect.width;
  const UInt           uiHeight         = rect.height;
  const UInt           uiStride         = pcOrgYuv ->getStride (compID);
        Pel           *piOrg            = pcOrgYuv ->getAddr( compID, uiAbsPartIdx );
        Pel           *piPred           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piResi           = pcResiYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piReco           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
  const UInt           uiQTLayer        = sps.getQuadtreeTULog2MaxSize() - uiLog2TrSize;
        Pel           *piRecQt          = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
  const UInt           uiRecQtStride    = m_pcQTTempTComYuv[ uiQTLayer ].getStride(compID);
  const UInt           uiZOrder         = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
        Pel           *piRecIPred       = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
        UInt           uiRecIPredStride = pcCU->getPic()->getPicYuvRec()->getStride  ( compID );
        TCoeff        *pcCoeff          = m_ppcQTTempCoeff[compID][uiQTLayer] + rTu.getCoefficientOffset(compID);
        Bool           useTransformSkip = pcCU->getTransformSkip(uiAbsPartIdx, compID);

#if ADAPTIVE_QP_SELECTION
        TCoeff        *pcArlCoeff       = m_ppcQTTempArlCoeff[compID][ uiQTLayer ] + rTu.getCoefficientOffset(compID);
#endif

  const UInt           uiChPredMode     = pcCU->getIntraDir( chType, uiAbsPartIdx );
  const UInt           partsPerMinCU    = 1<<(2*(sps.getMaxTotalCUDepth() - sps.getLog2DiffMaxMinCodingBlockSize()));
  const UInt           uiChCodedMode    = (uiChPredMode==DM_CHROMA_IDX && !bIsLuma) ? pcCU->getIntraDir(CHANNEL_TYPE_LUMA, getChromasCorrespondingPULumaIdx(uiAbsPartIdx, chFmt, partsPerMinCU)) : uiChPredMode;
  const UInt           uiChFinalMode    = ((chFmt == CHROMA_422)       && !bIsLuma) ? g_chroma422IntraAngleMappingTable[uiChCodedMode] : uiChCodedMode;

  const Int            blkX                                 = g_auiRasterToPelX[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            blkY                                 = g_auiRasterToPelY[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            bufferOffset                         = blkX + (blkY * MAX_CU_SIZE);
        Pel  *const    encoderLumaResidual                  = resiLuma[RESIDUAL_ENCODER_SIDE ] + bufferOffset;
        Pel  *const    reconstructedLumaResidual            = resiLuma[RESIDUAL_RECONSTRUCTED] + bufferOffset;
  const Bool           bUseCrossCPrediction                 = isChroma(compID) && (uiChPredMode == DM_CHROMA_IDX) && checkCrossCPrediction;
  const Bool           bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
        Pel *const     lumaResidualForEstimate              = bUseReconstructedResidualForEstimate ? reconstructedLumaResidual : encoderLumaResidual;

#if DEBUG_STRING
  const Int debugPredModeMask=DebugStringGetPredModeMask(MODE_INTRA);
#endif

  //===== init availability pattern =====
  DEBUG_STRING_NEW(sTemp)

#if !DEBUG_STRING
  if( default0Save1Load2 != 2 )
#endif
  {
    const Bool bUseFilteredPredictions=TComPrediction::filteringIntraReferenceSamples(compID, uiChFinalMode, uiWidth, uiHeight, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

    initIntraPatternChType( rTu, compID, bUseFilteredPredictions DEBUG_STRING_PASS_INTO(sDebug) );

    //===== get prediction signal =====
    predIntraAng( compID, uiChFinalMode, piOrg, uiStride, piPred, uiStride, rTu, bUseFilteredPredictions );

    // save prediction
    if( default0Save1Load2 == 1 )
    {
      Pel*  pPred   = piPred;
      Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
      Int k = 0;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pPredBuf[ k ++ ] = pPred[ uiX ];
        }
        pPred += uiStride;
      }
    }
  }
#if !DEBUG_STRING
  else
  {
    // load prediction
    Pel*  pPred   = piPred;
    Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
    Int k = 0;
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pPred[ uiX ] = pPredBuf[ k ++ ];
      }
      pPred += uiStride;
    }
  }
#endif

  //===== get residual signal =====
  {
    // get residual
    Pel*  pOrg    = piOrg;
    Pel*  pPred   = piPred;
    Pel*  pResi   = piResi;

    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pResi[ uiX ] = pOrg[ uiX ] - pPred[ uiX ];
      }

      pOrg  += uiStride;
      pResi += uiStride;
      pPred += uiStride;
    }
  }

  if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
  {
    if (bUseCrossCPrediction)
    {
      if (xCalcCrossComponentPredictionAlpha( rTu, compID, lumaResidualForEstimate, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride ) == 0)
      {
        return;
      }
      TComTrQuant::crossComponentPrediction ( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, false );
    }
    else if (isLuma(compID) && !bUseReconstructedResidualForEstimate)
    {
      xStoreCrossComponentPredictionResult( encoderLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
    }
  }

  //===== transform and quantization =====
  //--- init rate estimation arrays for RDOQ ---
  if( useTransformSkip ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ() )
  {
    m_pcEntropyCoder->estimateBit( m_pcTrQuant->m_pcEstBitsSbac, uiWidth, uiHeight, chType );
  }

  //--- transform and quantization ---
  TCoeff uiAbsSum = 0;
  if (bIsLuma)
  {
    pcCU       ->setTrIdxSubParts ( uiTrDepth, uiAbsPartIdx, uiFullDepth );
  }

  const QpParam cQP(*pcCU, compID);

#if RDOQ_CHROMA_LAMBDA
  m_pcTrQuant->selectLambda     (compID);
#endif

  m_pcTrQuant->transformNxN     ( rTu, compID, piResi, uiStride, pcCoeff,
#if ADAPTIVE_QP_SELECTION
    pcArlCoeff,
#endif
    uiAbsSum, cQP
    );

  //--- inverse transform ---

#if DEBUG_STRING
  if ( (uiAbsSum > 0) || (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask) )
#else
  if ( uiAbsSum > 0 )
#endif
  {
    m_pcTrQuant->invTransformNxN ( rTu, compID, piResi, uiStride, pcCoeff, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sDebug, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );
  }
  else
  {
    Pel* pResi = piResi;
    memset( pcCoeff, 0, sizeof( TCoeff ) * uiWidth * uiHeight );
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      memset( pResi, 0, sizeof( Pel ) * uiWidth );
      pResi += uiStride;
    }
  }


  //===== reconstruction =====
  {
    Pel* pPred      = piPred;
    Pel* pResi      = piResi;
    Pel* pReco      = piReco;
    Pel* pRecQt     = piRecQt;
    Pel* pRecIPred  = piRecIPred;

    if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
    {
      if (bUseCrossCPrediction)
      {
        TComTrQuant::crossComponentPrediction( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, true );
      }
      else if (isLuma(compID))
      {
        xStoreCrossComponentPredictionResult( reconstructedLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
      }
    }

 #if DEBUG_STRING
    std::stringstream ss(stringstream::out);
    const Bool bDebugPred=((DebugOptionList::DebugString_Pred.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugResi=((DebugOptionList::DebugString_Resi.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugReco=((DebugOptionList::DebugString_Reco.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));

    if (bDebugPred || bDebugResi || bDebugReco)
    {
      ss << "###: " << "CompID: " << compID << " pred mode (ch/fin): " << uiChPredMode << "/" << uiChFinalMode << " absPartIdx: " << rTu.GetAbsPartIdxTU() << "\n";
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        ss << "###: ";
        if (bDebugPred)
        {
          ss << " - pred: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pPred[ uiX ] << ", ";
          }
        }
        if (bDebugResi)
        {
          ss << " - resi: ";
        }
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          if (bDebugResi)
          {
            ss << pResi[ uiX ] << ", ";
          }
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        if (bDebugReco)
        {
          ss << " - reco: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pReco[ uiX ] << ", ";
          }
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
        ss << "\n";
      }
      DEBUG_STRING_APPEND(sDebug, ss.str())
    }
    else
#endif
    {

      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }

  //===== update distortion =====
  ruiDist += m_pcRdCost->getDistPart( bitDepth, piReco, uiStride, piOrg, uiStride, uiWidth, uiHeight, compID );
}




Void
TEncSearch::xRecurIntraCodingLumaQT(TComYuv*    pcOrgYuv,
                                    TComYuv*    pcPredYuv,
                                    TComYuv*    pcResiYuv,
                                    Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                    Distortion& ruiDistY,
#if HHI_RQT_INTRA_SPEEDUP
                                    Bool        bCheckFirst,
#endif
                                    Double&     dRDCost,
                                    TComTU&     rTu
                                    DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU   *pcCU          = rTu.getCU();
  const UInt    uiAbsPartIdx  = rTu.GetAbsPartIdxTU();
  const UInt    uiFullDepth   = rTu.GetTransformDepthTotal();
  const UInt    uiTrDepth     = rTu.GetTransformDepthRel();
  const UInt    uiLog2TrSize  = rTu.GetLog2LumaTrSize();
        Bool    bCheckFull    = ( uiLog2TrSize  <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
        Bool    bCheckSplit   = ( uiLog2TrSize  >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

        Pel     resiLumaSplit [NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];
        Pel     resiLumaSingle[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

#if HHI_RQT_INTRA_SPEEDUP
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // don't check split if TU size is less or equal to max TU size
  Bool noSplitIntraMaxTuSize = bCheckFull;
  if(m_pcEncCfg->getRDpenalty() && ! isIntraSlice)
  {
    // in addition don't check split if TU size is less or equal to 16x16 TU size for non-intra slice
    noSplitIntraMaxTuSize = ( uiLog2TrSize  <= min(maxTuSize,4) );

    // if maximum RD-penalty don't check TU size 32x32
    if(m_pcEncCfg->getRDpenalty()==2)
    {
      bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
    }
  }
  if( bCheckFirst && noSplitIntraMaxTuSize )

  {
    bCheckSplit = false;
  }
#else
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // if maximum RD-penalty don't check TU size 32x32
  if((m_pcEncCfg->getRDpenalty()==2)  && !isIntraSlice)
  {
    bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
  }
#endif
  Double     dSingleCost                        = MAX_DOUBLE;
  Distortion uiSingleDistLuma                   = 0;
  UInt       uiSingleCbfLuma                    = 0;
  Bool       checkTransformSkip  = pcCU->getSlice()->getPPS()->getUseTransformSkip();
  Int        bestModeId[MAX_NUM_COMPONENT] = { 0, 0, 0};
  checkTransformSkip           &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());
  checkTransformSkip           &= (!pcCU->getCUTransquantBypass(0));

  assert (rTu.ProcessComponentSection(COMPONENT_Y));
  const UInt totalAdjustedDepthChan   = rTu.GetTransformDepthTotalAdj(COMPONENT_Y);

  if ( m_pcEncCfg->getUseTransformSkipFast() )
  {
    checkTransformSkip       &= (pcCU->getPartitionSize(uiAbsPartIdx)==SIZE_NxN);
  }

  if( bCheckFull )
  {
    if(checkTransformSkip == true)
    {
      //----- store original entropy coding status -----
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );

      Distortion singleDistTmpLuma                    = 0;
      UInt       singleCbfTmpLuma                     = 0;
      Double     singleCostTmp                        = 0;
      Int        firstCheckId                         = 0;

      for(Int modeId = firstCheckId; modeId < 2; modeId ++)
      {
        DEBUG_STRING_NEW(sModeString)
        Int  default0Save1Load2 = 0;
        singleDistTmpLuma=0;
        if(modeId == firstCheckId)
        {
          default0Save1Load2 = 1;
        }
        else
        {
          default0Save1Load2 = 2;
        }


        pcCU->setTransformSkipSubParts ( modeId, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
        xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, singleDistTmpLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sModeString), default0Save1Load2 );

        singleCbfTmpLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );

        //----- determine rate and r-d cost -----
        if(modeId == 1 && singleCbfTmpLuma == 0)
        {
          //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
          singleCostTmp = MAX_DOUBLE;
        }
        else
        {
          UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );
          singleCostTmp     = m_pcRdCost->calcRdCost( uiSingleBits, singleDistTmpLuma );
        }
        if(singleCostTmp < dSingleCost)
        {
          DEBUG_STRING_SWAP(sDebug, sModeString)
          dSingleCost   = singleCostTmp;
          uiSingleDistLuma = singleDistTmpLuma;
          uiSingleCbfLuma = singleCbfTmpLuma;

          bestModeId[COMPONENT_Y] = modeId;
          if(bestModeId[COMPONENT_Y] == firstCheckId)
          {
            xStoreIntraResultQT(COMPONENT_Y, rTu );
            m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
          }

          if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
          {
            const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
            const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
            for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
            {
              if (bMaintainResidual[storedResidualIndex])
              {
                xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
              }
            }
          }
        }
        if (modeId == firstCheckId)
        {
          m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
        }
      }

      pcCU ->setTransformSkipSubParts ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

      if(bestModeId[COMPONENT_Y] == firstCheckId)
      {
        xLoadIntraResultQT(COMPONENT_Y, rTu );
        pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, rTu.GetTransformDepthTotalAdj(COMPONENT_Y) );

        m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
      }
    }
    else
    {
      //----- store original entropy coding status -----
      if( bCheckSplit )
      {
        m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
      }
      //----- code luma/chroma block with given intra prediction mode and store Cbf-----
      dSingleCost   = 0.0;

      pcCU ->setTransformSkipSubParts ( 0, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
      xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, uiSingleDistLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sDebug));

      if( bCheckSplit )
      {
        uiSingleCbfLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );
      }
      //----- determine rate and r-d cost -----
      UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );

      if(m_pcEncCfg->getRDpenalty() && (uiLog2TrSize==5) && !isIntraSlice)
      {
        uiSingleBits=uiSingleBits*4;
      }

      dSingleCost       = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDistLuma );

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }
    }
  }

  if( bCheckSplit )
  {
    //----- store full entropy coding status, load original entropy coding status -----
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    else
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    //----- code splitted block -----
    Double     dSplitCost      = 0.0;
    Distortion uiSplitDistLuma = 0;
    UInt       uiSplitCbfLuma  = 0;

    TComTURecurse tuRecurseChild(rTu, false);
    DEBUG_STRING_NEW(sSplit)
    do
    {
      DEBUG_STRING_NEW(sChild)
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, bCheckFirst, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#endif
      DEBUG_STRING_APPEND(sSplit, sChild)
      uiSplitCbfLuma |= pcCU->getCbf( tuRecurseChild.GetAbsPartIdxTU(), COMPONENT_Y, tuRecurseChild.GetTransformDepthRel() );
    } while (tuRecurseChild.nextSection(rTu) );

    UInt    uiPartsDiv     = rTu.GetAbsPartIdxNumParts();
    {
      if (uiSplitCbfLuma)
      {
        const UInt flag=1<<uiTrDepth;
        UChar *pBase=pcCU->getCbf( COMPONENT_Y );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
    //----- restore context states -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    
    //----- determine rate and r-d cost -----
    UInt uiSplitBits = xGetIntraBitsQT( rTu, true, false, false );
    dSplitCost       = m_pcRdCost->calcRdCost( uiSplitBits, uiSplitDistLuma );

    //===== compare and set best =====
    if( dSplitCost < dSingleCost )
    {
      //--- update cost ---
      DEBUG_STRING_SWAP(sSplit, sDebug)
      ruiDistY += uiSplitDistLuma;
      dRDCost  += dSplitCost;

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSplit[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }

      return;
    }

    //----- set entropy coding status -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );

    //--- set transform index and Cbf values ---
    pcCU->setTrIdxSubParts( uiTrDepth, uiAbsPartIdx, uiFullDepth );
    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
    pcCU ->setTransformSkipSubParts  ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

    //--- set reconstruction for next intra prediction blocks ---
    const UInt  uiQTLayer   = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt  uiZOrder    = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
    const UInt  uiWidth     = tuRect.width;
    const UInt  uiHeight    = tuRect.height;
    Pel*  piSrc       = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( COMPONENT_Y, uiAbsPartIdx );
    UInt  uiSrcStride = m_pcQTTempTComYuv[ uiQTLayer ].getStride  ( COMPONENT_Y );
    Pel*  piDes       = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
    UInt  uiDesStride = pcCU->getPic()->getPicYuvRec()->getStride  ( COMPONENT_Y );

    for( UInt uiY = 0; uiY < uiHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        piDes[ uiX ] = piSrc[ uiX ];
      }
    }
  }
  ruiDistY += uiSingleDistLuma;
  dRDCost  += dSingleCost;
}


Void
TEncSearch::xSetIntraResultLumaQT(TComYuv* pcRecoYuv, TComTU &rTu)
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiTrDepth    = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====

    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    const UInt coeffOffset = rTu.getCoefficientOffset(COMPONENT_Y);
    const UInt numCoeffInBlock = tuRect.width * tuRect.height;

    if (numCoeffInBlock!=0)
    {
      const TCoeff* srcCoeff = m_ppcQTTempCoeff[COMPONENT_Y][uiQTLayer] + coeffOffset;
      TCoeff* destCoeff      = pcCU->getCoeff(COMPONENT_Y) + coeffOffset;
      ::memcpy( destCoeff, srcCoeff, sizeof(TCoeff)*numCoeffInBlock );
#if ADAPTIVE_QP_SELECTION
      const TCoeff* srcArlCoeff = m_ppcQTTempArlCoeff[COMPONENT_Y][ uiQTLayer ] + coeffOffset;
      TCoeff* destArlCoeff      = pcCU->getArlCoeff (COMPONENT_Y)               + coeffOffset;
      ::memcpy( destArlCoeff, srcArlCoeff, sizeof( TCoeff ) * numCoeffInBlock );
#endif
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Y, pcRecoYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }

  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultLumaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}


Void
TEncSearch::xStoreIntraResultQT(const ComponentID compID, TComTU &rTu )
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff    = tuRect.width * tuRect.height;
      TCoeff* pcCoeffSrc = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffDst = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffDst = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( compID, &m_pcQTTempTransformSkipTComYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }
  }
}


Void
TEncSearch::xLoadIntraResultQT(const ComponentID compID, TComTU &rTu)
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt uiZOrder     = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff = tuRect.width * tuRect.height;
      TCoeff* pcCoeffDst = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffSrc = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffDst = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffSrc = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTransformSkipTComYuv.copyPartToPartComponent( compID, &m_pcQTTempTComYuv[ uiQTLayer ], uiAbsPartIdx, tuRect.width, tuRect.height );

      Pel*    piRecIPred        = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
      UInt    uiRecIPredStride  = pcCU->getPic()->getPicYuvRec()->getStride (compID);
      Pel*    piRecQt           = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
      UInt    uiRecQtStride     = m_pcQTTempTComYuv[ uiQTLayer ].getStride  (compID);
      UInt    uiWidth           = tuRect.width;
      UInt    uiHeight          = tuRect.height;
      Pel* pRecQt               = piRecQt;
      Pel* pRecIPred            = piRecIPred;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pRecIPred[ uiX ] = pRecQt   [ uiX ];
        }
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }
}

Void
TEncSearch::xStoreCrossComponentPredictionResult(       Pel    *pResiDst,
                                                  const Pel    *pResiSrc,
                                                        TComTU &rTu,
                                                  const Int     xOffset,
                                                  const Int     yOffset,
                                                  const Int     strideDst,
                                                  const Int     strideSrc )
{
  const Pel *pSrc = pResiSrc + yOffset * strideSrc + xOffset;
        Pel *pDst = pResiDst + yOffset * strideDst + xOffset;

  for( Int y = 0; y < rTu.getRect( COMPONENT_Y ).height; y++ )
  {
    ::memcpy( pDst, pSrc, sizeof(Pel) * rTu.getRect( COMPONENT_Y ).width );
    pDst += strideDst;
    pSrc += strideSrc;
  }
}

SChar
TEncSearch::xCalcCrossComponentPredictionAlpha(       TComTU &rTu,
                                                const ComponentID compID,
                                                const Pel*        piResiL,
                                                const Pel*        piResiC,
                                                const Int         width,
                                                const Int         height,
                                                const Int         strideL,
                                                const Int         strideC )
{
  const Pel *pResiL = piResiL;
  const Pel *pResiC = piResiC;

        TComDataCU *pCU = rTu.getCU();
  const Int  absPartIdx = rTu.GetAbsPartIdxTU( compID );
  const Int diffBitDepth = pCU->getSlice()->getSPS()->getDifferentialLumaChromaBitDepth();

  SChar alpha = 0;
  Int SSxy  = 0;
  Int SSxx  = 0;

  for( UInt uiY = 0; uiY < height; uiY++ )
  {
    for( UInt uiX = 0; uiX < width; uiX++ )
    {
      const Pel scaledResiL = rightShift( pResiL[ uiX ], diffBitDepth );
      SSxy += ( scaledResiL * pResiC[ uiX ] );
      SSxx += ( scaledResiL * scaledResiL   );
    }

    pResiL += strideL;
    pResiC += strideC;
  }

  if( SSxx != 0 )
  {
    Double dAlpha = SSxy / Double( SSxx );
    alpha = SChar(Clip3<Int>(-16, 16, (Int)(dAlpha * 16)));

    static const SChar alphaQuant[17] = {0, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8};

    alpha = (alpha < 0) ? -alphaQuant[Int(-alpha)] : alphaQuant[Int(alpha)];
  }
  pCU->setCrossComponentPredictionAlphaPartRange( alpha, compID, absPartIdx, rTu.GetAbsPartIdxNumParts( compID ) );

  return alpha;
}

Void
TEncSearch::xRecurIntraChromaCodingQT(TComYuv*    pcOrgYuv,
                                      TComYuv*    pcPredYuv,
                                      TComYuv*    pcResiYuv,
                                      Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      Distortion& ruiDist,
                                      TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU         *pcCU                  = rTu.getCU();
  const UInt          uiTrDepth             = rTu.GetTransformDepthRel();
  const UInt          uiAbsPartIdx          = rTu.GetAbsPartIdxTU();
  const ChromaFormat  format                = rTu.GetChromaFormat();
  UInt                uiTrMode              = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt          numberValidComponents = getNumberValidComponents(format);

  if(  uiTrMode == uiTrDepth )
  {
    if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      return;
    }

    const UInt uiFullDepth = rTu.GetTransformDepthTotal();

    Bool checkTransformSkip = pcCU->getSlice()->getPPS()->getUseTransformSkip();
    checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Cb), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

    if ( m_pcEncCfg->getUseTransformSkipFast() )
    {
      checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

      if (checkTransformSkip)
      {
        Int nbLumaSkip = 0;
        const UInt maxAbsPartIdxSub=uiAbsPartIdx + (rTu.ProcessingAllQuadrants(COMPONENT_Cb)?1:4);
        for(UInt absPartIdxSub = uiAbsPartIdx; absPartIdxSub < maxAbsPartIdxSub; absPartIdxSub ++)
        {
          nbLumaSkip += pcCU->getTransformSkip(absPartIdxSub, COMPONENT_Y);
        }
        checkTransformSkip &= (nbLumaSkip > 0);
      }
    }


    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      DEBUG_STRING_NEW(sDebugBestMode)

      //use RDO to decide whether Cr/Cb takes TS
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[uiFullDepth][CI_QT_TRAFO_ROOT] );

      const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

      TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

      const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

      do
      {
        const UInt subTUAbsPartIdx   = TUIterator.GetAbsPartIdxTU(compID);

        Double     dSingleCost               = MAX_DOUBLE;
        Int        bestModeId                = 0;
        Distortion singleDistC               = 0;
        UInt       singleCbfC                = 0;
        Distortion singleDistCTmp            = 0;
        Double     singleCostTmp             = 0;
        UInt       singleCbfCTmp             = 0;
        SChar      bestCrossCPredictionAlpha = 0;
        Int        bestTransformSkipMode     = 0;

        const Bool checkCrossComponentPrediction =    (pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, subTUAbsPartIdx) == DM_CHROMA_IDX)
                                                   &&  pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                   && (pcCU->getCbf(subTUAbsPartIdx,  COMPONENT_Y, uiTrDepth) != 0);

        const Int  crossCPredictionModesToTest = checkCrossComponentPrediction ? 2 : 1;
        const Int  transformSkipModesToTest    = checkTransformSkip            ? 2 : 1;
        const Int  totalModesToTest            = crossCPredictionModesToTest * transformSkipModesToTest;
              Int  currModeId                  = 0;
              Int  default0Save1Load2          = 0;

        for(Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
        {
          for(Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
          {
            pcCU->setCrossComponentPredictionAlphaPartRange(0, compID, subTUAbsPartIdx, partIdxesPerSubTU);
            DEBUG_STRING_NEW(sDebugMode)
            pcCU->setTransformSkipPartRange( transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU );
            currModeId++;

            const Bool isOneMode  = (totalModesToTest == 1);
            const Bool isLastMode = (currModeId == totalModesToTest); // currModeId is indexed from 1

            if (isOneMode)
            {
              default0Save1Load2 = 0;
            }
            else if (!isOneMode && (transformSkipModeId == 0) && (crossCPredictionModeId == 0))
            {
              default0Save1Load2 = 1; //save prediction on first mode
            }
            else
            {
              default0Save1Load2 = 2; //load it on subsequent modes
            }

            singleDistCTmp = 0;

            xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, (crossCPredictionModeId != 0), singleDistCTmp, compID, TUIterator DEBUG_STRING_PASS_INTO(sDebugMode), default0Save1Load2);
            singleCbfCTmp = pcCU->getCbf( subTUAbsPartIdx, compID, uiTrDepth);

            if (  ((crossCPredictionModeId == 1) && (pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) == 0))
               || ((transformSkipModeId    == 1) && (singleCbfCTmp == 0))) //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
            {
              singleCostTmp = MAX_DOUBLE;
            }
            else if (!isOneMode)
            {
              UInt bitsTmp = xGetIntraBitsQTChroma( TUIterator, compID, false );
              singleCostTmp  = m_pcRdCost->calcRdCost( bitsTmp, singleDistCTmp);
            }

            if(singleCostTmp < dSingleCost)
            {
              DEBUG_STRING_SWAP(sDebugBestMode, sDebugMode)
              dSingleCost               = singleCostTmp;
              singleDistC               = singleDistCTmp;
              bestCrossCPredictionAlpha = (crossCPredictionModeId != 0) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;
              bestTransformSkipMode     = transformSkipModeId;
              bestModeId                = currModeId;
              singleCbfC                = singleCbfCTmp;

              if (!isOneMode && !isLastMode)
              {
                xStoreIntraResultQT(compID, TUIterator);
                m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
              }
            }

            if (!isOneMode && !isLastMode)
            {
              m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
            }
          }
        }

        if(bestModeId < totalModesToTest)
        {
          xLoadIntraResultQT(compID, TUIterator);
          pcCU->setCbfPartRange( singleCbfC << uiTrDepth, compID, subTUAbsPartIdx, partIdxesPerSubTU );

          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
        }

        DEBUG_STRING_APPEND(sDebug, sDebugBestMode)
        pcCU ->setTransformSkipPartRange                ( bestTransformSkipMode,     compID, subTUAbsPartIdx, partIdxesPerSubTU );
        pcCU ->setCrossComponentPredictionAlphaPartRange( bestCrossCPredictionAlpha, compID, subTUAbsPartIdx, partIdxesPerSubTU );
        ruiDist += singleDistC;
      } while (TUIterator.nextSection(rTu));

      if (splitIntoSubTUs)
      {
        offsetSubTUCBFs(rTu, compID);
      }
    }
  }
  else
  {
    UInt    uiSplitCbf[MAX_NUM_COMPONENT] = {0,0,0};

    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiTrDepthChild   = tuRecurseChild.GetTransformDepthRel();
    do
    {
      DEBUG_STRING_NEW(sChild)

      xRecurIntraChromaCodingQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, ruiDist, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );

      DEBUG_STRING_APPEND(sDebug, sChild)
      const UInt uiAbsPartIdxSub=tuRecurseChild.GetAbsPartIdxTU();

      for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
      {
        uiSplitCbf[ch] |= pcCU->getCbf( uiAbsPartIdxSub, ComponentID(ch), uiTrDepthChild );
      }
    } while ( tuRecurseChild.nextSection(rTu) );


    UInt uiPartsDiv = rTu.GetAbsPartIdxNumParts();
    for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      if (uiSplitCbf[ch])
      {
        const UInt flag=1<<uiTrDepth;
        ComponentID compID=ComponentID(ch);
        UChar *pBase=pcCU->getCbf( compID );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
  }
}




Void
TEncSearch::xSetIntraResultChromaQT(TComYuv*    pcRecoYuv, TComTU &rTu)
{
  if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
  {
    return;
  }
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth   = rTu.GetTransformDepthRel();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====
    const TComRectangle &tuRectCb=rTu.getRect(COMPONENT_Cb);
    UInt uiNumCoeffC    = tuRectCb.width*tuRectCb.height;//( pcCU->getSlice()->getSPS()->getMaxCUWidth() * pcCU->getSlice()->getSPS()->getMaxCUHeight() ) >> ( uiFullDepth << 1 );
    const UInt offset = rTu.getCoefficientOffset(COMPONENT_Cb);

    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID component = ComponentID(ch);
      const TCoeff* src           = m_ppcQTTempCoeff[component][uiQTLayer] + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      TCoeff* dest                = pcCU->getCoeff(component) + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      ::memcpy( dest, src, sizeof(TCoeff)*uiNumCoeffC );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[component][ uiQTLayer ] + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      TCoeff* pcArlCoeffDst = pcCU->getArlCoeff(component)                + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeffC );
#endif
    }

    //===== copy reconstruction =====

    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cb, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cr, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultChromaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}



Void
TEncSearch::estIntraPredLumaQT(TComDataCU* pcCU,
                               TComYuv*    pcOrgYuv,
                               TComYuv*    pcPredYuv,
                               TComYuv*    pcResiYuv,
                               TComYuv*    pcRecoYuv,
                               Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                               DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt         uiDepth               = pcCU->getDepth(0);
  const UInt         uiInitTrDepth         = pcCU->getPartitionSize(0) == SIZE_2Nx2N ? 0 : 1;
  const UInt         uiNumPU               = 1<<(2*uiInitTrDepth);
  const UInt         uiQNumParts           = pcCU->getTotalNumPart() >> 2;
  const UInt         uiWidthBit            = pcCU->getIntraSizeIdx(0);
  const ChromaFormat chFmt                 = pcCU->getPic()->getChromaFormat();
  const UInt         numberValidComponents = getNumberValidComponents(chFmt);
  const TComSPS     &sps                   = *(pcCU->getSlice()->getSPS());
  const TComPPS     &pps                   = *(pcCU->getSlice()->getPPS());
        Distortion   uiOverallDistY        = 0;
        UInt         CandNum;
        Double       CandCostList[ FAST_UDI_MAX_RDMODE_NUM ];
        Pel          resiLumaPU[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

  // Lambda calculation at equivalent Qp of 4 is recommended because at that Qp, the quantisation divisor is 1.
#if FULL_NBIT
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#else
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12 - 6 * (sps.getBitDepth(CHANNEL_TYPE_LUMA) - 8)) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#endif

  //===== set QP and clear Cbf =====
  if ( pps.getUseDQP() == true)
  {
    pcCU->setQPSubParts( pcCU->getQP(0), 0, uiDepth );
  }
  else
  {
    pcCU->setQPSubParts( pcCU->getSlice()->getSliceQp(), 0, uiDepth );
  }

  //===== loop over partitions =====
  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);

  do
  {
    const UInt uiPartOffset=tuRecurseWithPU.GetAbsPartIdxTU();
//  for( UInt uiPU = 0, uiPartOffset=0; uiPU < uiNumPU; uiPU++, uiPartOffset += uiQNumParts )
  //{
    //===== init pattern for luma prediction =====
    DEBUG_STRING_NEW(sTemp2)

    //===== determine set of modes to be tested (using prediction signal only) =====
    Int numModesAvailable     = 35; //total number of Intra modes
    UInt uiRdModeList[FAST_UDI_MAX_RDMODE_NUM];
    Int numModesForFullRD = m_pcEncCfg->getFastUDIUseMPMEnabled()?g_aucIntraModeNumFast_UseMPM[ uiWidthBit ] : g_aucIntraModeNumFast_NotUseMPM[ uiWidthBit ];

    // this should always be true
    assert (tuRecurseWithPU.ProcessComponentSection(COMPONENT_Y));
    initIntraPatternChType( tuRecurseWithPU, COMPONENT_Y, true DEBUG_STRING_PASS_INTO(sTemp2) );

    Bool doFastSearch = (numModesForFullRD != numModesAvailable);
    if (doFastSearch)
    {
      assert(numModesForFullRD < numModesAvailable);

      for( Int i=0; i < numModesForFullRD; i++ )
      {
        CandCostList[ i ] = MAX_DOUBLE;
      }
      CandNum = 0;

      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt uiAbsPartIdx=tuRecurseWithPU.GetAbsPartIdxTU();

      Pel* piOrg         = pcOrgYuv ->getAddr( COMPONENT_Y, uiAbsPartIdx );
      Pel* piPred        = pcPredYuv->getAddr( COMPONENT_Y, uiAbsPartIdx );
      UInt uiStride      = pcPredYuv->getStride( COMPONENT_Y );
      DistParam distParam;
      const Bool bUseHadamard=pcCU->getCUTransquantBypass(0) == 0;
      m_pcRdCost->setDistParam(distParam, sps.getBitDepth(CHANNEL_TYPE_LUMA), piOrg, uiStride, piPred, uiStride, puRect.width, puRect.height, bUseHadamard);
      distParam.bApplyWeight = false;
      for( Int modeIdx = 0; modeIdx < numModesAvailable; modeIdx++ )
      {
        UInt       uiMode = modeIdx;
        Distortion uiSad  = 0;

        const Bool bUseFilter=TComPrediction::filteringIntraReferenceSamples(COMPONENT_Y, uiMode, puRect.width, puRect.height, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

        predIntraAng( COMPONENT_Y, uiMode, piOrg, uiStride, piPred, uiStride, tuRecurseWithPU, bUseFilter, TComPrediction::UseDPCMForFirstPassIntraEstimation(tuRecurseWithPU, uiMode) );

        // use hadamard transform here
        uiSad+=distParam.DistFunc(&distParam);

        UInt   iModeBits = 0;

        // NB xModeBitsIntra will not affect the mode for chroma that may have already been pre-estimated.
        iModeBits+=xModeBitsIntra( pcCU, uiMode, uiPartOffset, uiDepth, CHANNEL_TYPE_LUMA );

        Double cost      = (Double)uiSad + (Double)iModeBits * sqrtLambdaForFirstPass;

#if DEBUG_INTRA_SEARCH_COSTS
        std::cout << "1st pass mode " << uiMode << " SAD = " << uiSad << ", mode bits = " << iModeBits << ", cost = " << cost << "\n";
#endif

        CandNum += xUpdateCandList( uiMode, cost, numModesForFullRD, uiRdModeList, CandCostList );
      }

      if (m_pcEncCfg->getFastUDIUseMPMEnabled())
      {
        Int uiPreds[NUM_MOST_PROBABLE_MODES] = {-1, -1, -1};

        Int iMode = -1;
        pcCU->getIntraDirPredictor( uiPartOffset, uiPreds, COMPONENT_Y, &iMode );

        const Int numCand = ( iMode >= 0 ) ? iMode : Int(NUM_MOST_PROBABLE_MODES);

        for( Int j=0; j < numCand; j++)
        {
          Bool mostProbableModeIncluded = false;
          Int mostProbableMode = uiPreds[j];

          for( Int i=0; i < numModesForFullRD; i++)
          {
            mostProbableModeIncluded |= (mostProbableMode == uiRdModeList[i]);
          }
          if (!mostProbableModeIncluded)
          {
            uiRdModeList[numModesForFullRD++] = mostProbableMode;
          }
        }
      }
    }
    else
    {
      for( Int i=0; i < numModesForFullRD; i++)
      {
        uiRdModeList[i] = i;
      }
    }

    //===== check modes (using r-d costs) =====
#if HHI_RQT_INTRA_SPEEDUP_MOD
    UInt   uiSecondBestMode  = MAX_UINT;
    Double dSecondBestPUCost = MAX_DOUBLE;
#endif
    DEBUG_STRING_NEW(sPU)
    UInt       uiBestPUMode  = 0;
    Distortion uiBestPUDistY = 0;
    Double     dBestPUCost   = MAX_DOUBLE;

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
    UInt max=numModesForFullRD;

    if (DebugOptionList::ForceLumaMode.isSet())
    {
      max=0;  // we are forcing a direction, so don't bother with mode check
    }
    for ( UInt uiMode = 0; uiMode < max; uiMode++)
#else
    for( UInt uiMode = 0; uiMode < numModesForFullRD; uiMode++ )
#endif
    {
      // set luma prediction mode
      UInt uiOrgMode = uiRdModeList[uiMode];

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );

      DEBUG_STRING_NEW(sMode)
      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, true, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#endif

#if DEBUG_INTRA_SEARCH_COSTS
      std::cout << "2nd pass [luma,chroma] mode [" << Int(pcCU->getIntraDir(CHANNEL_TYPE_LUMA, uiPartOffset)) << "," << Int(pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, uiPartOffset)) << "] cost = " << dPUCost << "\n";
#endif

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sMode)
#if HHI_RQT_INTRA_SPEEDUP_MOD
        uiSecondBestMode  = uiBestPUMode;
        dSecondBestPUCost = dBestPUCost;
#endif
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();

        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
#if HHI_RQT_INTRA_SPEEDUP_MOD
      else if( dPUCost < dSecondBestPUCost )
      {
        uiSecondBestMode  = uiOrgMode;
        dSecondBestPUCost = dPUCost;
      }
#endif
    } // Mode loop

#if HHI_RQT_INTRA_SPEEDUP
#if HHI_RQT_INTRA_SPEEDUP_MOD
    for( UInt ui =0; ui < 2; ++ui )
#endif
    {
#if HHI_RQT_INTRA_SPEEDUP_MOD
      UInt uiOrgMode   = ui ? uiSecondBestMode  : uiBestPUMode;
      if( uiOrgMode == MAX_UINT )
      {
        break;
      }
#else
      UInt uiOrgMode = uiBestPUMode;
#endif

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
      if (DebugOptionList::ForceLumaMode.isSet())
      {
        uiOrgMode = DebugOptionList::ForceLumaMode.getInt();
      }
#endif

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );
      DEBUG_STRING_NEW(sModeTree)

      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;

      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, false, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sModeTree));

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sModeTree)
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );

        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
    } // Mode loop
#endif

    DEBUG_STRING_APPEND(sDebug, sPU)

    //--- update overall distortion ---
    uiOverallDistY += uiBestPUDistY;

    //--- update transform index and cbf ---
    const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
    ::memcpy( pcCU->getTransformIdx()       + uiPartOffset, m_puhQTTempTrIdx,  uiQPartNum * sizeof( UChar ) );
    for (UInt component = 0; component < numberValidComponents; component++)
    {
      const ComponentID compID = ComponentID(component);
      ::memcpy( pcCU->getCbf( compID  ) + uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
      ::memcpy( pcCU->getTransformSkip( compID  ) + uiPartOffset, m_puhQTTempTransformSkipFlag[compID ], uiQPartNum * sizeof( UChar ) );
    }

    //--- set reconstruction for next intra prediction blocks ---
    if( !tuRecurseWithPU.IsLastSection() )
    {
      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt  uiCompWidth   = puRect.width;
      const UInt  uiCompHeight  = puRect.height;

      const UInt  uiZOrder      = pcCU->getZorderIdxInCtu() + uiPartOffset;
            Pel*  piDes         = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
      const UInt  uiDesStride   = pcCU->getPic()->getPicYuvRec()->getStride( COMPONENT_Y);
      const Pel*  piSrc         = pcRecoYuv->getAddr( COMPONENT_Y, uiPartOffset );
      const UInt  uiSrcStride   = pcRecoYuv->getStride( COMPONENT_Y);

      for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
      {
        for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
        {
          piDes[ uiX ] = piSrc[ uiX ];
        }
      }
    }

    //=== update PU data ====
    pcCU->setIntraDirSubParts     ( CHANNEL_TYPE_LUMA, uiBestPUMode, uiPartOffset, uiDepth + uiInitTrDepth );
	
  } while (tuRecurseWithPU.nextSection(tuRecurseCU));


  if( uiNumPU > 1 )
  { // set Cbf for all blocks
    UInt uiCombCbfY = 0;
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfY |= pcCU->getCbf( uiPartIdx, COMPONENT_Y,  1 );
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Y  )[ uiOffs ] |= uiCombCbfY;
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  //===== reset context models =====
  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  //===== set distortion (rate and r-d costs are determined later) =====
  pcCU->getTotalDistortion() = uiOverallDistY;
}




Void
TEncSearch::estIntraPredChromaQT(TComDataCU* pcCU,
                                 TComYuv*    pcOrgYuv,
                                 TComYuv*    pcPredYuv,
                                 TComYuv*    pcResiYuv,
                                 TComYuv*    pcRecoYuv,
                                 Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                                 DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt    uiInitTrDepth  = pcCU->getPartitionSize(0) != SIZE_2Nx2N && enable4ChromaPUsInIntraNxNCU(pcOrgYuv->getChromaFormat()) ? 1 : 0;

  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);
  const UInt    uiQNumParts    = tuRecurseWithPU.GetAbsPartIdxNumParts();
  const UInt    uiDepthCU=tuRecurseWithPU.getCUDepth();
  const UInt    numberValidComponents = pcCU->getPic()->getNumberValidComponents();

  do
  {
    UInt       uiBestMode  = 0;
    Distortion uiBestDist  = 0;
    Double     dBestCost   = MAX_DOUBLE;

    //----- init mode list -----
    if (tuRecurseWithPU.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      UInt uiModeList[FAST_UDI_MAX_RDMODE_NUM];
      const UInt  uiQPartNum     = uiQNumParts;
      const UInt  uiPartOffset   = tuRecurseWithPU.GetAbsPartIdxTU();
      {
        UInt  uiMinMode = 0;
        UInt  uiMaxMode = NUM_CHROMA_MODE;

        //----- check chroma modes -----
        pcCU->getAllowedChromaDir( uiPartOffset, uiModeList );

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
        if (DebugOptionList::ForceChromaMode.isSet())
        {
          uiMinMode=DebugOptionList::ForceChromaMode.getInt();
          if (uiModeList[uiMinMode]==34)
          {
            uiMinMode=4; // if the fixed mode has been renumbered because DM_CHROMA covers it, use DM_CHROMA.
          }
          uiMaxMode=uiMinMode+1;
        }
#endif

        DEBUG_STRING_NEW(sPU)

        for( UInt uiMode = uiMinMode; uiMode < uiMaxMode; uiMode++ )
        {
          //----- restore context models -----
          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          
          DEBUG_STRING_NEW(sMode)
          //----- chroma coding -----
          Distortion uiDist = 0;
          pcCU->setIntraDirSubParts  ( CHANNEL_TYPE_CHROMA, uiModeList[uiMode], uiPartOffset, uiDepthCU+uiInitTrDepth );
          xRecurIntraChromaCodingQT       ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );

          if( pcCU->getSlice()->getPPS()->getUseTransformSkip() )
          {
            m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          }

          UInt    uiBits = xGetIntraBitsQT( tuRecurseWithPU, false, true, false );
          Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );

          //----- compare -----
          if( dCost < dBestCost )
          {
            DEBUG_STRING_SWAP(sPU, sMode);
            dBestCost   = dCost;
            uiBestDist  = uiDist;
            uiBestMode  = uiModeList[uiMode];

            xSetIntraResultChromaQT( pcRecoYuv, tuRecurseWithPU );
            for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
            {
              const ComponentID compID = ComponentID(componentIndex);
              ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_puhQTTempTransformSkipFlag[compID], pcCU->getTransformSkip( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_phQTTempCrossComponentPredictionAlpha[compID], pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, uiQPartNum * sizeof( SChar ) );
            }
          }
        }

        DEBUG_STRING_APPEND(sDebug, sPU)

        //----- set data -----
        for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
        {
          const ComponentID compID = ComponentID(componentIndex);
          ::memcpy( pcCU->getCbf( compID )+uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getTransformSkip( compID )+uiPartOffset, m_puhQTTempTransformSkipFlag[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, m_phQTTempCrossComponentPredictionAlpha[compID], uiQPartNum * sizeof( SChar ) );
        }
      }

      if( ! tuRecurseWithPU.IsLastSection() )
      {
        for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
        {
          const ComponentID compID    = ComponentID(ch);
          const TComRectangle &tuRect = tuRecurseWithPU.getRect(compID);
          const UInt  uiCompWidth     = tuRect.width;
          const UInt  uiCompHeight    = tuRect.height;
          const UInt  uiZOrder        = pcCU->getZorderIdxInCtu() + tuRecurseWithPU.GetAbsPartIdxTU();
                Pel*  piDes           = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
          const UInt  uiDesStride     = pcCU->getPic()->getPicYuvRec()->getStride( compID);
          const Pel*  piSrc           = pcRecoYuv->getAddr( compID, uiPartOffset );
          const UInt  uiSrcStride     = pcRecoYuv->getStride( compID);

          for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
          {
            for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
            {
              piDes[ uiX ] = piSrc[ uiX ];
            }
          }
        }
      }

      pcCU->setIntraDirSubParts( CHANNEL_TYPE_CHROMA, uiBestMode, uiPartOffset, uiDepthCU+uiInitTrDepth );
      pcCU->getTotalDistortion      () += uiBestDist;
    }

  } while (tuRecurseWithPU.nextSection(tuRecurseCU));

  //----- restore context models -----

  if( uiInitTrDepth != 0 )
  { // set Cbf for all blocks
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
}




/** Function for encoding and reconstructing luma/chroma samples of a PCM mode CU.
 * \param pcCU pointer to current CU
 * \param uiAbsPartIdx part index
 * \param pOrg pointer to original sample arrays
 * \param pPCM pointer to PCM code arrays
 * \param pPred pointer to prediction signal arrays
 * \param pResi pointer to residual signal arrays
 * \param pReco pointer to reconstructed sample arrays
 * \param uiStride stride of the original/prediction/residual sample arrays
 * \param uiWidth block width
 * \param uiHeight block height
 * \param compID texture component type
 */
Void TEncSearch::xEncPCM (TComDataCU* pcCU, UInt uiAbsPartIdx, Pel* pOrg, Pel* pPCM, Pel* pPred, Pel* pResi, Pel* pReco, UInt uiStride, UInt uiWidth, UInt uiHeight, const ComponentID compID )
{
  const UInt uiReconStride   = pcCU->getPic()->getPicYuvRec()->getStride(compID);
  const UInt uiPCMBitDepth   = pcCU->getSlice()->getSPS()->getPCMBitDepth(toChannelType(compID));
  const Int  channelBitDepth = pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
  Pel* pRecoPic = pcCU->getPic()->getPicYuvRec()->getAddr(compID, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu()+uiAbsPartIdx);

  const Int pcmShiftRight=(channelBitDepth - Int(uiPCMBitDepth));

  assert(pcmShiftRight >= 0);

  for( UInt uiY = 0; uiY < uiHeight; uiY++ )
  {
    for( UInt uiX = 0; uiX < uiWidth; uiX++ )
    {
      // Reset pred and residual
      pPred[uiX] = 0;
      pResi[uiX] = 0;
      // Encode
      pPCM[uiX] = (pOrg[uiX]>>pcmShiftRight);
      // Reconstruction
      pReco   [uiX] = (pPCM[uiX]<<(pcmShiftRight));
      pRecoPic[uiX] = pReco[uiX];
    }
    pPred += uiStride;
    pResi += uiStride;
    pPCM += uiWidth;
    pOrg += uiStride;
    pReco += uiStride;
    pRecoPic += uiReconStride;
  }
}


//!  Function for PCM mode estimation.
Void TEncSearch::IPCMSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv )
{
  UInt              uiDepth      = pcCU->getDepth(0);
  const Distortion  uiDistortion = 0;
  UInt              uiBits;

  Double dCost;

  for (UInt ch=0; ch < pcCU->getPic()->getNumberValidComponents(); ch++)
  {
    const ComponentID compID  = ComponentID(ch);
    const UInt width  = pcCU->getWidth(0)  >> pcCU->getPic()->getComponentScaleX(compID);
    const UInt height = pcCU->getHeight(0) >> pcCU->getPic()->getComponentScaleY(compID);
    const UInt stride = pcPredYuv->getStride(compID);

    Pel * pOrig    = pcOrgYuv->getAddr  (compID, 0, width);
    Pel * pResi    = pcResiYuv->getAddr(compID, 0, width);
    Pel * pPred    = pcPredYuv->getAddr(compID, 0, width);
    Pel * pReco    = pcRecoYuv->getAddr(compID, 0, width);
    Pel * pPCM     = pcCU->getPCMSample (compID);

    xEncPCM ( pcCU, 0, pOrig, pPCM, pPred, pResi, pReco, stride, width, height, compID );

  }

  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiDepth, 0, true, false);
  uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  dCost = m_pcRdCost->calcRdCost( uiBits, uiDistortion );

  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  pcCU->getTotalBits()       = uiBits;
  pcCU->getTotalCost()       = dCost;
  pcCU->getTotalDistortion() = uiDistortion;

  pcCU->copyToPic(uiDepth);
}




Void TEncSearch::xGetInterPredictionError( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, Distortion& ruiErr, Bool /*bHadamard*/ )
{
  motionCompensation( pcCU, &m_tmpYuvPred, REF_PIC_LIST_X, iPartIdx );

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;
  pcCU->getPartIndexAndSize( iPartIdx, uiAbsPartIdx, iWidth, iHeight );

  DistParam cDistParam;

  cDistParam.bApplyWeight = false;


  m_pcRdCost->setDistParam( cDistParam, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA),
                            pcYuvOrg->getAddr( COMPONENT_Y, uiAbsPartIdx ), pcYuvOrg->getStride(COMPONENT_Y),
                            m_tmpYuvPred .getAddr( COMPONENT_Y, uiAbsPartIdx ), m_tmpYuvPred.getStride(COMPONENT_Y),
                            iWidth, iHeight, m_pcEncCfg->getUseHADME() && (pcCU->getCUTransquantBypass(iPartIdx) == 0) );

  ruiErr = cDistParam.DistFunc( &cDistParam );
}

//! estimation of best merge coding
Void TEncSearch::xMergeEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPUIdx, UInt& uiInterDir, TComMvField* pacMvField, UInt& uiMergeIndex, Distortion& ruiCost, TComMvField* cMvFieldNeighbours, UChar* uhInterDirNeighbours, Int& numValidMergeCand )
{

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;

 
  pcCU->getPartIndexAndSize( iPUIdx, uiAbsPartIdx, iWidth, iHeight );
  UInt uiDepth = pcCU->getDepth( uiAbsPartIdx );

  PartSize partSize = pcCU->getPartitionSize( 0 );
  if ( pcCU->getSlice()->getPPS()->getLog2ParallelMergeLevelMinus2() && partSize != SIZE_2Nx2N && pcCU->getWidth( 0 ) <= 8 )
  {
    if ( iPUIdx == 0 )
    {
      pcCU->setPartSizeSubParts( SIZE_2Nx2N, 0, uiDepth ); // temporarily set
      pcCU->getInterMergeCandidates( 0, 0, cMvFieldNeighbours,uhInterDirNeighbours, numValidMergeCand );
      pcCU->setPartSizeSubParts( partSize, 0, uiDepth ); // restore
    }
  }
  else
  {
    pcCU->getInterMergeCandidates( uiAbsPartIdx, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );
  }

  xRestrictBipredMergeCand( pcCU, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );

  ruiCost = std::numeric_limits<Distortion>::max();
  for( UInt uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )
  {
    Distortion uiCostCand = std::numeric_limits<Distortion>::max();
    UInt       uiBitsCand = 0;

    PartSize ePartSize = pcCU->getPartitionSize( 0 );

    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( cMvFieldNeighbours[0 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( cMvFieldNeighbours[1 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );

    xGetInterPredictionError( pcCU, pcYuvOrg, iPUIdx, uiCostCand, m_pcEncCfg->getUseHADME() );
    uiBitsCand = uiMergeCand + 1;
    if (uiMergeCand == m_pcEncCfg->getMaxNumMergeCand() -1)
    {
        uiBitsCand--;
    }
    uiCostCand = uiCostCand + m_pcRdCost->getCost( uiBitsCand );
    if ( uiCostCand < ruiCost )
    {
      ruiCost = uiCostCand;
      pacMvField[0] = cMvFieldNeighbours[0 + 2*uiMergeCand];
      pacMvField[1] = cMvFieldNeighbours[1 + 2*uiMergeCand];
      uiInterDir = uhInterDirNeighbours[uiMergeCand];
      uiMergeIndex = uiMergeCand;
    }
  }
 
}

/** convert bi-pred merge candidates to uni-pred
 * \param pcCU
 * \param puIdx
 * \param mvFieldNeighbours
 * \param interDirNeighbours
 * \param numValidMergeCand
 * \returns Void
 */
Void TEncSearch::xRestrictBipredMergeCand( TComDataCU* pcCU, UInt puIdx, TComMvField* mvFieldNeighbours, UChar* interDirNeighbours, Int numValidMergeCand )
{
	
  if ( pcCU->isBipredRestriction(puIdx) )
  {
    for( UInt mergeCand = 0; mergeCand < numValidMergeCand; ++mergeCand )
    {
      if ( interDirNeighbours[mergeCand] == 3 )
      {
        interDirNeighbours[mergeCand] = 1;
        mvFieldNeighbours[(mergeCand << 1) + 1].setMvField(TComMv(0,0), -1);
      }
    }
  }
}

//! search of the best candidate for inter prediction
#if AMP_MRG
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv DEBUG_STRING_FN_DECLARE(sDebug), Bool bUseRes, Bool bUseMRG )
#else
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv, Bool bUseRes )
#endif
{
  for(UInt i=0; i<NUM_REF_PIC_LIST_01; i++)
  {
    m_acYuvPred[i].clear();
  }
  m_cYuvPredTemp.clear();
  pcPredYuv->clear();

  if ( !bUseRes )
  {
    pcResiYuv->clear();
  }

  pcRecoYuv->clear();
  
  TComMv       cMvSrchRngLT;
  TComMv       cMvSrchRngRB;

  TComMv       cMvZero;
  TComMv       TempMv; //kolya

  TComMv       cMv[2];
  TComMv       cMvBi[2];
  TComMv       cMvTemp[2][33];

  Int          iNumPart    = pcCU->getNumPartitions();
  Int          iNumPredDir = pcCU->getSlice()->isInterP() ? 1 : 2;

  TComMv       cMvPred[2][33];

  TComMv       cMvPredBi[2][33];
  Int          aaiMvpIdxBi[2][33];

  Int          aaiMvpIdx[2][33];
  Int          aaiMvpNum[2][33];

  AMVPInfo     aacAMVPInfo[2][33];

  Int          iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
  Int          iRefIdxBi[2];

  UInt         uiPartAddr;
  Int          iRoiWidth, iRoiHeight;

  UInt         uiMbBits[3] = {1, 1, 0};

  UInt         uiLastMode = 0;
  Int          iRefStart, iRefEnd;

  PartSize     ePartSize = pcCU->getPartitionSize( 0 );

  Int          bestBiPRefIdxL1 = 0;
  Int          bestBiPMvpL1 = 0;
  Distortion   biPDistTemp = std::numeric_limits<Distortion>::max();

  TComMvField cMvFieldNeighbours[MRG_MAX_NUM_CANDS << 1]; // double length for mv of both lists
  UChar uhInterDirNeighbours[MRG_MAX_NUM_CANDS];
  Int numValidMergeCand = 0 ;

  for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
  {
    Distortion   uiCost[2] = { std::numeric_limits<Distortion>::max(), std::numeric_limits<Distortion>::max() };
    Distortion   uiCostBi  =   std::numeric_limits<Distortion>::max();
    Distortion   uiCostTemp;

    UInt         uiBits[3];
    UInt         uiBitsTemp;
    Distortion   bestBiPDist = std::numeric_limits<Distortion>::max();

    Distortion   uiCostTempL0[MAX_NUM_REF];
    for (Int iNumRef=0; iNumRef < MAX_NUM_REF; iNumRef++)
    {
      uiCostTempL0[iNumRef] = std::numeric_limits<Distortion>::max();
    }
    UInt         uiBitsTempL0[MAX_NUM_REF];

    TComMv       mvValidList1;
    Int          refIdxValidList1 = 0;
    UInt         bitsValidList1 = MAX_UINT;
    Distortion   costValidList1 = std::numeric_limits<Distortion>::max();

    xGetBlkBits( ePartSize, pcCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);

    pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
	
	
#if AMP_MRG
    Bool bTestNormalMC = true;

    if ( bUseMRG && pcCU->getWidth( 0 ) > 8 && iNumPart == 2 )
    {
      bTestNormalMC = false;
    }

    if (bTestNormalMC)
    {
#endif

    //  Uni-directional prediction
    for ( Int iRefList = 0; iRefList < iNumPredDir; iRefList++ )
    {
      RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

      for ( Int iRefIdxTemp = 0; iRefIdxTemp < pcCU->getSlice()->getNumRefIdx(eRefPicList); iRefIdxTemp++ )
      {
        uiBitsTemp = uiMbBits[iRefList];
        if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
        {
          uiBitsTemp += iRefIdxTemp+1;
          if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
          {
            uiBitsTemp--;
          }
        }
        xEstimateMvPredAMVP( pcCU, pcOrgYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
        aaiMvpIdx[iRefList][iRefIdxTemp] = pcCU->getMVPIdx(eRefPicList, uiPartAddr);
        aaiMvpNum[iRefList][iRefIdxTemp] = pcCU->getMVPNum(eRefPicList, uiPartAddr);

        if(pcCU->getSlice()->getMvdL1ZeroFlag() && iRefList==1 && biPDistTemp < bestBiPDist)
        {
          bestBiPDist = biPDistTemp;
          bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
          bestBiPRefIdxL1 = iRefIdxTemp;
        }

        uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];

        if ( m_pcEncCfg->getFastMEForGenBLowDelayEnabled() && iRefList == 1 )    // list 1
        {
          if ( pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) >= 0 )
          {
            cMvTemp[1][iRefIdxTemp] = cMvTemp[0][pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            uiCostTemp = uiCostTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            /*first subtract the bit-rate part of the cost of the other list*/
            uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )] );
            /*correct the bit-rate part of the current ref*/
            m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
            uiBitsTemp += m_pcRdCost->getBitsOfVectorWithPredictor( cMvTemp[1][iRefIdxTemp].getHor(), cMvTemp[1][iRefIdxTemp].getVer() );
            /*calculate the correct cost*/
            uiCostTemp += m_pcRdCost->getCost( uiBitsTemp );
          }
          else
          {
            xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
          }
        }
        else
        {
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
        }
        xCopyAMVPInfo(pcCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
        xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

        if ( iRefList == 0 )
        {
          uiCostTempL0[iRefIdxTemp] = uiCostTemp;
          uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
        }
        if ( uiCostTemp < uiCost[iRefList] )
        {
          uiCost[iRefList] = uiCostTemp;
          uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

          // set motion
          cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
          iRefIdx[iRefList] = iRefIdxTemp;
        }

        if ( iRefList == 1 && uiCostTemp < costValidList1 && pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
        {
          costValidList1 = uiCostTemp;
          bitsValidList1 = uiBitsTemp;

          // set motion
          mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
          refIdxValidList1 = iRefIdxTemp;
        }
      }
    }

    //  Bi-predictive Motion estimation
    if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )
    {

      cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
      iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];

      ::memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
      ::memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));

      UInt uiMotBits[2];

      if(pcCU->getSlice()->getMvdL1ZeroFlag())
      {
        xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
        pcCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
        cMvPredBi[1][bestBiPRefIdxL1]   = pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo()->m_acMvCand[bestBiPMvpL1];

        cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
        iRefIdxBi[1] = bestBiPRefIdxL1;
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        TComYuv* pcYuvPred = &m_acYuvPred[REF_PIC_LIST_1];
        motionCompensation( pcCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );

        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiMbBits[1];

        if ( pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1) > 1 )
        {
          uiMotBits[1] += bestBiPRefIdxL1+1;
          if ( bestBiPRefIdxL1 == pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1)-1 )
          {
            uiMotBits[1]--;
          }
        }

        uiMotBits[1] += m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][AMVP_MAX_NUM_CANDS];

        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

        cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
      }
      else
      {
        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiBits[1] - uiMbBits[1];
        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
      }

      // 4-times iteration (default)
      Int iNumIter = 4;

      // fast encoder setting: only one iteration
      if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 || pcCU->getSlice()->getMvdL1ZeroFlag() )
      {
        iNumIter = 1;
      }

      for ( Int iIter = 0; iIter < iNumIter; iIter++ )
      {
        Int         iRefList    = iIter % 2;

        if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 )
        {
          if( uiCost[0] <= uiCost[1] )
          {
            iRefList = 1;
          }
          else
          {
            iRefList = 0;
          }
        }
        else if ( iIter == 0 )
        {
          iRefList = 0;
        }
        if ( iIter == 0 && !pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllMv( cMv[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllRefIdx( iRefIdx[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          TComYuv*  pcYuvPred = &m_acYuvPred[1-iRefList];
          motionCompensation ( pcCU, pcYuvPred, RefPicList(1-iRefList), iPartIdx );
        }

        RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

        if(pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          iRefList = 0;
          eRefPicList = REF_PIC_LIST_0;
        }

        Bool bChanged = false;

        iRefStart = 0;
        iRefEnd   = pcCU->getSlice()->getNumRefIdx(eRefPicList)-1;

        for ( Int iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
        {
          uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
          if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
          {
            uiBitsTemp += iRefIdxTemp+1;
            if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
            {
              uiBitsTemp--;
            }
          }
          uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];
          // call ME
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );

          xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], pcCU->getCUMvField(eRefPicList)->getAMVPInfo());
          xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

          if ( uiCostTemp < uiCostBi )
          {
            bChanged = true;

            cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
            iRefIdxBi[iRefList] = iRefIdxTemp;

            uiCostBi            = uiCostTemp;
            uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
            uiBits[2]           = uiBitsTemp;

            if(iNumIter!=1)
            {
              //  Set motion
              pcCU->getCUMvField( eRefPicList )->setAllMv( cMvBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
              pcCU->getCUMvField( eRefPicList )->setAllRefIdx( iRefIdxBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );

              TComYuv* pcYuvPred = &m_acYuvPred[iRefList];
              motionCompensation( pcCU, pcYuvPred, eRefPicList, iPartIdx );
            }
          }
        } // for loop-iRefIdxTemp

        if ( !bChanged )
        {
          if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
          {
            xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
            xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
            if(!pcCU->getSlice()->getMvdL1ZeroFlag())
            {
              xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
              xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
            }
          }
          break;
        }
      } // for loop-iter
    } // if (B_SLICE)

#if AMP_MRG
    } //end if bTestNormalMC
#endif
    //  Clear Motion Field
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );

    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

    UInt uiMEBits = 0;
    // Set Motion Field_
    cMv[1] = mvValidList1;
	
    iRefIdx[1] = refIdxValidList1;
    uiBits[1] = bitsValidList1;
    uiCost[1] = costValidList1;

#if AMP_MRG
    if (bTestNormalMC)
    {
#endif
    if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
    {
      uiLastMode = 2;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMvBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdxBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 3, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[2];
    }
    else if ( uiCost[0] <= uiCost[1] )
    {
      uiLastMode = 0;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[0];
    }
    else
    {
      uiLastMode = 1;
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMv[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdx[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 2, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[1];
    }
#if AMP_MRG
    } // end if bTestNormalMC
#endif

    if ( pcCU->getPartitionSize( uiPartAddr ) != SIZE_2Nx2N )
    {
      UInt uiMRGInterDir = 0;
      TComMvField cMRGMvField[2];
      UInt uiMRGIndex = 0;

      UInt uiMEInterDir = 0;
      TComMvField cMEMvField[2];

      m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

#if AMP_MRG
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      Distortion uiMECost  = std::numeric_limits<Distortion>::max();

      if (bTestNormalMC)
      {
        xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
        uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
      }
#else
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
      Distortion uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
#endif
      // save ME result.
      uiMEInterDir = pcCU->getInterDir( uiPartAddr );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

      // find Merge result
      Distortion uiMRGCost = std::numeric_limits<Distortion>::max();

      xMergeEstimation( pcCU, pcOrgYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);

      if ( uiMRGCost < uiMECost )
      {
        // set Merge result
        pcCU->setMergeFlagSubParts ( true,          uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setMergeIndexSubParts( uiMRGIndex,    uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts  ( uiMRGInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMRGMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMRGMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      }
      else
      {
        // set ME result
        pcCU->setMergeFlagSubParts( false,        uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts ( uiMEInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMEMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMEMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );
      }
    }

    //  MC
    motionCompensation ( pcCU, pcPredYuv, REF_PIC_LIST_X, iPartIdx );

  } //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )

  setWpScalingDistParam( pcCU, -1, REF_PIC_LIST_X );
 // CTUW = iRoiWidth;
 // CTUH = iRoiHeight;
 // myfile << CTUH << ',' << CTUW << endl;
  return;
}


// AMVP
Void TEncSearch::xEstimateMvPredAMVP( TComDataCU* pcCU, TComYuv* pcOrgYuv, UInt uiPartIdx, RefPicList eRefPicList, Int iRefIdx, TComMv& rcMvPred, Bool bFilled, Distortion* puiDistBiP )
{

  AMVPInfo*  pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();

  TComMv     cBestMv;
  Int        iBestIdx   = 0;
  TComMv     cZeroMv;
  TComMv     cMvPred;
  Distortion uiBestCost = std::numeric_limits<Distortion>::max();
  UInt       uiPartAddr = 0;
  Int        iRoiWidth, iRoiHeight;
  Int        i;
 
  pcCU->getPartIndexAndSize( uiPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
 

  // Fill the MV Candidates
  if (!bFilled)
  {
    pcCU->fillMvpCand( uiPartIdx, uiPartAddr, eRefPicList, iRefIdx, pcAMVPInfo );
  }

  // initialize Mvp index & Mvp
  iBestIdx = 0;
  cBestMv  = pcAMVPInfo->m_acMvCand[0];
  if (pcAMVPInfo->iN <= 1)
  {
    rcMvPred = cBestMv;

    pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));

    if(pcCU->getSlice()->getMvdL1ZeroFlag() && eRefPicList==REF_PIC_LIST_1)
    {
      (*puiDistBiP) = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, rcMvPred, 0, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    }
    return;
  }

  if (bFilled)
  {
    assert(pcCU->getMVPIdx(eRefPicList,uiPartAddr) >= 0);
    rcMvPred = pcAMVPInfo->m_acMvCand[pcCU->getMVPIdx(eRefPicList,uiPartAddr)];
    return;
  }

  m_cYuvPredTemp.clear();
  //-- Check Minimum Cost.
  for ( i = 0 ; i < pcAMVPInfo->iN; i++)
  {
    Distortion uiTmpCost;
    uiTmpCost = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, pcAMVPInfo->m_acMvCand[i], i, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    if ( uiBestCost > uiTmpCost )
    {
      uiBestCost = uiTmpCost;
      cBestMv   = pcAMVPInfo->m_acMvCand[i];
      iBestIdx  = i;
      (*puiDistBiP) = uiTmpCost;
    }
  }

  m_cYuvPredTemp.clear();

  // Setting Best MVP
  rcMvPred = cBestMv;
  pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  return;
  
}

UInt TEncSearch::xGetMvpIdxBits(Int iIdx, Int iNum)
{
  assert(iIdx >= 0 && iNum >= 0 && iIdx < iNum);

  if (iNum == 1)
  {
    return 0;
  }

  UInt uiLength = 1;
  Int iTemp = iIdx;
  if ( iTemp == 0 )
  {
    return uiLength;
  }

  Bool bCodeLast = ( iNum-1 > iTemp );

  uiLength += (iTemp-1);

  if( bCodeLast )
  {
    uiLength++;
  }

  return uiLength;
}

Void TEncSearch::xGetBlkBits( PartSize eCUMode, Bool bPSlice, Int iPartIdx, UInt uiLastMode, UInt uiBlkBit[3])
{
  if ( eCUMode == SIZE_2Nx2N )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else if ( (eCUMode == SIZE_2NxN || eCUMode == SIZE_2NxnU) || eCUMode == SIZE_2NxnD )
  {
    UInt aauiMbBits[2][3][3] = { { {0,0,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7,5,7}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( (eCUMode == SIZE_Nx2N || eCUMode == SIZE_nLx2N) || eCUMode == SIZE_nRx2N )
  {
    UInt aauiMbBits[2][3][3] = { { {0,2,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7-2,7-2,9-2}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( eCUMode == SIZE_NxN )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else
  {
    printf("Wrong!\n");
    assert( 0 );
  }
}

Void TEncSearch::xCopyAMVPInfo (AMVPInfo* pSrc, AMVPInfo* pDst)
{
  pDst->iN = pSrc->iN;
  for (Int i = 0; i < pSrc->iN; i++)
  {
    pDst->m_acMvCand[i] = pSrc->m_acMvCand[i];
  }
}

Void TEncSearch::xCheckBestMVP ( TComDataCU* pcCU, RefPicList eRefPicList, TComMv cMv, TComMv& rcMvPred, Int& riMVPIdx, UInt& ruiBits, Distortion& ruiCost )
{
  AMVPInfo* pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();
  
  assert(pcAMVPInfo->m_acMvCand[riMVPIdx] == rcMvPred);

  if (pcAMVPInfo->iN < 2)
  {
    return;
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(0) );
  m_pcRdCost->setCostScale ( 0    );

  Int iBestMVPIdx = riMVPIdx;

  m_pcRdCost->setPredictor( rcMvPred );
  Int iOrgMvBits  = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
  iOrgMvBits += m_auiMVPIdxCost[riMVPIdx][AMVP_MAX_NUM_CANDS];
  Int iBestMvBits = iOrgMvBits;

  for (Int iMVPIdx = 0; iMVPIdx < pcAMVPInfo->iN; iMVPIdx++)
  {
    if (iMVPIdx == riMVPIdx)
    {
      continue;
    }

    m_pcRdCost->setPredictor( pcAMVPInfo->m_acMvCand[iMVPIdx] );

    Int iMvBits = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
    iMvBits += m_auiMVPIdxCost[iMVPIdx][AMVP_MAX_NUM_CANDS];

    if (iMvBits < iBestMvBits)
    {
      iBestMvBits = iMvBits;
      iBestMVPIdx = iMVPIdx;
    }
  }

  if (iBestMVPIdx != riMVPIdx)  //if changed
  {
    rcMvPred = pcAMVPInfo->m_acMvCand[iBestMVPIdx];

    riMVPIdx = iBestMVPIdx;
    UInt uiOrgBits = ruiBits;
    ruiBits = uiOrgBits - iOrgMvBits + iBestMvBits;
    ruiCost = (ruiCost - m_pcRdCost->getCost( uiOrgBits ))  + m_pcRdCost->getCost( ruiBits );
  }
  
}


Distortion TEncSearch::xGetTemplateCost( TComDataCU* pcCU,
                                         UInt        uiPartAddr,
                                         TComYuv*    pcOrgYuv,
                                         TComYuv*    pcTemplateCand,
                                         TComMv      cMvCand,
                                         Int         iMVPIdx,
                                         Int         iMVPNum,
                                         RefPicList  eRefPicList,
                                         Int         iRefIdx,
                                         Int         iSizeX,
                                         Int         iSizeY
                                         )
{
  Distortion uiCost = std::numeric_limits<Distortion>::max();

  TComPicYuv* pcPicYuvRef = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdx )->getPicYuvRec();

  pcCU->clipMv( cMvCand );

  // prediction pattern
  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, true, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }
  else
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, false, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }

  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xWeightedPredictionUni( pcCU, pcTemplateCand, uiPartAddr, iSizeX, iSizeY, eRefPicList, pcTemplateCand, iRefIdx );
  }

  // calc distortion

  uiCost = m_pcRdCost->getDistPart( pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA), pcTemplateCand->getAddr(COMPONENT_Y, uiPartAddr), pcTemplateCand->getStride(COMPONENT_Y), pcOrgYuv->getAddr(COMPONENT_Y, uiPartAddr), pcOrgYuv->getStride(COMPONENT_Y), iSizeX, iSizeY, COMPONENT_Y, DF_SAD );
  uiCost = (UInt) m_pcRdCost->calcRdCost( m_auiMVPIdxCost[iMVPIdx][iMVPNum], uiCost, DF_SAD );
  return uiCost;
}


Void TEncSearch::xMotionEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, RefPicList eRefPicList, TComMv* pcMvPred, Int iRefIdxPred, TComMv& rcMv, UInt& ruiBits, Distortion& ruiCost, Bool bBi  )
{
  UInt          uiPartAddr;
  Int           iRoiWidth;
  Int           iRoiHeight;

  TComMv        cMvHalf, cMvQter;
  TComMv        cMvSrchRngLT;
  TComMv        cMvSrchRngRB;
  // Distortion   INTCOST=0;
  TComYuv*      pcYuv = pcYuvOrg;
   
  assert(eRefPicList < MAX_NUM_REF_LIST_ADAPT_SR && iRefIdxPred<Int(MAX_IDX_ADAPT_SR));
  m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];

  Int           iSrchRng      = ( bBi ? m_bipredSearchRange : m_iSearchRange );
  TComPattern   tmpPattern;
  TComPattern*  pcPatternKey  = &tmpPattern;

  Double        fWeight       = 1.0;

  pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );

  if ( bBi ) // Bipredictive ME
  {
    TComYuv*  pcYuvOther = &m_acYuvPred[1-(Int)eRefPicList];
    pcYuv                = &m_cYuvPredTemp;

    pcYuvOrg->copyPartToPartYuv( pcYuv, uiPartAddr, iRoiWidth, iRoiHeight );

    pcYuv->removeHighFreq( pcYuvOther, uiPartAddr, iRoiWidth, iRoiHeight, pcCU->getSlice()->getSPS()->getBitDepths().recon, m_pcEncCfg->getClipForBiPredMeEnabled() );

    fWeight = 0.5;
  }
  m_cDistParam.bIsBiPred = bBi;

  //  Search key pattern initialization
  pcPatternKey->initPattern( pcYuv->getAddr  ( COMPONENT_Y, uiPartAddr ),
                             iRoiWidth,
                             iRoiHeight,
                             pcYuv->getStride(COMPONENT_Y),
                             pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );

  Pel*        piRefY      = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu() + uiPartAddr );
  Int         iRefStride  = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getStride(COMPONENT_Y);

  TComMv      cMvPred = *pcMvPred;

  if ( bBi )
  {
	  
    xSetSearchRange   ( pcCU, rcMv   , iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }
  else
  {
	  
    xSetSearchRange   ( pcCU, cMvPred, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }

  m_pcRdCost->selectMotionLambda(true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setPredictor  ( *pcMvPred );
  m_pcRdCost->setCostScale  ( 2 );

  setWpScalingDistParam( pcCU, iRefIdxPred, eRefPicList );
  //  Do integer search
  if ( (m_motionEstimationSearchMethod==MESEARCH_FULL) || bBi )
  {
    xPatternSearch      ( pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost );
  }
  else
  {
    rcMv = *pcMvPred;
    const TComMv *pIntegerMv2Nx2NPred=0;
    if (pcCU->getPartitionSize(0) != SIZE_2Nx2N || pcCU->getDepth(0) != 0)
    {
      pIntegerMv2Nx2NPred = &(m_integerMv2Nx2N[eRefPicList][iRefIdxPred]);
    }
    
    // EMI: Save Block width and height in global variables, to use in our NN
    PUHeight = iRoiHeight;
    PUWidth = iRoiWidth;
    PIdx = iPartIdx;
    PAddr = uiPartAddr;

    xPatternSearchFast  ( pcCU, pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost, pIntegerMv2Nx2NPred );
    if (pcCU->getPartitionSize(0) == SIZE_2Nx2N)
    {
      m_integerMv2Nx2N[eRefPicList][iRefIdxPred] = rcMv;
    }
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );
  m_pcRdCost->setCostScale ( 1 );
  
  const Bool bIsLosslessCoded = pcCU->getCUTransquantBypass(uiPartAddr) != 0;
  xPatternSearchFracDIF( bIsLosslessCoded, pcPatternKey, piRefY, iRefStride, &rcMv, cMvHalf, cMvQter, ruiCost );

  m_pcRdCost->setCostScale( 0 );

  
  
  // EMI: Modification
  
  /* 
  Fractional Motion Estimation values computed by standard are stored in TComMv variables cMvHalf & cMvQter
  We create other TComMv variables, and replace the standard values with our NN predicted values
  Our NN modifies global variables MVX_HALF & MVX_QRTER, which in return are set used to set our new Mv
  */
  TComMv MV_HALF, MV_QRTER;
  MV_HALF.setHor(MVX_HALF);
  MV_HALF.setVer(MVY_HALF);
  MV_QRTER.setHor(MVX_QRTER);
  MV_QRTER.setVer(MVY_QRTER);

  // For finding Integer Motion Estimation, Set Horizontal and Vertical values to zero:

  // MV_HALF.setHor(0);
  // MV_HALF.setVer(0);
  // MV_QRTER.setHor(0);
  // MV_QRTER.setVer(0);

  /* 
  EMI: To Write the errors and output MV in a CSV file:
  Real values for errors: U,V,H           - NN values for errors: IN[]
  Real values for MV: cMvHalf, cMvQter    - NN values for MV: MV_HALF, MV_QRTER
  Block Width and Hight: iRoiWidth, iRoiHeight
  */
  
  // ofstream mv_nn;
  // ofstream errors;
  // errors.open("/home/vague/git-repos/data/HM16.9/extract_data/SSE_errors.csv", ios::app);
  // mv_nn.open("/home/vague/git-repos/data/HM16.9/extract_data/mv_nn.csv", ios::app);
  // mv_nn << NN_out << endl;
  // mv_nn << MV_HALF.getHor() << ',' << MV_QRTER.getHor() << ',' << MV_HALF.getVer() << ',' << MV_QRTER.getVer() << endl;
  // mv_nn << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer()  << endl;
  // errors << IN[8] << ',' << IN[9] << ',' << IN[10] << ',' << IN[11] << ',' << IN[12] << ',' << IN[13] << ',' << IN[14] << ',' << IN[15] << ',' << IN[16] << endl;
  // errors << IN[0] << ',' << IN[1] << ',' << IN[2] << ',' << IN[3] << ',' << IN[4] << ',' << IN[5] << ',' << IN[6] << ',' << IN[7] << endl;

  // errors << U1 << ',' << V1 << ',' << U2 << ',' << H1 << ',' << C << ',' << H2 << ',' << U3 << ',' << V2 << ',' << U4 << ',' << iRoiHeight << ',' << iRoiWidth << endl;
  // errors << ',' << uiPartAddr << ',' << iPartIdx << endl;
  
  /*
  EXPERIMENTAL -> Write the values of the output class directly instead of coordinates "Works quite well":
  Half * 0.5 + Quarter * 0.25:  results in range from -0.75->0.75
  Add both X & Y + 0.75:        range is now 0->1.5
  Multiply X by 4:              X values are now [0, 1, 2, 3, 4, 5, 6]
  Multiply Y by 4*7=28:         Y values are now [0, 7, 14, 21, 28, 35, 42]
  Adding X+Y results in the desired output class, given that the mapping starts from 
  0 for top left corner, 24 center, and 48 for bottom right corner
  */
  
  // int MV_X = (((cMvHalf.getHor() * 0.5) + (cMvQter.getHor() * 0.25)) + 0.75) * 4;
  // int MV_Y = (((cMvHalf.getVer() * 0.5) + (cMvQter.getVer() * 0.25)) + 0.75) * 28;
  // int OUT_CLASS = MV_Y + MV_X;
  // mv_nn << OUT_CLASS << endl;
  // mv_nn << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer()  << endl;
  

  // Replace Motion Vector with values computed by our NN

  rcMv <<= 2;
  // rcMv += (cMvHalf <<= 1);
  // rcMv += cMvQter;
  rcMv += (MV_HALF <<= 1);
  rcMv += MV_QRTER;
  
  // End of modification

  UInt uiMvBits = m_pcRdCost->getBitsOfVectorWithPredictor( rcMv.getHor(), rcMv.getVer() );

  ruiBits      += uiMvBits;
  ruiCost       = (Distortion)( floor( fWeight * ( (Double)ruiCost - (Double)m_pcRdCost->getCost( uiMvBits ) ) ) + (Double)m_pcRdCost->getCost( ruiBits ) );
}


Void TEncSearch::xSetSearchRange ( const TComDataCU* const pcCU, const TComMv& cMvPred, const Int iSrchRng,
                                   TComMv& rcMvSrchRngLT, TComMv& rcMvSrchRngRB )
{
  Int  iMvShift = 2;
  TComMv cTmpMvPred = cMvPred;
  pcCU->clipMv( cTmpMvPred );

  rcMvSrchRngLT.setHor( cTmpMvPred.getHor() - (iSrchRng << iMvShift) );
  rcMvSrchRngLT.setVer( cTmpMvPred.getVer() - (iSrchRng << iMvShift) );

  rcMvSrchRngRB.setHor( cTmpMvPred.getHor() + (iSrchRng << iMvShift) );
  rcMvSrchRngRB.setVer( cTmpMvPred.getVer() + (iSrchRng << iMvShift) );
  pcCU->clipMv        ( rcMvSrchRngLT );
  pcCU->clipMv        ( rcMvSrchRngRB );

#if ME_ENABLE_ROUNDING_OF_MVS
  rcMvSrchRngLT.divideByPowerOf2(iMvShift);
  rcMvSrchRngRB.divideByPowerOf2(iMvShift);
#else
  rcMvSrchRngLT >>= iMvShift;
  rcMvSrchRngRB >>= iMvShift;
#endif
}


Void TEncSearch::xPatternSearch(const TComPattern* const pcPatternKey,
	const Pel*               piRefY,
	const Int                iRefStride,
	const TComMv* const      pcMvSrchRngLT,
	const TComMv* const      pcMvSrchRngRB,
	TComMv&      rcMv,
	Distortion&  ruiSAD)
{
	Int   iSrchRngHorLeft = pcMvSrchRngLT->getHor();
	Int   iSrchRngHorRight = pcMvSrchRngRB->getHor();
	Int   iSrchRngVerTop = pcMvSrchRngLT->getVer();
	Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

	Distortion  uiSad;
	Distortion  uiSadBest = std::numeric_limits<Distortion>::max();
	Int         iBestX = 0;
	Int         iBestY = 0;


	m_pcRdCost->setDistParam(pcPatternKey, piRefY, iRefStride, m_cDistParam);

	// fast encoder decision: use subsampled SAD for integer ME
	if (m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE3)
	{
		if (m_cDistParam.iRows > 8)
		{
			m_cDistParam.iSubShift = 1;
		}
	}

	piRefY += (iSrchRngVerTop * iRefStride);

	for (Int y = iSrchRngVerTop; y <= iSrchRngVerBottom; y++)
	{
		for (Int x = iSrchRngHorLeft; x <= iSrchRngHorRight; x++)
		{
			//  find min. distortion position
			m_cDistParam.pCur = piRefY + x;

			setDistParamComp(COMPONENT_Y);

			m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
			uiSad = m_cDistParam.DistFunc(&m_cDistParam);

			// motion cost
			uiSad += m_pcRdCost->getCostOfVectorWithPredictor(x, y);

			if (uiSad < uiSadBest)
			{
				uiSadBest = uiSad;
				iBestX = x;
				iBestY = y;
				m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
			}
		}
		piRefY += iRefStride;
	}




		rcMv.set(iBestX, iBestY);


		ruiSAD = uiSadBest - m_pcRdCost->getCostOfVectorWithPredictor(iBestX, iBestY);

		//getchar();
		return;
	}


Void TEncSearch::xPatternSearchFast( const TComDataCU* const  pcCU,
                                     const TComPattern* const pcPatternKey,
                                     const Pel* const         piRefY,
                                     const Int                iRefStride,
                                     const TComMv* const      pcMvSrchRngLT,
                                     const TComMv* const      pcMvSrchRngRB,
                                     TComMv&                  rcMv,
                                     Distortion&              ruiSAD,
                                     const TComMv* const      pIntegerMv2Nx2NPred )
{
  assert (MD_LEFT < NUM_MV_PREDICTORS);
  pcCU->getMvPredLeft       ( m_acMvPredictors[MD_LEFT] );
  assert (MD_ABOVE < NUM_MV_PREDICTORS);
  pcCU->getMvPredAbove      ( m_acMvPredictors[MD_ABOVE] );
  assert (MD_ABOVE_RIGHT < NUM_MV_PREDICTORS);
  pcCU->getMvPredAboveRight ( m_acMvPredictors[MD_ABOVE_RIGHT] );

  switch ( m_motionEstimationSearchMethod )
  {
    case MESEARCH_DIAMOND:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, false );
	  
      C = array_e[0];
      for (int i = 1; i <=index_ref - 1; i++)
      {
        if (array_e[i] < C)
          C = array_e[i];

      }
	 
      // index_ref = index_ref + 1;
      U1 = array_e[index_ref];
      V1 = array_e[index_ref + 1];
      U2 = array_e[index_ref + 2];
      H1 = array_e[index_ref + 3];	  
      H2 = array_e[index_ref + 4];
      U3 = array_e[index_ref + 5];
      V2 = array_e[index_ref + 6];
      U4 = array_e[index_ref + 7];
      	  
      // EMI: neural network implementation
      
      // Reset all values of arrays

      memset(IN, 0, sizeof(IN));
      memset(X1, 0, sizeof(X1));
      memset(X2, 0, sizeof(X2));
      memset(OUT, 0, sizeof(OUT));
      memset(array_e, 0, sizeof(array_e));
      N = 0; NN_out = 0; counter_i = 0; index_ref = 0;


      // Normalize input values using the computed mean and standard deviations

      IN[8] = (U1 - mean[0]) / stdev[0];
      IN[9] = (V1 - mean[1]) / stdev[1];
      IN[10] = (U2 - mean[2]) / stdev[2];
      IN[11] = (H1 - mean[3]) / stdev[3];
      IN[12] = (C - mean[4]) / stdev[4];
      IN[13] = (H2 - mean[5]) / stdev[5];
      IN[14] = (U3 - mean[6]) / stdev[6];
      IN[15] = (V2 - mean[7]) / stdev[7];
      IN[16] = (U4 - mean[8]) / stdev[8];

      // Input layer also consists of categorical variables, in which we will use embedding matrices depending on block Height and Width

      switch (PUHeight) {
        case 4:   IN[0] = embs0[1][0];  IN[1] = embs0[1][1];   IN[2] = embs0[1][2];   IN[3] = embs0[1][3];		break;
        case 8:   IN[0] = embs0[2][0];  IN[1] = embs0[2][1];   IN[2] = embs0[2][2];   IN[3] = embs0[2][3];		break;
        case 12:  IN[0] = embs0[3][0];  IN[1] = embs0[3][1];   IN[2] = embs0[3][2];   IN[3] = embs0[3][3];	  break;
        case 16:  IN[0] = embs0[4][0];  IN[1] = embs0[4][1];   IN[2] = embs0[4][2];   IN[3] = embs0[4][3];		break;
        case 24:  IN[0] = embs0[5][0];  IN[1] = embs0[5][1];   IN[2] = embs0[5][2];   IN[3] = embs0[5][3];	  break;
        case 32:  IN[0] = embs0[6][0];  IN[1] = embs0[6][1];   IN[2] = embs0[6][2];   IN[3] = embs0[6][3];		break;
        case 64:  IN[0] = embs0[7][0];  IN[1] = embs0[7][1];   IN[2] = embs0[7][2];   IN[3] = embs0[7][3];		break;
        default:  IN[0] = embs0[0][0];  IN[1] = embs0[0][1];   IN[2] = embs0[0][2];   IN[3] = embs0[0][3];		break;
      }

      switch (PUWidth) {
        case 4:   IN[4] = embs1[1][0];  IN[5] = embs1[1][1];   IN[6] = embs1[1][2];   IN[7] = embs1[1][3];		break;
        case 8:   IN[4] = embs1[2][0];  IN[5] = embs1[2][1];   IN[6] = embs1[2][2];   IN[7] = embs1[2][3];		break;
        case 12:  IN[4] = embs1[3][0];  IN[5] = embs1[3][1];   IN[6] = embs1[3][2];   IN[7] = embs1[3][3];	  break;
        case 16:  IN[4] = embs1[4][0];  IN[5] = embs1[4][1];   IN[6] = embs1[4][2];   IN[7] = embs1[4][3];		break;
        case 24:  IN[4] = embs1[5][0];  IN[5] = embs1[5][1];   IN[6] = embs1[5][2];   IN[7] = embs1[5][3];	  break;
        case 32:  IN[4] = embs1[6][0];  IN[5] = embs1[6][1];   IN[6] = embs1[6][2];   IN[7] = embs1[6][3];		break;
        case 64:  IN[4] = embs1[7][0];  IN[5] = embs1[7][1];   IN[6] = embs1[7][2];   IN[7] = embs1[7][3];		break;
        default:  IN[4] = embs1[0][0];  IN[5] = embs1[0][1];   IN[6] = embs1[0][2];   IN[7] = embs1[0][3];		break;
      }

      // Input Layer
      for(int i=0;i<9;i++){
        IN[i+8] = (IN[i+8] * BN_gamma_in[i]);	  
      }

      
      // First Hidden Layer
      for (int i = 0; i < 22; i++) {
        for (int j = 0; j < 17; j++) {
          X1[i] += (in_h1[i][j] * IN[j]);
        }
        X1[i] += b1[i];
        X1[i] = (relu(X1[i]) * BN_gamma_1[i]) + BN_beta_1[i];
      }

      // Second Hidden Layer
      for (int i = 0; i < 20; i++) {
        for (int j = 0; j < 22; j++) {
          X2[i] += (h1_h2[i][j] * X1[j]);
        }
        X2[i] += b2[i];
        X2[i] = (relu(X2[i]) * BN_gamma_2[i]) + BN_beta_2[i];
      }

      // OUTPUT LAYER
      for (int i = 0; i < 49; i++) {
        for (int j = 0; j < 20; j++) {
          OUT[i] += (h2_out[i][j] * X2[j]);
        }
        OUT[i] += bout[i];
      }
      
      // Decision: NN_out holds the index of the maximum element

      N = sizeof(OUT) / sizeof(float); // Size of OUT[] array, used in next step
      NN_out = std::distance(OUT, std::max_element(OUT, OUT + N));
      
      switch (NN_out) {
        case 0: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 1: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 2: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 3: MVX_HALF = 0;   MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 4: MVX_HALF = 0;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 5: MVX_HALF = 1;   MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 6: MVX_HALF = 1;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;

        case 7: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 8: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 9: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 10: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 11: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 12: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 13: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;

        case 14: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 15: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 16: MVX_HALF = 0;  MVX_QRTER = -1;   MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 17: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 18: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 19: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 20: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;

        case 21: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 22: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 23: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 24: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 25: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 26: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 27: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;

        case 28: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 29: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 30: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 31: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 32: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 33: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 34: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;

        case 35: MVX_HALF = -1; MVX_QRTER = -1;   MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 36: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 37: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 38: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 0;		break;
        case 39: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 40: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 41: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;

        case 42: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 43: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 44: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 45: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 1;	  break;
        case 46: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 47: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 48: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        default: MVX_HALF = 0;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
      }


      //end of neural network code

      break;



    case MESEARCH_SELECTIVE:
      xTZSearchSelective( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred );
      break;

    case MESEARCH_DIAMOND_ENHANCED:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, true );
      break;

    case MESEARCH_FULL: // shouldn't get here.
    default:
      break;
  }
}


Void TEncSearch::xTZSearch( const TComDataCU* const pcCU,
                            const TComPattern* const pcPatternKey,
                            const Pel* const         piRefY,
                            const Int                iRefStride,
                            const TComMv* const      pcMvSrchRngLT,
                            const TComMv* const      pcMvSrchRngRB,
                            TComMv&                  rcMv,
                            Distortion&              ruiSAD,
                            const TComMv* const      pIntegerMv2Nx2NPred,
                            const Bool               bExtendedSettings)
{
  const Bool bUseAdaptiveRaster                      = bExtendedSettings;
  const Int  iRaster                                 = 5;
  const Bool bTestOtherPredictedMV                   = bExtendedSettings;
  const Bool bTestZeroVector                         = true;
  const Bool bTestZeroVectorStart                    = bExtendedSettings;
  const Bool bTestZeroVectorStop                     = false;
  const Bool bFirstSearchDiamond                     = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bFirstCornersForDiamondDist1            = bExtendedSettings;
  const Bool bFirstSearchStop                        = m_pcEncCfg->getFastMEAssumingSmootherMVEnabled();
  const UInt uiFirstSearchRounds                     = 3;     // first search stop X rounds after best match (must be >=1)
  const Bool bEnableRasterSearch                     = true;
  const Bool bAlwaysRasterSearch                     = bExtendedSettings;  // true: BETTER but factor 2 slower
  const Bool bRasterRefinementEnable                 = false; // enable either raster refinement or star refinement
  const Bool bRasterRefinementDiamond                = false; // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bRasterRefinementCornersForDiamondDist1 = bExtendedSettings;
  const Bool bStarRefinementEnable                   = true;  // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond                  = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementCornersForDiamondDist1   = bExtendedSettings;
  const Bool bStarRefinementStop                     = false;
  const UInt uiStarRefinementRounds                  = 2;  // star refinement stop X rounds after best match (must be >=1)
  const Bool bNewZeroNeighbourhoodTest               = bExtendedSettings;

  UInt uiSearchRange = m_iSearchRange;
  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;

  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      if (cMv != rcMv && (cMv.getHor() != cStruct.iBestX && cMv.getVer() != cStruct.iBestY))
      {
        // only test cMV if not obviously previously tested.
        xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
      }
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    if ((rcMv.getHor() != 0 || rcMv.getVer() != 0) &&
        (0 != cStruct.iBestX || 0 != cStruct.iBestY))
    {
      // only test 0-vector if not obviously previously tested.
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
    }
  }

  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  if (pIntegerMv2Nx2NPred != 0)
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    if ((rcMv != integerMv2Nx2NPred) &&
        (integerMv2Nx2NPred.getHor() != cStruct.iBestX || integerMv2Nx2NPred.getVer() != cStruct.iBestY))
    {
      // only test integerMv2Nx2NPred if not obviously previously tested.
      xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);
    }

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // start search
  Int  iDist = 0;
  Int  iStartX = cStruct.iBestX;
  Int  iStartY = cStruct.iBestY;

  const Bool bBestCandidateZero = (cStruct.iBestX == 0) && (cStruct.iBestY == 0);

  // first search around best position up to now.
  // The following works as a "subsampled/log" window search around the best candidate
  for (iDist = 1; iDist <= (Int)uiSearchRange; iDist *= 2)
	  
  {
    if ( bFirstSearchDiamond == 1 )
    {
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bFirstCornersForDiamondDist1 );
    }
    else
    {
      xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
    }

    if ( bFirstSearchStop && ( cStruct.uiBestRound >= uiFirstSearchRounds ) ) // stop criterion
    {
      break;
    }
  }

  if (!bNewZeroNeighbourhoodTest)
  {
    // test whether zero Mv is a better start point than Median predictor
    if ( bTestZeroVectorStart && ((cStruct.iBestX != 0) || (cStruct.iBestY != 0)) )
    {
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
      if ( (cStruct.iBestX == 0) && (cStruct.iBestY == 0) )
      {
        // test its neighborhood
        for ( iDist = 1; iDist <= (Int)uiSearchRange; iDist*=2 )
        {
          xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
          if ( bTestZeroVectorStop && (cStruct.uiBestRound > 0) ) // stop criterion
          {
            break;
          }
        }
      }
    }
  }
  else
  {
    // Test also zero neighbourhood but with half the range
    // It was reported that the original (above) search scheme using bTestZeroVectorStart did not
    // make sense since one would have already checked the zero candidate earlier
    // and thus the conditions for that test would have not been satisfied
    if (bTestZeroVectorStart == true && bBestCandidateZero != true)
    {
      for ( iDist = 1; iDist <= ((Int)uiSearchRange >> 1); iDist*=2 )
      {
        xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
        if ( bTestZeroVectorStop && (cStruct.uiBestRound > 2) ) // stop criterion
        {
          break;
        }
      }
    }
  }

  // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
  if ( cStruct.uiBestDistance == 1 )
  {
    cStruct.uiBestDistance = 0;
    xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
  }

  // raster search if distance is too big
  if (bUseAdaptiveRaster)
  {
    int iWindowSize = iRaster;
    Int   iSrchRngRasterLeft   = iSrchRngHorLeft;
    Int   iSrchRngRasterRight  = iSrchRngHorRight;
    Int   iSrchRngRasterTop    = iSrchRngVerTop;
    Int   iSrchRngRasterBottom = iSrchRngVerBottom;

    if (!(bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster))))
    {
      iWindowSize ++;
      iSrchRngRasterLeft /= 2;
      iSrchRngRasterRight /= 2;
      iSrchRngRasterTop /= 2;
      iSrchRngRasterBottom /= 2;
    }
    cStruct.uiBestDistance = iWindowSize;
    for ( iStartY = iSrchRngRasterTop; iStartY <= iSrchRngRasterBottom; iStartY += iWindowSize )
    {
      for ( iStartX = iSrchRngRasterLeft; iStartX <= iSrchRngRasterRight; iStartX += iWindowSize )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iWindowSize );
      }
    }
  }
  else
  {
    if ( bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster) || bAlwaysRasterSearch ) )
    {
      cStruct.uiBestDistance = iRaster;
      for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += iRaster )
      {
        for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += iRaster )
        {
          xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iRaster );
        }
      }
    }
  }

  // raster refinement

  if ( bRasterRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      if ( cStruct.uiBestDistance > 1 )
      {
        iDist = cStruct.uiBestDistance >>= 1;
        if ( bRasterRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bRasterRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
      }

      // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // star refinement
  if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bStarRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }


  // EMI: BIG DIFFERENCE!
  // getting the 8 SAD points
  iDist = 1;
  iStartX = cStruct.iBestX;
  iStartY = cStruct.iBestY;
  index_ref = counter_i;
  
  xTZ8PointSquareSearch(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  iDist = 2;
  xTZ8PointSquareSearch2(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );
}


Void TEncSearch::xTZSearchSelective( const TComDataCU* const   pcCU,
                                     const TComPattern* const  pcPatternKey,
                                     const Pel* const          piRefY,
                                     const Int                 iRefStride,
                                     const TComMv* const       pcMvSrchRngLT,
                                     const TComMv* const       pcMvSrchRngRB,
                                     TComMv                   &rcMv,
                                     Distortion               &ruiSAD,
                                     const TComMv* const       pIntegerMv2Nx2NPred )
{
  const Bool bTestOtherPredictedMV    = true;
  const Bool bTestZeroVector          = true;
  const Bool bEnableRasterSearch      = true;
  const Bool bAlwaysRasterSearch      = false;  // 1: BETTER but factor 15x slower
  const Bool bStarRefinementEnable    = true;   // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond   = true;   // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementStop      = false;
  const UInt uiStarRefinementRounds   = 2;  // star refinement stop X rounds after best match (must be >=1)
  const UInt uiSearchRange            = m_iSearchRange;
  const Int  uiSearchRangeInitial     = m_iSearchRange >> 2;
  const Int  uiSearchStep             = 4;
  const Int  iMVDistThresh            = 8;

  Int   iSrchRngHorLeft         = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight        = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop          = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom       = pcMvSrchRngRB->getVer();
  Int   iFirstSrchRngHorLeft    = 0;
  Int   iFirstSrchRngHorRight   = 0;
  Int   iFirstSrchRngVerTop     = 0;
  Int   iFirstSrchRngVerBottom  = 0;
  Int   iStartX                 = 0;
  Int   iStartY                 = 0;
  Int   iBestX                  = 0;
  Int   iBestY                  = 0;
  Int   iDist                   = 0;

  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;
  cStruct.iBestX = 0;
  cStruct.iBestY = 0;


  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
  }

  if ( pIntegerMv2Nx2NPred != 0 )
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // Initial search
  iBestX = cStruct.iBestX;
  iBestY = cStruct.iBestY; 
  iFirstSrchRngHorLeft    = ((iBestX - uiSearchRangeInitial) > iSrchRngHorLeft)   ? (iBestX - uiSearchRangeInitial) : iSrchRngHorLeft;
  iFirstSrchRngVerTop     = ((iBestY - uiSearchRangeInitial) > iSrchRngVerTop)    ? (iBestY - uiSearchRangeInitial) : iSrchRngVerTop;
  iFirstSrchRngHorRight   = ((iBestX + uiSearchRangeInitial) < iSrchRngHorRight)  ? (iBestX + uiSearchRangeInitial) : iSrchRngHorRight;  
  iFirstSrchRngVerBottom  = ((iBestY + uiSearchRangeInitial) < iSrchRngVerBottom) ? (iBestY + uiSearchRangeInitial) : iSrchRngVerBottom;    

  for ( iStartY = iFirstSrchRngVerTop; iStartY <= iFirstSrchRngVerBottom; iStartY += uiSearchStep )
  {
    for ( iStartX = iFirstSrchRngHorLeft; iStartX <= iFirstSrchRngHorRight; iStartX += uiSearchStep )
    {
      xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 0 );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 1, false );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 2, false );
    }
  }

  Int iMaxMVDistToPred = (abs(cStruct.iBestX - iBestX) > iMVDistThresh || abs(cStruct.iBestY - iBestY) > iMVDistThresh);

  //full search with early exit if MV is distant from predictors
  if ( bEnableRasterSearch && (iMaxMVDistToPred || bAlwaysRasterSearch) )
  {
    for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += 1 )
    {
      for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += 1 )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 1 );
      }
    }
  }
  //Smaller MV, refine around predictor
  else if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    // start refinement
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, false );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );

}


Void TEncSearch::xPatternSearchFracDIF(
                                       Bool         bIsLosslessCoded,
                                       TComPattern* pcPatternKey,
                                       Pel*         piRefY,
                                       Int          iRefStride,
                                       TComMv*      pcMvInt,
                                       TComMv&      rcMvHalf,
                                       TComMv&      rcMvQter,
                                       Distortion&  ruiCost
                                      )
{
  //  Reference pattern initialization (integer scale)
	
  TComPattern cPatternRoi;
  Int         iOffset    = pcMvInt->getHor() + pcMvInt->getVer() * iRefStride;
  cPatternRoi.initPattern(piRefY + iOffset,
                          pcPatternKey->getROIYWidth(),
                          pcPatternKey->getROIYHeight(),
                          iRefStride,
                          pcPatternKey->getBitDepthY());

  //  Half-pel refinement
  xExtDIFUpSamplingH ( &cPatternRoi );

  rcMvHalf = *pcMvInt;   rcMvHalf <<= 1;    // for mv-cost
  TComMv baseRefMv(0, 0);
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 2, rcMvHalf, !bIsLosslessCoded );

  m_pcRdCost->setCostScale( 0 );

  xExtDIFUpSamplingQ ( &cPatternRoi, rcMvHalf );
  baseRefMv = rcMvHalf;
  baseRefMv <<= 1;

  rcMvQter = *pcMvInt;   rcMvQter <<= 1;    // for mv-cost
  rcMvQter += rcMvHalf;  rcMvQter <<= 1;
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 1, rcMvQter, !bIsLosslessCoded );
}


//! encode residual and calculate rate-distortion for a CU block
Void TEncSearch::encodeResAndCalcRdInterCU( TComDataCU* pcCU, TComYuv* pcYuvOrg, TComYuv* pcYuvPred,
                                            TComYuv* pcYuvResi, TComYuv* pcYuvResiBest, TComYuv* pcYuvRec,
                                            Bool bSkipResidual DEBUG_STRING_FN_DECLARE(sDebug) )
{
  assert ( !pcCU->isIntra(0) );

  const UInt cuWidthPixels      = pcCU->getWidth ( 0 );
  const UInt cuHeightPixels     = pcCU->getHeight( 0 );
  const Int  numValidComponents = pcCU->getPic()->getNumberValidComponents();
  const TComSPS &sps=*(pcCU->getSlice()->getSPS());

  // The pcCU is not marked as skip-mode at this point, and its m_pcTrCoeff, m_pcArlCoeff, m_puhCbf, m_puhTrIdx will all be 0.
  // due to prior calls to TComDataCU::initEstData(  );

  if ( bSkipResidual ) //  No residual coding : SKIP mode
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    pcYuvResi->clear();

    pcYuvPred->copyToPartYuv( pcYuvRec, 0 );
    Distortion distortion = 0;

    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID compID=ComponentID(comp);
      const UInt csx=pcYuvOrg->getComponentScaleX(compID);
      const UInt csy=pcYuvOrg->getComponentScaleY(compID);
      distortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID), pcYuvRec->getStride(compID), pcYuvOrg->getAddr(compID),
                                               pcYuvOrg->getStride(compID), cuWidthPixels >> csx, cuHeightPixels >> csy, compID);
    }

    m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST]);
    m_pcEntropyCoder->resetBits();

    if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex( pcCU, 0, true );

    UInt uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    pcCU->getTotalBits()       = uiBits;
    pcCU->getTotalDistortion() = distortion;
    pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( uiBits, distortion );

    m_pcRDGoOnSbacCoder->store(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_TEMP_BEST]);

#if DEBUG_STRING
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif

    return;
  }

  //  Residual coding.

   pcYuvResi->subtract( pcYuvOrg, pcYuvPred, 0, cuWidthPixels );

  TComTURecurse tuLevel0(pcCU, 0);

  Double     nonZeroCost       = 0;
  UInt       nonZeroBits       = 0;
  Distortion nonZeroDistortion = 0;
  Distortion zeroDistortion    = 0;

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_CURR_BEST ] );

  xEstimateInterResidualQT( pcYuvResi,  nonZeroCost, nonZeroBits, nonZeroDistortion, &zeroDistortion, tuLevel0 DEBUG_STRING_PASS_INTO(sDebug) );

  // -------------------------------------------------------
  // set the coefficients in the pcCU, and also calculates the residual data.
  // If a block full of 0's is efficient, then just use 0's.
  // The costs at this point do not include header bits.

  m_pcEntropyCoder->resetBits();
  m_pcEntropyCoder->encodeQtRootCbfZero( );
  const UInt   zeroResiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  const Double zeroCost     = (pcCU->isLosslessCoded( 0 )) ? (nonZeroCost+1) : (m_pcRdCost->calcRdCost( zeroResiBits, zeroDistortion ));

  if ( zeroCost < nonZeroCost || !pcCU->getQtRootCbf(0) )
  {
    const UInt uiQPartNum = tuLevel0.GetAbsPartIdxNumParts();
    ::memset( pcCU->getTransformIdx()     , 0, uiQPartNum * sizeof(UChar) );
    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID component = ComponentID(comp);
      ::memset( pcCU->getCbf( component ) , 0, uiQPartNum * sizeof(UChar) );
      ::memset( pcCU->getCrossComponentPredictionAlpha(component), 0, ( uiQPartNum * sizeof(SChar) ) );
    }
    static const UInt useTS[MAX_NUM_COMPONENT]={0,0,0};
    pcCU->setTransformSkipSubParts ( useTS, 0, pcCU->getDepth(0) );
#if DEBUG_STRING
    sDebug.clear();
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif
  }
  else
  {
    xSetInterResidualQTData( NULL, false, tuLevel0); // Call first time to set coefficients.
  }

  // all decisions now made. Fully encode the CU, including the headers:
  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST] );

  UInt finalBits = 0;
  xAddSymbolBitsInter( pcCU, finalBits );
  // we've now encoded the pcCU, and so have a valid bit cost

  if ( !pcCU->getQtRootCbf( 0 ) )
  {
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
  }
  else
  {
    xSetInterResidualQTData( pcYuvResiBest, true, tuLevel0 ); // else set the residual image data pcYUVResiBest from the various temp images.
  }
  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_TEMP_BEST ] );

  pcYuvRec->addClip ( pcYuvPred, pcYuvResiBest, 0, cuWidthPixels, sps.getBitDepths() );

  // update with clipped distortion and cost (previously unclipped reconstruction values were used)

  Distortion finalDistortion = 0;
  for(Int comp=0; comp<numValidComponents; comp++)
  {
    const ComponentID compID=ComponentID(comp);
    finalDistortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID ), pcYuvRec->getStride(compID ), pcYuvOrg->getAddr(compID ), pcYuvOrg->getStride(compID), cuWidthPixels >> pcYuvOrg->getComponentScaleX(compID), cuHeightPixels >> pcYuvOrg->getComponentScaleY(compID), compID);
  }

  pcCU->getTotalBits()       = finalBits;
  pcCU->getTotalDistortion() = finalDistortion;
  pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( finalBits, finalDistortion );
}



Void TEncSearch::xEstimateInterResidualQT( TComYuv    *pcResi,
                                           Double     &rdCost,
                                           UInt       &ruiBits,
                                           Distortion &ruiDist,
                                           Distortion *puiZeroDist,
                                           TComTU     &rTu
                                           DEBUG_STRING_FN_DECLARE(sDebug) )
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiDepth      = rTu.GetTransformDepthTotal();
  const UInt uiTrMode     = rTu.GetTransformDepthRel();
  const UInt subTUDepth   = uiTrMode + 1;
  const UInt numValidComp = pcCU->getPic()->getNumberValidComponents();
  DEBUG_STRING_NEW(sSingleStringComp[MAX_NUM_COMPONENT])

  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  UInt SplitFlag = ((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && pcCU->isInter(uiAbsPartIdx) && ( pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N ));
#if DEBUG_STRING
  const Int debugPredModeMask = DebugStringGetPredModeMask(pcCU->getPredictionMode(uiAbsPartIdx));
#endif

  Bool bCheckFull;

  if ( SplitFlag && uiDepth == pcCU->getDepth(uiAbsPartIdx) && ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) ) )
  {
    bCheckFull = false;
  }
  else
  {
    bCheckFull =  ( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
  }

  const Bool bCheckSplit  = ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

  assert( bCheckFull || bCheckSplit );

  // code full block
  Double     dSingleCost = MAX_DOUBLE;
  UInt       uiSingleBits                                                                                                        = 0;
  Distortion uiSingleDistComp            [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  Distortion uiSingleDist                                                                                                        = 0;
  TCoeff     uiAbsSum                    [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  UInt       uiBestTransformMode         [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  //  Stores the best explicit RDPCM mode for a TU encoded without split
  UInt       bestExplicitRdpcmModeUnSplit[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{3,3}, {3,3}, {3,3}};
  SChar      bestCrossCPredictionAlpha   [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};

  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );

  if( bCheckFull )
  {
    Double minCost[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/];
    Bool checkTransformSkip[MAX_NUM_COMPONENT];
    pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

    m_pcEntropyCoder->resetBits();

    memset( m_pTempPel, 0, sizeof( Pel ) * rTu.getRect(COMPONENT_Y).width * rTu.getRect(COMPONENT_Y).height ); // not necessary needed for inside of recursion (only at the beginning)

    const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    TCoeff *pcCoeffCurr[MAX_NUM_COMPONENT];
#if ADAPTIVE_QP_SELECTION
    TCoeff *pcArlCoeffCurr[MAX_NUM_COMPONENT];
#endif

    for(UInt i=0; i<numValidComp; i++)
    {
      minCost[i][0] = MAX_DOUBLE;
      minCost[i][1] = MAX_DOUBLE;
    }

    Pel crossCPredictedResidualBuffer[ MAX_TU_SIZE * MAX_TU_SIZE ];

    for(UInt i=0; i<numValidComp; i++)
    {
      checkTransformSkip[i]=false;
      const ComponentID compID=ComponentID(i);
      const Int channelBitDepth=pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
      pcCoeffCurr[compID]    = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
#if ADAPTIVE_QP_SELECTION
      pcArlCoeffCurr[compID] = m_ppcQTTempArlCoeff[compID ][uiQTTempAccessLayer] +  rTu.getCoefficientOffset(compID);
#endif

      if(rTu.ProcessComponentSection(compID))
      {
        const QpParam cQP(*pcCU, compID);

        checkTransformSkip[compID] = pcCU->getSlice()->getPPS()->getUseTransformSkip() &&
                                     TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(compID), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize()) &&
                                     (!pcCU->isLosslessCoded(0));

        const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

        TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

        const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

        do
        {
          const UInt           subTUIndex             = TUIterator.GetSectionNumber();
          const UInt           subTUAbsPartIdx        = TUIterator.GetAbsPartIdxTU(compID);
          const TComRectangle &tuCompRect             = TUIterator.getRect(compID);
          const UInt           subTUBufferOffset      = tuCompRect.width * tuCompRect.height * subTUIndex;

                TCoeff        *currentCoefficients    = pcCoeffCurr[compID] + subTUBufferOffset;
#if ADAPTIVE_QP_SELECTION
                TCoeff        *currentARLCoefficients = pcArlCoeffCurr[compID] + subTUBufferOffset;
#endif
          const Bool isCrossCPredictionAvailable      =    isChroma(compID)
                                                         && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                         && (pcCU->getCbf(subTUAbsPartIdx, COMPONENT_Y, uiTrMode) != 0);

          SChar preCalcAlpha = 0;
          const Pel *pLumaResi = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( COMPONENT_Y, rTu.getRect( COMPONENT_Y ).x0, rTu.getRect( COMPONENT_Y ).y0 );

          if (isCrossCPredictionAvailable)
          {
            const Bool bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
            const Pel  *const lumaResidualForEstimate       = bUseReconstructedResidualForEstimate ? pLumaResi                                                     : pcResi->getAddrPix(COMPONENT_Y, tuCompRect.x0, tuCompRect.y0);
            const UInt        lumaResidualStrideForEstimate = bUseReconstructedResidualForEstimate ? m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y) : pcResi->getStride(COMPONENT_Y);

            preCalcAlpha = xCalcCrossComponentPredictionAlpha(TUIterator,
                                                              compID,
                                                              lumaResidualForEstimate,
                                                              pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                              tuCompRect.width,
                                                              tuCompRect.height,
                                                              lumaResidualStrideForEstimate,
                                                              pcResi->getStride(compID));
          }

          const Int transformSkipModesToTest    = checkTransformSkip[compID] ? 2 : 1;
          const Int crossCPredictionModesToTest = (preCalcAlpha != 0)        ? 2 : 1; // preCalcAlpha cannot be anything other than 0 if isCrossCPredictionAvailable is false

          const Bool isOneMode                  = (crossCPredictionModesToTest == 1) && (transformSkipModesToTest == 1);

          for (Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
          {
            pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);

            for (Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
            {
              const Bool isFirstMode          = (transformSkipModeId == 0) && (crossCPredictionModeId == 0);
              const Bool bUseCrossCPrediction = crossCPredictionModeId != 0;

              m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
              m_pcEntropyCoder->resetBits();

              pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);
              pcCU->setCrossComponentPredictionAlphaPartRange((bUseCrossCPrediction ? preCalcAlpha : 0), compID, subTUAbsPartIdx, partIdxesPerSubTU );

              if ((compID != COMPONENT_Cr) && ((transformSkipModeId == 1) ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ()))
              {
                m_pcEntropyCoder->estimateBit(m_pcTrQuant->m_pcEstBitsSbac, tuCompRect.width, tuCompRect.height, toChannelType(compID));
              }

#if RDOQ_CHROMA_LAMBDA
              m_pcTrQuant->selectLambda(compID);
#endif

              Pel *pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
              UInt resiStride     = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);

              TCoeff bestCoeffComp   [MAX_TU_SIZE*MAX_TU_SIZE];
              Pel    bestResiComp    [MAX_TU_SIZE*MAX_TU_SIZE];

#if ADAPTIVE_QP_SELECTION
              TCoeff bestArlCoeffComp[MAX_TU_SIZE*MAX_TU_SIZE];
#endif
              TCoeff     currAbsSum   = 0;
              UInt       currCompBits = 0;
              Distortion currCompDist = 0;
              Double     currCompCost = 0;
              UInt       nonCoeffBits = 0;
              Distortion nonCoeffDist = 0;
              Double     nonCoeffCost = 0;

              if(!isOneMode && !isFirstMode)
              {
                memcpy(bestCoeffComp,    currentCoefficients,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(bestArlCoeffComp, currentARLCoefficients, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for(Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy(&bestResiComp[y * tuCompRect.width], (pcResiCurrComp + (y * resiStride)), (sizeof(Pel) * tuCompRect.width));
                }
              }

              if (bUseCrossCPrediction)
              {
                TComTrQuant::crossComponentPrediction(TUIterator,
                                                      compID,
                                                      pLumaResi,
                                                      pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                      crossCPredictedResidualBuffer,
                                                      tuCompRect.width,
                                                      tuCompRect.height,
                                                      m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                      pcResi->getStride(compID),
                                                      tuCompRect.width,
                                                      false);

                m_pcTrQuant->transformNxN(TUIterator, compID, crossCPredictedResidualBuffer, tuCompRect.width, currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }
              else
              {
                m_pcTrQuant->transformNxN(TUIterator, compID, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ), pcResi->getStride(compID), currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }

              if(isFirstMode || (currAbsSum == 0))
              {
                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pTempPel,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        tuCompRect.width,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        true);

                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride( compID ), pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }
                else
                {
                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pTempPel, tuCompRect.width, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }

                m_pcEntropyCoder->encodeQtCbfZero( TUIterator, toChannelType(compID) );

                if ( isCrossCPredictionAvailable )
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                nonCoeffBits = m_pcEntropyCoder->getNumberOfWrittenBits();
                nonCoeffCost = m_pcRdCost->calcRdCost( nonCoeffBits, nonCoeffDist );
              }

              if((puiZeroDist != NULL) && isFirstMode)
              {
                *puiZeroDist += nonCoeffDist; // initialized with zero residual distortion
              }

              DEBUG_STRING_NEW(sSingleStringTest)

              if( currAbsSum > 0 ) //if non-zero coefficients are present, a residual needs to be derived for further prediction
              {
                if (isFirstMode)
                {
                  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
                  m_pcEntropyCoder->resetBits();
                }

                m_pcEntropyCoder->encodeQtCbf( TUIterator, compID, true );

                if (isCrossCPredictionAvailable)
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                m_pcEntropyCoder->encodeCoeffNxN( TUIterator, currentCoefficients, compID );
                currCompBits = m_pcEntropyCoder->getNumberOfWrittenBits();

                pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 );

                m_pcTrQuant->invTransformNxN( TUIterator, compID, pcResiCurrComp, m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID), currentCoefficients, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sSingleStringTest, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );

                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        true);
                }

                currCompDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        pcResi->getStride(compID),
                                                        tuCompRect.width, tuCompRect.height, compID);

                currCompCost = m_pcRdCost->calcRdCost(currCompBits, currCompDist);
                  
                if (pcCU->isLosslessCoded(0))
                {
                  nonCoeffCost = MAX_DOUBLE;
                }
              }
              else if ((transformSkipModeId == 1) && !bUseCrossCPrediction)
              {
                currCompCost = MAX_DOUBLE;
              }
              else
              {
                currCompBits = nonCoeffBits;
                currCompDist = nonCoeffDist;
                currCompCost = nonCoeffCost;
              }

              // evaluate
              if ((currCompCost < minCost[compID][subTUIndex]) || ((transformSkipModeId == 1) && (currCompCost == minCost[compID][subTUIndex])))
              {
                bestExplicitRdpcmModeUnSplit[compID][subTUIndex] = pcCU->getExplicitRdpcmMode(compID, subTUAbsPartIdx);

                if(isFirstMode) //check for forced null
                {
                  if((nonCoeffCost < currCompCost) || (currAbsSum == 0))
                  {
                    memset(currentCoefficients, 0, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));

                    currAbsSum   = 0;
                    currCompBits = nonCoeffBits;
                    currCompDist = nonCoeffDist;
                    currCompCost = nonCoeffCost;
                  }
                }

#if DEBUG_STRING
                if (currAbsSum > 0)
                {
                  DEBUG_STRING_SWAP(sSingleStringComp[compID], sSingleStringTest)
                }
                else
                {
                  sSingleStringComp[compID].clear();
                }
#endif

                uiAbsSum                 [compID][subTUIndex] = currAbsSum;
                uiSingleDistComp         [compID][subTUIndex] = currCompDist;
                minCost                  [compID][subTUIndex] = currCompCost;
                uiBestTransformMode      [compID][subTUIndex] = transformSkipModeId;
                bestCrossCPredictionAlpha[compID][subTUIndex] = (crossCPredictionModeId == 1) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;

                if (uiAbsSum[compID][subTUIndex] == 0)
                {
                  if (bUseCrossCPrediction)
                  {
                    TComTrQuant::crossComponentPrediction(TUIterator,
                                                          compID,
                                                          pLumaResi,
                                                          m_pTempPel,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                          tuCompRect.width,
                                                          tuCompRect.height,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                          tuCompRect.width,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                          true);
                  }
                  else
                  {
                    pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
                    const UInt uiStride = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);
                    for(UInt uiY = 0; uiY < tuCompRect.height; uiY++)
                    {
                      memset(pcResiCurrComp, 0, (sizeof(Pel) * tuCompRect.width));
                      pcResiCurrComp += uiStride;
                    }
                  }
                }
              }
              else
              {
                // reset
                memcpy(currentCoefficients,    bestCoeffComp,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(currentARLCoefficients, bestArlCoeffComp, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for (Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy((pcResiCurrComp + (y * resiStride)), &bestResiComp[y * tuCompRect.width], (sizeof(Pel) * tuCompRect.width));
                }
              }
            }
          }

          pcCU->setExplicitRdpcmModePartRange            (   bestExplicitRdpcmModeUnSplit[compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU);
          pcCU->setTransformSkipPartRange                (   uiBestTransformMode         [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCbfPartRange                          ((((uiAbsSum                    [compID][subTUIndex] > 0) ? 1 : 0) << uiTrMode), compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCrossComponentPredictionAlphaPartRange(   bestCrossCPredictionAlpha   [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
        } while (TUIterator.nextSection(rTu)); //end of sub-TU loop
      } // processing section
    } // component loop

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      if (rTu.ProcessComponentSection(compID) && (rTu.getRect(compID).width != rTu.getRect(compID).height))
      {
        offsetSubTUCBFs(rTu, compID); //the CBFs up to now have been defined for two sub-TUs - shift them down a level and replace with the parent level CBF
      }
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    if( uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( 0, 5 - uiLog2TrSize );
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const UInt chOrderChange = ((ch + 1) == numValidComp) ? 0 : (ch + 1);
      const ComponentID compID=ComponentID(chOrderChange);
      if( rTu.ProcessComponentSection(compID) )
      {
        m_pcEntropyCoder->encodeQtCbf( rTu, compID, true );
      }
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if (rTu.ProcessComponentSection(compID))
      {
        if(isChroma(compID) && (uiAbsSum[COMPONENT_Y][0] != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, compID );
        }

        m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr[compID], compID );
        for (UInt subTUIndex = 0; subTUIndex < 2; subTUIndex++)
        {
          uiSingleDist += uiSingleDistComp[compID][subTUIndex];
        }
      }
    }

    uiSingleBits = m_pcEntropyCoder->getNumberOfWrittenBits();

    dSingleCost = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDist );
  } // check full

  // code sub-blocks
  if( bCheckSplit )
  {
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    Distortion uiSubdivDist = 0;
    UInt       uiSubdivBits = 0;
    Double     dSubdivCost = 0.0;

    //save the non-split CBFs in case we need to restore them later

    UInt bestCBF     [MAX_NUM_COMPONENT];
    UInt bestsubTUCBF[MAX_NUM_COMPONENT][2];
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);

      if (rTu.ProcessComponentSection(compID))
      {
        bestCBF[compID] = pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode);

        const TComRectangle &tuCompRect = rTu.getRect(compID);
        if (tuCompRect.width != tuCompRect.height)
        {
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

          for (UInt subTU = 0; subTU < 2; subTU++)
          {
            bestsubTUCBF[compID][subTU] = pcCU->getCbf ((uiAbsPartIdx + (subTU * partIdxesPerSubTU)), compID, subTUDepth);
          }
        }
      }
    }


    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiQPartNumSubdiv = tuRecurseChild.GetAbsPartIdxNumParts();

    DEBUG_STRING_NEW(sSplitString[MAX_NUM_COMPONENT])

    do
    {
      DEBUG_STRING_NEW(childString)
      xEstimateInterResidualQT( pcResi, dSubdivCost, uiSubdivBits, uiSubdivDist, bCheckFull ? NULL : puiZeroDist,  tuRecurseChild DEBUG_STRING_PASS_INTO(childString));
#if DEBUG_STRING
      // split the string by component and append to the relevant output (because decoder decodes in channel order, whereas this search searches by TU-order)
      std::size_t lastPos=0;
      const std::size_t endStrng=childString.find(debug_reorder_data_inter_token[MAX_NUM_COMPONENT], lastPos);
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        if (lastPos!=std::string::npos && childString.find(debug_reorder_data_inter_token[ch], lastPos)==lastPos)
        {
          lastPos+=strlen(debug_reorder_data_inter_token[ch]); // skip leading string
        }
        std::size_t pos=childString.find(debug_reorder_data_inter_token[ch+1], lastPos);
        if (pos!=std::string::npos && pos>endStrng)
        {
          lastPos=endStrng;
        }
        sSplitString[ch]+=childString.substr(lastPos, (pos==std::string::npos)? std::string::npos : (pos-lastPos) );
        lastPos=pos;
      }
#endif
    } while ( tuRecurseChild.nextSection(rTu) ) ;

    UInt uiCbfAny=0;
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      UInt uiYUVCbf = 0;
      for( UInt ui = 0; ui < 4; ++ui )
      {
        uiYUVCbf |= pcCU->getCbf( uiAbsPartIdx + ui * uiQPartNumSubdiv, ComponentID(ch),  uiTrMode + 1 );
      }
      UChar *pBase=pcCU->getCbf( ComponentID(ch) );
      const UInt flags=uiYUVCbf << uiTrMode;
      for( UInt ui = 0; ui < 4 * uiQPartNumSubdiv; ++ui )
      {
        pBase[uiAbsPartIdx + ui] |= flags;
      }
      uiCbfAny|=uiYUVCbf;
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    // when compID isn't a channel, code Cbfs:
    xEncodeInterResidualQT( MAX_NUM_COMPONENT, rTu );
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      xEncodeInterResidualQT( ComponentID(ch), rTu );
    }

    uiSubdivBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    dSubdivCost  = m_pcRdCost->calcRdCost( uiSubdivBits, uiSubdivDist );

    if (!bCheckFull || (uiCbfAny && (dSubdivCost < dSingleCost)))
    {
      rdCost += dSubdivCost;
      ruiBits += uiSubdivBits;
      ruiDist += uiSubdivDist;
#if DEBUG_STRING
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        DEBUG_STRING_APPEND(sDebug, sSplitString[ch])
      }
#endif
    }
    else
    {
      rdCost  += dSingleCost;
      ruiBits += uiSingleBits;
      ruiDist += uiSingleDist;

      //restore state to unsplit

      pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        const ComponentID compID=ComponentID(ch);

        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        if (rTu.ProcessComponentSection(compID))
        {
          DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])

          const Bool splitIntoSubTUs   = rTu.getRect(compID).width != rTu.getRect(compID).height;
          const UInt numberOfSections  = splitIntoSubTUs ? 2 : 1;
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> (splitIntoSubTUs ? 1 : 0);

          for (UInt subTUIndex = 0; subTUIndex < numberOfSections; subTUIndex++)
          {
            const UInt  uisubTUPartIdx = uiAbsPartIdx + (subTUIndex * partIdxesPerSubTU);

            if (splitIntoSubTUs)
            {
              const UChar combinedCBF = (bestsubTUCBF[compID][subTUIndex] << subTUDepth) | (bestCBF[compID] << uiTrMode);
              pcCU->setCbfPartRange(combinedCBF, compID, uisubTUPartIdx, partIdxesPerSubTU);
            }
            else
            {
              pcCU->setCbfPartRange((bestCBF[compID] << uiTrMode), compID, uisubTUPartIdx, partIdxesPerSubTU);
            }

            pcCU->setCrossComponentPredictionAlphaPartRange(bestCrossCPredictionAlpha[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setTransformSkipPartRange(uiBestTransformMode[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setExplicitRdpcmModePartRange(bestExplicitRdpcmModeUnSplit[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
          }
        }
      }

      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
    }
  }
  else
  {
    rdCost  += dSingleCost;
    ruiBits += uiSingleBits;
    ruiDist += uiSingleDist;
#if DEBUG_STRING
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[compID])

      if (rTu.ProcessComponentSection(compID))
      {
        DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])
      }
    }
#endif
  }
  DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[MAX_NUM_COMPONENT])
}



Void TEncSearch::xEncodeInterResidualQT( const ComponentID compID, TComTU &rTu )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  const UInt uiCurrTrMode = rTu.GetTransformDepthRel();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );

  const Bool bSubdiv = uiCurrTrMode != uiTrMode;

  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  if (compID==MAX_NUM_COMPONENT)  // we are not processing a channel, instead we always recurse and code the CBFs
  {
    if( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() && uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      if((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && (pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N))
      {
        assert(bSubdiv); // Inferred splitting rule - see derivation and use of interSplitFlag in the specification.
      }
      else
      {
        m_pcEntropyCoder->encodeTransformSubdivFlag( bSubdiv, 5 - uiLog2TrSize );
      }
    }

    assert( !pcCU->isIntra(uiAbsPartIdx) );

    const Bool bFirstCbfOfCU = uiCurrTrMode == 0;

    for (UInt ch=COMPONENT_Cb; ch<pcCU->getPic()->getNumberValidComponents(); ch++)
    {
      const ComponentID compIdInner=ComponentID(ch);
      if( bFirstCbfOfCU || rTu.ProcessingAllQuadrants(compIdInner) )
      {
        if( bFirstCbfOfCU || pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) )
        {
          m_pcEntropyCoder->encodeQtCbf( rTu, compIdInner, !bSubdiv );
        }
      }
      else
      {
        assert( pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode ) == pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) );
      }
    }

    if (!bSubdiv)
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }

  if( !bSubdiv )
  {
    if (compID != MAX_NUM_COMPONENT) // we have already coded the CBFs, so now we code coefficients
    {
      if (rTu.ProcessComponentSection(compID))
      {
        if (isChroma(compID) && (pcCU->getCbf(uiAbsPartIdx, COMPONENT_Y, uiTrMode) != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction(rTu, compID);
        }

        if (pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode) != 0)
        {
          const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
          TCoeff *pcCoeffCurr = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
          m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr, compID );
        }
      }
    }
  }
  else
  {
    if( compID==MAX_NUM_COMPONENT || pcCU->getCbf( uiAbsPartIdx, compID, uiCurrTrMode ) )
    {
      TComTURecurse tuRecurseChild(rTu, false);
      do
      {
        xEncodeInterResidualQT( compID, tuRecurseChild );
      } while (tuRecurseChild.nextSection(rTu));
    }
  }
}




Void TEncSearch::xSetInterResidualQTData( TComYuv* pcResi, Bool bSpatial, TComTU &rTu ) // TODO: turn this into two functions for bSpatial=true and false.
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiCurrTrMode=rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );
  const TComSPS *sps=pcCU->getSlice()->getSPS();

  if( uiCurrTrMode == uiTrMode )
  {
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTTempAccessLayer = sps->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if( bSpatial )
    {
      // Data to be copied is in the spatial domain, i.e., inverse-transformed.

      for(UInt i=0; i<pcResi->getNumberValidComponents(); i++)
      {
        const ComponentID compID=ComponentID(i);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          m_pcQTTempTComYuv[uiQTTempAccessLayer].copyPartToPartComponentMxN    ( compID, pcResi, rectCompTU );
        }
      }
    }
    else
    {
      for (UInt ch=0; ch < getNumberValidComponents(sps->getChromaFormatIdc()); ch++)
      {
        const ComponentID compID   = ComponentID(ch);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          const UInt numCoeffInBlock    = rectCompTU.width * rectCompTU.height;
          const UInt offset             = rTu.getCoefficientOffset(compID);
          TCoeff* dest                  = pcCU->getCoeff(compID)                        + offset;
          const TCoeff* src             = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + offset;
          ::memcpy( dest, src, sizeof(TCoeff)*numCoeffInBlock );

#if ADAPTIVE_QP_SELECTION
          TCoeff* pcArlCoeffSrc            = m_ppcQTTempArlCoeff[compID][uiQTTempAccessLayer] + offset;
          TCoeff* pcArlCoeffDst            = pcCU->getArlCoeff(compID)                        + offset;
          ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * numCoeffInBlock );
#endif
        }
      }
    }
  }
  else
  {

    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetInterResidualQTData( pcResi, bSpatial, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}




UInt TEncSearch::xModeBitsIntra( TComDataCU* pcCU, UInt uiMode, UInt uiPartOffset, UInt uiDepth, const ChannelType chType )
{
  // Reload only contexts required for coding intra mode information
  m_pcRDGoOnSbacCoder->loadIntraDirMode( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST], chType );

  // Temporarily set the intra dir being tested, and only
  // for absPartIdx, since encodeIntraDirModeLuma/Chroma only use
  // the entry at absPartIdx.

  UChar &rIntraDirVal=pcCU->getIntraDir( chType )[uiPartOffset];
  UChar origVal=rIntraDirVal;
  rIntraDirVal = uiMode;
  //pcCU->setIntraDirSubParts ( chType, uiMode, uiPartOffset, uiDepth + uiInitTrDepth );

  m_pcEntropyCoder->resetBits();
  if (isLuma(chType))
  {
    m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiPartOffset);
  }
  else
  {
    m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiPartOffset);
  }

  rIntraDirVal = origVal; // restore

  return m_pcEntropyCoder->getNumberOfWrittenBits();
}




UInt TEncSearch::xUpdateCandList( UInt uiMode, Double uiCost, UInt uiFastCandNum, UInt * CandModeList, Double * CandCostList )
{
  UInt i;
  UInt shift=0;

  while ( shift<uiFastCandNum && uiCost<CandCostList[ uiFastCandNum-1-shift ] )
  {
    shift++;
  }

  if( shift!=0 )
  {
    for(i=1; i<shift; i++)
    {
      CandModeList[ uiFastCandNum-i ] = CandModeList[ uiFastCandNum-1-i ];
      CandCostList[ uiFastCandNum-i ] = CandCostList[ uiFastCandNum-1-i ];
    }
    CandModeList[ uiFastCandNum-shift ] = uiMode;
    CandCostList[ uiFastCandNum-shift ] = uiCost;
    return 1;
  }

  return 0;
}





/** add inter-prediction syntax elements for a CU block
 * \param pcCU
 * \param uiQp
 * \param uiTrMode
 * \param ruiBits
 * \returns Void
 */
Void  TEncSearch::xAddSymbolBitsInter( TComDataCU* pcCU, UInt& ruiBits )
{
  if(pcCU->getMergeFlag( 0 ) && pcCU->getPartitionSize( 0 ) == SIZE_2Nx2N && !pcCU->getQtRootCbf( 0 ))
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    m_pcEntropyCoder->resetBits();
    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }
    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex(pcCU, 0, true);

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
  else
  {
    m_pcEntropyCoder->resetBits();

    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag ( pcCU, 0, true );
    m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
    m_pcEntropyCoder->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );
    m_pcEntropyCoder->encodePredInfo( pcCU, 0 );

    Bool codeDeltaQp = false;
    Bool codeChromaQpAdj = false;
    m_pcEntropyCoder->encodeCoeff   ( pcCU, 0, pcCU->getDepth(0), codeDeltaQp, codeChromaQpAdj );

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
}





/**
 * \brief Generate half-sample interpolated block
 *
 * \param pattern Reference picture ROI
 * \param biPred    Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingH( TComPattern* pattern )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;
  Int halfFilterSize = (filterSize>>1);
  Pel *srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[0].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 0, false, chFmt, pattern->getBitDepthY());
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[2].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 2, false, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + halfFilterSize * intStride + 1;
  dstPtr = m_filteredBlock[0][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
  dstPtr = m_filteredBlock[2][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+1, 2, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
  dstPtr = m_filteredBlock[0][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[2][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+1, 2, false, true, chFmt, pattern->getBitDepthY());
}





/**
 * \brief Generate quarter-sample interpolated blocks
 *
 * \param pattern    Reference picture ROI
 * \param halfPelRef Half-pel mv
 * \param biPred     Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingQ( TComPattern* pattern, TComMv halfPelRef )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Pel *srcPtr;
  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;

  Int halfFilterSize = (filterSize>>1);

  Int extHeight = (halfPelRef.getVer() == 0) ? height + filterSize : height + filterSize-1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  // Horizontal filter 1/4
  srcPtr = pattern->getROIY() - halfFilterSize * srcStride - 1;
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() >= 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 1, false, chFmt, pattern->getBitDepthY());

  // Horizontal filter 3/4
  srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() > 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 3, false, chFmt, pattern->getBitDepthY());

  // Generate @ 1,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][1].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());

  if (halfPelRef.getVer() != 0)
  {
    // Generate @ 2,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][1].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 2,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][3].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 0,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][1].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 0,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][3].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());
  }

  if (halfPelRef.getHor() != 0)
  {
    // Generate @ 1,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[1][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[3][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 1,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[1][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[3][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }

  // Generate @ 1,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][3].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
}





//! set wp tables
Void  TEncSearch::setWpScalingDistParam( TComDataCU* pcCU, Int iRefIdx, RefPicList eRefPicListCur )
{
  if ( iRefIdx<0 )
  {
    m_cDistParam.bApplyWeight = false;
    return;
  }

  TComSlice       *pcSlice  = pcCU->getSlice();
  WPScalingParam  *wp0 , *wp1;

  m_cDistParam.bApplyWeight = ( pcSlice->getSliceType()==P_SLICE && pcSlice->testWeightPred() ) || ( pcSlice->getSliceType()==B_SLICE && pcSlice->testWeightBiPred() ) ;

  if ( !m_cDistParam.bApplyWeight )
  {
    return;
  }

  Int iRefIdx0 = ( eRefPicListCur == REF_PIC_LIST_0 ) ? iRefIdx : (-1);
  Int iRefIdx1 = ( eRefPicListCur == REF_PIC_LIST_1 ) ? iRefIdx : (-1);

  getWpScaling( pcCU, iRefIdx0, iRefIdx1, wp0 , wp1 );

  if ( iRefIdx0 < 0 )
  {
    wp0 = NULL;
  }
  if ( iRefIdx1 < 0 )
  {
    wp1 = NULL;
  }

  m_cDistParam.wpCur  = NULL;

  if ( eRefPicListCur == REF_PIC_LIST_0 )
  {
    m_cDistParam.wpCur = wp0;
  }
  else
  {
    m_cDistParam.wpCur = wp1;
  }
}



//! \}
