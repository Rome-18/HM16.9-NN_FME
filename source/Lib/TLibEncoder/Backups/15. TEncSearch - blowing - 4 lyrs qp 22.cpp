/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2016, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     TEncSearch.cpp
 \brief    encoder search class
 */

#include "TLibCommon/CommonDef.h"
#include "TLibCommon/TComRom.h"
#include "TLibCommon/TComMotionInfo.h"
#include "TEncSearch.h"
#include "TLibCommon/TComTU.h"
#include "TLibCommon/Debug.h"
#include <math.h>
#include <limits>
#include <fstream>
#include <iostream>
#include <algorithm>


// EMI: Parameters declaration

signed short MVX_HALF, MVX_QRTER, MVY_HALF, MVY_QRTER = 0;
float  C, H1, H2, V1, V2, U1, U2, U3, U4;
long int array_e[100000];

float IN[17] = {};
float X1[40], X2[40], X3[40], X4[40] = {};
float OUT[49] = {};
int N, NN_out, index_ref, counter_i, PUHeight, PUWidth;

/*
The next group of variables are all 1D and 2D arrays. The reason why I declared them as std::array is because that
way they can be assigned in a cleaner manner. These arrays are assigned values in TEncSearch::init() function depending
on the chosen Quantization Parameter
https://stackoverflow.com/questions/16059781/2d-array-value-assign-after-declaration-in-c for more info on 2D array assignment
*/
std::array<std::array<float,4>,8> embs0, embs1;
std::array<std::array<float,17>,40> in_h1;
std::array<std::array<float,40>,40> h1_h2, h2_h3, h3_h4;
std::array<std::array<float,40>,49> h4_out;
std::array<float ,40> b1, b2, b3, b4, BN_gamma_1, BN_beta_1, BN_gamma_2, BN_beta_2, BN_gamma_3, BN_beta_3, BN_gamma_4, BN_beta_4;
// std::array<float ,20> b2, BN_gamma_2, BN_beta_2;
std::array<float ,49> bout;
std::array<float ,9> BN_gamma_in, mean, stdev;

// Helper Functions

float relu(float x){
	if (x>0)	{	return x; }
	else { return 0; }
}

float sigmoid(float x){
  return (1 / (1 + std::exp(-x)));
}

//end of modification


//! \ingroup TLibEncoder
//! \{

static const TComMv s_acMvRefineH[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static const TComMv s_acMvRefineQ[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static Void offsetSubTUCBFs(TComTU &rTu, const ComponentID compID)
{
        TComDataCU *pcCU              = rTu.getCU();
  const UInt        uiTrDepth         = rTu.GetTransformDepthRel();
  const UInt        uiAbsPartIdx      = rTu.GetAbsPartIdxTU(compID);
  const UInt        partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

  //move the CBFs down a level and set the parent CBF

  UChar subTUCBF[2];
  UChar combinedSubTUCBF = 0;

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);

    subTUCBF[subTU]   = pcCU->getCbf(subTUAbsPartIdx, compID, uiTrDepth);
    combinedSubTUCBF |= subTUCBF[subTU];
  }

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);
    const UChar compositeCBF = (subTUCBF[subTU] << 1) | combinedSubTUCBF;

    pcCU->setCbfPartRange((compositeCBF << uiTrDepth), compID, subTUAbsPartIdx, partIdxesPerSubTU);
  }
}


TEncSearch::TEncSearch()
: m_puhQTTempTrIdx(NULL)
, m_pcQTTempTComYuv(NULL)
, m_pcEncCfg (NULL)
, m_pcTrQuant (NULL)
, m_pcRdCost (NULL)
, m_pcEntropyCoder (NULL)
, m_iSearchRange (0)
, m_bipredSearchRange (0)
, m_motionEstimationSearchMethod (MESEARCH_FULL)
, m_pppcRDSbacCoder (NULL)
, m_pcRDGoOnSbacCoder (NULL)
, m_pTempPel (NULL)
, m_isInitialized (false)
{
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    m_ppcQTTempCoeff[ch]                           = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]                        = NULL;
#endif
    m_puhQTTempCbf[ch]                             = NULL;
    m_phQTTempCrossComponentPredictionAlpha[ch]    = NULL;
    m_pSharedPredTransformSkip[ch]                 = NULL;
    m_pcQTTempTUCoeff[ch]                          = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = NULL;
#endif
    m_puhQTTempTransformSkipFlag[ch]               = NULL;
  }

  for (Int i=0; i<MAX_NUM_REF_LIST_ADAPT_SR; i++)
  {
    memset (m_aaiAdaptSR[i], 0, MAX_IDX_ADAPT_SR * sizeof (Int));
  }
  for (Int i=0; i<AMVP_MAX_NUM_CANDS+1; i++)
  {
    memset (m_auiMVPIdxCost[i], 0, (AMVP_MAX_NUM_CANDS+1) * sizeof (UInt) );
  }

  setWpScalingDistParam( NULL, -1, REF_PIC_LIST_X );
}


Void TEncSearch::destroy()
{
  assert (m_isInitialized);
  if ( m_pTempPel )
  {
    delete [] m_pTempPel;
    m_pTempPel = NULL;
  }

  if ( m_pcEncCfg )
  {
    const UInt uiNumLayersAllocated = m_pcEncCfg->getQuadtreeTULog2MaxSize()-m_pcEncCfg->getQuadtreeTULog2MinSize()+1;

    for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
    {
      for (UInt layer = 0; layer < uiNumLayersAllocated; layer++)
      {
        delete[] m_ppcQTTempCoeff[ch][layer];
#if ADAPTIVE_QP_SELECTION
        delete[] m_ppcQTTempArlCoeff[ch][layer];
#endif
      }
      delete[] m_ppcQTTempCoeff[ch];
      delete[] m_puhQTTempCbf[ch];
#if ADAPTIVE_QP_SELECTION
      delete[] m_ppcQTTempArlCoeff[ch];
#endif
    }

    for( UInt layer = 0; layer < uiNumLayersAllocated; layer++ )
    {
      m_pcQTTempTComYuv[layer].destroy();
    }
  }

  delete[] m_puhQTTempTrIdx;
  delete[] m_pcQTTempTComYuv;

  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    delete[] m_pSharedPredTransformSkip[ch];
    delete[] m_pcQTTempTUCoeff[ch];
#if ADAPTIVE_QP_SELECTION
    delete[] m_ppcQTTempTUArlCoeff[ch];
#endif
    delete[] m_phQTTempCrossComponentPredictionAlpha[ch];
    delete[] m_puhQTTempTransformSkipFlag[ch];
  }
  m_pcQTTempTransformSkipTComYuv.destroy();

  m_tmpYuvPred.destroy();
  m_isInitialized = false;
}

TEncSearch::~TEncSearch()
{
  if (m_isInitialized)
  {
    destroy();
  }
}




Void TEncSearch::init(TEncCfg*       pcEncCfg,
                      TComTrQuant*   pcTrQuant,
                      Int            iSearchRange,
                      Int            bipredSearchRange,
                      MESearchMethod motionEstimationSearchMethod,
                      const UInt     maxCUWidth,
                      const UInt     maxCUHeight,
                      const UInt     maxTotalCUDepth,
                      TEncEntropy*   pcEntropyCoder,
                      TComRdCost*    pcRdCost,
                      TEncSbac***    pppcRDSbacCoder,
                      TEncSbac*      pcRDGoOnSbacCoder
                      )
{
  assert (!m_isInitialized);
  m_pcEncCfg                     = pcEncCfg;
  m_pcTrQuant                    = pcTrQuant;
  m_iSearchRange                 = iSearchRange;
  m_bipredSearchRange            = bipredSearchRange;
  m_motionEstimationSearchMethod = motionEstimationSearchMethod;
  m_pcEntropyCoder               = pcEntropyCoder;
  m_pcRdCost                     = pcRdCost;

  m_pppcRDSbacCoder              = pppcRDSbacCoder;
  m_pcRDGoOnSbacCoder            = pcRDGoOnSbacCoder;
  
  for (UInt iDir = 0; iDir < MAX_NUM_REF_LIST_ADAPT_SR; iDir++)
  {
    for (UInt iRefIdx = 0; iRefIdx < MAX_IDX_ADAPT_SR; iRefIdx++)
    {
      m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange;
    }
  }

  // initialize motion cost
  for( Int iNum = 0; iNum < AMVP_MAX_NUM_CANDS+1; iNum++)
  {
    for( Int iIdx = 0; iIdx < AMVP_MAX_NUM_CANDS; iIdx++)
    {
      if (iIdx < iNum)
      {
        m_auiMVPIdxCost[iIdx][iNum] = xGetMvpIdxBits(iIdx, iNum);
      }
      else
      {
        m_auiMVPIdxCost[iIdx][iNum] = MAX_INT;
      }
    }
  }

  const ChromaFormat cform=pcEncCfg->getChromaFormatIdc();
  initTempBuff(cform);

  m_pTempPel = new Pel[maxCUWidth*maxCUHeight];

  const UInt uiNumLayersToAllocate = pcEncCfg->getQuadtreeTULog2MaxSize()-pcEncCfg->getQuadtreeTULog2MinSize()+1;
  const UInt uiNumPartitions = 1<<(maxTotalCUDepth<<1);
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    const UInt csx=::getComponentScaleX(ComponentID(ch), cform);
    const UInt csy=::getComponentScaleY(ComponentID(ch), cform);
    m_ppcQTTempCoeff[ch] = new TCoeff* [uiNumLayersToAllocate];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]  = new TCoeff*[uiNumLayersToAllocate];
#endif
    m_puhQTTempCbf[ch] = new UChar  [uiNumPartitions];

    for (UInt layer = 0; layer < uiNumLayersToAllocate; layer++)
    {
      m_ppcQTTempCoeff[ch][layer] = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy)];
#if ADAPTIVE_QP_SELECTION
      m_ppcQTTempArlCoeff[ch][layer]  = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy) ];
#endif
    }

    m_phQTTempCrossComponentPredictionAlpha[ch]    = new SChar  [uiNumPartitions];
    m_pSharedPredTransformSkip[ch]                 = new Pel   [MAX_CU_SIZE*MAX_CU_SIZE];
    m_pcQTTempTUCoeff[ch]                          = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#endif
    m_puhQTTempTransformSkipFlag[ch]               = new UChar [uiNumPartitions];
  }
  m_puhQTTempTrIdx   = new UChar  [uiNumPartitions];
  m_pcQTTempTComYuv  = new TComYuv[uiNumLayersToAllocate];
  for( UInt ui = 0; ui < uiNumLayersToAllocate; ++ui )
  {
    m_pcQTTempTComYuv[ui].create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  }
  m_pcQTTempTransformSkipTComYuv.create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  m_tmpYuvPred.create(MAX_CU_SIZE, MAX_CU_SIZE, pcEncCfg->getChromaFormatIdc());
  m_isInitialized = true;

  // EMI: Weights and Bias Initialization based on QP

  if(m_pcEncCfg->getQP() == 27){
    
    embs0 = {{
			{{0.26888916,0.33337578,0.26942757,0.3971767}},
			{{0.0048518013,0.043297287,-0.008824279,0.0021500925}},
			{{-0.0075342553,-0.014839634,0.006728149,-0.0018673245}},
			{{0.020745702,-0.07163908,-0.03310908,0.029965091}},
			{{0.021908993,-0.08273415,0.008476719,0.00074990944}},
			{{-0.008009936,-0.2331889,-0.2164679,0.052489445}},
			{{-0.012068137,-0.22542445,-0.15615678,0.016278626}},
			{{0.22077987,-0.60080224,-1.099746,-0.95901775}}
    }};

    embs1 = {{
			{{-0.18688016,0.0007355213,-0.35365492,0.12459138}},
			{{0.020424744,-0.007628322,0.03671953,-0.00021638475}},
			{{-0.0027425757,0.0068448805,-0.021018915,0.00016698838}},
			{{-0.109797366,0.0015004467,0.06415523,-0.014492594}},
			{{-0.019343065,-0.01409941,-0.09645954,0.0035052167}},
			{{-0.11857826,0.0033721866,0.07289964,0.1086809}},
			{{-0.035313357,-0.22693714,-0.24610956,0.051204808}},
			{{-0.4047911,-0.5407213,0.026340954,-1.3581167}}
    }};

    in_h1 = {{
			{{-0.06205056,-0.35290056,-0.17085886,-0.03093076,0.14076932,-0.0027149946,-0.37947422,0.14230068,0.33937028,0.84634465,0.5179456,-0.015585538,-9.091468,-0.28714353,0.35315046,1.7618704,9.276261}},
			{{0.106475,-0.038478512,-0.038874738,0.14463015,0.24839367,-0.011581389,-0.10276053,0.004481586,-0.77762854,2.408172,3.4319596,2.2488587,-0.53393686,-0.81117415,-2.3617988,-7.1781826,9.203312}},
			{{0.010929881,-0.032975428,-0.04102234,-0.009746591,-0.01582309,-0.057727892,-0.013366925,-0.07726804,2.901721,-0.9644129,-6.4703283,1.0182652,1.3778181,3.298214,-2.5790217,-1.8984816,9.976436}},
			{{0.036058843,0.039748468,0.050374635,0.074876726,0.1738276,0.043435615,0.038132843,0.032399498,1.6107361,-3.7441838,1.5366392,0.30319127,0.1167481,-0.9786074,-0.27042404,7.336364,14.390563}},
			{{0.14166173,-0.1381795,-0.019242147,-0.04911218,0.14151356,-0.109705314,-0.14721693,-0.09792631,1.2913625,-0.32723206,1.0107722,-4.8773675,-0.6276112,4.9407687,-0.117250964,0.22388439,-3.1512997}},
			{{0.028258547,-0.06493587,0.051529072,-0.051958356,-0.015319186,0.050087526,-0.053480648,0.009935036,0.57836014,0.27297753,2.189681,-0.5382368,1.4118688,-0.75655,-6.6051335,2.851554,14.506139}},
			{{0.024909379,-0.07826331,-0.05164261,0.031078111,0.013927204,0.0023033412,-0.1207748,-0.0076333554,-0.35257983,1.3250577,-9.426376,0.18225591,0.7959614,0.4455838,0.9224792,1.2213817,1.4526724}},
			{{-0.034434684,-0.036904573,-0.036984455,0.0044503305,0.0022352843,0.02447542,-0.05466938,-0.052179776,-8.6051,1.4200547,-0.06964812,-1.1123106,0.44600558,0.7085214,0.23790993,1.9818953,-12.046127}},
			{{0.05612522,-0.053258315,-0.049601946,-0.082962066,0.20616135,-0.035906706,-0.094146594,-0.21764475,0.37478,0.4535718,-0.63387877,6.473826,-0.4954997,-3.847885,0.5448075,-1.1453211,-4.0227966}},
			{{-0.0034042317,-0.007310502,-0.0024796273,0.017100245,0.011897236,0.007181073,-0.0025964999,-0.007471835,-3.7994056,0.16058457,0.09644091,0.3959259,0.091042444,-0.35414875,-0.07290709,-0.34743732,32.707943}},
			{{-0.037098546,-0.02184826,0.09622031,-0.019358614,0.2773329,0.04349763,-0.051807966,-0.022291442,-0.7937578,0.34028953,3.3398802,1.2353382,0.43074632,-6.4747047,-0.21276964,4.3569326,9.554955}},
			{{0.086764835,-0.09399598,0.030442169,0.015489392,0.1474069,0.10181992,-0.25395727,-0.055025198,0.084465295,1.6414195,3.3661375,-0.9266418,-3.9580152,-1.0733072,0.7427766,6.7843914,16.321978}},
			{{0.038944904,-0.1165917,-0.040001918,0.029891953,-0.16265483,-0.045573883,-0.07998126,0.024584796,1.1195836,0.21934424,-0.2359118,-6.9565787,1.5117892,1.8226818,-0.4790659,1.0555794,-3.4993136}},
			{{0.18147786,-0.79711163,-0.027062135,0.071451694,-0.36080667,-0.15596116,-0.55688643,-0.23473834,-0.99446654,1.9915721,-0.87775594,1.5315607,-7.375366,1.6138308,0.34931263,3.474257,10.917939}},
			{{-0.11416159,0.05675029,-0.084050104,0.031858806,0.26031992,0.032140642,-0.028479006,-0.04986942,6.095314,0.68255955,-4.590063,0.14352731,-1.5620162,2.5416958,-3.3501284,3.634533,4.956368}},
			{{-0.007302549,0.0122601995,-0.011264465,0.011372025,0.10683094,0.013605445,-0.011882047,-0.00807854,0.87629265,-0.10972005,0.26869184,-0.79082423,-0.30955082,1.0720605,0.61201364,1.2442973,-31.37301}},
			{{0.30989602,3.8671997,-2.3637662,0.07695089,1.4588475,-1.7068859,3.2868009,0.017731521,2.2054026,0.9699397,1.2383561,1.9953256,-5.2647686,0.9153282,-1.3367555,8.4430275,7.2875338}},
			{{-0.0127452025,-0.06539125,0.00012233038,0.005950654,-0.08679785,-0.0035518114,-0.037985794,0.02170182,-0.29264957,0.85816336,0.2798071,0.47960874,2.1470857,0.28790626,-0.40317458,-10.321914,-5.884294}},
			{{-0.007813763,-0.13459231,-0.0066805524,0.027717425,-0.10702333,-0.013101047,-0.10787466,-0.0068500806,0.21397544,-6.458878,-0.27586344,0.20158952,3.2919679,0.35352588,0.050470274,3.236864,-3.6190698}},
			{{0.004155157,-0.025466671,0.0070963968,0.0057676947,-0.019397598,-0.0014343722,-0.009436511,0.0062604994,-8.454919,-1.3703815,2.0976155,2.4382021,0.90462697,-0.17364484,0.73064977,0.48918065,-13.785964}},
			{{0.04697719,-0.10657512,-0.052549705,0.03133773,-0.060816657,-0.041547704,-0.0850572,0.021462012,-1.1553674,0.68908817,-0.2240088,1.0087705,2.2158256,-6.145701,-0.4696225,1.960309,-13.21202}},
			{{0.006502851,0.03906795,0.082761705,-0.015540242,0.14226197,0.047210503,0.052887995,-0.0056152917,2.0708876,1.1520886,-1.9235245,-3.2856722,1.011641,0.4664508,2.9268582,-5.6797056,20.014566}}
    }};

    h1_h2 = {{
			{{0.35094085,-2.2402449,-0.1899432,2.12071,-2.3197274,-1.5581638,0.54768217,-4.3301105,0.10796151,-0.8270882,-0.32651496,0.03813263,-2.3699894,2.6702452,1.0795506,-3.2972543,-1.7485937,-3.2245114,0.08564647,-0.5345541,0.55380297,-0.92347175}},
			{{-0.13892595,-1.1600838,-0.71871233,-0.56147826,1.4583054,-0.63852006,-4.5078773,0.28163454,-17.80308,-0.85855585,-0.5010922,0.8611811,0.7203713,1.469543,-0.26100937,-1.3725061,-1.5335901,0.20998645,1.0077381,-0.41116214,-2.1185532,-0.27265194}},
			{{0.3079511,1.0750291,0.5049704,0.8935327,-0.51759446,-1.1526767,-1.6026238,-1.4446186,0.3119105,-0.7113408,-3.206323,2.12646,-2.1710691,2.4642508,-0.8686417,-0.5530051,-1.5335767,0.46945602,0.5356811,0.1500205,-2.8925562,-0.79467994}},
			{{-0.1371943,0.01638802,-0.04297027,-0.3389799,1.2207017,-0.3633783,-0.55255103,-0.93430597,-1.9512007,-0.906236,-1.4181786,1.0477778,-0.24240734,1.5967987,2.1774058,-1.0066862,-1.7927074,0.21652652,0.35408664,-0.40967813,-1.5735074,-0.6679476}},
			{{2.4858496,-0.76165456,-0.3517925,-0.94289786,0.37053475,-1.4792296,0.13063738,0.14434257,0.48796114,-0.2882178,0.09113615,2.5568302,0.96494746,1.6070769,0.29534578,-0.5776445,-1.617194,-2.1622865,-2.1062133,-0.80959475,1.5881277,-1.1188457}},
			{{0.2699315,0.06951124,-12.836189,1.0374107,-1.2934433,-2.5519533,-4.727695,-0.46610394,0.10499331,-1.3989019,1.580358,-1.7766451,-3.696533,2.2707334,-3.898118,0.025809456,-1.0685409,-1.0034182,0.47761568,0.3056113,1.5203408,-8.1998625}},
			{{0.33145577,1.4343811,-1.2619538,-4.2770047,-0.21141861,-0.55467916,-3.0694506,0.22544861,-1.5746648,-2.2796106,-0.26662084,-0.2744821,1.7530524,2.611429,-0.321195,-0.9298099,-1.6583027,-0.6345922,-4.1202707,-1.236761,-0.05696857,1.4528233}},
			{{0.6649986,-3.2696273,-0.97046334,2.992011,1.0387673,-2.819785,-2.7294092,0.37235475,-1.6290104,-0.18846889,-0.07836999,-0.19418149,1.8009968,2.8629882,-1.501163,-1.0391941,-2.858956,-5.1101813,-0.18903583,-0.052934773,1.0198922,-2.2331572}},
			{{-0.2090871,-0.4863,-0.3434963,-0.15692429,-14.244794,-3.507891,-0.327892,-4.7131414,1.0962831,-1.3126769,0.5506627,0.26604748,-1.0746812,2.1443985,-1.0832554,-3.2378063,-1.5466508,1.0739665,0.78134483,-0.5170236,0.33557218,-0.6794828}},
			{{3.5604343,0.3686872,2.8006117,-0.07721485,1.243771,-0.1532469,0.29830387,-0.07404779,0.5372764,-0.57433385,-3.5204198,-2.4241369,-0.86414254,0.6292585,-3.0412486,-3.2954564,-2.2026162,0.70872927,0.96881056,2.8033655,-4.0779014,-1.4233943}},
			{{1.1375115,-0.98163444,-2.7333426,-2.420467,-0.049400855,-0.8016565,-1.0057743,0.46772525,0.06104554,1.4204303,-0.8316258,0.48675457,-2.2376308,2.7042665,-3.5708475,1.9274199,-2.084789,-3.028697,-1.78003,0.23304671,-1.444798,-3.7727928}},
			{{0.2787427,-3.8977058,-1.6968523,2.1526449,0.26585564,-0.5777819,1.0322582,-5.1364098,-0.8909205,-1.7032422,-0.6330761,-3.6418428,2.8178172,3.1043227,2.5000916,-1.1715995,-2.3278046,-2.4642208,-0.89261997,-3.7265446,-1.7824707,-1.2786335}},
			{{0.1468516,2.2869775,-1.2811421,-0.66315,-2.175888,-1.4759085,0.8499608,-0.89643914,-1.2093097,0.49633095,1.9841406,-3.5020623,-2.4993303,3.585398,1.3752866,-8.656708,-1.892992,-0.10636012,-2.101777,-6.399404,0.18612,-0.5168197}},
			{{0.3187965,0.8776294,-0.03385597,-2.157772,0.27649468,-0.31644908,0.63999206,-2.2176418,0.67728674,0.060577005,-0.6455512,1.2257292,-0.031750217,1.6234127,0.9185435,-4.135025,-1.7360418,0.18702967,-2.8012435,-3.063499,-1.7824427,-0.56632155}},
			{{8.336277,0.23362431,-0.3214503,0.22865617,1.1477137,-0.6676485,-0.20343372,0.10704715,0.5659633,-0.0055566705,-1.2266669,-3.577075,0.8880544,-1.3492509,0.15086433,-0.03396892,-2.279213,0.83596766,0.7386306,-0.25862324,0.39894703,-1.2986002}},
			{{0.094671555,1.5624152,-2.5905702,-1.3493106,-1.9703066,-1.5833949,-1.0344691,-0.78521127,0.48159406,-14.881109,0.93155867,-1.241062,-0.77729714,2.2357914,-2.0795553,2.5020876,-1.8124553,0.27522323,0.26213428,-0.3391898,0.8248072,-0.9162607}},
			{{0.6346298,-1.0644522,-12.560466,-4.602836,0.99542594,-5.6723986,-0.688924,0.36092505,0.40686184,0.9942901,-0.7643233,-3.294334,0.4974624,2.586748,-2.7569902,3.6963434,-1.4336312,1.0329549,-1.8438996,-0.5574699,-1.0923316,-0.59785414}},
			{{2.4036782,1.6507438,-0.71953446,1.9461348,-0.38766816,-2.2943404,-2.2732177,-2.0516312,-0.8682256,-1.5863603,-2.6366065,-1.9373174,-2.469638,5.1838274,-0.68299,-0.7010495,-1.8912034,0.40655643,0.40518835,-0.2576297,-2.84953,-0.48186648}},
			{{0.79366726,2.8408353,-1.3921822,-0.92032325,0.45316005,0.5040676,-1.2483644,-2.6600072,-3.4523458,-0.7358735,-0.49137264,-3.8292105,-0.6162937,2.0696054,3.5619512,-2.952356,-2.7494411,-1.4761109,0.10497004,-11.780169,-0.016464291,-4.367115}},
			{{1.9874853,-2.898325,-1.1393987,-2.0905585,1.562599,0.7442111,-1.2687485,-1.0680461,0.38125464,-1.678275,1.2116766,1.7678914,0.46113765,2.7411454,1.0333128,-2.5381014,-2.5871656,-4.540075,-3.7753105,-0.6407381,0.16413058,-1.3504753}}
    }};

    h4_out = {{
			{{-3.066898,0.33597252,-4.3193107,-5.9171557,-1.4519075,0.1585446,-1.307392,0.26427296,-2.0777688,0.72498894,0.9315726,-1.7895601,-0.18311319,-5.3318124,0.47089276,-2.657698,0.94375306,-5.579117,-6.7812314,-3.3494408}},
			{{-3.8382218,0.8723686,-0.8508142,-1.8907461,-4.017043,0.05642419,-3.286129,1.3037126,0.18308787,1.2933713,1.0631888,-3.1651897,-3.1137052,-6.6733828,0.9947935,-1.9616302,0.65434134,-2.965401,-4.335585,-4.7650056}},
			{{-1.3334192,0.17848012,0.20237091,-0.6668556,-6.296603,0.89948446,-4.5818176,1.1195525,-0.2715365,1.131891,-0.3903994,-2.1460447,-3.657837,-9.043678,0.20865734,-1.8548945,-0.7890347,0.80833966,-1.8982964,-6.455065}},
			{{0.25737804,-0.8342683,0.28947586,-0.20062467,-5.7464275,0.31966275,-6.7188654,0.41323593,-0.9750862,0.510417,-2.6556249,-0.25093982,-2.7764225,-4.642855,-1.0192517,-0.5433152,-1.4663838,1.1000988,-0.30659217,-5.212606}},
			{{1.3635522,-1.3905246,0.4155117,0.3156958,-5.1820226,-1.0285122,-6.480496,-0.2273342,0.23929483,0.9564057,-5.936832,1.3524238,-1.6392542,-2.4697106,0.31916192,-0.92729574,-3.9550247,0.5047273,-0.38671678,-4.6871114}},
			{{1.8220454,-1.5600618,-0.83586097,-0.24619363,-3.1651537,-1.5776894,-4.3183527,-2.232596,0.93256444,0.87008345,-6.4551415,1.6517231,-0.4721319,0.019785374,0.9320186,-0.88896513,-5.7873363,-3.248359,-0.20928088,-4.693013}},
			{{1.2193208,-3.5418696,-6.419055,-0.62468106,-2.2244475,-2.4114418,-3.6295211,-1.3947701,-0.20606567,0.6099411,-4.315041,1.2826613,0.37429148,0.03990931,0.62928414,-1.163504,-5.003934,-6.729938,0.21595964,-2.4657507}},
			{{-2.2376385,1.3145744,-5.1392307,-9.28425,-0.29371154,-0.89478725,-0.2890302,1.5292064,-4.2114506,-0.9162807,1.1116388,-2.229063,-1.3736753,-4.9795732,1.0150046,-1.8020424,0.7387924,-10.033238,-3.8260446,-1.2612056}},
			{{-2.5452945,1.3313079,-0.9764796,-1.5793886,-0.9829576,-0.61390364,-2.2224698,1.7981511,-1.4229046,-0.42024714,1.0602186,-1.1185387,-3.4425783,-5.8023376,1.0033271,-2.7365422,0.80811685,-4.6861796,-2.9851909,-3.1755347}},
			{{-0.4755881,0.47714654,0.7258598,-0.12189527,-1.9181178,0.52068126,-3.137563,1.6696932,-1.0549392,-0.60526407,0.615335,0.21175581,-4.3982015,-6.1673527,0.7833304,-2.514501,-0.9871368,0.28132817,-1.6935302,-3.3175735}},
			{{0.7111771,-0.93454254,0.77698946,0.6218478,-1.9828802,0.98585284,-4.007147,1.297756,-0.8039556,0.2812075,-1.5475285,1.0714691,-3.8891544,-4.896421,-0.36554307,-0.94877124,-3.101908,0.7842019,-0.5285244,-2.9719925}},
			{{1.532712,-1.7115608,0.33408797,0.12741388,-1.7534162,0.6465887,-3.802126,0.72971314,0.52892923,-0.72826326,-4.106918,1.533637,-1.7484101,-1.2558686,0.7459857,-1.1483244,-4.3613462,0.2574915,-0.77873456,-2.134241}},
			{{1.77803,-2.359384,-1.7161206,-0.9837191,-0.99470335,0.1875843,-2.9066608,-0.060650334,1.343257,-0.272496,-6.839042,1.4163661,0.05726755,0.39479586,0.5605167,-1.4331193,-5.526842,-5.5432286,-1.2094295,-1.9107502}},
			{{1.6037307,-2.90865,-9.361994,-1.1249639,-0.53895444,-2.166398,-1.0920125,-0.046345837,0.125311,-1.3265362,-7.525629,1.1254019,1.2216245,-0.0883723,0.601887,-1.8534551,-4.2412987,-8.795844,-1.3030221,0.14426555}},
			{{-1.4020936,1.8783013,-6.7523994,-6.1049705,0.32907194,-2.449745,0.62714183,0.955518,-4.4325776,-1.8453784,0.30462673,-1.1657361,-2.65002,-5.1691008,0.45084414,-1.6615989,0.5161384,-10.211124,-2.2577465,0.36013895}},
			{{-2.170781,1.9126688,-0.7984417,-0.6703616,0.68824244,-2.3110282,-0.5281962,0.9738895,-1.6637805,-1.9485301,0.19450593,0.57711375,-3.6335447,-5.14275,0.8531755,-2.6455173,0.9918387,-4.986569,-2.1581345,-0.35603845}},
			{{-0.7985861,0.23418935,0.59653986,0.84627545,0.46060294,-1.022204,-1.592849,0.8024595,-1.1363257,-0.8493021,0.633168,0.93304783,-4.676906,-4.5239882,0.84121126,-1.5705754,0.3085501,0.3597514,-0.6534184,0.09124972}},
			{{0.45091185,-1.061355,0.89863145,0.62177604,0.22753738,0.31893027,-2.0340052,0.5562612,-0.8663485,-0.09152598,0.12321731,0.52001154,-2.6921961,-2.2764153,-0.55414414,-0.7042064,-2.1222668,0.7032,-0.47533277,0.25435078}},
			{{0.8856428,-1.5220866,0.5108761,-0.41985595,0.38129228,1.2943358,-1.9225384,0.12525812,0.33291212,-0.4782512,-1.72376,0.07782341,-0.51151925,-0.22873364,0.48234576,-0.53630596,-4.588667,0.102802515,-1.3113252,0.33338684}},
			{{1.0830115,-1.5328617,-2.1400847,-2.1691468,0.2847174,1.0263671,-2.0228631,-0.13029212,1.7165205,-1.9579799,-3.3428383,-0.5013263,0.8596006,0.44840267,0.762657,-0.48737705,-5.0746436,-4.9462543,-1.5131612,0.48755726}},
			{{0.9162966,-2.9620821,-10.2780285,-1.1686447,-0.34274387,-0.7210792,-0.9803669,-0.081343554,0.91863644,-3.4837945,-5.131263,-0.8731665,1.6097764,-0.7511817,0.07968486,-1.3703616,-3.8215487,-6.1191225,-1.6473702,1.5227057}},
			{{-0.4937812,1.6350044,-5.752102,-2.1065938,-0.12759317,-3.5973747,0.7381057,-0.09112318,-3.6400151,-3.354544,-1.987856,0.07687807,-2.7193139,-3.4447966,-1.3548948,-1.2812862,-0.4427916,-6.1202593,-1.0882374,0.916395}},
			{{-1.7774154,1.7100859,-1.4481148,0.41708422,0.63411653,-4.7994804,0.58793485,-0.107667446,-1.6882156,-2.5073094,-1.4795358,0.9909748,-3.568137,-3.2109563,-0.5885503,-1.5473729,0.81577194,-4.4396195,-1.0074238,0.6196923}},
			{{-0.7025387,0.5488594,0.32630196,0.8476636,0.7457396,-2.6700466,-0.041643098,-0.52725047,-1.2148969,-1.8033645,0.2436905,0.49941403,-2.9298956,-2.0252852,-0.6812175,-1.1452378,0.613915,0.63106275,-0.01848799,0.7994851}},
			{{-0.01595192,-1.2572938,0.68198705,0.26124382,0.641662,-0.7948483,-0.6343308,-0.57397574,-0.96203816,-0.74104136,0.62164676,-0.7436562,-1.0457451,-0.60850054,-1.8617029,-0.2999391,-0.37847218,0.6678042,-0.41183636,0.7086558}},
			{{-0.17956927,-1.467107,0.36408314,-1.2503222,0.8174676,0.78850794,-0.71645314,-0.6577471,0.7404123,-1.7387198,0.26613167,-1.6384454,0.4425627,0.14847042,-0.78489476,0.01347125,-2.0864162,0.21990535,-1.1012096,0.8184835}},
			{{-0.57023335,-1.391772,-2.1475918,-4.3651133,0.62581533,1.5164584,-1.0217779,-0.5318343,1.822747,-3.0066934,-1.2873352,-2.9052937,1.0600275,0.2630437,-0.53226715,0.51169133,-3.7908056,-5.2637315,-1.6727047,1.0903986}},
			{{-0.52767795,-2.6107392,-8.27047,-3.9067993,0.05821217,0.45179346,-0.42848146,-0.2175615,1.0498726,-3.6186957,-1.8428042,-2.4806764,0.1552082,-1.6762105,-0.9500483,0.095106274,-2.897252,-6.2431726,-1.648091,1.3366858}},
			{{-0.6426221,1.0529166,-8.678345,-0.6726559,-0.97339517,-4.553662,1.1803737,-0.9103235,-3.6852348,-2.732604,-5.687733,1.1820695,-2.0410857,-1.8510122,-0.047169846,-2.3725867,-1.426912,-8.337407,0.3348643,1.930513}},
			{{-1.3143848,1.4457488,-1.7633926,1.0154039,-0.44482473,-4.691282,1.2386998,-1.5315621,-1.6591095,-1.9965184,-4.064885,0.64440095,-2.7810142,-1.421254,0.75789475,-1.9414196,0.043090105,-4.1736703,0.75955534,0.8975732}},
			{{-0.19275106,0.20562771,0.26215583,0.9093468,0.25794888,-4.1661944,0.9412055,-1.8827757,-1.284355,-0.7927206,-1.7959061,-0.9382245,-1.3369777,-0.7341001,0.5091127,-0.98117954,1.2115258,0.46854162,0.7045803,0.42777827}},
			{{-0.798324,-0.9508906,0.6754302,-0.31972557,0.449288,-2.0962148,0.62119126,-1.7672268,-0.51591223,-0.1547734,-0.07168338,-2.546306,0.5057787,0.081473716,-0.76439923,0.038688723,0.81409514,0.82605094,-0.5663353,0.0931513}},
			{{-2.0547943,-1.0319499,0.41059464,-3.0558786,0.6486855,-0.15036665,0.14065933,-1.3586587,0.8275868,-0.6525431,0.36955187,-3.6261907,1.0326712,0.2659703,0.6673085,0.7835342,-0.18074036,0.20892648,-1.6415908,0.31100494}},
			{{-2.3758476,-1.0790728,-2.1287808,-7.037675,0.739997,1.3696635,-0.1560831,-1.2352136,1.6891729,-1.7250944,-0.007370657,-3.2659287,0.36849734,0.14300235,0.9623716,1.8196745,-1.2016879,-5.4825087,-2.274796,0.18472293}},
			{{-1.8095647,-2.0080717,-10.158643,-10.557332,0.40853894,1.4257499,0.22408535,-0.46138996,0.2877154,-2.6438196,-0.06870861,-2.989226,-1.262832,-1.9730976,0.57505566,2.0180683,-0.6549924,-10.22548,-1.7852268,0.6364764}},
			{{0.4461632,0.035924073,-8.933114,-0.09234405,-3.104706,-3.8404527,1.5087941,-2.6001623,-2.5813222,-1.7315909,-4.4373326,0.22585319,-1.8311411,-0.9743249,0.743812,-2.558144,-3.380929,-10.405035,2.2260115,1.9071939}},
			{{0.02887681,0.86866695,-2.048456,1.036821,-3.4686303,-3.6429226,1.4390725,-3.0782397,-1.528878,-0.6544497,-5.3817587,-0.88780946,-1.462845,0.06698537,0.7134323,-2.0425618,-1.6483307,-4.2938547,1.8612311,0.30221236}},
			{{-1.353149,0.19976316,0.12863132,0.688166,-1.9919474,-3.238766,1.297858,-3.2674317,-1.1637446,-1.1785905,-4.2000723,-2.230186,0.53818476,0.40496272,0.7842975,-0.93631274,0.43051586,0.52497816,1.1827406,-2.1583009}},
			{{-2.2870598,-0.9260336,0.63505286,-0.8714629,-1.9665816,-2.520462,1.27416,-3.4174604,-0.25524274,0.21522152,-1.9934747,-3.3176212,1.0344235,0.18277681,-0.47040686,0.15749346,1.3876754,0.98268235,-0.93098015,-3.157776}},
			{{-3.0142355,-1.0701418,0.503319,-2.765654,-1.3761343,-0.5833733,0.9854207,-2.278635,0.75932634,-1.0285566,-0.22319059,-3.2748365,0.25221038,0.06519047,0.5812951,1.4983788,1.229669,-0.10668402,-2.0521734,-3.7265184}},
			{{-3.4297566,-1.0007738,-2.0691917,-4.9278097,-0.5295277,0.7313919,0.48950118,-1.3534662,1.3243787,-0.83828425,0.38064462,-3.9052289,-0.96967643,-0.62908936,0.9287864,2.7324648,0.5805016,-4.119846,-2.381443,-2.7677054}},
			{{-2.9156199,-0.81683433,-5.7033615,-10.749707,-0.3134151,0.9188053,0.8333489,-0.7849528,-0.3210946,-2.3502462,0.74896735,-2.9670324,-1.4278603,-2.7352204,0.99415934,2.7581046,0.16869605,-7.9184847,-2.2087672,-1.0049262}},
			{{0.23007649,-0.84519726,-5.815947,0.053247098,-4.449718,-3.6603453,-0.3012601,-3.8331566,-2.7845886,0.23953818,-2.6958504,-0.51387656,-1.1872458,-0.18816285,0.7680459,-1.7141556,-3.9536788,-6.466744,2.5406759,-0.2937594}},
			{{0.4044079,0.49627456,-1.013548,0.87338257,-4.6598396,-3.9216983,0.040972915,-4.397419,-0.6225199,0.33603317,-5.70017,-1.9232651,-0.7010463,0.40177432,1.005409,-2.1844537,-3.5444944,-2.7960732,2.4837375,-2.8121498}},
			{{-1.2155232,-0.19252086,0.29376194,0.5111527,-5.03778,-2.6554613,0.004648141,-6.176399,-0.6982954,0.24920438,-5.3030076,-1.9827203,0.809459,0.31056398,0.21699119,-1.6209613,-1.1472052,0.8443454,1.1571301,-6.9383564}},
			{{-2.0595171,-0.96969587,0.35174164,-1.1054661,-4.9201584,-1.1765217,-0.019884787,-5.362471,-0.38249588,0.46863303,-3.305183,-3.6134408,-0.07649077,-0.6402233,-0.7983068,-0.18159266,0.8280754,1.1670134,-0.5752589,-4.8521304}},
			{{-3.9415202,-1.0034428,0.14742163,-2.450942,-5.236689,-0.4546354,0.08204179,-3.8641174,0.8691916,0.24460061,-0.86552376,-3.8773582,-0.67738736,-3.4745033,0.24794574,1.4960473,1.8535928,0.52248293,-2.1050828,-6.7286286}},
			{{-3.966066,-1.0987251,-1.2574024,-2.3734457,-3.5381832,0.3199425,-0.59736323,-1.4395517,1.3117973,0.17840424,0.23714986,-4.839118,-1.1276605,-4.32524,1.0083866,2.660343,1.6395502,-2.8541398,-3.0613978,-4.668307}},
			{{-1.6701401,-0.63114583,-4.3917913,-6.6908655,-1.6874294,0.7860625,-0.5538958,-1.5358143,-1.1143105,-0.6799871,0.47498232,-3.7217052,-0.7955002,-3.7695148,0.76843154,2.4424388,0.9572536,-4.1430864,-3.9546835,-3.3034892}}
    }};

    b1 = {
			-0.60210836, 0.18945721, -0.26552498, 0.2640773, 0.2180244, -0.4247985, -0.42111692, -0.4025271, 0.33799252, -0.019199293, 0.009905055, 0.724221, -0.49563923, 0.3963077, 0.26111564, 0.05002394, 0.28496352, -0.31952268, -0.50277406, -0.26096177, -0.69376665, 0.17874445
    };

    b2 = {
			0.74696624, 0.3846849, 1.5476271, 0.9965938, 2.132027, -0.5797378, 0.5872936, 0.55615634, 0.7494177, -0.0038235558, -0.18315186, -1.094765, -0.83366734, 0.430824, 0.020939147, 0.33440065, -1.2245744, -0.41185778, -0.84126973, 0.41897535
    };

    bout = {
			-2.407016, -1.8684318, -1.453138, -0.7228578, -0.9929487, -1.3253256, -2.1858861, -2.312111, -0.82392985, -0.23452261, 0.66780365, 0.09397568, -0.5964343, -2.452249, -1.836157, -0.39621726, 1.1300654, 1.6598724, 1.3922262, -0.07923506, -2.118753, -1.2336315, 0.3074725, 1.5711837, 2.5573614, 1.5986004, 0.3353753, -1.6927739, -2.1762505, -0.40862727, 1.2885319, 1.7262784, 1.236852, -0.2640607, -2.1991682, -2.550665, -0.6349711, -0.21275407, 0.4729668, -0.14078999, -0.49896806, -2.0212617, -2.2288725, -1.4638003, -1.5718899, -0.99863434, -1.472633, -1.4711082, -1.7023442
    };

    BN_gamma_in = {
			0.33374506, 0.88557863, 0.44883358, 0.6509423, 0.9652897, 0.7312501, 0.6207009, 0.34989476, 0.03389716
    };

    BN_gamma_1 = {
			5.6786466, 3.4703245, 7.2192545, 3.6617916, 2.8335927, 8.479494, 7.4399743, 8.978987, 2.6377435, 12.0498295, 3.0441427, 2.3028302, 8.49144, 2.6803298, 3.0796738, 9.467199, 1.8655304, 11.495024, 8.181942, 9.062074, 10.924568, 5.1439013
    };

    BN_gamma_2 = {
			0.17893454, 0.1971101, 0.11917643, 0.1379635, 0.12006492, 0.22108577, 0.18737441, 0.1874615, 0.1936909, 0.19751711, 0.19040631, 0.2782673, 0.29314083, 0.1359517, -0.28042123, 0.22073679, 0.25191358, 0.16657636, 0.313996, 0.15935662
    };

    BN_beta_1 = {
			-0.43478298, -0.40837958, -0.017061608, -0.5742905, -0.13781892, -0.099713504, -0.1672824, -0.1082751, -0.14699878, -0.08220062, -0.502702, -0.44958055, -0.20099999, -0.5442624, -0.2989939, -0.23611149, -0.011625829, -0.20057993, -0.28376234, -0.035505958, -0.23717202, -0.48265147
    };

    BN_beta_2 = {
			-0.25091317, -0.28539738, -0.12927878, -0.092178956, -0.18537998, -0.10818178, -0.12726577, -0.15941255, -0.21386056, -0.23076798, -0.0786912, -0.0819933, -0.09125569, -0.08367135, 0.299151, -0.2578983, -0.09530835, -0.04725937, -0.14871296, -0.08736679
    };
    
    mean = {
      57479.15596430949,35502.85275136948,53428.18770928572,46543.56181859651,17589.15456102924,46240.91567667166,53692.6507076018,35119.45035165905,57276.29801354078
    };

    stdev = {
      207677.34728660225,154962.88030363916,191576.07600115417,181696.56921362053,127069.28025293918,180191.77552818554,192388.33261921056,154020.73044885873,205901.42822234138
    };
  }

  else if(m_pcEncCfg->getQP() == 32){
    
    embs0 = {{
			{{0.27178106,0.1562536,0.29687002,0.19387302}},
			{{0.0005826703,0.04503933,-0.012307142,0.0020174638}},
			{{-0.0009466682,-0.00960623,0.011385387,-0.0021233724}},
			{{0.07860421,-0.050415576,-0.021897053,-0.10868027}},
			{{0.0068658455,-0.07425601,-0.0014656468,0.009458856}},
			{{-0.13870968,-0.18110885,-0.12789325,-0.22385864}},
			{{-0.026851362,-0.1893832,-0.09772639,-0.014543245}},
			{{0.14630552,-0.5311645,-0.7479692,0.11717225}}
    }};

    embs1 = {{
			{{-0.24382272,-0.02293396,-0.081736326,-0.308432}},
			{{-0.008461359,0.01221801,-0.040905356,-0.002273267}},
			{{0.007605914,0.002354036,0.015264896,0.003054202}},
			{{0.011686197,-0.2013675,-0.051249437,-0.057847563}},
			{{-0.0045802975,-0.010979273,0.08206608,-0.010402694}},
			{{-0.015234189,-0.26718876,-0.010512383,0.19019148}},
			{{-0.13180132,-0.052574083,0.20649542,-0.06308843}},
			{{-0.63776934,-0.26613146,0.4637781,-0.4099232}}
    }};

    in_h1 = {{
			{{-0.0007222936,-0.16729552,-0.084687114,0.0103214355,-0.025339566,-0.09943552,0.09472984,-0.16694811,-0.34150082,-10.190184,4.5201325,0.4631142,2.7785094,-1.5521905,1.767668,1.421891,0.5205178}},
			{{-0.03343856,-0.1283778,-0.0131712975,-0.0034226263,-0.0062364326,-0.09917375,0.10278422,0.012169279,-0.4293848,0.5047209,0.6589794,-9.607029,2.6884062,3.246944,-0.5600475,0.01772281,0.2585595}},
			{{-0.010130377,0.079061486,0.04699638,-0.07449548,0.052406017,-0.35339037,-0.025647739,0.12171437,1.4016248,-1.8974005,-2.8385973,5.1811395,-0.3313903,-9.074126,-11.952666,0.65552396,1.2825204}},
			{{0.012098921,-0.11555442,-0.010076737,0.007689509,-0.011739936,-0.4001231,0.026372138,0.14192547,1.3723336,-6.8596897,17.743591,-0.59488523,-1.2755471,0.5277019,-5.690724,3.2699444,-0.40980852}},
			{{0.003955381,-0.011323103,-0.010288339,0.0044367197,-0.008879286,-0.012994118,0.0054098517,0.013618643,0.32071397,0.49671078,-31.124008,-0.057790007,-0.013990506,2.0024776,5.149352,0.050921395,0.0873149}},
			{{-0.10146686,1.7724854,-0.9862231,0.056964666,-0.52665144,-0.26059234,-1.652385,-0.5145191,-0.70732236,2.1951363,-8.800853,3.2464542,-4.8417273,4.750741,-16.88138,2.5581748,-1.5810698}},
			{{0.021718698,-0.400763,-0.0062290244,0.24771564,0.12885864,0.03902137,0.23085143,-0.41254598,2.8093712,2.8800006,-8.70334,-2.2556064,-2.9603388,-6.6868806,-6.3275757,1.0831944,4.2791963}},
			{{-0.012122147,-0.09093992,-0.049011182,-0.025537329,-0.0676107,-0.11308133,0.063605316,0.052529424,0.4139118,-0.15221612,1.0963707,1.8587861,1.6831055,-12.7516775,1.8157268,0.13249719,-0.070772596}},
			{{-0.01025639,0.053482298,0.095963,0.010544924,0.0036512953,0.03790084,-0.0050996756,-0.015966693,-5.6376657,-1.710763,-13.909494,-1.4102304,4.1660333,-2.6015239,-12.0245285,-0.64730847,-4.4021273}},
			{{0.04843131,-0.3295965,-0.08245097,-0.007570107,-0.07049912,-0.89569366,0.08228426,0.23854816,-0.15401743,5.971915,2.9002252,0.5896565,3.0523846,-0.94868654,1.0847206,-5.965654,0.6110476}},
			{{0.0036841854,-0.79190207,-0.19270067,-0.014087026,-0.31594685,0.3466838,0.9202676,0.07184742,-1.5765762,1.2057122,5.380285,-4.2357626,-10.102044,-0.73568827,2.1889038,1.1567936,0.75898826}},
			{{-0.03505506,-0.16561766,0.012925229,0.08180655,-0.09259458,0.13518721,0.24068047,0.05570491,-2.6303434,-2.0732386,5.315644,2.6399543,2.0142345,8.132688,4.052682,-1.2937635,-4.8726416}},
			{{0.046944473,0.84348124,-0.2965688,-0.04258306,-0.32035396,0.12232241,-0.8285533,-0.08964593,3.2413516,-3.024646,19.912468,-2.1461077,0.45365998,0.60463434,21.316551,-1.6615728,1.7984512}},
			{{-0.030184686,-0.08089985,-0.02805699,0.040920258,-0.037074752,0.060537625,0.13086022,-0.031024417,-0.26306146,-1.8276106,-22.04345,1.9356097,1.559581,3.941801,-17.816648,-0.57147104,-0.06507938}},
			{{-0.016717996,0.016888928,0.014745781,-0.029568031,-0.018817203,-0.15261616,0.018475315,0.06585316,2.1849084,0.2987483,-8.278772,-6.3332415,-0.42156404,7.9931474,9.481775,0.39207855,-1.1558123}},
			{{0.022971887,-0.052988295,-0.046114657,0.038577326,-0.00093727943,-0.028171137,-0.030185271,-0.0679245,5.106966,-1.6262915,3.5399375,-1.5276268,0.6593049,1.5460359,9.697568,0.9474646,-6.2484307}},
			{{0.008496091,-0.010261549,-0.016958926,-0.0034088388,0.0010616628,0.023558544,0.0072159255,-0.01734435,2.7616343,-0.60846037,-5.0357113,-2.5235395,-1.4013602,8.646088,17.485699,-1.0206221,0.23682547}},
			{{-0.020039653,-0.081539415,-0.0081595285,0.009911343,0.05658702,-0.041935336,0.14773782,-0.107275225,-1.6523757,4.208569,18.970922,2.8962831,-2.5874503,-4.0757113,10.526065,-0.506362,0.0070581576}},
			{{-0.01619768,-0.0043124887,-0.022691846,0.016156964,0.015731832,-0.049525384,-0.010858982,-0.014762219,-7.078418,2.3212147,8.895474,1.0891938,-0.2804251,1.075912,15.847625,-0.22913104,0.20572418}},
			{{-0.012124357,-0.009979954,-0.02627301,-0.017955258,-0.016156718,-0.07271752,0.0054838867,0.016186016,0.40325722,0.6086555,4.633067,1.3196052,-0.29583824,-0.14050202,-27.535728,-0.052492503,0.34495702}},
			{{0.0047819563,-0.8823443,-0.40813714,0.050036695,-0.1836177,-1.0841756,0.5213021,-0.25813788,-0.11442537,2.817391,-2.9369898,2.1360528,-8.096101,4.321172,-6.8684907,1.8101056,-0.82485896}},
			{{0.084378056,0.16556393,-0.12137975,0.018480495,0.08509416,-0.8410589,-0.37786156,-0.18971847,-0.0014161459,0.12527682,-12.02242,-0.39602813,8.065005,2.0153701,-7.1658363,0.43440783,-0.8108726}}
    }};

    h1_h2 = {{
			{{0.46733418,-0.16096526,-1.3779025,-0.5296222,1.9656878,-2.678903,-0.8880296,-1.216787,1.4795922,-0.84599626,1.2665863,-0.34892502,-2.2388778,-1.0417763,2.1684644,-0.98697627,-1.8831486,-2.9729075,-7.588645,6.154331,1.8518957,-0.010169139}},
			{{-2.239726,-0.25071865,-0.75759727,-3.3061647,2.160107,-1.9541756,-3.476842,-0.58239156,0.9342924,0.22045998,-0.5249128,1.5794525,-1.3143777,-2.0263789,2.122949,1.1670951,0.19015893,1.3319883,-0.17510694,-4.9378767,2.8849232,-0.1608168}},
			{{-0.32668984,0.12981117,1.9893602,1.6028223,1.8229938,-1.9418769,0.22062477,1.2011495,-0.7327636,-1.8713267,0.1929405,-2.1528292,-1.1566775,-3.8592072,1.5171715,-1.392965,-0.015816906,-0.22044297,-1.0548717,-1.2520225,2.0698447,-0.27751744}},
			{{-0.39088312,-0.48896208,-2.8215268,-0.2341731,9.330177,-1.8825034,-1.3981965,-3.6152613,0.29165912,1.2681972,-0.6619432,-0.45701802,-2.3732085,-0.82476234,2.6876252,-5.483071,2.36215,-0.7234621,-0.6154284,-2.0054624,2.3300169,-0.44491145}},
			{{-1.2019414,-0.5693807,1.6550012,-4.528651,0.54617167,-1.9706175,1.2085274,1.5202929,-0.051495034,1.9063284,-0.571999,-4.360171,-0.9610814,1.7622883,-2.3884022,-2.808616,-0.45676467,-0.34714893,-2.0186343,-0.6157769,1.3386554,-1.0139021}},
			{{-4.5395913,0.8045448,-0.6106717,-3.6995637,3.6082418,-2.7155437,0.28509328,1.0844837,-0.42438748,0.20828837,-1.2932807,-1.4109381,-0.5461097,-2.3675847,0.89196956,-0.6727995,0.16249199,1.9317616,-1.5922046,-0.24382037,2.661238,-0.10319002}},
			{{0.5946189,-2.45921,-2.5728724,1.1818364,2.832401,-0.8874107,-0.52956796,-3.595096,-0.7241307,-0.08719586,0.9028002,0.039364092,-2.6604578,-1.216092,-0.9768696,-1.6624749,3.5694716,0.03578491,-0.43828747,1.698664,1.9840034,0.000570275}},
			{{-2.6304762,-0.5986014,-0.067243114,-0.9504156,0.32507783,-2.625632,0.13826767,-0.06997978,-1.1130337,-2.3771577,0.57608837,-1.3951561,-0.12350817,-0.88147324,0.48606938,-0.09164605,-0.923805,1.0993143,0.18785557,-0.14280967,4.138186,-0.2954275}},
			{{0.468315,-5.5819473,2.0000236,0.709903,3.4740512,-1.7059572,-1.9701988,0.7828689,-0.3682883,0.23618741,-0.15971734,1.9255381,-2.4380789,-1.1607496,-1.9258211,-1.2928586,0.99923146,2.6608217,-1.8541918,-2.712652,2.2900672,-0.10430681}},
			{{-0.72085524,-0.47975028,-1.5110831,2.4008346,5.8745685,-2.2218533,-4.238405,-0.51177734,1.5123538,-0.8808029,-0.024984503,0.6322753,-0.9533706,-2.0387564,-2.0170333,0.93927705,-3.4955702,3.8707309,-2.0564547,-0.8357152,2.1013367,-1.175157}},
			{{1.0637561,1.4857764,0.4274521,-0.25225174,-0.24372214,-0.6795046,-0.558656,0.91459143,0.63136506,0.6964916,-1.7033913,-0.7409801,-1.7115083,0.17429624,0.6747576,-0.17688109,0.13333942,-1.0635579,-0.28811434,-0.27161604,1.8960378,-14.912447}},
			{{-0.6282318,0.17943966,-1.0135455,2.5266778,3.1865728,-2.456607,-1.9518396,0.70890766,-0.1802982,-2.302862,-1.6265254,-0.22565912,-0.60230225,-1.0321451,-0.43637928,-4.6203,-0.3200667,-1.3377157,1.5921478,-4.4041443,3.2524745,-0.6245389}},
			{{0.593798,1.6201082,2.955274,0.72917324,-1.4906026,-2.4125473,-2.8606424,-0.5187431,-1.1542772,-1.0645046,-3.3801193,-3.0067158,-2.383004,1.792679,3.5507627,-0.35295236,1.9726,-3.4192345,-2.127963,-2.690809,2.0494382,-0.33464167}},
			{{-2.0947018,-0.64074415,1.5952574,0.6163578,-1.093383,-1.9596831,0.35330474,0.4930704,-0.7001369,-2.9672925,-1.081584,-1.1129534,-1.3214351,2.0102057,0.57424164,-1.3298684,1.1295261,-4.017822,-2.7188542,-1.6284165,3.4039228,-0.4144481}},
			{{-0.20164087,-3.709945,3.714549,-0.29140973,-2.525115,-1.843098,-0.7825483,-0.8830477,0.43374303,-0.44646263,-0.3217031,0.331924,-0.9780278,-2.3408463,-2.6435578,-1.1067016,-1.7348807,-1.7755988,-5.2977476,-3.128419,3.3178632,-0.71449393}},
			{{0.8924063,0.08004779,1.189749,0.11464974,1.9032722,-1.2627355,-1.731855,-0.83153474,-0.5415733,0.4851316,-1.7439804,-1.0998136,-1.953987,-0.46047154,-1.332169,-0.47011265,4.109115,-0.50828683,-1.2920228,-2.0471134,3.2486646,-9.758817}},
			{{-1.7788799,-1.9000838,0.364542,-2.4473166,0.7196706,-3.5619438,-0.4612579,-1.0581598,1.7788649,-0.52018183,0.09662012,-2.316609,-1.2880237,2.8518803,-1.9575485,-0.19621162,1.6758258,-2.4917734,-1.2927473,3.0174143,3.3786001,-0.22503905}},
			{{0.261765,-1.7993783,1.0077285,1.0989226,0.47731355,-0.85956806,-1.4211967,-2.8411431,1.0587494,0.46575153,-0.13725445,-0.05905216,-3.4399655,-0.5315417,-2.4100509,-0.92937803,4.749442,1.61849,-1.0853202,-1.5577716,1.650838,-0.46848843}},
			{{-2.9607034,0.76106095,0.76675797,-2.0978444,-0.9090318,-1.1492908,1.4126669,-0.9591291,1.3960541,-0.99186033,-1.4717724,1.7352757,-1.48312,-0.4730525,0.016230034,-1.5283372,2.0264761,-0.7180739,-1.46674,1.1250124,1.9371375,-0.014461352}},
			{{-1.7776676,0.11604641,0.030551005,0.5888615,0.6556674,-1.4705982,1.0219507,0.26519695,3.413277,-1.1236167,1.4105083,-1.5013844,-1.4753498,-1.8126218,1.3437761,-0.13049941,0.94600517,2.3235593,-0.2902499,-1.2380612,2.0045154,-0.3000127}}
    }};

    h4_out = {{
			{{-4.64132,1.1369852,-1.8325193,0.22273482,-1.5715749,-2.7404761,-0.6771207,0.1955358,-1.6337425,0.5705972,0.13055302,-2.3612452,-0.74507326,-4.416316,-4.0692616,-7.883145,-4.627503,-4.4562755,-5.6485543,-2.8381772}},
			{{-2.835911,0.356258,-3.018914,1.6872808,-1.7443286,-5.1842885,-0.008840262,-1.6014357,-0.7327274,0.8978315,-0.3534597,-2.43241,0.5164936,-5.4714007,-1.7563887,-3.7592566,-5.7717543,-0.6426615,-5.51474,-3.3029397}},
			{{-0.77702326,-0.6288999,-1.6689929,1.471405,-1.3559994,-6.092747,0.46012995,-5.1427197,0.39436832,1.2766814,-0.24640596,-1.6136099,-0.38691938,-2.0488937,-2.0321171,0.39514866,-4.2556434,0.45639232,-5.493548,-5.149797}},
			{{-0.28564703,-1.2109267,-0.4107146,-0.15872863,-1.3188443,-5.720401,-0.1030471,-6.925652,0.47896594,0.36411145,0.679513,-0.4337025,-0.23182693,0.7506746,-0.9976604,0.866016,-0.8049578,0.7299026,-2.5790653,-4.943276}},
			{{0.37295803,-4.136207,-0.5368652,-1.6330681,-0.6701518,-5.7497005,-0.5810051,-5.742883,0.72294915,-1.9608617,-0.44035405,1.3717463,1.2805601,0.8644782,0.16421257,0.8488268,-0.44948852,0.95102066,-1.1669225,-4.3795877}},
			{{0.18159942,-4.734642,-0.874949,-1.5010068,0.15886067,-4.9687467,-1.3125973,-2.9839275,0.3662074,-4.61096,-0.46615097,2.9502466,1.0177525,0.5899759,1.6236233,-2.7011774,-0.4012876,-0.40828288,0.4230351,-3.008887}},
			{{0.4249136,-2.8374205,-0.057907797,-3.5415227,0.63056844,-3.0080311,-3.358974,0.13588786,-1.6948344,-7.26294,0.196507,1.3988572,-0.44927812,0.8364068,1.3551265,-6.5319858,-1.1904122,-3.4278612,0.31767645,-3.573261}},
			{{-3.20262,1.1515619,0.106605686,-0.0696857,-2.143054,-1.0059266,-0.8152101,0.64399713,-4.7898874,0.5393334,-0.26513228,-2.2667675,-0.42138067,-3.7716024,-4.3281693,-11.173831,-3.1533742,-5.707086,-7.7671933,-0.7276168}},
			{{-0.96505296,0.76786387,-0.27144077,1.0032752,-2.8704824,-3.3137019,0.62281173,-0.57096124,-2.3059878,0.45603722,-0.5515004,-2.1239612,0.7004048,-3.520968,-2.6558294,-5.37325,-3.381747,-2.0618875,-4.271785,-0.88537985}},
			{{-0.024491716,-0.8082561,0.37619418,0.5844133,-3.1914828,-3.5661187,0.81418395,-2.0678139,-0.7321738,1.2099994,-0.7141873,-1.5353075,0.5553649,-1.4102019,-1.8720819,0.15690924,-2.5009596,0.47259364,-3.94065,-1.544744}},
			{{0.13080105,-1.5704082,0.93120354,-0.9284301,-2.5646334,-3.2431452,0.41421324,-4.484749,0.4014133,1.1336114,0.5306443,-0.7070735,0.5960404,0.6806369,-0.9830494,0.6772413,-0.23751731,0.86487216,-2.594861,-2.225923}},
			{{0.26276353,-3.3253946,1.4166291,-2.3963234,-0.57290524,-3.8031888,-0.9301282,-3.1083431,0.40391427,-0.092046596,-0.7484006,0.30867675,0.24697714,0.8292097,0.5960023,0.54951376,-1.0261487,1.0275848,0.14174825,-1.7687956}},
			{{-0.014214518,-3.204736,1.4928802,-3.052362,0.5092636,-3.5946965,-3.802507,-1.6183009,0.033381283,-2.1178768,-0.48001748,0.9402496,-0.4227204,0.21353345,1.8425212,-4.68835,-0.51338553,-0.8968556,0.67434895,-1.3004578}},
			{{1.1136833,-2.4686944,1.3940722,-5.127874,0.401643,-0.82810426,-6.735117,0.23185687,-2.4052045,-5.7054806,-0.4858316,-0.09340516,-1.0944233,0.6253933,1.8141207,-9.817379,-2.190899,-4.0574512,0.42730343,-1.1965728}},
			{{-2.1304753,0.79050916,0.63705677,1.0855416,-2.9866004,-0.07737951,-1.168241,0.5726624,-6.552535,0.10118653,-0.24485856,-1.030515,-1.3832545,-0.51677495,-3.4782186,-8.441324,-3.194976,-8.999006,-6.2980857,0.5512306}},
			{{-0.3216742,0.721969,0.5211723,1.5658824,-3.807778,-0.8556781,0.3107311,0.057663932,-3.3248494,-0.66333133,-0.7329323,-0.95648324,0.513046,-0.66769266,-2.9360328,-5.3089747,-4.654693,-2.7225497,-3.4781923,0.8805667}},
			{{0.3022813,0.22268821,0.45368358,0.5129111,-3.3539157,-1.7232853,0.90649015,-0.10933901,-1.1010753,0.21063721,-0.65311867,-0.5942722,0.29354903,0.33582997,-2.0247934,0.4716182,-2.0007062,0.13339205,-2.5605597,0.68144625}},
			{{-0.36906597,-1.0952324,0.6913394,-0.6979516,-1.8220023,-1.9299837,0.28820395,-0.5256252,0.24477075,0.9320882,0.7493267,-0.49388933,-0.4677617,1.0287491,-0.8321453,0.5859534,-0.37415695,0.87193674,-0.6906826,0.15669456}},
			{{-0.31492305,-3.2454355,1.2208158,-2.018484,-0.0745525,-2.0994997,-1.6854798,-0.75739986,0.61865133,0.93594724,-0.48570886,-0.09126207,-1.4489064,0.2372152,0.6011615,0.62337714,-0.36740652,0.80930644,0.73821694,0.11147376}},
			{{-0.33357468,-4.3735085,1.2708377,-2.8772058,0.88268256,-1.324318,-5.3645473,-0.31382674,0.7943057,-0.05716373,-0.828104,0.09987043,-2.3405118,-0.53623164,1.6894977,-4.43922,-1.0040262,-1.2505311,0.55017155,0.27421388}},
			{{0.18840425,-3.2807355,1.2855456,-4.2484875,0.9548698,-0.26615205,-6.471484,0.2636379,-0.49968413,-2.504522,-0.5561459,-0.4636302,-3.6124709,0.31923756,1.2674261,-7.036847,-2.0202248,-7.9371986,0.36220703,-0.32917067}},
			{{-0.2002069,-0.42698416,0.62772024,0.7991651,-2.2479608,0.7351414,-1.2428603,0.37224802,-7.2284126,-0.9365154,0.7699978,0.4767024,-1.0627114,0.81742746,-2.4069266,-5.3771715,-7.398682,-8.386695,-1.503167,0.22258642}},
			{{0.8030032,0.59359014,0.45554006,1.6238322,-3.3354154,0.14017653,0.2143236,0.32871497,-4.4874263,-1.7533642,0.20229772,0.55602837,0.52311367,0.11310509,-1.9199468,-4.634042,-4.606863,-2.8053477,-0.7183792,0.9253407}},
			{{0.49217883,0.4099223,-0.035376877,0.9622763,-2.717444,-0.07474351,0.8056257,0.6269057,-1.816134,-0.9844033,0.34420285,0.50950456,-0.49287358,0.61147237,-1.1462232,0.5043969,-1.7730517,0.096030325,-0.48217767,0.8995497}},
			{{-0.39117405,-0.22266501,-0.44885215,-0.34215117,-1.0711782,-0.47753507,0.017176688,0.7635422,0.035682276,0.12473259,1.6635188,0.13697407,-2.0706623,0.31504968,-0.69255257,0.5617428,-0.30998263,0.74585265,0.38133913,0.8264223}},
			{{-0.65823174,-1.5957261,0.16531724,-1.6667714,0.28205204,-0.38203084,-1.6290336,0.7066675,0.77146775,0.9065797,0.269699,0.0978968,-3.1291394,-1.2404009,0.61261356,0.558066,-0.66780555,0.55381846,0.70195806,0.69949263}},
			{{-0.6845914,-2.7018592,0.5239354,-2.2859054,1.1847544,-0.20152661,-5.884024,0.44348428,1.1486132,0.98703927,0.009692357,0.14693715,-3.6623175,-1.9735426,1.0627953,-4.079725,-1.9405618,-1.4829185,-0.48284125,0.71969485}},
			{{-1.7185258,-2.1409085,0.566894,-3.4455626,0.4333808,0.5149673,-6.0579987,0.5614159,0.35945842,0.5762021,0.8017133,0.035020746,-3.902038,-0.41177422,-0.14347878,-6.114112,-3.4711282,-7.3934565,-1.1563864,-0.17911072}},
			{{2.2024329,-0.8684066,1.1265314,0.1591946,-1.0576082,1.0049274,-1.039158,0.41683656,-7.3319087,-4.7724743,-0.5466509,2.0316374,-0.24073361,0.5836809,-1.0526205,-6.9159327,-5.937476,-9.447503,0.00058949686,-0.1958307}},
			{{1.5409209,0.046562366,0.20290743,1.4213653,-1.9755388,1.0763596,0.7848079,-0.3799206,-4.3609877,-3.5062225,-0.73385257,2.4783144,0.42880553,0.16852313,-1.2742313,-4.5850673,-2.6424017,-2.8879156,0.5784127,0.39164877}},
			{{0.32741335,0.8600117,-0.5062592,0.9541519,-1.1656697,0.7654224,0.8345538,-0.10066152,-1.9564823,-2.6362734,-0.26486558,2.2016635,-0.8146398,0.08398038,-1.014033,0.44910437,-0.18892173,0.014212807,0.69276613,0.56045336}},
			{{-0.98694485,0.84602356,-1.2553651,0.090550534,0.28123662,0.68173116,-0.05728483,0.26483548,-0.081579685,-0.89052314,1.0331206,0.87749076,-2.0207214,-0.8829474,-0.54151034,0.6212593,0.18841141,0.8894941,0.66395026,0.48751888}},
			{{-1.7773354,0.38519704,-1.0566558,-1.4467659,1.178564,0.2667244,-1.1529499,0.5398566,0.85549265,0.42299768,-0.40053135,0.7543808,-2.0618038,-3.1319366,0.013173699,0.5404707,-0.85574657,0.6371012,-0.1826202,0.8710421}},
			{{-2.0214014,-0.35287148,-0.5061023,-2.512596,0.94201016,0.65701306,-4.547462,0.7052512,1.3152117,1.2545813,-0.77839303,0.7643634,-2.543935,-3.8999975,0.2684163,-3.5838888,-3.2187757,-0.93540174,-2.5777404,0.62497157}},
			{{-3.001203,-0.3800996,0.14656454,-3.9397473,0.31234506,1.0240198,-6.03669,0.817886,-0.027606437,1.8285713,-0.111747995,0.015730528,-2.4930966,-3.4357817,-0.7560588,-5.376081,-5.3669987,-7.542088,-3.2542405,0.29031017}},
			{{2.8661633,-2.0995734,0.2961033,-0.35960883,-0.60084224,1.7249774,-0.34808192,-0.86449194,-6.5743346,-4.865807,-1.1659902,2.505329,-0.8701213,0.59281486,0.6767596,-7.8682237,-2.771971,-9.651418,0.284777,-1.2205895}},
			{{1.9628311,-1.7790947,-1.7991489,1.3223401,-1.0194936,1.5197997,0.9200435,-1.8336002,-3.7685378,-2.9190552,-0.92058843,3.7989974,0.2997831,0.19843826,-0.1255937,-4.410626,-0.66212714,-2.7914145,0.858458,-0.64308316}},
			{{0.50760657,-0.033835445,-2.7883754,1.1671575,0.06425556,1.3830824,0.8381196,-1.6747828,-1.7643387,-3.0055106,-0.7605719,3.2569358,-0.7437273,-1.0571007,-0.7735097,0.16502881,0.24831669,0.08906485,0.8380041,-0.61743295}},
			{{-1.2900958,1.3156971,-2.9144948,0.33339435,0.8925835,1.2279394,-0.18545695,-2.8052592,-0.19278644,-1.7353884,0.70554316,1.7888185,-1.3182406,-2.028158,-0.69508106,0.6389352,0.0534643,0.97046757,-0.015323054,-0.40964276}},
			{{-1.7870722,1.5231268,-3.5348957,-0.73939884,0.94907975,1.0221761,-0.6792453,-0.91001654,0.82560056,-0.19222037,-0.84078664,1.9314995,-1.522413,-3.5925133,-0.21673977,0.4494155,-2.1782513,0.7774022,-1.8787498,-0.20073593}},
			{{-1.8786932,1.2541797,-2.7938464,-2.0654604,0.5631357,0.7984796,-2.5864823,-0.4267551,1.3021201,1.0814896,-0.833722,1.343655,-1.8610734,-4.3529468,-0.15657738,-3.4316878,-4.059943,-0.7361188,-5.246602,0.3011993}},
			{{-3.496095,1.0482326,-1.2464411,-3.2550714,0.2641977,1.2837005,-4.1500487,0.0860862,-1.0054256,2.2752185,-0.7939252,0.38390014,-2.0972154,-3.9937305,-0.923403,-6.342039,-6.6946,-4.7059073,-6.681561,-0.13032338}},
			{{2.6118412,-3.1181183,-0.97527033,-0.11928093,-0.7006795,0.9228049,-0.11262338,-1.1272131,-4.8631377,-5.13056,-0.7729515,3.6842325,-0.7914046,0.79793584,0.19258364,-4.1799736,-0.85630065,-5.3216987,0.34394827,-5.459711}},
			{{2.0086062,-4.026115,-4.3398905,1.4355531,-0.7581475,0.89429903,0.8872702,-2.0960033,-3.4756486,-3.5886245,-0.9907807,4.6175046,0.72647727,-0.60761726,1.2482634,-2.6044352,0.399852,-1.1000586,0.69595397,-5.8887854}},
			{{-0.026971404,-2.6137385,-3.9270625,1.4830359,0.47112235,0.8943593,0.6538397,-3.8049312,-0.91588384,-2.6597972,-0.24518184,4.5957193,-0.30709636,-1.4543177,-0.9410946,0.32965308,0.7232972,0.47581753,0.05103788,-6.4390063}},
			{{-1.4554136,0.5819419,-3.436186,0.5659132,0.2958416,0.74976975,-0.3401571,-6.2436733,0.2755433,-1.2508069,0.7764188,2.2251587,-1.5458064,-1.3842255,-1.175878,0.81294316,-0.5002313,0.8856272,0.043540806,-3.8578856}},
			{{-2.4795978,2.1078074,-4.2336874,-0.49785936,-0.5912617,0.2935651,-0.5432309,-5.0369854,1.2081741,-0.4390384,-0.50541633,1.3932782,-0.8941555,-4.552408,-0.26790732,0.6349498,-2.857046,0.53916335,0.15488032,-3.0564868}},
			{{-3.0837457,2.2909873,-5.3588963,-1.7100333,-1.170069,-0.26991645,-1.2460984,-1.7901479,1.4242672,0.7754235,-0.8465658,0.9543244,0.29491016,-5.9951854,0.23150688,-2.4694288,-5.2654614,-0.31122708,-3.4823654,-2.4903576}},
			{{-4.8894086,2.1090863,-2.628496,-2.4842184,-1.4630647,-0.074353784,-1.7425954,-1.0901592,-0.47583085,2.005091,-0.57950026,0.9835185,-0.9630858,-3.8942652,-0.9640933,-3.4643373,-6.522356,-3.5642462,-5.324626,-1.9482251}}
    }};

    b1 = {
			-0.21988548, -0.3915779, 0.15806352, 0.18345469, -0.05338209, -0.09581837, 0.40492305, -0.24858864, -1.5188023, -0.24470997, -0.84820986, -0.2927701, 0.11499235, -0.1197592, 0.05637328, -0.14485307, 0.36029956, 0.24858746, -0.10255062, -0.026909785, 0.21854764, 1.182476
    };

    b2 = {
			-0.50385183, -0.26420397, 0.7456199, -0.24981897, -0.33663076, 0.15321241, 0.51657075, -0.030079033, 0.427477, -0.14844337, 0.87332654, -0.16277255, -0.50295633, 0.32799828, -0.3448195, -0.47166607, -0.7966887, 0.24177065, 0.91495615, 0.41965398
    };

    bout = {
			-1.4756167, -1.176304, -0.83746314, -0.2405762, -0.8882552, -1.2144722, -1.3524338, -1.6364152, -0.33822158, -0.082043014, 0.6148163, -0.12118895, -0.42084625, -1.6480861, -1.2325834, -0.2086811, 0.95432854, 1.355636, 0.87519836, -0.33598152, -1.2758226, -0.6940351, 0.5417856, 1.4673846, 2.443634, 1.2836998, 0.3045752, -0.78648305, -1.306887, -0.22562444, 0.9556252, 1.3675799, 0.74045485, -0.5069496, -1.4118581, -1.673896, -0.54476565, -0.2686828, 0.5725887, -0.34062436, -0.74962604, -1.7920586, -1.6616081, -1.4777868, -1.1584407, -0.43348134, -1.0076888, -1.5036361, -1.7044656
    };

    BN_gamma_in = {
			0.35053104, 0.36907583, 0.03588921, 0.3640476, 0.60374045, 0.20899928, 0.039141834, 0.88798696, 0.49755174
    };

    BN_gamma_1 = {
			8.094861, 10.14118, 3.5887334, 4.053101, -12.225097, 3.8598945, 2.1431384, 9.703565, 15.433145, 5.1180778, 3.9629874, 5.1332684, 3.7080405, 7.685786, 5.3347344, 5.917572, 3.5943801, 3.5081847, 7.457506, 10.0471945, 3.3481328, 1.6324234
    };

    BN_gamma_2 = {
			0.32611236, 0.23336765, 0.15358745, 0.20659748, 0.20135191, 0.18418075, 0.13467248, 0.18075173, 0.16075507, 0.2621407, 0.30043578, -0.22415756, 0.1801741, 0.19347832, 0.20926279, 0.1379608, 0.20675619, 0.13937277, 0.11991841, 0.12588546
    };

    BN_beta_1 = {
			-0.17648306, -0.21089317, -0.3293891, -0.35526356, 0.055853844, -0.00519813, -0.3108609, -0.18307582, -0.042325266, -0.2679411, -0.19158739, -0.3925915, -0.029167313, -0.34923583, -0.47308847, -0.15546264, -0.41969118, -0.26217964, -0.087082855, -0.11809182, -0.46828288, -1.0911832
    };

    BN_beta_2 = {
			-0.13759148, -0.12784384, -0.13686973, -0.13765632, -0.099115826, -0.09942085, -0.117987104, -0.078117676, -0.09967579, -0.11933789, -0.35844833, 0.16602351, -0.084899396, -0.12782098, -0.13944024, -0.023381552, -0.0436448, -0.06435467, -0.1278522, -0.09936514
    };
    
    mean = {
      54923.98630026454,34253.43096171213,51066.430216003784,44663.03649485166,19008.86047394739,44379.26173907137,51312.456969054336,33936.88848975141,54689.80229219386
    };

    stdev = {
      203013.1651297521,152801.63182374722,187379.1033813536,178073.72926964832,128008.23973479208,176605.8923592302,188119.38609298086,151866.63960198764,200972.0251179253
    };
  }
  
  else if(m_pcEncCfg->getQP() == 37){
    
    embs0 = {{
			{{-0.3470052,0.042158753,0.06555167,-0.24942112}},
			{{0.0012416508,-0.03624891,-0.014858524,-0.00029238863}},
			{{-0.00027659867,0.010932403,0.011401979,-0.00010721941}},
			{{-0.12817083,0.02549043,-0.014852615,0.2388338}},
			{{-0.0058533926,0.07687753,-0.004683608,0.0073759016}},
			{{0.050861236,0.16400601,-0.08467209,0.06425282}},
			{{0.03247923,0.20594762,-0.11652993,0.005445059}},
			{{-0.51205677,0.49682516,-0.47895297,-0.5936651}}
    }};

    embs1 = {{
			{{0.09159002,-0.2794488,0.13715395,-0.1154376}},
			{{0.011388057,0.0027535467,0.0050375396,-0.037943646}},
			{{-0.010741315,-0.0013891995,-0.0005055049,0.011862188}},
			{{0.02216715,0.10183957,-0.4033617,0.04653914}},
			{{0.018742219,-0.0013493678,-0.003195422,0.07908031}},
			{{-0.0030735182,-0.16288877,-0.47302285,0.061246034}},
			{{0.15841623,-0.0009215101,3.5366975e-05,0.21555556}},
			{{0.64163005,0.043512583,0.07277514,0.5386578}}
    }};

    in_h1 = {{
			{{0.028487116,0.58744574,-0.12733692,0.006922589,0.13352378,0.0456484,0.26455435,0.44636774,-5.2501707,3.9604583,0.8839479,3.133904,2.20829,1.3143345,-0.63779205,-10.249599,-0.36710617}},
			{{0.009585747,-0.0019583306,0.014227383,-0.0060739852,0.0073650093,-0.0114870565,-0.06778173,-0.01214751,10.291096,0.6218175,3.5571086,-0.6588866,1.6871678,-8.18242,-0.096049234,-4.6257796,3.1888103}},
			{{-0.046415113,-0.26087904,-0.10891892,-0.61874014,-0.07918267,-0.16925544,-0.24479899,-0.36110428,0.014904348,0.09155421,-0.46558878,-0.081500374,0.34462786,-0.3541816,-0.023853516,-0.045855336,-0.35737133}},
			{{-0.019205611,0.045933425,0.031324923,-0.0009301365,-0.061523188,-0.15932998,-0.039449837,0.15111642,-2.2377045,-0.08956652,0.94129,-9.415207,1.5198684,9.927203,-0.08748579,-0.0119918175,0.64599913}},
			{{-0.03673015,0.1994141,-0.05867599,0.07977603,0.07193017,-0.043180365,-0.9980351,0.1976254,-17.967457,4.5192986,-2.9329088,4.170119,-4.652027,4.0497,-0.079751804,-3.3641257,-0.30195454}},
			{{0.03747097,0.09668131,-0.07306357,0.04468251,0.05068288,0.04353597,0.06804956,0.069112614,8.368875,1.2510496,-15.533346,0.14558661,-0.85382164,2.761696,0.40586287,-1.3547198,1.8910869}},
			{{0.01926122,0.019252121,-0.044287607,0.013237818,0.031175122,-0.028871244,-0.06467707,0.010172096,-1.0804204,1.9007608,2.4530184,1.5416938,3.1077151,7.4675975,-5.3676744,-2.6097066,-0.119536564}},
			{{0.09117301,1.9000092,-0.088182844,0.4905155,0.38624063,0.1767619,-3.5602224,1.4185988,-2.5119727,1.5099303,-3.2609708,-0.26241827,1.8147396,-8.902644,-2.5974658,5.6137815,-2.2785418}},
			{{-0.26159242,-0.31255746,-0.24432203,-0.25010538,0.22745192,-0.666661,-0.26207027,-0.25490046,0.33535188,-0.07541194,-0.41619214,0.17148615,-0.349629,-0.033802442,-0.051431295,-0.14048253,0.013384609}},
			{{-0.032573663,0.35236022,-0.021458007,0.12589741,0.08076667,0.049469173,-0.96555346,0.2139328,8.808344,-1.4966321,2.1296363,-1.468395,-3.7014341,12.70431,-0.10775348,-0.16213827,0.8102665}},
			{{-0.010154817,0.5059937,-0.0059902435,0.14417644,0.02298734,-0.056181166,-0.85394585,0.4371525,-10.426561,-1.6557211,8.442343,4.6940784,-3.6215365,-6.2604566,1.1979817,1.5039291,0.21712995}},
			{{0.10430359,0.26794562,-0.040148802,-0.010896125,-0.070140876,0.20411465,0.37141994,0.2216136,-3.4903293,1.2269421,3.0753305,-8.798381,-2.5718477,1.2740256,4.1102676,-0.19831038,-0.87333816}},
			{{0.12958668,0.41264552,0.31836137,0.1731022,-0.06743995,-0.35779265,-0.13598801,0.3742843,3.5167255,0.0950021,0.5898496,0.96378464,-12.782195,1.5799283,0.41500384,-0.5230079,0.5968525}},
			{{0.007798082,0.024223221,-0.028990116,-0.0032114845,0.030958481,-0.007862107,-0.031545497,0.023963535,-0.07714095,-1.4448835,-14.6036215,1.258219,2.9940293,4.5572023,0.4281824,0.6807963,-0.41831034}},
			{{-0.05984264,-0.030537937,-0.024150824,-0.038415164,0.18978654,0.13996215,0.07802615,-0.32450363,3.8325648,-2.5272079,11.958755,2.1447852,-0.93584204,1.2197663,0.23129575,-5.231378,4.022215}},
			{{0.022414405,0.0229333,-0.031974986,0.014366598,0.021446439,0.028210908,-0.021067152,-0.004786928,4.7724333,-0.72878337,3.2930527,-7.7491,3.3162503,5.7525573,3.4190712,-1.9653927,-3.5811095}},
			{{-0.23320106,-3.1918018,0.27445933,0.66852194,-0.5803425,-0.052845024,-1.3683163,-2.92117,10.859421,5.2126746,2.1705716,0.5389596,0.46337146,1.7162265,-0.2223555,2.9055443,-0.43810305}},
			{{0.017062383,0.9283131,-0.2860547,0.02280253,0.29778588,0.19638236,-0.2520731,0.7882429,-0.29630134,3.8015418,0.22604842,1.2872896,-11.964098,4.090107,-0.27987155,2.404775,-0.7438043}},
			{{0.071554095,1.0721743,-0.29435992,-0.043731745,0.3214663,0.23345414,-0.38710737,0.9980179,-1.1476817,-7.017208,1.465731,4.8261995,4.6214976,5.888428,-1.9441315,3.019119,-1.8874016}},
			{{-0.006656082,0.01502027,0.0012240972,-0.020596573,0.0232439,-0.017947096,-0.054768775,0.007836323,-1.6310424,2.3213763,1.3708874,5.744501,1.4119906,-0.19403173,-0.06544226,-1.8982857,-6.5750732}},
			{{0.0042947116,0.03532192,-0.041659974,0.018459154,0.04488036,-0.010568099,-0.014390746,0.022625582,-26.280369,0.3717449,2.3602593,1.5708874,-0.510845,0.3132474,0.08039524,0.46968025,0.019097803}},
			{{0.059902143,-0.61530465,-0.60209966,0.060630273,0.52859634,0.12125519,-0.15616192,-0.6996632,-9.569188,1.1843466,-3.1146057,3.7777507,-6.2113295,7.9558496,-0.99439037,4.230964,-1.7831339}}
    }};

    h1_h2 = {{
			{{0.5659353,-0.3473509,-0.0018178677,-2.0095031,1.1754417,1.1146034,-0.35455152,-2.7462964,0.004027741,1.4900099,4.0292897,-2.316443,0.846824,-1.2957547,-2.1435113,-0.31653377,-0.060113356,1.2642117,-0.016790831,0.26233566,-1.3727378,-1.5706018}},
			{{-1.8439622,-0.85611814,0.0022501748,-0.3232995,-1.2769588,-0.564967,-0.4573722,-0.86497283,0.0006209062,4.5132537,-0.4505499,-1.2997379,-0.46356076,-1.3451667,-2.6391742,-1.2325166,-1.3031511,1.8742005,-0.346756,-9.220784,-1.8443484,-1.4090095}},
			{{-1.3127215,-0.18128084,-0.002398593,-3.260809,0.50380063,-2.0524151,-10.92751,-1.0561857,-0.00018922813,-0.20204791,4.679287,-2.3663027,0.37504128,-0.12210816,-2.0667002,-0.36201847,-1.7941772,1.0645295,-0.44914475,-0.6641386,0.6411212,-1.1924679}},
			{{-0.016629891,-0.23857895,-0.0026113952,-0.7322689,-0.35608223,-0.42618227,0.031472284,-2.0212963,0.0040620607,4.6810517,-0.0027015742,-0.49023074,0.7696344,0.24172086,-2.6126487,-0.46554288,-0.0063375104,1.2242632,-0.31066668,-0.6667813,-0.16213854,-1.218195}},
			{{1.4892274,-0.06015345,0.008132835,0.26481903,3.3893514,-3.329973,-0.7332599,-1.7437502,-0.0061530066,4.3154974,-0.7909039,2.1131785,0.37669456,-0.86453897,-2.9953256,-0.9474341,-2.99427,-0.54921234,-2.1533508,-1.0919932,1.7839735,-1.285744}},
			{{-1.2576166,-1.1994818,-0.0030414946,-1.202925,-0.023112858,0.6034879,1.0494972,-0.68230236,0.0027750456,0.02608144,-0.07087468,-3.9092765,-0.6575816,0.89670485,0.15849335,-6.6639266,-0.5045244,3.8966837,-0.9162733,-0.5979901,-3.9488547,-1.4129634}},
			{{1.4958621,0.24212563,0.0011490273,-0.44345513,2.0401196,-0.16408117,0.25208306,-1.6307474,-9.902002e-05,1.6626536,-0.81003153,-5.800068,-0.47538352,0.31507525,-0.88667446,4.6247396,-2.1477695,-0.7263978,0.42460492,-0.063284,-1.043304,-1.2102357}},
			{{-4.6846776,-1.2079033,0.0027933966,0.5052647,-3.7345734,0.2967786,-0.62931395,0.46584418,-0.0090919165,2.0076854,2.5421634,-1.1497388,-0.11689365,-0.2440084,-1.6970775,-0.90601707,0.001896364,2.356122,-2.7823882,-0.22995824,-0.112673916,-1.1492145}},
			{{0.20336665,1.4035715,0.006101443,-3.5534072,2.7215195,0.21430296,-0.6889119,-1.2360868,-0.006861377,-0.37389746,3.7118754,-1.367458,0.087027386,-0.8526156,-2.3631892,-1.6357281,-2.797136,0.56631297,-1.8123754,-0.59458065,-4.5689487,-1.4816822}},
			{{1.1909612,-9.516781,-6.2753505e-05,0.23215707,0.095701724,-0.4386482,2.3917763,1.4349223,-0.00029317368,-1.0468974,-2.232467,0.8351794,-0.3118017,1.3450117,-12.837525,-3.6602128,-1.0761614,-1.4425132,-0.546575,1.3548993,1.3878235,-6.65607}},
			{{-0.15820087,-2.5410507,-0.0054635284,-0.48989925,1.035907,4.9434743,-1.1589592,0.13605414,0.003959364,-0.03785907,1.4567289,-0.052046075,-1.1676222,-1.2301877,-1.1678419,-1.2693535,-2.0805666,0.23102549,-2.2018816,-0.9512046,2.9083843,-1.2200328}},
			{{-0.12720378,-0.313762,-0.01671872,-0.28449157,2.5956838,-1.3364794,-0.6250202,-0.82902735,0.009858945,2.7698245,-0.83094966,-0.26785424,0.088314004,-12.915248,-1.4667435,0.90915644,-0.08854087,1.2778928,-0.31618628,0.341816,-1.5468997,-1.5313972}},
			{{-0.60114217,-3.0106843,-0.00085674337,-1.2072574,0.9373956,-4.0684605,-0.67165655,-1.1346748,0.0019777345,0.902767,0.46654716,0.087745495,-1.2477658,-0.24267818,-0.16472885,-0.7100164,-2.3559208,2.1695929,-1.5534433,1.1582007,3.0888205,-1.0594178}},
			{{0.41648278,0.020635994,0.0001408746,-2.949217,1.269272,-0.4005571,-0.48702407,-2.7975914,-0.0051687425,4.0230184,1.4867262,-0.5299626,-1.7601446,-0.4854966,-1.4244132,-0.1340769,-2.281207,1.0099398,-0.19044183,-0.442792,-0.33990976,-0.67229617}},
			{{-0.08086183,1.0101848,-0.0036841081,0.33665177,0.7217579,-0.948905,-0.5506217,-0.0015539193,0.0025844814,0.11785893,0.14773005,-0.8869999,-0.12010947,-0.81196815,-0.7447828,0.4134706,0.12847324,3.26967,-2.8031163,-0.3534793,-1.0949585,-1.3697509}},
			{{-0.4553555,0.5995594,0.0035571926,-0.41876382,0.1708512,-0.071523614,0.322246,-0.87803537,-0.0010665256,0.09058997,-0.28657869,0.9496607,-1.3522187,0.030881694,-0.32511583,-0.94918746,-5.5579357,0.8342269,-0.21004999,0.21167852,-0.47350532,0.33240685}},
			{{-0.037321754,-1.2563499,0.00052554085,-0.0013172006,1.1199094,-0.55886304,-0.897009,-1.1138209,0.0011422096,0.105956875,0.4574809,0.4864547,-2.3189034,-0.82144195,0.46093637,-0.483153,-0.19652523,1.253555,-0.13238993,-0.18714066,0.75532275,-0.27349362}},
			{{0.25216377,0.19033481,0.0021963327,-0.48061815,0.3607366,1.9872278,0.34027526,-0.5035591,-0.0007134166,-0.10156003,0.39320844,-0.36573347,-1.8289216,0.10909409,0.23273177,-0.3981694,-0.06198096,1.1179167,-0.71849495,-1.1514305,-1.3272032,0.02051182}},
			{{-3.3607883,-1.0383563,-0.00053929066,0.61846435,-1.0220517,0.6588143,-0.21650289,-0.2945861,-0.0030319197,-0.20489651,0.7326975,-0.45024788,-0.09479204,-0.88138956,0.13501821,-0.5591492,-0.00874973,5.3452578,-1.5601301,-0.21300443,-0.2652403,-1.9585372}},
			{{-2.3774788,-1.701845,-0.0031932527,0.00012293053,-0.9612059,2.6650996,-0.6581098,-0.6429335,-0.0004494896,2.815552,2.6501596,0.37344953,-0.61542076,-0.85545903,-1.4965812,-1.647289,-4.591514,-1.5660977,-0.19236022,-0.09125853,2.4113991,-1.2033998}}
    }};

    h4_out = {{
			{{-2.6414363,-0.68368804,-1.1196954,-0.7715738,1.1600193,-6.247414,-1.092166,-1.2768879,-3.0917857,-3.3020318,2.1741793,-0.97340477,1.0695753,-2.214433,-3.0801685,0.1665879,0.9023257,-8.175159,-1.2240009,-0.0193082}},
			{{-0.8106161,-0.3978061,-0.9563585,0.7630383,0.7010286,-5.1357784,-0.16844517,-1.5103955,-2.7265723,-2.1752703,0.81256044,-1.1152962,0.8906716,-0.43499416,-5.29144,-0.6680187,-0.126858,-6.184265,-2.5993528,1.4044918}},
			{{-0.8542198,0.09509764,0.424555,0.3614972,-0.47969818,-3.4970682,-0.5988248,-1.0690109,-2.9539888,-1.5797642,-1.2275337,-0.4240901,0.1441861,0.9681961,-6.365782,-0.4963067,-0.22898637,-1.9763159,-2.9015913,2.0245404}},
			{{-0.085431196,0.26288575,0.12748368,-0.15430246,-1.642774,-0.8402461,-0.62175024,-0.35826248,-1.1727971,-1.1574857,-1.692139,-0.5757525,-0.8892365,0.98309755,-8.0438385,0.5934824,0.25806582,-0.39172086,-1.4503155,1.4123898}},
			{{0.43789864,-0.042639878,0.16536464,0.09029701,-2.8131223,0.7036518,0.10458443,-0.2609097,-0.57263494,-1.6732799,-1.982602,-3.5881941,-3.7358735,0.5393857,-3.7598362,-0.4944821,1.1214577,0.43407938,-2.4446602,2.121863}},
			{{0.5499495,-0.6358282,0.7713348,0.10060869,-2.5821018,1.2933788,0.5038295,-0.37940875,-1.0011652,-2.0893407,1.1837856,-4.0847616,-5.9972105,-0.18829967,-3.343674,-0.24343644,4.389921,0.38108507,-2.065004,0.14197712}},
			{{-0.7515555,-0.0630689,-0.05330817,-0.7951865,-4.2910256,0.59969664,-0.37575597,-1.2335993,-0.6548385,-3.2622569,3.7408154,-3.1080074,-6.7465286,-2.4769356,-1.823174,0.92690045,6.7493095,0.06785023,-1.2592863,-1.143644}},
			{{-4.8403187,-0.88742673,-1.6963612,-1.2022666,1.0588771,-4.3302193,-1.9075447,0.36321682,-2.647714,-1.9401212,1.4053952,-0.6579402,0.79406005,-4.5674133,-0.66112465,-0.096500084,1.7779188e-05,-7.4064775,0.25055572,0.15374136}},
			{{-2.5020869,0.18078426,-1.0129547,0.6580854,0.98739696,-3.3978446,-0.8059387,0.50571895,-2.2641978,0.060126204,0.59634185,-0.9210571,0.7192389,-1.4990485,-3.0084612,-0.5312491,-0.6441128,-5.221673,-0.44178632,0.3047997}},
			{{-1.329589,0.59216577,-0.059746534,0.7508359,-0.371768,-2.5279312,-0.969889,0.92929214,-2.4368012,-0.114238806,-0.46665978,-0.8629417,0.43310866,0.8303751,-3.748695,-0.6002977,-0.5504373,-2.126056,-0.8252146,0.8650701}},
			{{-0.1306426,0.55213356,0.38343894,0.35782456,-2.0280957,-0.6244977,-0.35846046,0.96349627,-1.8028696,0.71130115,-0.9795866,-1.6739936,-0.06661074,0.8268226,-3.8082626,0.08115558,-0.14200687,-0.1410549,-0.96494853,1.2000611}},
			{{0.6403507,-0.23514464,0.61861986,-0.15554775,-2.5146234,0.6080933,-0.5758557,1.0652491,-0.5802971,-0.2958643,-0.1425567,-3.252852,-2.0326664,0.5173975,-2.6022182,-0.58064204,0.8722813,0.5142089,-0.6564273,0.758031}},
			{{0.73922855,-1.0022196,0.9208604,-1.1708444,-3.448816,0.783034,-0.50515723,0.84770095,-0.29092366,0.06890429,1.8320652,-3.279846,-3.7333796,-1.2037051,-1.7348247,-0.38194346,3.3423014,0.5875949,-0.5211399,-0.39279568}},
			{{-0.2508028,-1.1082386,-0.11665612,-2.8697855,-4.4883175,0.3297215,-1.6556901,0.56571496,-0.10405924,-1.936027,2.9528935,-1.9460758,-5.5344157,-5.301009,0.20070727,0.60281175,5.305204,-0.00962971,0.101848304,-0.65710586}},
			{{-5.840837,0.16809368,-2.0994334,-0.9698862,1.18835,-3.1717613,-0.7896768,0.8096134,-2.3382065,-1.5299863,0.8209552,-0.17086369,0.24359772,-6.5922475,0.2115929,-0.021773718,0.27410108,-4.3866687,0.88626146,-0.51034254}},
			{{-3.509294,0.8569552,-1.7780286,0.86590487,1.1273628,-2.563737,-1.0771432,0.6024512,-1.992687,-0.13997461,0.2223389,-0.08335471,0.295928,-2.4970605,-0.97480863,-0.3890083,-0.4177668,-3.5336282,0.7984487,-0.37625003}},
			{{-1.7281775,0.88004756,-0.6670873,0.8018833,0.056408077,-1.3216465,-0.69383156,0.50846493,-2.0843592,0.2918244,-0.28003177,-0.5965295,0.49965644,0.38943473,-1.3875864,-0.44947937,-0.7722167,-1.0103192,0.5756552,-0.09507111}},
			{{-0.13300608,0.29452115,-0.016171364,0.28929898,-1.3963703,-0.010929123,-0.6872744,0.56650084,-1.212424,0.4707357,-0.62810063,-1.3245301,0.6172222,0.6692574,-1.1254299,0.26250836,-0.31871456,0.22825797,0.3601394,0.29577798}},
			{{0.64081347,-0.48800996,0.76481175,-0.6733164,-2.8686943,0.2837987,-0.55783486,0.47329706,-0.03517055,0.20010528,0.17352533,-2.4456584,-0.5199624,0.3582335,-0.7189519,-0.5387684,0.14044416,0.5961689,0.37059525,-0.10489826}},
			{{0.9404116,-1.4357281,0.97898185,-2.736682,-3.630035,0.20071396,-1.0435598,0.61357605,1.0352514,-0.29896486,0.88922095,-2.7991445,-1.7346597,-2.6449685,-0.26493263,-0.6474723,1.5556091,0.45440146,0.7230306,-0.48394263}},
			{{-0.34024188,-1.7400346,0.13564134,-4.4720864,-4.3519287,-0.405774,-1.3314229,0.9099313,1.4746203,-1.6468713,1.3670052,-2.908148,-2.7963135,-7.180831,1.0119694,0.21569806,3.5435245,-0.14672993,0.8967222,-0.5461023}},
			{{-7.4421124,0.71393085,-2.1827214,-0.6084747,1.1785718,-0.98764855,-1.0108408,0.49086538,-1.1351779,-0.73652935,-0.8113413,0.22935672,-0.7839158,-8.155677,0.48634118,1.2982881,1.0632153,-2.5609725,0.9990986,-0.7183124}},
			{{-4.7898397,1.2236979,-2.4929593,0.87443554,1.1781129,-0.7503405,-0.6837426,-0.17845464,-1.2838304,0.9749742,-0.70046514,0.5217483,-0.33600652,-3.2234857,-0.2073127,0.34581318,0.16496447,-1.604959,1.0141919,-0.8259367}},
			{{-1.8919818,0.84083,-1.6597935,0.61497056,0.44128036,-0.1534826,-1.1037604,-0.25757438,-1.0930558,1.0342534,-0.67123544,0.22609463,0.123394355,0.08350433,-0.28590178,0.50773895,-0.62627727,-0.35623467,0.71256113,-0.8217632}},
			{{-0.12758188,-0.288445,-0.65123516,-0.08679927,-0.59223205,0.13463032,-0.92002624,-0.5710538,-0.36043608,2.163244,-0.6556836,-0.6035838,0.67417336,0.5912629,-0.044263303,1.1662861,-0.42817712,0.30839896,0.6565442,-0.51699996}},
			{{0.5659693,-1.3574061,0.51673025,-1.5269829,-2.0367787,0.0094283465,-1.2655697,-0.4265038,0.85629857,0.8441468,-0.3276098,-1.3202579,0.39128903,0.092243865,0.3693389,0.1522486,-0.5163033,0.41296402,0.4438828,-0.60207504}},
			{{0.84977394,-2.0471008,0.9800095,-4.453201,-2.9578164,-0.5009841,-1.1628346,-0.053113423,1.706398,0.8981278,-0.13544862,-2.034675,-0.04425777,-3.4620197,0.6272227,-0.15971303,0.35009587,-0.13454719,0.65209645,-0.6376581}},
			{{-0.626436,-2.3552592,0.8421815,-5.8323016,-2.7458231,-1.5101379,-1.0191592,0.35578957,1.7975199,-0.75131136,-0.2613312,-2.4201567,-0.6626193,-7.9519734,1.0838455,0.9517442,1.026892,-0.72979814,0.8427456,-0.5666886}},
			{{-7.8244376,1.4611768,-4.2202864,-0.001519672,0.67996436,0.6198394,-2.0980585,-0.43496764,-0.105037585,-1.2311276,-0.83813626,0.31190407,-2.941821,-7.7646885,1.0329555,0.5291396,2.2137659,-1.2502499,0.59731317,-0.9860545}},
			{{-4.3632574,1.245896,-3.399062,0.85163546,1.2441603,0.66578656,-1.2039316,-1.3771125,-0.77990144,0.038394395,-1.0335674,0.98607033,-2.0546663,-2.7398858,0.2012889,-0.07252326,1.3014436,-0.40116638,0.6398942,-1.1574873}},
			{{-1.959476,0.5681222,-2.666477,0.37999117,0.745705,0.5669037,-0.19084786,-1.8237191,-0.31085438,0.46853003,-0.89989996,0.86692584,-0.56454754,0.06594826,0.22117086,-0.05327149,0.1295509,0.33374977,0.104050204,-1.0008768}},
			{{-0.07370735,-0.91064143,-1.4292265,-0.7013635,0.10731659,0.08944648,-0.18992613,-1.9842398,0.2659986,0.684632,-0.50878465,0.4491519,0.3729428,0.48906928,0.45533267,0.5504791,-0.21068436,0.5884115,-0.076693244,-0.70337284}},
			{{0.6273839,-2.165834,-0.07479455,-2.4746227,-0.9994559,-0.8621437,-0.59815896,-1.7081401,1.1920787,0.12793988,-0.7565324,-0.037682608,0.6564268,0.06715207,0.5394806,-0.5341502,-0.5861941,0.3421573,0.030740224,-0.5741897}},
			{{0.9510985,-3.068486,0.74570227,-4.9196525,-1.9049222,-1.7422097,-1.670508,-1.1994368,1.6555521,-0.20241092,-0.8741628,-0.55982476,0.6342135,-2.9864945,0.85133785,-0.6971883,-0.06816773,-0.7264575,0.3991819,-0.60645515}},
			{{-0.28973252,-3.4472065,1.1970062,-8.0463085,-1.2872075,-2.8239107,-2.105392,-0.72319037,1.3521246,-1.3358079,-0.7109603,-0.9763768,0.41562194,-7.831822,1.3128842,-0.01648461,0.47690752,-1.5474694,0.8041615,-0.5852979}},
			{{-5.6663795,1.1496835,-4.932216,0.001606401,0.5098662,1.7858369,-2.3421612,-1.4741671,-0.101769954,-1.7451446,-0.5151991,0.30842322,-4.158617,-4.974341,0.9369379,0.72874755,4.9442363,-0.8219764,-0.14973296,-1.1658492}},
			{{-3.0784698,0.93096733,-4.118883,0.75334936,1.072467,1.3816186,-0.39555192,-2.9815454,-0.8922786,0.29570103,-1.0212467,0.82522,-3.0287073,-1.6814327,0.41042298,0.020620646,3.404903,0.09169269,-0.752806,-1.0027943}},
			{{-1.4907626,-0.081361406,-2.9197962,0.25370812,0.8549328,0.7158262,0.2734813,-2.9043784,-0.10285762,-0.20120125,-1.2105886,0.9428641,-2.3193946,0.26274166,0.43118098,-0.1675796,0.97343236,0.41603824,-1.6295123,-0.89578193}},
			{{-0.09450189,-1.4102553,-2.071385,-1.2310426,0.5505449,-0.64650023,0.4698889,-1.8589002,0.57028943,0.47120348,-0.68522733,0.57737464,-0.47801962,0.5958337,0.5170326,0.24634416,-0.07362497,0.40164608,-2.6521153,-0.44387203}},
			{{0.7849286,-3.1305575,-0.8354933,-2.8650515,-0.34808108,-2.291729,-0.2781976,-2.4090505,1.003737,-0.42795232,-1.0806708,0.7767532,0.5279402,0.34997424,0.33806744,-0.6301131,-0.12909903,-0.19006361,-1.7304564,-0.3699316}},
			{{1.0052434,-4.589901,-0.26943037,-3.5273592,-1.366593,-2.9694176,-1.2182146,-2.5451138,1.0908437,-0.18797511,-1.3780117,0.3938984,1.2318377,-1.8265923,0.6286299,-0.5294772,0.41070247,-2.674215,-0.6772121,-0.017203448}},
			{{-0.06606736,-4.8953724,-0.022961317,-6.6995215,-1.4274411,-4.231092,-2.8345547,-1.3088537,0.76085436,-2.2066457,-0.6507047,-0.5099953,1.3110237,-5.0510545,1.7992226,-0.042832304,0.8430777,-4.3980637,-0.20738472,-0.33583054}},
			{{-2.7983022,1.2144014,-4.783736,-0.08512082,0.21577647,2.210153,-0.83132994,-3.1782928,-0.4693693,-3.0640576,-0.9419943,-1.3155601,-4.5758224,-2.5367649,-0.14101045,0.85589963,6.186969,-0.6079314,-1.0875717,-1.2350416}},
			{{-1.7378333,0.15207584,-3.8103297,0.6099594,1.1759906,1.5106922,0.9264759,-4.09099,-0.6925538,-2.042631,-1.4228415,-0.18617123,-5.1996408,-0.4630422,-1.2038814,0.06301904,4.292963,0.1556885,-1.7136455,-0.8283613}},
			{{-1.0701411,0.20460561,-2.971523,-0.008482786,0.6950537,0.047720112,1.5017551,-1.3730263,-0.058139,-2.019644,-0.88088423,0.007273566,-4.0637307,0.55657816,-0.42135996,-0.0017468084,0.8033721,0.44199097,-5.0078726,-1.4193013}},
			{{0.035524946,-1.2510242,-1.7388397,-0.7194827,0.3349424,-0.73409337,0.052335493,-1.8069679,0.45514825,-1.2498721,-1.0219088,-0.07507776,-0.42966717,0.85545266,-0.3410577,0.50450546,-0.06667062,0.050032094,-7.0518875,-0.5614259}},
			{{0.6869871,-3.2802386,-0.47722855,-2.4367123,-0.028475905,-4.080423,1.1009493,-1.9446566,0.6293664,-2.030424,-0.6028131,0.33392546,0.216004,0.730571,-0.8318306,-0.6247563,-0.2756689,-0.7031606,-5.1913366,-0.5277505}},
			{{0.9882152,-5.455882,-0.7416215,-1.8433341,-0.902339,-4.3979034,0.4399991,-3.5909545,0.6711501,-2.3394074,-1.4928046,0.50804925,1.3526456,-0.41807827,-0.91207427,-0.5432237,0.8343793,-4.645868,-2.4967072,0.17624344}},
			{{-0.28488642,-5.6511297,-0.30758846,-2.9442174,-1.0775825,-4.7164903,-1.1327212,-2.867036,0.11273204,-3.5000985,-1.2441338,0.091853395,1.5155939,-2.2824025,0.37044567,0.39493206,1.263753,-7.343756,-1.0397441,-0.0807938}}
    }};

    b1 = {
			-0.11087356, 0.11896728, -0.23086089, -0.08732864, 0.45063308, 0.029116552, -0.33972573, -0.09337084, -0.30379713, 0.79959846, 0.6124893, 0.30832857, -0.3621259, -0.22258614, 0.452873, -0.104422525, 1.1591879, 0.36911687, -0.12929708, -0.33745185, -0.061687067, -0.017868023
    };

    b2 = {
			0.3761198, -0.001633271, -0.36021474, 0.33602, 0.49981514, 0.34358954, 0.2006933, -1.5804679, -0.088692285, -0.66359615, 0.8525075, 0.30044734, 0.696566, -0.05696556, 0.3419808, 2.391765, 1.9333972, 1.7604089, 0.3491689, 0.45975465
    };

    bout = {
			-0.9322295, -0.8319202, -0.33890012, 0.3726229, -0.48463383, -1.0237616, -1.0719318, -1.3250556, -0.4514574, -0.30547464, 0.5619598, -0.37563905, -0.6749312, -1.4217302, -0.7715764, -0.4081692, 0.4713198, 0.9331147, 0.3633525, -0.6286224, -1.0407205, -0.1458977, 0.4464512, 1.0413654, 2.0640643, 0.8008865, 0.15067342, -0.2383123, -1.2180129, -0.5716048, 0.4032022, 0.97420686, 0.2712851, -0.7244596, -1.1537776, -1.597742, -0.74772483, -0.43877637, 0.5781913, -0.46134236, -0.7516122, -1.6579332, -1.2619662, -1.0549468, -0.5167837, 0.029882895, -0.602274, -1.0658728, -1.12746
    };

    BN_gamma_in = {
			0.057639718, 0.67415535, 0.15779614, 0.32943404, 0.38675815, 0.18923873, 0.78430665, 0.4502687, 0.61734027
    };

    BN_gamma_1 = {
			4.0772996, 5.499209, 0.13400486, 4.222234, 3.2444541, 3.8196187, 8.071683, 1.8944999, 0.5058664, 3.4248307, 2.8809288, 2.6133761, -3.6890736, 17.269135, 3.0607805, 5.435639, 0.67227066, 3.114117, 2.7360542, 7.641779, 8.881477, 7.0148892
    };

    BN_gamma_2 = {
			0.15920137, 0.2525782, 0.22945441, 0.15102147, 0.17156608, 0.18297341, 0.18170251, 0.14430925, 0.21034466, 1.4870164, 0.21300974, 0.15632561, 0.16720052, 0.12625639, 0.14418027, 0.26980808, -0.13676198, 0.127032, 0.12907723, 0.21448918
    };

    BN_beta_1 = {
			-0.32388026, -0.058439184, -0.00045901598, -0.1680844, -1.2232924, -0.12045191, -0.022219565, -0.8562941, 0.0005444882, -1.7062914, -1.1490017, -0.5753182, 0.15119809, -0.019047718, -0.0021898844, -0.051947102, -0.1200477, -0.7567054, -0.7230986, -0.023631722, -0.06765934, -0.0015201438
    };

    BN_beta_2 = {
			-0.07691966, -0.074238166, -0.0666633, -0.0718895, -0.089213535, -0.102995574, -0.21600102, -0.063759714, -0.08673896, -0.08091984, -0.1555077, -0.10705561, -0.10734169, -0.057452925, -0.0581775, -0.63441163, 0.22163211, -0.19138467, -0.08486706, -0.27262318
    };
    
    mean = {
      50270.00278812122,32814.100678744784,46891.28361361622,41621.16404294983,21791.178170341536,41337.433591779336,47095.434124997926,32595.08412435691,49923.88279260183
    };

    stdev = {
      192277.57002833168,148902.63299216705,178409.20944839143,170471.77005005843,129693.55635497085,169053.99203804682,178924.76577600988,148103.8200182561,189676.17710192283
    };
  }

  else { // QP=22 and Default
    
    embs0 = {{
			{{-0.15999384,0.1169413,-0.24525781,-0.15169387}},
			{{0.017906602,0.0021782143,-0.004573885,-0.002478232}},
			{{-0.006220355,-0.0027203052,0.0040086466,0.0032101504}},
			{{-0.02912146,-0.03740433,-0.010441853,0.008311572}},
			{{-0.039129436,0.00463289,-0.0003652604,-0.008513847}},
			{{-0.12707068,-0.2693914,-0.15159118,0.085863106}},
			{{-0.10558799,-0.01889694,-0.0791674,0.026641423}},
			{{-0.19788985,-0.55465555,-0.303195,-0.8920192}}
    }};

    embs1 = {{
			{{0.22216794,0.3774822,-0.39910254,0.038417757}},
			{{-0.016546467,0.004544257,-0.00061463704,0.0007035641}},
			{{0.009466206,-0.005080758,0.0012749464,0.004962145}},
			{{0.009665419,0.0035552378,-0.0013639865,-0.05209392}},
			{{0.048771836,0.017642021,-0.009558673,0.0097826505}},
			{{0.043895267,-0.05099346,0.004058678,-0.054808073}},
			{{0.12516929,0.08967884,0.074497744,0.017810753}},
			{{0.27504432,0.25484654,0.6424521,-0.010604336}}
    }};

    in_h1 = {{
			{{-2.578872,-0.29512382,1.730418,0.2726976,-5.771079,0.30441302,0.50379467,1.5118376,2.594914,1.1287049,0.28914133,-4.063687,-13.448003,-2.4330356,3.1925545,-1.3262249,1.5502455}},
			{{0.30804598,0.0075833267,-0.083247796,-0.018330283,0.01792985,0.019952442,-0.10599161,0.083418876,1.0065117,3.059084,-0.53186995,-2.4467335,4.368726,13.079658,-1.4264853,-4.919805,4.0424385}},
			{{0.50420076,0.054200187,-0.24140835,0.09469702,-0.32024324,0.13054048,0.06972781,0.29687735,-1.9134307,-1.5567602,2.882923,-0.9412811,1.8217698,12.987328,2.5210354,-2.9710166,-5.836267}},
			{{-0.29575685,0.01193816,0.17097543,7.1153954e-05,0.11748443,-0.038671333,-0.053233728,0.19963416,0.8968978,-3.2203505,0.3393923,-0.34043258,13.565456,-4.586773,-0.01567497,4.526134,-0.7315958}},
			{{0.0006843098,0.015383859,0.0052084876,-0.008184309,0.043714482,0.02276043,0.0035869454,-0.10525188,-1.3013319,8.418675,-4.4957566,-1.1631374,2.4953003,0.56377465,0.38041264,6.9156184,-0.8588764}},
			{{0.2123394,-0.04648374,-0.15139441,0.077338256,-0.11831444,0.040942986,0.13073426,0.1215464,-0.75391454,-2.3074598,0.03542663,1.4819238,-10.090843,1.1059355,0.35335448,8.327735,3.1963031}},
			{{-0.3010581,-0.0077100685,0.37539083,-0.005802592,0.15984072,-0.13048951,-0.122120686,0.2368218,-1.1642283,0.6378857,3.3230083,0.29146272,-7.5984807,16.653513,-0.28137487,-2.107425,0.4521991}},
			{{-0.23904446,0.003770364,-0.014276617,-0.10919674,0.16209613,0.07969081,0.01351258,-0.036172025,0.26454517,1.3792073,0.14298372,-3.7181742,10.564654,2.6755886,-2.1506739,6.9056582,-0.37440547}},
			{{0.022571601,0.014229,-0.02113089,0.038353793,0.08531623,-0.03648032,0.031133084,-0.060906187,0.32949066,0.88603747,-0.11400082,0.22482684,0.74193186,-20.086441,0.24779095,2.8647265,-2.7143593}},
			{{-0.11582535,0.03445691,-0.12129066,-0.07530825,-0.14868979,0.21374424,0.0042518354,0.09300038,1.6892686,5.669063,0.9307163,-0.3253565,-2.1895397,0.6325405,-0.6169163,-11.046143,-1.2159266}},
			{{-0.000805217,0.0141192805,-0.011602419,-5.0272436e-05,-0.027257282,0.023151826,-0.013481414,0.03127563,0.14719635,0.8101019,1.1350564,-0.16615929,-1.4898181,-22.640951,0.056219388,2.4149067,0.88484955}},
			{{-0.0050500277,0.040030964,-0.12195719,0.15467596,0.44936675,-0.3334638,0.1524739,-0.3464737,0.13233802,2.408303,0.64393914,-3.049195,4.6302037,13.469142,-2.2224877,1.1539912,2.530302}},
			{{0.0793051,0.042987492,-0.085159875,0.009350374,-0.03427034,0.067323,0.0006273639,-0.0750523,0.89356345,-4.709213,1.5488348,0.45660606,-2.9039288,16.537855,-0.836295,6.071777,-0.9016401}},
			{{-0.06510365,0.07689505,-0.08160544,-0.11084112,-0.14766453,0.2117227,-0.06219523,-0.23377632,-1.0651113,-5.0093255,-0.79005796,0.07648278,5.867953,-9.060964,0.845374,8.330722,2.8920906}},
			{{1.336707,-0.4055143,0.7157043,-0.74410886,-0.69650495,-0.6583614,1.692607,-2.0525186,0.9340974,-0.6415192,2.1177182,0.54830164,-15.39576,-7.0514274,0.21675606,6.273298,1.528064}},
			{{-0.0517921,0.008985737,0.02280125,0.02846277,0.03469507,-0.036949616,-0.025072379,-0.010768815,-0.5122977,3.5592525,2.1007874,0.07343219,1.564479,-0.6029325,0.890672,-8.973922,-6.1445565}},
			{{-0.06424547,0.008185217,0.034945305,-0.007511508,0.006596994,-0.027199103,-0.056108586,-0.21420756,-1.3914585,-6.341566,1.4201057,-0.77909714,3.0956206,2.0027134,1.3969069,8.286134,-2.0846286}},
			{{-0.68298554,0.15002188,-0.26758108,-0.14774776,0.7301545,0.20451386,0.001764964,-1.4146663,-0.48505038,2.388585,-0.62128097,0.9927376,-11.21844,-14.260632,0.52679485,-1.0171875,-0.23795056}},
			{{-0.12407543,0.06360809,-0.031186255,-0.026186025,0.060996905,0.04493593,-0.01334534,0.19218954,-0.255228,3.5353947,-0.44737422,2.611785,-7.7228675,-8.567001,-1.353841,9.021975,-0.34534228}},
			{{-0.070377775,0.041501395,0.010293293,0.013528146,0.0971798,-0.009265966,-0.010723229,0.055527743,-0.0612816,2.082594,-0.7865527,0.1152599,2.1324077,-3.1684299,1.0058464,-13.348272,2.403128}},
			{{-0.14597662,0.037250437,-0.018338976,0.050112665,0.17332724,-0.043192048,0.008189834,-0.024734566,-6.3552537,0.9958705,1.0256574,-0.025612613,5.691217,5.918813,0.8785816,2.656812,0.5957354}},
			{{0.4617385,0.17470996,-0.009150971,-0.01858197,-0.41037184,-0.24720974,0.2651678,-0.03908856,-0.056649603,0.13114733,0.050010633,-0.0735661,-11.540876,-1.1224844,-0.05308165,-0.40883595,-0.040653765}},
			{{-0.22500725,0.061428268,0.3489817,0.1722243,0.09956645,-0.18432532,-0.14384732,0.40347597,4.29128,-4.2869096,-3.9984167,-0.7702319,3.420059,-3.1419437,-0.70700055,4.399197,2.6472142}},
			{{-0.029844575,0.09738572,-0.15987678,-0.071058504,-0.008842691,0.15667234,0.0042953435,-0.19680294,-0.81330496,1.3416647,0.2768437,-0.04806448,10.339898,16.231852,-0.4557608,-0.9534329,0.9047758}},
			{{-0.37471506,0.015512171,0.00050044537,-0.114955895,-0.52145547,0.54880077,0.1311977,1.1548691,-0.25023746,2.7099605,-0.4789139,-3.4674115,6.313964,-3.5238013,-0.7360712,10.83031,-2.6145918}},
			{{-0.12421655,0.07782356,-0.14440066,-0.134656,-0.049670264,0.28052264,-0.042103563,-0.04697646,-0.20967896,-1.5779562,0.3971976,0.6892982,10.086018,4.868621,-0.42210487,-10.278007,-0.53622115}},
			{{-0.19761813,0.03345281,0.05241689,0.02371653,0.21249549,-0.079548754,0.0042345524,-0.051347822,0.3892837,-1.3862379,-6.2341013,0.3338065,10.344279,-6.1223664,0.21217015,0.80127853,0.41341618}},
			{{-0.022550529,0.02779714,-0.0056644697,-0.016471786,-0.016896978,0.041676,-0.028361939,-0.055083282,1.0210131,5.1536455,-0.3605576,-2.1145694,-2.1566365,16.877234,1.1541703,2.887562,-0.70997334}},
			{{0.08368194,-0.032719087,-0.12644748,0.040163867,0.08535647,-0.05347806,0.14432941,-0.24777448,1.2182432,-5.2777796,1.1508043,0.6849865,-11.049049,9.189761,0.45746902,-1.5586134,1.38701}},
			{{-0.19560167,0.048152715,-0.020225279,0.03622961,0.10891313,0.036443483,-0.029525468,0.04354205,0.23247664,-5.311689,-0.12797087,0.10001476,-4.553028,2.486762,-0.097466245,10.754319,-0.13263498}},
			{{-0.07272916,-0.0032849503,-0.026658429,0.019815937,0.0047190306,0.05507778,0.010431095,-0.03748485,0.16979262,2.1206315,0.15395117,-0.2812962,-15.314269,1.993211,0.20217258,1.5103122,0.35168356}},
			{{0.6122055,-0.037047718,-0.04071085,0.05248382,-0.3699603,0.000104686354,0.049864512,-0.46275157,-0.49507302,2.9388337,-0.12930328,0.28553915,13.080163,-8.160947,0.02477216,-4.7605085,1.0514362}},
			{{8.072133,-0.5413367,-2.2456868,0.82547975,-3.9869285,2.6543002,-0.49764243,-0.30919775,1.6917007,4.828725,2.0105963,1.7560428,-9.1518545,2.7058702,-0.37646356,10.321853,-0.7991874}},
			{{-0.044440895,-0.23109318,0.32663792,-0.18792546,-0.014549761,0.30825618,0.0258422,0.009097234,-0.23615204,0.28254968,-0.17328084,-0.7281037,-0.21351612,-0.26201433,0.08310131,0.32549736,-0.5033661}},
			{{-0.17020975,0.007517838,0.03718049,0.047680967,0.098595165,-0.038127676,-0.022166872,0.03230207,0.16442563,3.8225958,0.19967598,0.11245734,-2.898459,0.32915896,-0.20906784,-13.194863,0.008951815}},
			{{0.14043202,-0.0183966,-0.025033144,-0.041304994,-0.24684945,0.124988995,-0.06707552,0.59906787,0.24492146,0.85409003,-1.1081326,2.9410856,-10.268492,-6.7495294,0.9298198,3.9087973,-3.230429}},
			{{0.16369906,0.046092466,-0.11503169,0.00045568822,-0.15723738,0.13387617,0.014334562,-0.18787086,2.2843425,-6.75885,0.83304864,-2.201251,5.022461,9.022492,0.70722634,3.9079158,-1.9260575}},
			{{-0.14172724,0.07718645,0.01687233,0.11965453,0.19755358,-0.07342366,-0.0070665246,-0.48116946,0.33295673,2.5717783,0.4295308,0.31145886,6.0939054,9.82484,-5.0575776,-1.4660854,1.218718}},
			{{0.4716973,-0.00062455377,-0.3559969,-0.12960461,0.1641704,0.119725764,-0.14980832,-0.038758766,-0.6006452,0.2790471,-0.26826307,-0.14821528,0.012822964,-0.41392574,-0.1096315,-0.051889267,0.387751}},
			{{-0.1552462,0.064426966,-0.08911142,0.07007955,0.31377062,-0.076279104,0.0044603674,-0.3597302,-1.0211408,0.079483405,1.1538464,-3.9698071,2.2318573,13.191981,0.25730512,0.08538778,1.8468223}}
    }};

    h1_h2 = {{
			{{0.6494229,3.4985557,-2.6555662,-1.8187678,0.23719996,-1.8892409,0.110712,3.4779098,-5.460859,1.2698061,-3.027961,3.0406528,1.4551195,-1.8984953,-0.46227705,-1.2034694,-1.5446527,-1.71511,1.9364406,1.7008331,-2.0390806,0.00012496537,0.4835241,2.1245675,-0.9359521,-1.0333778,-4.475627,1.0372258,-0.9255436,-1.8293362,1.9904745,-0.79533374,1.1494434,0.016961839,-0.1948602,-4.238097,-0.15357837,2.9406219,-0.0021510422,-1.6818001}},
			{{0.15131848,-1.5946279,3.8787653,1.3302386,-0.3737165,0.53491974,1.5824597,-0.011356931,-1.127727,-4.7531066,-9.820242,-1.3470509,0.30201134,2.334384,-0.055074867,-0.11352075,1.0358791,1.0878692,-1.400933,0.054596126,2.794163,-0.00361551,-0.588883,3.8348918,0.38489714,2.969815,-0.48569033,-10.703675,2.2725873,1.4574919,-0.06200557,1.2197517,-1.1315917,-0.006134711,-1.5173455,-0.6417167,-2.6211598,-1.0990062,0.0022889436,-0.20480831}},
			{{-0.23738092,2.7695086,-3.5842307,1.4376264,-1.4165987,-0.19156545,0.92656624,0.22586347,0.20342264,7.3540754,-8.846204,0.61805177,0.5793707,-1.5855925,-1.2449129,-1.8137132,-5.2513676,-0.73346305,2.0095046,-3.064112,-1.0226785,0.0011179419,0.013088191,2.79195,-0.97547513,2.6291108,-0.4500374,-7.5052004,-0.45572558,1.1260551,0.3943863,3.125262,-1.6557242,-0.005519714,1.6855911,-1.267162,-1.7496217,2.677802,0.0010298865,-0.9379268}},
			{{-0.21632539,-0.037348945,-0.100060925,-8.0218725,-0.3021015,-0.7080068,-0.20937333,-0.2686016,-0.088678,0.017199721,-1.4549991,-0.08114442,-0.7132777,-0.06004372,-0.28816196,-0.04057083,-0.024918402,-0.17877188,-1.349546,-1.6523161,-0.11121293,0.0012299907,0.039068043,-5.6077557,-0.32906097,-0.18007734,-0.13694099,-3.4337862,-1.0170566,0.21532074,12.912141,-4.2823505,-0.74732906,-0.00064300565,0.22804393,-0.52341986,0.33541396,-0.020717166,0.00019784468,0.22771995}},
			{{-0.29174307,-1.1604975,-0.9981561,-6.075874,0.75612754,0.9841131,-2.548089,-1.6850051,0.006169437,1.0711675,8.373672,-0.37556034,-1.1320739,-0.752665,-1.2499241,1.0545104,-0.950366,5.046158,0.3968496,-0.15538815,-1.0361743,-0.007511917,-0.8541315,-8.748488,0.2610583,-0.42477852,0.5642486,-4.187477,-0.39715385,1.8498148,-1.0644922,-1.3010248,-1.0962555,-0.00786134,0.09137174,1.0260831,-1.1336232,-1.1973389,0.0062275995,-2.1213977}},
			{{-0.24288698,-1.1569403,-1.8070407,-1.458526,-0.545467,0.69376665,1.0825046,0.32104573,1.5423956,-2.4556112,4.3468904,-0.054020897,-0.11869355,-1.1990184,-0.19118783,-1.1458567,-2.2230642,0.7284041,1.4494962,-2.7712772,-0.083852686,-0.0002562047,-0.6486781,-1.3999472,1.5324318,-0.98256284,-0.042461783,6.363018,-0.009670893,-0.55771536,2.8531435,-2.064743,0.40607283,-0.009150362,-2.6134686,1.6164458,-0.5147644,-0.39678007,0.0075569083,0.6875371}},
			{{-0.6649442,-1.0942607,-0.24555823,5.7589626,-1.2429979,-1.5036864,-0.13876088,1.0223598,2.7783256,0.5497337,-2.7308846,0.4567779,-2.3838615,-1.3863883,1.5268945,-0.51332307,0.2538658,-1.140994,-3.346161,6.1742644,0.2104364,-0.00010642522,0.8223433,-1.2785146,1.8490378,-0.95198125,0.35861,2.3337214,0.6241796,-1.659308,-0.21774374,-3.2916856,-1.9335655,-0.00061771966,0.095109485,-0.26153693,9.266058,-1.3491765,-0.005070416,-1.0629295}},
			{{-0.6670236,-0.6337278,0.21911085,1.0893263,-0.8858386,-0.20993744,-4.4784956,0.14904508,2.5795271,0.081947304,7.182697,-0.96845895,-3.3905263,0.6505346,-0.19111848,0.5880339,-0.19099304,1.779119,0.8450397,0.53099054,0.21357906,0.0010931612,0.7242533,-1.968432,-0.73728913,0.06369733,-0.6996592,-3.1523154,1.9873294,-0.6876127,-0.039203167,-0.2609194,0.57435817,0.0021319496,-0.20034671,-0.6635709,-0.18957831,0.15182266,-0.00096170086,-1.194734}},
			{{0.48281577,0.021013293,-2.9832213,0.6166063,-0.42672965,-0.08331199,-3.7579217,-0.49428797,-0.78924584,-1.9851416,-21.553316,-0.7481853,1.5570419,3.4659765,-0.923296,-3.3808944,-1.7826518,-1.8344574,-0.5023346,0.38841718,-0.8916902,-0.003533087,3.4993958,2.4829333,-1.0631804,2.008456,1.0530896,-3.2469506,0.0069874106,1.791407,1.2821923,-0.18149853,-0.97597027,0.00039832832,-2.1950736,0.47569856,-0.63580877,0.8201701,0.0022833087,0.41900867}},
			{{-0.3436907,-0.023050712,0.07413098,-7.1276436,-0.013919546,0.18004577,-0.6786157,-1.4065791,-1.0021322,-0.069454245,-0.29370034,-0.14787748,0.04838256,-1.5138396,-0.12650824,0.28525934,0.19475058,0.3181376,0.4291445,0.8254766,-0.14911494,-0.0023146267,0.016409613,-0.5068534,0.29947937,-1.9355224,-0.60305655,-1.6627883,0.070387445,1.4293493,10.108889,-9.799685,-1.5617666,0.0032764336,0.8548685,-0.39129832,0.3699114,-0.37324056,-0.0020742358,-0.2459838}},
			{{-0.95402247,-0.0059587737,-2.3599555,0.0741897,2.6012526,-0.8561225,-10.694374,0.94039357,1.4806042,-1.2428819,7.894862,0.05287004,-8.826011,0.15809035,-0.008437227,-1.1761137,-1.3147995,2.2753685,0.30803284,-0.09842256,-1.1191425,-0.0013840814,3.0906034,-3.1185505,-0.106236525,0.10875249,0.47527698,-3.0948353,9.534057,0.27370057,0.56605315,1.2172942,-1.9829954,0.0018875106,-0.78016055,0.032864574,-1.0471333,-0.81166637,-0.0031053324,-1.8145682}},
			{{0.18484962,-0.36177465,0.027563274,0.5614504,0.33639553,0.72958326,0.64961296,0.66967833,1.2014228,-0.37309512,-10.383398,0.2700877,0.13919888,-0.7696013,0.3476254,-0.024996407,-0.7089945,0.054977447,1.0353578,-2.8887193,-0.091038726,2.590694e-05,-0.53068256,-2.7424295,0.3656816,0.15594704,0.5405078,6.1263633,0.09577156,0.40940082,-1.2188902,-0.77582175,-0.3781253,0.0022001343,0.62499195,0.6749716,0.91899663,-0.86422,-0.0025719528,-0.1913924}},
			{{-0.7965415,-2.17588,0.80404466,-1.7587647,-2.7812228,2.0605774,1.1573275,-1.9784575,-4.473646,0.7028378,-1.6172626,-0.7517309,3.0371232,-0.48200825,-1.664158,-0.36259735,0.031961083,-0.2830917,0.09907619,4.6646276,-0.4045843,-0.0025694242,-0.6023902,1.398488,-2.9376836,1.602044,-0.3164827,1.3855927,-2.019195,0.32200846,0.92850345,-2.1237788,0.8820015,0.0005003536,2.6977913,-0.5109249,1.6798449,-1.5900013,0.00014679134,-0.18631484}},
			{{2.0723493,-0.4820185,-1.3876691,1.378361,0.2983507,0.10949395,3.2363608,-2.8873417,-0.63236594,-1.2284746,-1.4014077,-0.07348625,0.7898916,-2.0349193,-0.53287274,0.81285566,1.3972552,3.6504548,3.8925383,0.36725414,-0.65975827,0.0021240325,0.8684163,-0.039200798,-0.33259773,-2.0616262,-0.28130433,1.7182444,1.0639254,1.6063653,-4.689209,-3.5561426,-5.328838,0.008485771,-0.5808157,0.83916533,-2.8333945,0.45048892,-0.0133380825,-0.2543604}},
			{{-8.434773,0.8722313,-0.5179257,-2.7381814,0.19975263,-2.0462167,0.13060021,0.044363078,-4.644876,-0.07958854,2.3994741,-2.1783142,0.69547886,1.1888201,-0.7107538,0.14657013,1.4516083,5.0314007,-1.0280367,1.1459031,-0.17884375,0.010007427,1.2490036,-0.49927863,-0.3584557,0.18791525,-5.1004634,1.5582547,-1.8257844,2.6328475,1.2241735,-2.959209,0.73036873,0.0027226906,0.47441816,-1.2370496,-1.509145,0.095020905,-0.009704638,-0.840113}},
			{{-0.79734266,-1.5008988,2.9516194,-2.1836307,0.89084923,1.0374116,-1.1512082,1.5354012,0.25057796,-1.168701,4.706957,0.32464018,-8.602778,-0.40838084,-1.5821271,0.4537266,-0.01381477,1.3711114,-1.228306,-5.760484,1.9149779,0.0052582333,-4.469085,-0.52803713,3.9228008,-1.5040082,-1.5134286,-2.7483532,16.01495,0.1547893,-0.74588555,1.3197691,-1.4582359,0.009915152,-0.35989165,-1.6592458,-2.8066072,-1.5062114,-0.008548443,5.1940265}},
			{{-0.06021803,-1.2994046,-0.48492068,2.0719626,0.49183545,-2.6384175,-1.7562137,-0.374088,3.4119458,-1.3850737,-11.904759,-0.04843212,1.2683275,-0.7940113,-0.14983372,6.3284416,-0.66510415,-0.43718767,0.80711997,-4.1798973,-0.5464959,-0.004286146,-1.7153572,0.0034361002,0.22385888,1.9946193,-1.0314748,0.23105228,0.75173837,-0.28692698,0.8073142,-0.87713164,-0.53082824,-0.0036514867,-0.053116035,1.073785,0.070433415,-0.28894696,0.0038279635,0.14773841}},
			{{-0.70883644,-1.946013,-0.8388505,3.3493593,-0.25085613,0.910404,4.3303213,0.5756517,4.6995173,0.50445,3.2855496,1.225444,0.63413596,-1.0191222,0.009750472,0.21827656,2.6169338,-0.0808973,3.137836,-7.838162,-0.21352023,0.006216061,-4.4915013,0.109534845,-0.6364742,1.7453635,-1.8168261,-3.317005,0.79801744,1.2794974,-0.03764289,0.2798729,-2.4743602,0.0059063383,-1.0929147,2.4320836,-3.7953012,-0.4888153,0.0007421869,-0.98397726}},
			{{0.30516326,-0.9870697,-0.53478056,-7.1730404,-2.109297,-1.879462,1.6175824,-2.0798595,-1.5967718,1.6209718,-16.739439,-1.1984428,0.43405533,-3.1165385,-0.50632733,4.218896,0.93943435,0.78950906,-3.272689,3.0400088,-0.082573414,0.012903405,-0.045514017,-1.948507,0.7843211,4.6507373,-0.08017639,-3.5942805,0.03286687,0.17072088,-10.743721,-2.9438214,-1.2892029,0.0041256235,2.9306102,0.45765254,1.196834,1.2907511,-0.0037582638,-0.4221633}},
			{{-2.7003217,-3.2324061,0.025699522,1.3555481,0.91464525,-0.0036127053,-1.4976625,1.0863099,3.0826342,-0.91260326,3.0608144,-3.1007402,-2.564642,-0.15133336,-0.120223925,2.5526388,-2.3616881,4.0847774,2.3451254,1.6820844,-0.858967,0.004222969,1.5221924,-5.063685,-1.469609,0.7766591,-0.6472944,-0.26811346,-2.1532655,1.5084603,-1.1969402,2.202954,1.0053103,0.003120061,0.124929965,2.374545,1.3708357,-1.294095,-0.0028193288,-2.5397732}},
			{{-0.73761415,-0.12783074,-3.3848114,-5.2452736,1.3185002,2.065048,0.59375215,-1.718143,0.9971438,0.4796835,1.2061826,-1.3558387,-0.9580459,0.67656463,0.20300569,-2.7615018,0.5464811,0.20231095,4.53307,1.3143684,0.48144042,-0.0043282914,1.2147294,0.7367381,1.4920204,1.5254544,4.3746796,-0.59526247,0.48408782,-2.46807,-3.2354054,2.3708131,-0.9450005,-0.015986694,4.144498,-0.45328018,-2.5962577,-0.19861485,0.009692784,0.7288348}},
			{{-1.0867513,-1.4087397,0.5098182,-4.7791657,0.8751755,-1.0288125,1.8112968,-1.4934891,0.38992146,-2.2563615,-3.0457973,-1.3871018,-6.1093917,3.932566,0.29632136,-1.1191605,-0.6314156,-0.9483651,-0.34458387,9.571957,2.3315008,0.0031226065,-1.2048575,0.48041484,1.6840408,1.6294385,-0.568073,2.5904126,1.3947266,-2.4927628,2.0542188,-0.74264824,-0.30125803,-0.0034202517,-2.6667135,-0.83487105,-6.581111,0.4122889,0.001945418,0.498658}},
			{{1.6138277,0.2965459,-0.5690969,-3.9731188,-0.19292241,-1.3463514,0.04873082,0.6707584,-0.2856513,2.3156955,0.06073211,1.7065009,-2.4750614,-5.7687235,-0.8443799,-1.189029,-1.2878263,2.283005,-6.2147,2.355605,-0.48728335,-0.0026183308,-2.4476278,-3.1198528,-1.0143818,5.4962583,-0.28549114,-1.482901,-1.2378696,-5.014318,3.9535894,-1.2502197,-2.6977642,0.0008723538,9.722837,1.6275061,-2.7282314,-0.8893754,0.007456969,-1.0986282}},
			{{-0.027593687,-1.3218488,-0.2220111,-0.64656144,-0.41802314,-2.4202855,-2.331969,-0.11841545,15.688928,-1.0732378,-0.5860283,-0.1643685,-0.14002803,-1.149725,0.86237365,3.9866493,0.8555766,1.593369,1.6087735,-8.102979,0.05003042,0.0034856922,-0.62145525,-0.72708833,2.011835,-1.2838994,-0.942889,-2.1391182,10.290911,-0.95976263,-1.7323855,-2.0381439,-1.487915,0.004736922,-0.675576,-2.1029127,3.8709197,-0.8278087,-0.0039601116,-1.2025456}},
			{{-0.43289226,-1.2765179,-2.2695115,-3.3110394,0.31850863,-1.9933127,-0.3220451,-0.79301107,0.005309,-1.2723411,-1.3589315,-0.86615056,0.919765,-1.0634917,-0.93860626,-1.373488,-0.84297746,0.237353,-0.5318181,-5.1422634,9.093002,-0.00054852065,-1.1164111,-0.68030477,0.7171462,0.6535527,-0.597306,-0.17717771,2.8214421,-1.1605856,-0.30110303,-0.31575683,-0.53052825,-0.0016499164,-0.7643292,0.026655596,0.51573366,-0.9785248,0.0022139926,-1.5303808}},
			{{1.7437146,-1.7632076,-1.11185,4.855622,-1.443219,2.4017677,0.65261275,-2.1498044,-0.60213363,-10.229742,-0.97006035,-1.1224298,0.725506,1.657518,-0.40100363,-2.288719,2.7695563,0.4238433,0.19743799,-2.4041512,0.45184603,0.003911929,1.6029068,-0.843841,0.6353309,0.021237444,1.1513197,-3.1848478,-0.21650213,2.609355,1.3605189,-0.9718747,-0.19815436,-0.011783183,-3.3877728,-0.114184394,4.48588,-0.1264472,0.008344726,1.2918628}},
			{{0.06571827,-1.2650726,-0.77097183,1.1717093,0.16142808,-0.5892171,2.0982425,0.2808893,-0.47225183,-2.6190367,9.654735,0.7807282,-0.041060206,-0.923523,-1.2149745,-0.81742805,-0.9590841,0.031428974,3.0522995,1.5870966,0.8622446,-0.005132378,-0.80700165,0.1268871,1.5512325,1.2953882,-1.182124,-5.749864,0.051640037,-0.7781777,-0.15689155,0.8604213,-0.24101251,0.005741449,-0.067595534,-0.540971,-3.557664,1.7364736,-0.005979527,0.14738698}},
			{{1.2564378,0.3979893,-0.17498726,3.898073,-0.2383061,-1.2608309,-0.07884099,-0.72730863,0.6657869,0.87582636,8.965437,-0.5020422,-1.3857586,-0.8751603,-0.20690516,-1.4387143,1.1241429,-0.5396247,-1.8657978,3.4844646,-0.77149504,0.007615378,-0.5386476,-0.23025975,-1.2953415,-2.1062617,-0.18030138,-4.697966,-0.66435784,0.36838472,0.47397482,0.9960386,-1.6169918,0.006734753,0.358307,0.03432723,0.3212716,-0.25412774,-0.0051821163,0.9709783}},
			{{-1.9285376,4.9264097,0.7904757,0.73017573,-2.5127544,-3.8535726,-1.635512,2.3261576,-6.6999364,-2.3585637,-3.406167,2.3792198,-1.1944114,-0.96763915,-1.8017781,-0.47091427,3.1999059,-0.32499176,-1.3313955,-3.6847801,0.41167915,0.0094843935,-0.025116516,-1.1480794,5.230532,1.0205683,-2.7532806,4.4788766,1.8166461,-0.7093248,-0.84788716,-0.98539484,-1.2050189,0.0030365493,-1.8822008,-6.6790757,1.2492703,3.589269,-0.010259891,3.3855858}},
			{{1.318265,-0.2039347,-1.0816345,-2.5461397,0.5909332,-1.0987543,0.9110349,-1.4094406,-0.7524899,3.6824331,-0.40679437,0.40601817,-1.0967324,-5.803793,-0.6593056,2.9350996,0.6580445,1.0766466,0.041262873,2.555824,-1.5772645,0.00019510592,-1.0406917,1.5213856,-0.4673577,0.8961848,-1.183798,0.75773764,0.6399354,-4.373166,-1.9261967,2.0078082,-0.6590784,0.0035506506,8.311753,1.0642567,-0.87021667,0.062780835,-0.007445156,0.32573557}},
			{{0.6834601,-0.24094692,-1.7450265,-3.712748,-0.21283458,0.4678228,0.51263577,-0.30975637,-0.60733175,-2.717675,1.1170521,0.26194513,-2.3361695,4.025556,-0.6877876,-0.043215115,0.5158649,0.4901618,-4.128193,-5.2497582,0.13112059,-0.0021281037,0.14813916,-0.56326514,-0.11616727,-0.2368579,-0.4384977,-5.7580523,-5.3762417,3.973521,-4.921175,-6.7634344,-2.1076195,0.0034819806,-4.260074,0.3119968,3.4851515,-0.6600586,-0.0030886892,-0.43364477}},
			{{0.0595163,0.11319594,-0.20215914,-0.21896835,0.19443978,-0.46909124,-0.3176534,-0.035174593,-0.08826503,-0.10354866,0.18888885,-0.27865207,-0.00016711901,-0.049587663,-0.52893364,-0.11295294,-0.3205921,0.21474223,-0.40700516,0.041593842,0.15944931,-0.050534774,-0.31473744,0.088867895,-0.008084245,-0.34157047,0.091232836,-0.2983286,-0.081068814,-0.06223235,0.14312457,-0.25374767,-0.32214454,0.1414462,-0.0007390262,0.19577083,-0.0037570347,0.12669542,0.13951309,-0.117095575}},
			{{-0.6851324,-2.8789713,1.8476586,2.5806649,1.4408623,-2.1677437,-1.2031349,-1.1600215,14.874076,-1.8290204,1.7641735,0.71145236,-1.0741829,-1.3181871,-2.2968733,1.4023551,0.7248126,2.2865472,-0.5197853,-7.736124,-0.8327494,-0.0013751135,0.50404495,1.1754788,0.19955659,2.0133991,-0.25374308,-0.68214643,5.8113537,0.30524746,-0.36544558,-1.1423093,-0.61904305,-0.003806825,2.3671482,0.34663472,1.5428772,-1.1268094,-0.004984499,-0.34199864}},
			{{2.5551476,0.66329575,1.8677545,-2.229647,0.8472206,1.6491675,1.6483763,-1.290854,-1.574063,-0.06497443,-1.4953542,-0.09206904,-0.8810731,-0.27991942,-0.5117228,-0.39912796,3.183778,0.12474956,7.121915,-5.2141876,0.5097015,0.0018190877,-0.94315046,1.3274435,-1.6557139,-2.6992366,0.13639838,-1.3197573,-0.32140088,-2.5324259,1.8951477,1.9250387,-0.7969742,0.007461799,-1.5147645,0.91131294,-2.9098616,1.7731533,-0.0041653756,-1.1822656}},
			{{-0.88437814,-2.8980365,0.06862297,-5.112458,3.2596002,-1.4506067,1.1856993,-0.6035354,-2.305846,-2.816101,0.3846127,-1.1780099,0.53298795,0.014150065,-0.69629294,0.027403334,2.2065094,-2.1073658,-1.5208375,-4.117666,0.35767445,-0.0023088027,-1.1090059,5.2620025,-1.0349929,-1.6295949,-1.8209977,1.9454908,-0.9641259,0.57348657,1.9161825,-0.8775683,0.8140648,0.006687793,0.5784485,-4.9948373,0.83272606,-2.7437184,0.0008027095,2.7889404}},
			{{-1.817111,0.0045322618,-1.4740226,3.7343104,0.16401781,-3.7459207,-1.5777153,-0.47189415,0.40018147,-0.058427606,-0.25222525,1.2083725,9.625984,-2.9678934,0.013847254,-0.92177665,1.563016,-1.2887963,2.2174084,-5.863434,-2.4545975,-0.0041227024,-1.1885252,-1.1304058,0.78541356,1.965318,-0.49755776,1.7655103,0.55289745,2.140309,-1.1427603,-2.36047,-0.8300497,-0.00030673645,0.6970701,2.375296,1.4630276,1.9048347,0.0044462546,-1.0186661}},
			{{-0.6174014,-0.97070026,0.1335528,-2.28886,1.3071722,0.5880756,-1.6330466,-1.650826,-3.049646,0.26463923,-0.12019415,-1.8351581,-4.5995255,0.45801255,-1.6743513,0.61963516,-0.16920136,0.6930902,0.792901,3.4621415,-0.19276945,-0.0028515141,1.6993026,0.94074005,-0.21554612,0.44373968,0.04943552,-0.9063548,1.8364878,-2.5427241,0.62466085,-1.033229,-0.62006176,-0.0006068331,0.720437,-1.148595,-0.007587419,-1.2264769,0.0031228543,3.1153865}},
			{{0.044752747,0.070207365,-1.9101017,-0.4407791,1.6329987,-0.09430953,-9.599009,-3.3686655,-4.9625325,-3.2373068,-5.9656787,-0.92202175,-3.7349074,1.4531816,-1.2601024,-7.963122,0.75089186,0.4762154,4.189618,-1.2983361,-0.5611927,0.008240936,1.0516644,-0.50099516,-0.37920934,0.7140876,4.821326,1.1550828,-1.1225085,0.75385046,1.9763576,-0.85266775,-0.94969,0.013224946,-2.2065663,-0.06919363,-2.0575755,-1.1949464,-0.014214972,-1.0064874}},
			{{-0.78769207,1.1224985,0.5474348,-1.4015174,1.5937047,0.60105735,-0.14637238,1.2252147,0.246772,-0.19549121,1.9666532,-0.20412965,0.5729713,0.508233,1.9754158,0.98983663,-0.6923873,-0.9509497,0.61252534,1.5245453,0.579325,-0.008672927,1.1636837,-0.9308242,1.9260455,0.7513134,0.9477071,2.9380062,1.2781309,0.64036405,-11.754806,-1.6119457,2.4391086,-0.0013388441,-0.028809605,-0.080067,-0.44939908,0.24536555,0.0035449096,-0.52991366}},
			{{1.2085285,0.5793947,-4.784218,-3.0221622,-0.07067377,2.0437136,-1.7898974,-0.99093354,-2.9654353,-2.2941563,3.747091,0.6868228,0.19121346,2.7278843,-0.8152115,-0.28031084,-1.6758155,-0.36165854,-1.2681092,1.553917,-0.9415818,0.013877926,3.3874588,3.2433636,-2.693324,-1.806939,-1.1118188,-2.6324043,-0.08760965,3.5551367,3.7095065,0.72511065,-0.3025004,0.014500174,-3.6591113,-0.38923815,-0.54162043,-1.3717216,-0.02031957,-0.1859869}}
    }};

    h2_h3 = {{
			{{0.47371215,2.2984755,0.68844587,-2.1446285,-5.580645,0.23299381,-0.68177146,-1.1167178,-0.8153911,0.48792967,1.0771247,1.3300532,1.2137972,0.39737043,3.5632489,-1.3123164,-1.1821922,-0.20411561,-1.5189708,-3.0671394,0.50307816,-0.5778178,-0.0343792,-0.34145105,0.067019284,0.19443037,0.5292885,-0.09424192,-2.214291,-0.21731104,0.15715618,-0.002736009,-0.79891944,-0.013668878,0.033558782,-0.62930703,-0.804113,-1.576557,0.060703896,-1.0347776}},
			{{0.14765748,-1.5083584,3.3432922,-0.15751041,0.43140334,-0.14025645,-1.0219364,0.8877951,-0.12270516,-0.16480115,0.32978678,-1.0399493,-10.031864,-0.40276495,0.33116227,0.07091211,-4.4518843,-2.4991426,1.54546,-4.148875,-0.2341876,-0.10961889,-0.3422386,-0.4294745,1.516348,-0.56105185,3.5523233,-1.4540583,0.8079364,0.20734984,-0.44401306,-0.0033383782,-1.1596224,0.7718301,0.39625555,4.2823997,-2.4472206,-1.3064569,-0.25795326,1.20658}},
			{{-1.3652693,-0.527147,-0.34318778,-2.2378058,-0.8359976,0.15347846,0.34294912,1.5487449,0.49879944,-1.7116594,1.704087,-0.5666758,0.36858863,-1.021615,-0.4486092,0.2515428,0.5592327,0.36536676,0.8594235,1.5676043,0.3426503,0.055736605,-1.0626287,-0.6468126,0.017517218,-0.3655981,-0.107062474,1.0918958,-0.3721118,0.45819163,-0.6346637,-0.009283683,1.247329,0.42140937,-1.3352185,0.5068504,-0.6223188,2.1558423,1.6262248,1.5779283}},
			{{-1.5875843,1.92795,-4.0544996,0.0432723,0.4677771,-2.9911094,-2.9895349,-0.09655909,-5.1839933,0.59625834,1.5640953,-2.6057627,0.24425551,1.8872901,-0.87299997,-0.93875974,0.07219689,1.7578051,2.9231637,0.42102706,-1.4468765,-2.2151453,-4.1885443,-0.49277312,0.5100976,-0.36378458,0.1896704,-0.89274555,-0.27519023,-1.8176929,1.5494984,-0.00032635193,0.46545395,-0.70948476,-0.032198254,0.32657224,-2.3057647,-1.5480906,-1.7584584,-6.7038445}},
			{{-0.5158141,-0.537717,0.5473237,0.56497735,-3.2294047,-0.420673,0.89727485,-3.098353,-0.8369494,0.60302424,0.2753775,-0.512829,-8.331958,-1.529846,-1.9805647,2.623669,-0.84067357,-2.599264,-1.6635064,-2.9759057,-2.4238002,-0.5655311,-0.09502311,0.106543444,0.4249253,-0.5641,-2.1881406,0.06938669,4.685749,0.14498559,-0.24201249,0.004503379,-0.17486835,-5.508599,3.4564872,-0.32444045,2.38355,-0.84860843,1.0042896,-0.33292183}},
			{{0.10569511,1.116822,4.2022023,1.1616702,-0.81866753,-6.964731,-0.23376426,-1.0845877,-1.1557184,0.8709012,-0.37822768,-2.6166148,-2.4387016,0.47167152,0.12790367,2.2886665,-1.5069962,-3.3129454,0.8361636,-0.011219916,0.37140056,0.3750901,0.5920875,-0.55380297,6.414328,0.7706618,1.1011975,-1.6469027,-0.32002056,-1.7969993,-0.96487504,0.00498051,-1.4917166,0.21743834,0.28344378,-0.55441964,0.69859076,-0.97114307,-1.1599392,-2.0283196}},
			{{-2.0448,0.5664155,0.6845097,-1.4658917,-0.8358254,0.15365183,0.10649067,0.7961198,0.6578349,-0.31593385,0.14725482,0.45194525,0.57777977,1.278515,-1.155337,1.7422773,-0.04708436,-0.6525798,0.5485514,0.1545052,-0.13756518,-0.3859692,-2.4651315,-1.6648014,0.05170664,1.5439258,-0.4949412,0.45799223,0.11554179,-1.7808745,0.9900048,0.0033136755,-1.4562252,0.3357683,1.1439553,0.958953,0.122927606,0.8651419,-0.5974528,2.4413688}},
			{{0.22466804,-1.2880329,-1.0752286,-0.5459329,1.5512418,2.291902,-0.5539774,0.8223423,-1.1584048,2.033471,0.4686864,-0.71987987,0.36429673,2.056498,0.26960784,0.042194825,-1.6358472,-0.07278794,-1.8278524,0.3301305,-0.12564777,-0.30577487,-0.35384038,-0.714904,-0.51378584,-1.0550578,-0.09742753,0.6911792,-0.4602135,-0.96066946,-0.8842974,0.0053316127,-0.119516835,0.18194547,0.21082942,-0.5479062,0.25413126,-1.2012994,-1.6650469,-0.30325508}},
			{{-0.70481336,-1.0028749,-0.48112518,0.14056538,3.9998364,0.024210328,0.20999195,4.200961,0.75959027,-0.48166385,1.7885185,-3.067407,-8.93685,-1.3466655,0.22852917,0.18889669,-0.27979684,-0.407942,-0.45956865,-3.9819598,-0.31366134,0.30868995,-0.06821944,1.5064352,-0.30353338,0.2667576,0.86161184,2.8628745,-3.1368022,-0.30180493,0.06675924,-0.0041138628,3.9270046,-2.9743962,-0.053857952,-0.17500678,0.7545688,-0.4110386,1.4179714,-1.1602348}},
			{{0.5328778,1.6562728,-0.71192515,0.45859265,-0.37416735,-10.517576,-0.19144247,-0.7114857,1.8245667,-0.22370069,-0.1535959,0.34577593,-0.32190904,-0.89110553,-0.347021,0.40462023,-0.99383885,0.770967,1.0208371,0.42700824,-1.3416132,-2.0100033,-1.5230017,-0.033657413,-0.31797755,5.071079,0.33293107,0.6944103,-0.34393966,-4.822532,3.1652443,0.0011315069,-0.5244707,-5.755385,-0.8620366,1.0148399,0.023307972,0.15131788,-0.46248603,-2.2045765}},
			{{1.6891719,-3.162548,0.5036383,1.1542494,-0.22412916,0.2960028,0.051406898,0.2063119,0.94712764,1.043979,-0.15776718,0.27272758,-0.5920314,0.6666898,0.2220163,-1.4414244,-2.3518932,-1.5755794,-1.3121202,0.25504163,1.4186618,-1.2321088,0.3325075,-2.9487834,-3.0594049,-0.691788,-0.33890206,-1.1083736,0.7878682,-0.006218376,0.4648898,-0.000119233984,-1.1482637,-0.22197348,-1.8044646,1.7210126,0.099224076,1.4657825,-0.87564284,2.2117345}},
			{{1.5805587,-0.32853338,-0.12460108,-1.1672319,-0.104212664,0.49133292,-0.118390545,0.1264657,0.8828285,0.07709682,-1.6131266,0.01703548,0.7180576,1.2820946,-0.6511941,-0.8040982,-1.5555738,0.34367123,-0.04250638,0.122392416,0.86079526,0.54339874,1.7015606,-1.9782295,-0.4075219,-3.271699,0.1293952,0.96731246,-0.09734738,1.9527379,-3.2981925,0.0067765624,-0.5873988,-0.49600786,-0.63313574,-1.4502451,-0.509931,-1.2191535,-1.6161797,-0.6783335}},
			{{0.2147906,1.7265784,0.94825935,6.569722,-0.22135368,0.16491266,0.23178358,0.80341315,0.47051585,-0.3195991,0.64061606,1.3468401,0.8238786,-1.4050953,-0.98941696,2.428579,0.2534491,1.2140387,-1.5405566,0.806488,0.14466189,0.6873864,2.3572533,2.7195885,0.02891337,0.039266687,0.60475457,0.9571888,-0.10231162,0.32040522,1.3972733,0.027441474,-0.4258254,0.21298744,0.30920118,0.47045204,0.6637692,-0.5720638,-0.3199227,1.3912737}},
			{{-2.2917113,1.4436668,-0.7789845,1.2815719,-0.38252053,-2.2247977,-1.6349905,-1.8821332,2.4799056,-0.19207378,3.0001307,5.7847557,-3.77705,-0.5315851,-1.5722127,0.8200322,0.4898878,4.7502093,3.147496,-0.72548074,4.496988,0.49794325,1.9393011,1.4502218,-0.715544,-0.009083992,-0.0011457922,-3.6484256,-0.40122658,-3.017225,0.17710176,0.0111572435,-2.002612,-1.798896,0.4804464,-1.1157897,-0.21571594,2.6297886,-1.4097931,-0.33941308}},
			{{-1.8662732,-2.4099693,-1.3053598,-1.4503291,-1.3249414,0.21937484,0.7942066,-1.7418326,2.0997195,0.26794612,-1.1134684,1.6934384,-1.212507,0.5981312,0.746651,-5.4106627,-1.6076258,2.6750724,-1.1972632,-1.6440526,-1.1287314,-6.7564535,-0.35514998,0.08465726,-0.16507356,-0.16385536,-4.80697,-3.6611981,1.1871337,-1.1954695,0.97140515,-0.00862425,-0.8913607,-3.65935,-0.67575926,0.70487833,1.6084639,1.9468781,-2.1427372,-0.28441995}},
			{{-1.6732452,-2.6448226,-2.0790365,-0.620267,-2.8791897,-0.13028905,-2.1187413,-0.03791813,1.3739016,-0.2737975,-0.6616834,-1.2156755,-1.4089409,-0.5447324,1.1568242,-1.8589523,1.6416767,2.0087824,0.66256374,3.2392547,-0.23540895,-0.09415697,0.39876512,3.3366814,-0.8494133,-0.6651092,1.8088448,-0.080266885,-2.983888,-0.029021105,0.6859757,0.0039394046,1.6328399,-0.061883975,-2.4229524,-0.10563475,-0.13129908,1.9236894,0.176713,0.8615922}},
			{{-1.8832948,-1.4889,-2.0126233,0.37736577,-1.103793,-0.72352153,0.58764315,0.9446985,-2.9837928,1.0438365,0.23771948,0.16161695,0.20588455,1.4012504,0.94585717,-1.873028,1.4329937,-0.39296612,-1.0891646,0.4669212,-2.5195866,0.5175764,1.5663053,-2.0932448,0.0014512031,0.00645702,-1.6592216,0.08902245,0.78556204,1.2766635,0.46746954,0.011836787,0.04830387,1.028172,2.0942981,-0.5140152,0.5555114,-1.6629896,-0.6956246,-0.72298443}},
			{{0.4993116,2.2254603,1.7619059,1.9868162,0.6699981,-0.974017,0.8518124,-0.116933785,0.5423905,-0.67234564,1.3541601,-0.90966654,-1.1447582,0.116378956,0.058308654,1.4741371,4.7096686,-0.21545587,1.8567015,-1.9099617,-2.4435873,-5.4964375,-0.70997936,3.3556993,-0.8107419,1.185089,1.9226459,0.2629833,-0.80915517,-3.3924773,0.7595148,-0.007766444,2.3301497,-0.5974841,-1.2477762,2.0090916,2.2357273,-1.7373552,2.065668,1.1049585}},
			{{-0.72044367,-1.2727072,1.6798805,-1.009184,-0.02406603,0.39459535,-2.3025455,1.5646303,-0.9755454,-0.55473787,1.4830873,-1.3682439,-1.0402541,0.4488325,0.69541305,-2.645354,-1.8726285,-0.43758267,-2.7292974,-0.7234115,3.3943176,2.1630118,0.9707395,-0.22997813,-1.1536548,-0.7103336,1.5957345,-0.037482847,-1.5105672,0.28875747,0.24575101,-0.011881417,-2.7195752,-0.59034526,-1.6834382,-2.1429904,2.311646,0.7399514,-0.9718971,0.7701295}},
			{{-0.81028247,-0.37345505,-0.3409526,0.049153954,0.08984582,0.32315618,-0.9950646,-2.1356592,0.73560643,0.69444543,-0.7072432,0.6021127,1.5655161,0.94665873,2.6888258,-0.3538795,0.13479745,0.68492925,0.6595948,0.65190053,0.04917036,0.23720996,0.36205196,0.84497243,-0.2669488,-0.18374677,-0.013578393,-1.8185109,-2.1324909,0.12981698,0.5448626,-0.009165857,-0.78409195,0.22260286,-1.3482888,-0.17857625,0.17121416,-0.41054824,-0.5664375,0.5039358}},
			{{-0.379913,-2.7266104,-1.1907873,-1.3001462,-3.346463,1.3071187,-0.33127224,-2.486786,-0.12807684,-0.3174937,-0.4837766,1.588737,0.04106808,0.14655131,0.4304323,1.4826709,-0.75791645,-0.55820984,-0.51354843,-2.0902078,-1.0617208,0.97049165,0.58660185,-0.53099716,1.2300786,-0.7219193,-0.43276694,-0.98744917,0.77025354,0.41520086,-0.20306246,-0.007883832,-0.87095827,-1.2543542,1.0394201,-0.29636738,0.7481394,-0.363064,0.35627967,0.5760808}},
			{{-0.25066963,1.3687295,0.8838619,0.3361361,0.5651169,-0.56765103,3.1828392,2.5494125,0.45416778,0.09001898,1.109119,-12.61531,0.4667272,0.58711576,-0.6102224,-1.3729987,-2.6450622,3.032858,-0.7154025,-1.6928275,0.55286074,0.9164875,0.19476591,-0.8773011,0.5130938,-0.0014913243,2.0529206,2.5243664,-1.0238634,0.3091276,0.052534636,-0.000740511,0.69078946,-5.759927,2.0987937,-1.293072,0.17500722,-1.7395651,0.8357266,0.13876975}},
			{{-1.0653182,0.5492482,-3.6323397,0.025701357,-1.0460546,-2.7012267,-0.46352345,-0.90217525,-8.515448,0.33442175,4.359525,0.32439327,0.09159731,1.2771741,-0.24387975,-1.2527331,0.43506092,0.09101679,3.958763,-0.07588056,-2.8514886,1.5909997,1.2218742,-1.2465438,0.5289417,-1.1616249,-1.5079468,-1.6269162,-0.27934602,-0.0934239,-2.3305812,0.0040686107,-0.7704828,-1.3064528,1.333083,-6.0587783,0.5780325,2.5483634,-0.47927734,-2.8504388}},
			{{0.10425559,0.31109306,0.92415035,5.4885893,0.9329568,-0.5216873,-0.15330714,-0.28855053,0.23013552,5.0678225,0.56554276,-0.29345688,-0.34883267,-0.033916652,-0.23557673,-0.018434761,0.14365837,0.7116798,0.0883033,0.38800338,0.49513823,1.2254372,-0.08621511,0.18127882,0.18177353,-0.38493434,0.48691452,-0.5837191,0.07298747,-0.3918828,0.1861413,-0.0038803034,0.20178384,-1.3359995,-0.23377243,0.44544947,-0.1066852,0.24685265,-1.0783005,-0.54959166}},
			{{0.6938048,-0.5477299,-0.1313798,0.97960633,3.0520852,-0.7245226,0.92443043,0.4942812,-0.5137468,2.7431953,0.6042586,1.7193519,0.053815722,-4.2740912,-0.46475396,-1.4723204,-0.65684366,0.4639714,-1.5487587,1.9960616,-0.8434889,1.1086977,2.2889187,-0.037240498,0.005277093,1.430175,1.3640788,-0.43187067,0.9111776,2.2749405,1.346652,0.0057797874,-1.2107114,0.77038616,1.4140278,1.5579858,0.24290535,0.16057923,-8.57207,2.023862}},
			{{-1.1278814,1.0994233,2.6742942,-4.042787,-0.46139508,-7.843389,-0.27599978,0.1835153,3.6287262,-0.9374392,-0.24737586,2.0617673,0.0943653,-1.2837256,-1.6101439,-0.42740974,3.453078,0.7047131,2.1639762,-0.330272,-0.3087016,0.39533398,-0.9206188,0.10658538,1.290548,-0.16212626,-0.23031718,-2.699213,-0.09250948,-0.4065372,1.3153886,-0.009344972,-0.8422805,0.8405065,-1.645208,0.9649355,0.76560223,1.0202628,-2.0282815,-1.6496063}},
			{{1.9806384,-1.8326373,1.2002776,2.1002135,-0.59110284,-0.07382716,-1.3402063,-4.8289723,-1.0862807,1.7373554,0.5759047,1.4424995,-0.8326897,0.99113864,0.9040928,0.6162172,-1.8277897,-1.2408196,-0.29267266,-5.426536,-1.3118669,0.70325893,0.60209763,-0.36873192,-0.48037434,-0.03566179,-1.7472618,-2.668077,1.1012167,-0.24777614,0.3362893,0.0014630458,-0.814345,-1.866699,3.1814377,0.9765597,1.0864593,-1.0195053,-5.173328,-1.0665947}},
			{{0.34163606,-0.30161977,-0.34446993,0.9654703,1.5602587,-3.9977858,0.57647,-0.60316867,-0.26845524,0.027048307,-0.07717388,0.38551044,0.39325157,-0.6778445,0.23029627,-0.17013001,-0.14648068,0.61417586,-0.15412956,0.12580524,0.6217189,0.503787,1.5105966,-0.20352028,0.13668494,2.3795478,-0.14641385,0.15085812,0.22684263,1.9321971,1.5932544,0.0033549569,0.29276243,-1.4829115,-0.21466435,0.2065159,0.037989352,-0.09349265,0.77460176,0.3533919}},
			{{-2.5465307,0.4998036,1.1244684,0.4036638,-0.5704739,0.107634656,0.4100117,-0.24470252,-0.09233465,0.31013018,-2.0221283,0.5932276,-0.17346373,0.3054007,-0.4241901,2.5742905,2.2081678,1.4407967,0.4190351,0.805429,-1.6508625,1.105758,-0.73490316,3.4866624,0.20966874,-0.553096,-0.03938814,-0.6950611,-1.2419345,0.7621017,-0.92715734,-0.002117684,1.9764578,0.6822171,0.8736679,-1.2193658,-0.72501606,1.0348026,-0.5901672,-0.93752104}},
			{{0.6986974,-0.5443712,-0.85434544,0.4172679,1.1171594,0.37224466,-0.18857019,0.0081026135,0.94992954,0.28768256,-3.9155526,-0.7599672,0.4467893,-0.32347515,1.487375,-0.7787669,-0.2676983,2.205782,-1.8758075,-0.27279243,-2.1000133,-1.1410868,0.3050092,1.0725766,0.17241621,1.7203757,1.217463,0.40454718,-0.72726357,-1.4561055,2.4990633,0.0025599482,0.31909618,0.152274,-0.78207296,0.8251562,-1.874965,-1.5742517,0.19745724,-0.045814395}},
			{{-1.3467475,-0.8550199,-4.403529,0.8866579,-1.4179567,-0.9081951,-3.5111723,-1.0566816,-0.70549583,1.3514198,1.0618223,-0.7066797,-0.79317933,2.281124,-0.12859802,-0.27005714,1.7671247,0.44992694,0.8370155,0.92766523,-1.3821512,0.88787174,-0.7807033,0.08664997,0.38603032,-0.78483975,-1.5446129,-3.7762134,-1.7048978,-0.9993681,-0.8644808,0.010011379,0.16921641,-1.5028485,0.8418087,-3.9365208,-1.4098079,-2.7335951,-4.1621923,-5.095364}},
			{{-2.1514404,1.6736054,-3.5939548,-0.12657982,-0.14215912,-0.43836325,-1.1791955,-1.5518025,0.14989072,-0.22823009,-4.8992896,0.06306407,0.1672302,0.16864777,0.9508098,2.6902776,-3.5330646,0.7667558,-1.4715219,-2.318191,-1.1362088,1.7296613,0.47095713,-2.4931984,2.8184898,0.65792257,1.4006767,-1.3604597,0.5931298,-2.4311686,0.2854664,-0.01748865,-0.64535743,1.3402209,0.27409175,-1.8947637,-0.19382888,0.067181304,-0.5010644,-1.2683758}},
			{{1.1540684,-1.466675,0.8184326,0.0023769883,-0.28102916,-0.44059235,-4.9915037,1.1461757,0.9041889,0.28207248,1.0053121,-2.4537814,-1.0326533,2.0693097,0.4620529,-0.6898397,-2.6791675,0.18197754,-0.7522388,0.742072,3.2287722,-0.53088486,0.2254641,-0.48669973,0.5522108,0.8601756,1.5896319,-0.7156297,-2.012666,-3.7736473,-0.1835666,0.0030893188,0.7341317,-1.7357942,1.2813584,0.96358806,-1.26656,-0.55643815,-5.073832,-1.5457362}},
			{{-1.088061,0.16565964,1.603781,0.5174117,-0.28301904,-11.292732,1.2790596,-0.22086369,0.24452838,-0.38857058,-0.2999955,-2.03289,0.12601571,-0.50170344,-0.76396763,-0.2895343,1.4513335,-2.9621196,2.0935624,-0.07524153,0.9464669,1.0885315,3.6029594,-0.060430367,-0.7309305,-3.4332426,1.4302024,0.28386107,-0.27079618,3.3484259,-2.0670342,-0.0060685,-0.71835744,-5.4803014,-0.29573876,-1.8396554,0.67404675,-0.16488913,-0.5847305,-1.1889381}},
			{{-0.53596175,-1.5664388,0.28270185,5.3066545,3.282488,-0.69109267,2.385001,-0.33696082,-0.44457713,3.7948062,0.21157098,1.7766576,-3.3353531,-4.034211,3.9096172,-0.38887715,-0.20341294,-0.055736374,-5.374084,-1.5581802,-0.3885522,0.49759433,3.6520936,-1.1112849,0.63829046,2.9265523,1.6758604,-0.86815256,-0.26228273,2.7680209,2.4794605,-0.0015428471,0.06632131,0.17359509,0.19464368,0.4288769,0.49455884,1.0202272,-5.947134,-0.122010574}},
			{{1.8871514,0.3328007,1.8236545,-1.8189837,-2.6025035,0.011246283,0.4463319,-0.31170198,-0.2417822,-2.1319594,0.09329573,-0.17858401,0.6888116,-0.79578465,-1.2811371,-0.30991733,-0.7892443,0.20490097,0.5444529,-0.8332892,0.5050379,0.7402115,-1.7050006,0.06705797,0.31580245,-0.24505417,-0.3605034,0.39539513,1.5965503,-0.18340696,-0.9842493,0.004876949,-0.27643624,0.42649662,1.8535724,0.75385183,-0.13871375,-0.85405356,0.99126214,0.06384497}},
			{{-1.5007327,-2.015914,-3.962828,-0.98815,-0.89595,0.49909553,1.127925,-1.8680968,5.544039,0.10374862,-3.7440894,-0.08673548,-0.09781676,0.50700617,0.23430271,1.3824326,2.730077,-2.2209334,0.23906372,0.9106076,-1.928134,0.44581053,0.5184883,0.7972989,-0.9289934,-0.33186993,-7.353165,-1.8572361,-0.16758122,-0.031604227,-0.4726776,0.0010192666,0.2991894,-1.4823852,-0.6171414,-1.3292103,1.1022004,1.901833,-0.25238693,-1.0599325}},
			{{1.2898338,-0.9521602,-1.3272294,0.32791957,-0.6567785,0.612931,0.8539763,-0.69585127,-0.6834609,0.20882623,2.033865,-0.64827627,-12.737524,-0.9431922,0.96204793,-3.2189372,1.0670507,0.27748883,-1.2570552,-0.6984255,0.48670653,-6.7507305,-0.3600067,-1.22236,-2.8644905,-0.98601294,0.9771521,-0.7935009,0.18441261,-0.25710937,-0.22975948,-0.0010963988,-2.2357907,-1.6212673,-1.04793,1.9652442,2.121032,1.44352,-1.3475935,1.1665267}},
			{{-2.3632846,-0.9169771,0.92543817,-0.469191,1.5169374,-0.051658135,-0.66462034,3.4205647,0.7184082,0.0577095,-0.8716659,-1.2322125,0.2792281,2.0552385,-3.7368176,-1.0938811,0.12948114,-1.0511252,0.43550375,1.0356804,-3.7635028,1.2726976,-1.0780392,0.48548934,0.29112342,-1.1041752,-0.5165757,0.29254618,-2.5789983,0.7564789,-1.0492722,0.0027351098,0.34365276,-0.016650679,-3.8907578,2.0906644,1.1246104,0.0051333276,-2.5534353,1.3496662}},
			{{-1.816319,-1.889972,1.7654358,1.7505833,0.123330675,-0.68509114,0.2786791,-0.563434,-0.5791102,0.5827776,-0.6959032,0.051533736,1.0343359,-0.6415247,3.151649,0.22686604,1.4245677,-2.3962507,-0.756503,-0.6931697,-0.46512178,-0.01289195,0.9338596,-2.6789901,-2.0767448,-0.58088356,1.0931177,1.038802,-1.8149565,1.1675671,0.92960674,0.009609559,-3.2734516,0.33179393,-0.87564284,-0.3266609,0.95955616,-2.7439466,-0.38244578,-0.14514333}}
    }};
    
    h3_h4 = {{
			{{0.48262975,0.12338258,-0.13637714,-0.73925143,0.5974509,-2.1448512,-0.3208485,0.5364158,-0.007423505,-6.322975,-0.14041531,0.7164938,-1.0050915,-0.49670798,-1.7263484,-0.80714583,-0.77687436,-1.9647866,1.6787305,-0.5829016,-0.31533802,-0.63577074,0.1033058,1.6881776,-1.6435769,-2.4565728,0.3526429,-0.3872646,1.8925917,-0.69643515,1.0152211,-0.16394512,0.67760617,0.67636913,1.2230405,-1.5188111,0.44413978,2.3174417,-0.6707975,-1.3895428}},
			{{1.0029473,1.2912917,-1.0053095,-0.33251813,0.65712786,0.19951028,-0.68383926,0.09622134,-5.356609,0.16966067,0.3598767,0.09378455,-0.5153681,-4.1653533,-0.442693,-4.282451,-0.06287163,-2.237487,-2.0376227,1.1469266,1.2296972,-2.0282845,1.3034582,1.4643433,-2.1919248,-0.08122232,-0.5887572,0.5891676,-0.15425263,-0.07390085,0.539328,0.18466388,2.8526673,0.94317347,0.4534288,-2.0451357,-1.3517445,1.0963761,-0.58883953,1.2338151}},
			{{0.17526954,0.69364274,-2.1939898,-1.888394,-0.5586654,-1.0170894,1.2757335,-1.3686916,-2.1970344,0.02249726,0.82592565,-1.3885406,-0.39214832,-0.72355366,2.096367,-1.9095572,-2.6093004,-0.47188747,-2.1236444,0.6944188,0.15199925,-2.5980382,-2.0167792,0.33031094,-0.26564863,-1.0305036,1.7351842,-0.24327257,-1.9820045,0.21957463,0.44409904,-2.8845053,1.5268852,-2.1847713,-2.2381716,-1.8774122,-0.35295284,-0.43423402,0.5500307,-1.0777783}},
			{{-0.75426674,-1.1630979,-3.3229582,-1.7872474,-0.4413643,-0.53626764,-1.8046968,-0.9245829,-2.0380962,-1.5340127,-2.2458622,-0.39003986,-1.3240114,-1.4585799,-0.6629227,-0.97302985,1.5845013,-0.60805285,-0.029396037,0.95417523,1.9082139,-1.6869901,-0.68433034,-0.68061393,-0.73654467,-0.7261676,1.134097,-0.08036673,-0.4178442,-3.842348,0.21416795,-0.07981415,0.2600994,-1.311632,-0.6557489,-1.976393,1.7543749,-1.8034031,0.29246297,-0.3916661}},
			{{1.1067306,0.92530394,-0.99898475,0.76750576,-2.5815353,-0.8581789,0.36784872,-0.056183312,-0.1080609,0.4171318,0.71043235,0.01943861,-0.6170238,-0.34191906,1.0866169,-0.37005237,-1.0693166,-1.2286333,-0.5962478,1.8524498,-1.5893803,-0.23111704,-0.08103195,0.9049638,0.54064083,0.45151514,1.3857137,-0.32691395,-1.6367615,-0.33630842,0.8448111,-0.40609568,0.88348633,-0.20147726,-0.39976257,-0.7838709,0.3786632,-0.35934186,1.6164925,2.1785185}},
			{{-0.3196375,-1.954768,-0.76075155,-0.7859147,0.33332235,-0.32877502,1.4656235,1.2157929,0.038351756,0.8431684,-0.9916687,-1.6899381,-0.3486846,-1.4632732,2.1527865,1.011576,0.30924684,-1.0031096,-1.0638002,-0.034750465,0.014781272,0.0004689502,-0.08447236,1.425428,-0.9115191,-2.0489256,0.7653105,-0.3924454,-1.3558851,0.8501104,1.5554605,0.7281578,0.020555977,-3.90321,-1.4859304,-0.3960959,-2.5422184,1.4353946,0.57109624,-1.0926706}},
			{{1.3113427,-1.0348518,-2.6306932,-1.7588022,-0.4363419,-2.2670512,0.3622818,-0.8077026,-2.7260222,0.3032262,0.41230285,0.23754165,-0.9840829,-0.9695027,0.8429814,-3.6068158,0.31425327,0.18493536,-1.0531332,0.34639743,0.8402199,-1.1327659,0.89700496,-0.7737913,-0.5838679,-0.81968427,-0.5397336,0.4209791,-0.51024705,0.3470433,1.1081767,-0.30716825,0.021518208,0.8512825,-0.06870994,0.29656914,-1.0086622,-0.8496753,2.4613304,0.13844135}},
			{{0.489079,-1.3133166,0.115674414,2.1496227,-1.494244,-0.276633,-0.3421325,-0.8940163,-1.8470304,0.006376991,-0.144645,-0.41409293,-0.79669327,-2.3582664,0.17545986,-0.08249687,1.2918122,-1.0712467,0.17245321,0.83349484,-0.9903001,-0.12085901,1.5664544,2.2334847,-0.228931,1.4705431,0.1227804,0.18285008,-0.32972512,-0.46656913,1.6575527,0.63983774,-0.18035604,0.22366716,-0.33096716,0.0044527566,-0.18373553,-0.30845818,0.8720035,-0.827555}},
			{{-0.114924416,-2.2163663,-0.7561536,-1.6433718,-0.22335245,0.19984871,-0.67034954,-0.5607593,-1.5367709,-2.0276728,-1.786188,0.6039388,-0.49575987,-1.8418303,0.65442467,-1.2597021,1.1472178,-1.4252161,-0.23043056,1.2308404,1.4557991,-0.90841687,0.84713304,0.39226705,-0.58626777,-1.393272,0.78359497,0.15224405,0.42413574,-2.3450541,2.0651274,-0.0895874,-0.40339276,0.11245514,-0.06845206,-0.8113781,-0.54820645,-2.1712716,0.8276973,-0.7125641}},
			{{-0.6403618,1.1832249,-2.4796154,1.0884008,-1.0536461,-1.5953403,-0.3557534,1.0100284,0.5613748,1.2325438,1.3665863,0.028446946,-1.4287964,-2.7340508,-0.4762178,0.35244384,-3.4381015,-0.5022232,-1.0764371,-0.2527625,-1.5289476,-2.0120335,0.94371814,0.9912326,-2.0631804,-0.94456756,1.0127169,-2.5629902,1.2927781,0.6445374,-0.00859814,-1.759099,1.5374767,-4.345679,2.247024,-0.5550872,-1.1598009,1.2540561,1.1143647,-0.8509449}},
			{{-0.3287816,0.86575764,-2.29693,-0.4376214,-0.076138526,0.23216353,-2.0399604,-3.7190015,-1.9289843,-0.8771627,1.4146154,2.16084,-1.2579961,-3.3047743,-0.48224923,1.4372587,0.44733205,0.5623941,0.0068576736,-0.41663095,-0.2508443,-1.1778398,-0.66149753,-1.3792461,-2.639356,0.020058554,1.419891,1.1016948,0.13608366,-1.2161801,2.4523935,-5.8099446,-0.63837296,-0.080834545,-2.4195807,-1.541048,2.0112493,1.0297501,1.571621,0.22068934}},
			{{0.14563887,-3.4773505,-1.6446499,-1.2171081,1.0269338,-0.44453537,2.9337556,0.31141526,0.8977438,-0.47687605,-0.5268069,-2.9579663,-0.98810446,-0.26298547,0.6983984,1.3134441,1.0187728,0.23969913,-0.06932754,-1.3061811,-0.7977177,-0.55578667,1.38221,-1.1198312,-0.75898206,-1.0901066,0.33850586,-1.2185946,-2.446778,0.105407394,-0.4163458,1.291503,0.6394664,-2.3862295,-3.182349,-2.3090525,-0.85571057,0.54724896,0.032653846,0.2917774}},
			{{0.4756016,0.23332472,-0.21964213,-1.1415682,-0.34750634,0.75986135,-2.5241528,0.24842326,-0.27013993,-3.2357745,-0.84976006,1.2860776,-0.6898236,-2.2242007,-3.2925467,-1.7062452,0.15554439,-1.5802152,2.3673754,-1.0781,-1.1906805,-0.1835173,2.4145932,-0.59111184,0.86294377,-1.5987378,-0.6958858,-0.9196372,0.94043285,-2.0778248,-0.31252733,0.44813964,2.8281832,-1.3371124,-0.84353524,-1.6369388,-1.3651576,-0.14957693,-1.196176,0.027430609}},
			{{-0.7385079,-1.246695,-0.77317977,0.21289541,-1.6011992,-0.15812708,-0.46715552,-1.9533141,-0.68623775,-2.7789135,0.5514148,1.0964988,-1.588581,0.70963454,-0.5246467,-1.1244929,-2.8689003,-3.844436,1.4637665,0.6492914,-1.5365953,-0.51157427,-0.6822188,0.9333188,-0.16419335,-1.0282078,-0.11668654,0.36560252,-4.2369013,-2.744251,0.2659851,-0.106737435,1.0521079,0.5727093,-1.9074098,-2.4489145,-0.67420965,0.27246332,0.20409356,0.62415034}},
			{{0.33236742,-1.4904634,-1.1799797,0.76499444,-1.0762494,-0.6005168,0.56793606,0.09650338,-1.9019542,0.25633192,-1.0360498,0.4118043,-0.726488,-1.1862803,0.0051299636,-0.66044754,-0.04756164,-1.1261243,-0.96825194,2.7468793,-1.1876764,-0.49738234,0.26160276,0.14264654,1.1414474,-0.5455521,1.1448685,-0.056875166,-0.5953149,-0.34489286,0.5068483,-0.11140454,1.0234789,0.22376016,-1.2581089,-0.82121885,0.30605164,0.4097462,-0.22293743,0.9639532}},
			{{-0.57243246,-0.9299728,-1.1297197,2.3915195,-1.3732724,-0.9449862,-1.009801,-0.62764764,-1.3223459,0.26893517,-1.3741719,-1.190907,-1.1280102,-2.2723908,0.56819564,0.37496176,0.17866424,-0.11908822,0.026258647,1.0268006,-1.6540691,-0.5173196,-2.0746386,0.23125957,0.3236695,-0.6929657,0.16703676,-0.89528275,-0.72446984,1.9322038,0.9633398,0.38240075,0.14609091,-1.5891784,-1.4955829,-1.5699306,-0.79921573,0.55752605,0.1999779,-2.1492333}},
			{{-0.4542102,-0.07065541,-0.9957065,0.52960813,-0.20237952,-2.807551,0.7100432,-0.5667214,-2.0934315,-1.9305316,1.4371394,-0.7929099,-0.32853356,-0.3097566,1.0850254,0.78029585,-0.5532695,0.08952731,-1.4746834,0.49167156,1.5102193,-1.1068319,-2.3154204,-0.37606055,-0.9222507,-1.5644265,1.7737362,-1.1044496,0.5288704,-0.37835285,0.26951197,-1.9022174,-0.38576993,-2.2188008,0.4204824,-1.407656,-0.6167698,2.4528077,-0.11483713,-1.2953461}},
			{{0.14293244,-0.22544184,-0.75304365,-4.111377,-0.28110194,0.47350195,0.23731479,-2.0722103,-2.7073903,-0.24923891,0.9208625,0.24160165,-0.7995038,-0.13069695,0.4228867,0.15845004,-4.6207657,0.49149507,0.07205124,1.4264596,-0.8986691,-0.27752087,-2.75395,0.11883739,-1.4987618,0.53861123,0.917033,0.19691993,-4.598671,-1.3595841,-2.1332433,-2.340313,2.0521626,1.1957498,1.6087788,0.020805778,0.6522413,-2.4507627,0.25431648,-0.18691474}},
			{{1.0975171,-1.1592784,-6.1813264,-0.04219968,-0.80073154,0.116578355,0.29537868,-0.9972863,0.2897438,0.55490637,-0.36055598,-0.09471712,-1.2552419,-1.4534335,0.68912834,-6.7175155,-0.19330889,0.24083085,-1.1931297,-0.15099244,0.17509048,-0.8721645,0.50868523,-2.0989444,-1.927347,-1.8644087,1.5420464,0.21527402,-1.1731825,-0.17486174,-0.3136705,0.20759585,0.97873425,0.7694049,-2.2880373,0.050325133,-0.3237534,-0.75945956,3.4512162,1.3041083}},
			{{0.6495978,0.29562488,-0.33001438,-1.3472173,-0.8537904,0.18719476,0.22306043,0.51812714,-1.0481316,-1.2713296,1.5052882,0.08376673,-0.36478382,-0.26877844,-0.9431143,0.30628416,-1.4285083,-0.59277546,0.17950284,1.2110798,-0.18258905,-1.1731586,-0.6109518,1.127525,-0.03779848,-0.45727745,0.06423434,-0.59948844,-1.4666657,-0.61406624,0.011258837,0.11370484,0.28830314,-1.3999761,0.0910567,-0.19469051,-0.4845157,1.1466032,0.008260483,-1.1810541}},
			{{0.75719416,-0.37885657,-1.4834809,-0.76436555,-2.6305704,-0.0074186698,0.22083233,-0.011337544,-2.893096,-2.7554104,2.3401928,-0.1980953,0.17610255,-0.37877762,0.012412556,-0.26325837,-1.5167484,-1.6052386,0.39715376,0.6344143,-0.9427042,-3.2719772,-1.0011464,1.3905623,-0.7255082,-0.5050183,0.2458368,-1.1865243,-1.56695,-1.3529259,-1.4916751,-1.0698476,1.5944222,-2.550292,-0.13996014,-1.277659,-0.46285573,0.22969277,-0.34539053,-0.74367326}},
			{{-0.2742326,-1.6694694,-0.65380114,0.85521275,-1.3840009,1.1211026,-0.27561778,0.39941493,0.5521691,-2.6585202,-2.2309089,0.033092298,-0.79486644,-2.067425,-0.584583,-0.32655755,-0.39225706,-1.0925646,-3.2887661,-2.1979704,-0.4593287,0.47731474,-2.2035558,-0.09937383,-0.9463589,-1.8617355,-2.468539,-1.1602488,0.7505677,2.3390117,-0.11855881,0.40240064,3.8084621,-1.696693,0.312207,-2.186758,-3.070401,-4.123551,-1.7234523,-0.95270175}},
			{{-0.23932841,0.1556573,-1.9965702,0.5329509,0.82902277,-1.264031,-4.0715055,-0.144711,0.8027877,-1.5492978,0.030173479,3.3469567,-0.68286186,0.16745551,0.30004188,1.7551006,0.19918725,-1.1726545,-0.20214143,-0.88066345,0.14712892,-0.3604884,-1.4700987,-1.119983,-1.3029088,-0.5080276,0.45253125,-0.5185568,0.0687581,-0.64973664,-0.42857638,-2.1357615,0.82967335,-0.6493899,-2.1975734,-1.5496713,1.3945084,-0.5963947,0.6541091,-0.50423706}},
			{{-0.67101693,0.21369877,-1.274356,-0.5390713,0.19481447,-0.86732256,0.027099755,2.5404217,0.23337731,-2.430629,2.0510564,0.010544427,-0.10102061,-0.6437404,0.7202318,0.44115674,0.71305317,-1.3554417,0.51016146,-0.8459721,0.5857106,-0.6058781,0.14914761,1.5283104,0.09977682,-0.9578736,0.24961422,-3.3880708,-0.48572248,-0.3136131,-0.53084356,-0.34348,0.3785545,-1.270739,0.72290975,-1.2118487,-0.36213714,0.024119414,-0.38037062,-0.4343264}},
			{{0.11531676,0.29754853,-0.12874067,0.6125349,0.37533456,-1.1281008,-2.1584034,1.1302892,0.44525126,-1.4269608,0.014180514,1.7569392,-0.17830381,-2.092822,-0.112729385,0.09015493,0.68022144,0.3831966,-0.09715943,-0.2665742,0.2529834,-0.033088032,-1.0444062,0.94381297,-0.84751016,-0.53303945,1.0363443,-0.4558211,-0.016339129,-1.1952368,0.77683204,-2.236556,-0.29706436,0.26849166,-0.95378405,-0.40691128,0.47214895,-1.4275432,0.5363815,0.15936776}},
			{{-0.24661103,-0.6952579,-2.179983,0.6245445,-2.6297727,-0.08876515,-1.1215676,0.5649441,-3.0954483,-3.9862328,-2.6211245,-0.596684,-0.9464957,-1.479232,-0.19238076,0.08271005,1.0702475,-1.6051085,-0.6774345,0.90197986,-0.3863344,-1.9420615,-0.8378942,0.7832493,-0.6675733,-1.2294065,-0.3637582,-1.2703741,1.5459266,-0.37513408,1.8409824,0.58384085,0.85665673,-3.4689586,0.66738707,-0.85830456,-1.1655171,-3.1582317,0.44253266,-0.82624024}},
			{{-4.837023,-0.4318731,0.04806262,0.021683201,0.5048665,-2.8707001,-0.8142368,0.2158465,-1.5591286,0.68442,-1.5969666,-0.32358536,-1.3450353,0.08714821,1.026888,1.1933359,-0.8105511,-0.12732205,0.56870526,1.2000941,-1.3426474,-0.61716944,-0.25362188,-2.0687864,-1.5207561,-1.2385253,-5.2707067,-0.26985633,-2.1308148,0.5159982,0.13441093,-2.189478,0.61636776,0.7538373,-1.9214625,-4.211058,0.391357,-0.66297823,0.272776,1.2098243}},
			{{-2.6335278,-0.4431948,0.8552886,0.076005526,-4.902187,-2.27898,-0.28966963,-0.07241525,-0.7278242,-1.51198,-0.20944953,-0.17649196,-0.68347627,-0.639605,-1.5004423,-0.093768775,-0.108653665,0.1635224,0.8195355,0.3589303,-0.50139046,-0.013926601,0.55257326,-2.122078,0.90188986,-0.73501915,-3.1677523,-0.41690323,0.41166252,0.4264351,0.040323675,-1.035737,0.9699003,0.057944965,-0.082811914,-0.9965069,-0.14143892,-1.1268113,-0.58712184,-0.22092073}},
			{{0.57196105,0.19452298,-0.21195656,-0.076471835,-0.7772111,0.3577403,-0.29820284,0.62638515,-0.1888252,-0.6812138,-1.777696,-0.1998247,-0.36186117,-0.9810345,-0.30694994,-0.025167368,1.1004835,-0.507748,-0.67651486,1.1055423,-0.09067044,-1.0239449,-0.93971175,1.5195446,-0.5012485,0.15971074,-0.009462021,-0.89306974,1.1650456,-0.29331657,3.115515,0.56340045,-0.045008823,-1.2650534,0.55650157,-0.30821028,-0.9557004,-2.2768881,0.63209695,-1.0705546}},
			{{0.78972745,0.026166413,-1.2434163,-3.3897548,0.2156654,-1.0592779,1.0041015,0.25213492,-0.79011834,0.4732626,1.2509556,-1.222689,-0.42882365,-0.5327707,-0.6858665,-1.5955056,-1.7534918,-0.43430537,-1.4485935,1.2792555,0.40854886,-1.0254793,1.4869744,0.6873348,-1.2815403,-0.5180727,1.6228765,-0.26408392,-2.3803515,0.40341634,0.2730381,-1.9111408,0.6805876,-1.531454,0.0064955084,-0.2436658,-0.5328805,-0.69842225,1.4041415,-1.2269087}},
			{{0.95038104,-1.1184137,0.10794589,0.527009,-1.27863,-0.25678778,0.4644918,0.018808385,-1.9907947,-0.16777192,-0.18199319,0.5473296,-0.64374536,-0.5874139,0.798281,-1.0201105,0.007295972,-0.30848488,0.16247894,2.054078,0.06399051,-0.30548012,-0.3212773,0.0924418,0.95923823,-0.35954958,0.088502765,0.06619645,0.07535546,0.78266156,-0.26747692,-0.24866453,0.26876327,-0.008342701,-0.84064627,-0.34791112,0.19583583,-0.3119958,0.25638837,1.3782517}},
			{{0.5246664,0.30857018,-0.9380039,-1.6459507,1.2565825,-0.42055708,0.14780116,-0.071381114,1.3645905,2.3929503,-4.994088,0.2463575,-5.535897,0.59164864,-0.31098837,0.71129006,-3.4284177,-1.1702118,-3.5004163,-1.9049231,-1.1224085,-0.9939102,-2.151228,0.13294987,-0.3831198,0.61507523,0.4091683,-0.24820717,-2.526123,-1.5124472,-1.9731295,-1.5041553,-0.89718413,1.591175,0.5337566,-1.0867743,-1.4030192,1.0179391,-0.28825602,0.8622852}},
			{{1.0318861,0.064580806,-0.97254837,0.6295173,-4.1618857,0.024596017,-0.6529365,0.2038971,-1.3842162,-0.32745442,0.6229734,0.060722098,-0.51960206,-1.7929522,-2.5220745,1.4067603,0.5390748,-0.54956865,0.44863904,0.567761,-2.941056,-0.0062071504,-0.84550697,0.86363274,-1.57569,-0.11790569,-0.47297582,0.25612906,-0.23169258,0.10541793,0.7860996,0.7504413,1.2739224,-0.5628053,0.9619794,0.09942834,-4.612213,0.81976986,2.2896078,-0.598041}},
			{{-1.6704063,-1.3509377,-0.5652477,1.8019222,-3.0641952,-2.4155083,0.92337143,0.46956918,0.15754591,0.5004484,-1.3718064,0.87255424,-0.47574365,-1.9119852,-1.1294645,1.6739054,1.1456496,-1.1711601,0.0945853,0.9974066,-0.65124476,0.51145834,-1.6285278,0.84962606,-0.78758395,-0.44867206,1.2328057,0.46176282,-1.8971828,-0.17954312,-0.7464107,-1.9514253,1.3787392,0.60116917,-0.27011177,-0.96662456,-0.11171474,-1.1476729,-0.0380106,-0.19470331}},
			{{1.1355289,-1.8913589,0.8496618,0.22840445,-2.5430508,-2.9307537,0.63709855,0.61183715,0.15149827,0.017156692,0.35968184,-1.0336897,-0.38837382,-0.60659194,0.5980111,-0.7022817,1.1585422,-0.4690815,-0.25445578,0.029532209,-0.66921175,-0.0049923067,-0.6011528,1.3548745,-0.7348094,-0.039074916,-2.1905062,-0.09029379,-0.54128253,0.68175524,0.20543815,-0.9805834,0.8003618,-2.3366115,-0.29968005,-1.7112933,-0.12809739,-0.0012779352,-0.6913747,-1.769197}},
			{{0.3147881,-0.09375695,-1.408565,0.6300099,1.2571536,-0.083908804,-0.26593196,0.07423848,0.38864562,0.4798898,0.027733728,-0.41350552,-2.2695334,0.40903473,0.7872076,2.0868764,0.40835437,-0.6364836,0.5106347,-1.8938608,0.4734983,-0.2766563,1.3144419,2.659015,2.1760652,0.043246634,0.46404383,-0.6731501,-0.8585494,0.71125436,-1.2782034,0.39051113,-0.27813667,0.75308233,-0.6933734,-2.0003014,0.3071119,-0.37457013,-0.67160577,0.85456955}},
			{{-1.2074314,0.12616384,0.45171472,-0.5416836,0.85963,-3.912313,-0.6158863,0.49464056,-0.07142594,-0.46658915,-0.7663422,0.10455698,-0.005191628,0.2378371,-0.7415367,-0.5420547,-0.1216094,-0.12277239,0.059016693,1.6281366,-0.4615109,-0.64516747,0.7830063,-0.76154214,-0.8849269,-0.13446146,-4.0292063,-0.10646028,-0.09783189,0.9463081,1.3721217,-1.042067,-0.09643847,-0.31614703,0.7213566,-1.196374,-0.78110087,-1.51102,-3.5744658,1.0346048}},
			{{0.0048333225,-0.6291232,-0.15523767,0.4689817,-0.16883898,-0.8029331,0.16270639,2.5599043,0.20049945,-1.4024775,-0.0013959514,0.3126556,0.034383655,-0.33285815,-0.12917554,0.048830457,-0.018749537,-0.40244287,-0.001959103,0.16862424,0.5482118,-0.0546662,0.63730055,-0.4045238,-0.13490807,-0.96572185,0.8674477,-2.1526005,-0.040730752,0.40762222,-1.0777892,-0.1908221,-0.17445439,-1.3931706,1.2130749,-0.46642753,-0.26202586,0.600004,0.047313817,0.26113304}},
			{{0.09728357,-0.26764554,0.36482134,-1.290601,-0.020809703,-0.033712476,-0.8945396,0.416835,-0.08564123,-0.47242582,0.3628726,1.193847,-0.19200078,0.22815175,-0.18545012,-0.48173887,-1.9040003,-1.8590804,0.8803778,0.84713674,-0.65496874,-0.4523946,-1.3007962,0.8905621,-0.3510047,-0.2086785,-0.029389119,-0.17605023,-0.7532223,-2.0842957,0.7793914,-1.979859,0.79007727,0.2275887,-1.4687748,-0.9772302,-0.19529004,-2.58227,-0.07584685,0.1256824}},
			{{-0.43015528,-1.256773,-1.4242275,-0.6394929,0.19369403,-0.19340691,0.5061578,2.737232,0.7242373,-1.9672017,-0.53921866,0.023770852,-0.676337,-1.6616164,-0.77315795,1.2227226,-0.4054428,-0.5196834,-0.47169095,-0.7734615,0.8725438,-0.6346464,-1.2939886,0.5649458,0.4876905,-0.5973534,0.5592974,-2.263483,0.7605674,-0.07179977,1.4672111,0.37447926,0.2118994,-1.5193255,-0.1429794,-1.3119478,0.26454565,0.97025067,-0.5353245,0.43516967}}
    }};
    
    
    h4_out = {{
			{{-0.5862116,0.7284698,-2.3403852,-1.2478986,-6.035403,0.60465884,-0.940754,0.16730167,0.13486758,-0.34327537,-1.4687818,-0.8578493,0.4383968,-0.99364066,-2.859661,-0.83611274,-3.012373,-3.4953024,-1.0561736,-0.48533544,1.4978418,-0.19101076,1.7691674,-5.495216,-2.409657,0.8195752,-0.2810379,-0.24529754,0.43939343,2.3096857,-2.4697719,-1.890227,-0.35379565,-3.6428483,-2.0413737,-1.103395,-0.81995237,-3.1528585,-3.8713195,-0.93968296}},
			{{-1.998531,0.8930146,-2.657771,-2.4627206,-4.9114356,0.5432845,0.040444214,0.78777313,-0.8218648,-1.2303817,1.1511828,-0.9386224,0.16864266,-1.5930911,0.39220992,-0.4855223,-2.013756,-3.6100867,1.2761185,-2.132431,0.89041597,-0.18360662,2.634365,-4.4046474,-2.4248781,0.6654849,1.3314877,-0.4557217,0.25997797,1.3780197,-0.80498505,-1.7874242,0.9492583,-2.6713235,-1.3333844,-1.0358282,-0.73095375,-3.644877,-3.6059725,-2.4845529}},
			{{-1.7606994,0.85546964,-1.9998026,0.0074075754,-0.4132239,0.14797415,-0.03653408,0.5154451,-1.7270695,-0.0009558231,1.2409606,-1.502574,-3.5967581,-2.3401783,1.3670297,0.6398222,-1.0648488,-2.872201,0.46398672,-2.9341056,2.6932657,-0.24072489,2.174828,-2.810251,-2.8999853,-1.1476088,-1.3107861,-0.8229659,-0.3371026,0.027276848,0.22338614,-1.4408371,0.7836159,-1.3033774,0.4335861,-0.5500022,-0.6056396,-3.44369,-2.402819,-4.415553}},
			{{-2.4023983,0.5347326,-0.49051815,0.08163501,0.45101362,0.44494787,-0.29548502,0.32647964,-3.0296206,0.26751208,-1.2315798,-1.403746,-1.0648173,-2.023676,0.70058084,-0.3602489,-0.9477475,-0.46086267,-1.0481069,-1.6989483,2.6528242,-0.83461356,2.3572621,-3.5205123,-2.150234,-2.9840162,-1.1162137,-1.2734554,-1.2724454,-0.4963675,0.115862094,-1.2933795,-0.16687241,0.32529336,0.32154217,0.39047763,0.42079204,-3.6201851,-2.1309397,-3.504695}},
			{{-2.5136738,-0.5038617,0.50803626,0.14242089,0.7427067,-0.0010218058,-1.2930169,-0.4467795,-2.1232266,-0.37806687,0.23656458,-1.4659926,1.3498873,-0.9799311,0.35286972,-1.7801286,-0.4941672,0.4949583,-1.0543734,-0.49256095,0.371107,-0.53536814,2.0716004,-4.1573176,-2.5760207,-2.1631343,0.2141463,-1.3423342,-2.9354546,-0.26644668,0.18943897,-1.531488,-0.89960426,0.68691003,1.088577,-0.4446973,-0.22867766,-4.7361665,-1.5081133,-2.9589548}},
			{{-2.9077227,-0.43187752,-0.60689586,-0.33725804,0.3607826,-0.5082221,-2.0562332,-1.0545248,-1.9091738,-0.7577912,0.6875923,-0.79441077,-1.3396145,0.38297015,-3.462929,-2.1123912,0.28920496,0.73812634,0.63550186,0.16586934,-0.6800876,-1.4291193,1.5422751,-0.28252092,-2.0456738,-0.86894226,0.9369004,-1.1324898,-3.57785,0.80484885,-1.1935806,-2.0636594,-1.2597243,0.67301977,1.452547,-1.1389462,-0.80387217,-4.46783,0.35250285,-4.18195}},
			{{0.028296608,-1.357571,-0.7075992,-0.62989295,-1.604331,-0.48961294,-2.7415946,-1.3175666,-0.581107,-0.4549032,-0.39876226,-0.93991137,-1.7176319,0.7243328,-5.8799095,-0.6666743,0.16581367,-0.6150706,-2.224815,-0.06855658,-1.1701756,-1.4001353,1.885048,0.704715,-2.22762,-0.5858944,-1.1782271,-0.59611845,-4.092985,0.55734074,-3.7264738,-1.9844321,-0.91446286,-0.50042176,1.0817287,-1.0294646,-0.62446725,-3.8839266,0.78562677,-5.877089}},
			{{-0.6981632,1.3139589,-2.6285284,-0.4588315,-2.3302274,1.208464,-0.6272926,-1.234402,0.40085787,1.1673582,-1.5667613,0.86995745,0.77185065,-1.0553079,-4.5003724,-1.5097444,-1.914348,-3.1834114,-1.0495727,-0.974489,0.74383754,-0.21341121,-1.0104555,-4.9701853,-1.8431443,0.48684523,-0.54978216,0.06517936,0.6155699,1.8648698,-3.8331366,-1.8988197,-2.8033164,-2.8291435,-1.9950002,-1.1874408,-1.5209508,-1.0766627,-3.046798,1.2530135}},
			{{-1.4386747,0.5947041,-1.4183176,-1.6406956,-4.8569117,1.1895362,0.67488605,0.5017388,-0.048114963,-0.058562994,-0.7924782,0.49670243,1.019221,-1.2453578,-1.7010425,-1.3210543,-1.2366719,-2.6363556,1.0928158,-1.4858211,0.56455797,0.25199386,1.0708658,-4.746071,-1.7400637,0.6689388,0.013929326,0.106152184,0.83560085,0.7093566,-0.6740529,-0.97981256,-1.1471229,-2.5129213,-1.3033218,-0.97197926,-0.9913591,-0.9968345,-2.3605728,-0.48037875}},
			{{-1.8382833,0.41798645,-0.06265994,-2.0205874,-0.7573801,0.8182249,0.5612198,0.101677135,-1.224895,-0.74627465,0.25108698,0.48600993,-0.5249612,-1.7704718,0.8130525,0.17596914,-0.2435286,-2.2139413,0.35167575,-1.5670102,2.488449,0.49851054,0.77205527,-3.9012973,-2.0912898,0.07140085,-0.896023,-0.31061053,0.43749923,-0.33070996,0.7923329,-1.254107,-0.023897123,-1.6714946,0.038856775,-0.64044166,-0.7270582,-0.9541092,-1.8581443,-1.829249}},
			{{-2.2015297,0.039070148,0.6979872,-0.8476291,0.5479898,0.6281588,-0.3300209,0.25815982,-2.1300507,-0.22619762,-0.24668033,0.48720503,-0.27577376,-1.2875823,0.53443223,0.7648283,0.15771402,-0.22098538,-1.1091679,-0.7490222,1.6693449,0.41669667,0.6088097,-2.9615886,-1.4155935,-1.9018741,-1.3270822,-0.8861277,-0.7066858,-0.70727736,0.5700975,-0.38140363,-0.108218074,-0.1741307,0.5441438,0.5586214,0.46858636,-1.1298279,-2.0941865,-2.0592678}},
			{{-2.4955466,-1.023193,0.016442563,-0.7800334,0.3157663,0.667613,-1.3342603,-1.3247464,-1.8932112,-0.6942596,0.14406784,0.5449603,-0.5114155,-0.26427925,0.13001403,-0.13639353,0.7957779,0.23725359,-0.79819906,0.391306,-0.3195901,0.11361053,0.777358,-1.045532,-1.78564,-3.0210836,0.04468463,-0.29891685,-1.5751075,0.0045222463,0.3824301,-1.2288322,-0.29486042,0.6588801,0.9850464,-0.46527243,0.23166364,-1.5478123,-0.9483312,-3.0577042}},
			{{-1.0322325,-0.89386976,-1.3157737,-0.6116646,-1.678088,0.50763875,-1.7580277,-0.9717446,-1.57007,0.070802264,-0.1874042,0.7783506,-1.9656614,1.0715684,-3.7956352,-2.159216,0.8100147,0.045754377,-0.6454484,0.46312335,-0.82424074,-0.7632466,0.8523416,0.42902955,-1.5206064,-1.5684863,0.59833336,0.3013743,-2.2762551,0.9447227,-1.5872446,-0.8642054,-0.480206,0.7050024,1.124801,-0.9175675,-0.8197292,-1.3555406,0.7689915,-4.3341436}},
			{{0.8234465,-0.36693487,-1.5571961,-1.4577034,-3.3414123,0.61879086,-3.363857,-0.86464465,-1.684288,0.14139234,0.77030724,0.6093699,-1.2369832,1.6725547,-4.7239623,-1.6158698,0.06752201,-2.3305275,-2.4411485,0.25386056,-0.14101613,-1.7667687,-0.43745342,0.70668143,-1.7263944,-0.98994416,-1.4058566,0.18175834,-3.629263,0.4062163,-5.3536553,-1.4644055,-0.8568539,-0.6490905,0.95331997,-1.4183302,-0.90379,-0.7330945,0.61498725,-3.371048}},
			{{0.14257097,1.2634124,-2.3042402,0.2122728,-1.6497481,0.38148034,-0.14531463,-2.0906742,0.90168107,0.28392503,-1.2047945,0.06613548,-0.21378565,-0.026082927,-4.4144254,1.2280962,0.1434778,-1.9223768,-1.5263746,-3.0102906,3.5131867,-0.9737751,0.97407544,-0.7008884,-1.2053906,-1.4826427,-0.4898139,0.06042485,-0.4178937,0.12887193,-4.081553,-0.9394077,-1.8137366,-2.9841027,-2.1677792,-0.37818757,-0.94345695,-0.13301505,-2.7367253,1.5667135}},
			{{-1.2444191,0.4042299,-0.25985083,0.010394695,-3.9836369,0.7219152,0.9519204,-0.650098,0.85424507,-0.46111545,-1.6063219,-0.34234837,0.18997504,-0.7302387,-2.3126755,-1.0776501,0.32419473,-1.7699127,1.0213622,-1.9193997,2.7233045,-0.77158475,1.0622102,-0.4100528,-1.1888338,-0.019065544,0.09380761,0.18074782,0.3395139,-0.47088698,-1.0854795,-1.4519764,-1.9710071,-1.6778344,-1.4126776,-0.49119172,-1.2564247,0.37606218,-1.558259,0.72527915}},
			{{-0.77026516,0.2799861,0.68079036,-1.7724328,-0.21964352,0.30892932,0.6548257,0.44617438,-0.2595001,-0.4895581,-1.0613624,-0.38351873,0.06284404,-1.8569621,0.6516948,-1.1207703,0.51446253,-0.7946167,0.09732689,-0.59292626,1.813238,-0.24669522,0.50693476,-0.11508547,-1.3339248,0.44850978,-0.4736729,-0.112863295,0.7288924,-0.68076056,0.625265,-0.08433292,-0.7129768,-1.4139608,-0.39304852,-0.45500252,-0.62413347,0.46094647,-1.9796922,0.32188642}},
			{{-1.8026439,0.0845689,0.187677,-2.143042,0.40261725,0.24353209,-0.46604025,0.4955723,-1.4553235,-0.4441913,-0.6458074,-0.21218742,-0.9054961,-1.3443636,0.500106,0.28147623,0.03515322,0.08746614,-1.085279,0.46519116,-0.11297141,0.028479211,-0.079524584,0.1107921,-0.90377265,-0.12391767,-1.3161037,-0.7082131,0.36510134,-0.4632133,0.60998404,-0.5636273,-0.33269304,-0.4279584,0.371184,0.63159716,0.49285465,0.3179541,-1.1644796,0.12821276}},
			{{-0.49811804,-0.8003074,-1.2473094,-1.3165586,0.2876377,0.5890072,-1.0856484,-0.2064266,-2.0073068,-0.10435257,-0.319243,-0.32520062,-1.4275542,0.22389396,0.13568774,0.5715091,0.1886743,-0.0151039865,-0.53154826,0.77668935,-0.6783774,0.65747714,0.37873897,0.2886298,-1.2283787,-1.855535,-0.047997322,0.06138754,-0.81735265,0.48806018,0.34922737,-0.1206434,-0.23273852,0.5676473,0.2996332,-0.47364926,0.32135704,0.34852946,-0.12631766,0.022698885}},
			{{0.17484733,-1.144939,-1.9637725,-0.9662449,-2.58781,0.6630375,-1.6285106,-1.18768,-1.7629482,-0.13012199,0.12001955,-0.0002458633,-0.4393416,0.7514603,-2.9477468,-0.67533123,-0.5450285,-0.9709251,-0.6488554,0.11979684,0.13012604,0.12940684,1.1627779,0.7974649,-1.283308,-3.2050345,0.605369,0.75950706,-1.8817767,0.9459059,-1.8229741,-1.0095699,0.52513725,0.70137423,0.6578005,-0.904036,-0.518992,0.32682157,0.8319661,-0.5089433}},
			{{0.88319963,-1.1655539,-0.07563443,-1.8472908,-2.4390724,0.2338823,-2.9957275,-1.0544809,-1.4577081,0.49970767,1.633372,-0.22460511,0.3738224,0.58684903,-4.2986383,-1.5200206,-0.5682009,-2.6799684,-2.9093275,-0.8102734,1.78764,-0.9093677,1.5268573,0.6671137,-1.1871796,-3.2611623,-2.3527873,0.046034593,-3.2075953,1.2811903,-5.6505494,-0.52301764,0.041482415,0.20208855,1.0039562,-1.3260441,-0.8706657,0.11811688,0.32335836,-0.10249663}},
			{{0.37081772,0.8701089,-0.8493165,-0.7974132,-4.161541,0.34626934,0.12648058,-2.3750138,0.20035449,-0.07776665,-0.84924424,-1.3788992,-1.4582667,-0.09897035,-3.6618145,0.11778806,0.042058226,-2.1679015,-1.2605457,-1.3658648,3.0368407,-2.0284312,0.9501326,0.36778286,0.5817253,-2.8895454,-1.8124712,-0.8145235,-1.1350245,-0.14259857,-3.6053352,-1.2465944,-2.7551003,-2.8367145,-1.0333955,0.67803484,-0.60933506,0.3085096,-2.105859,0.28828722}},
			{{0.16617374,0.14013772,0.61139524,0.4758604,-2.9356236,-0.24754395,0.9032193,-1.2185112,0.967202,-0.07697043,-1.3341402,-1.5514693,-1.182773,-0.41468725,-2.1556213,-0.4067608,0.68081963,-1.694638,0.9864655,-0.8508584,1.8115555,-1.3617382,1.0262724,0.51784045,0.2171575,-1.9104311,-0.19241537,-0.086614445,-0.7260728,-0.90005744,-1.3067982,0.29083055,-1.682773,-1.5428622,-1.0507772,0.4116299,-1.1333702,0.54145575,-2.127909,0.3789456}},
			{{-0.029723058,0.21729131,0.057968028,-0.2831912,0.06705525,-0.49147087,0.5956028,-0.7925848,0.43915084,-0.01398392,-1.2071012,-1.5199649,-0.78394485,-2.1001132,0.70050013,-1.5904671,0.25940022,-1.405813,0.15731594,0.4948799,-0.1595839,-1.4663291,1.2360911,0.35178423,-0.07999441,0.091391616,-0.3943997,-0.25688243,0.5916956,-0.6862307,0.30606404,0.007492298,-1.1421231,-0.9658652,-0.60211694,0.33976844,-0.83761936,0.6179121,-0.8185044,0.37011716}},
			{{0.23535213,0.44635764,-0.98405635,-1.615818,0.34791481,-0.28120908,-0.7507056,0.3731054,-0.37249357,0.009820881,-1.0322027,-1.3037962,-1.2360512,-0.7425812,0.41841802,-0.96305984,-0.5370692,-0.082778215,-0.99501425,0.6676477,-0.48672757,-0.9862216,0.99914885,0.26820177,0.01382597,0.37559894,-1.1582152,-1.2155114,0.780063,-0.26394522,0.37424758,1.0161622,-0.172357,-0.06975458,0.036927916,0.8111502,0.48147428,0.5198162,-0.028289145,0.19547008}},
			{{0.21132398,-0.88656557,-2.3057008,-1.6987872,0.055695064,0.102778375,-0.7294809,-1.0539496,-1.6364595,0.25147927,-0.876882,-1.4884351,-0.110494554,-0.004672554,0.4516749,0.22456972,-0.80427396,-1.498827,-0.29982483,0.6258723,-0.27176797,-0.06302923,1.3150012,0.35785273,-0.15264392,0.044387676,0.14666492,0.26113683,0.50658154,0.971708,0.10266849,0.016335161,0.07197791,0.42496815,-0.21168521,0.4370534,0.2989809,0.5832062,0.4312786,0.27951977}},
			{{0.38214913,-1.4024636,-1.3840654,-0.6585504,-1.992768,0.3140135,-0.9665984,-1.3488576,-1.8786074,0.5325373,-0.80418146,-1.2644366,0.42047822,0.13624099,-3.0495834,0.11830764,-0.9419737,-1.8656137,-1.0810405,-0.79486483,2.141579,0.53604484,1.3351307,0.38823876,-0.12632361,-1.9457514,0.8101761,0.58821034,-0.6566763,1.7719696,-1.955847,0.23354727,0.5997464,0.79723877,0.039810356,0.07063699,-0.4496732,0.693641,0.6656344,0.36783737}},
			{{0.36356074,-2.1503088,-2.1501513,-2.0875797,-1.901875,0.43249363,-2.8990793,-2.344561,-2.075109,0.21247262,0.11977593,-1.2290746,-0.3593822,-0.74018365,-4.4505863,-1.4216936,-0.8155177,-2.8910754,-2.5355506,-1.2659683,2.8879569,0.04321968,1.2251161,0.49900362,0.41357434,-2.0350614,-1.357797,-0.1458385,-0.99117744,1.996893,-4.7178645,-1.0323828,0.060680807,0.28263396,0.2645607,0.035922043,-0.3421727,0.3983468,-0.09272155,0.2745411}},
			{{0.44000557,1.5425078,0.67179894,-1.9672623,-6.1913295,-0.8099401,-0.020809224,-1.2540357,-0.22422047,0.61689436,-1.3626813,-1.1976105,-0.3258179,2.1439586,-3.1292741,-0.03454717,0.63862526,-2.3943686,-1.9936095,-0.36848137,1.9534848,-2.0861657,-0.37455848,0.7256168,0.5667312,-2.8569403,-0.746736,-0.30777887,-3.068565,-0.43811274,-4.1785817,-1.4136314,-2.4035504,-3.7030063,-1.2544804,-0.82943475,-1.2559472,0.013634038,-2.2267714,-0.40109274}},
			{{-0.50138634,0.29628527,0.45237058,-0.27680904,-1.2980225,-1.5605121,0.91434944,-1.2918811,0.6708315,0.7240588,-0.81341773,-1.0431604,-0.24931489,-1.5997256,-2.8518956,-0.27062792,0.09654581,-0.8912844,0.79018354,0.1550385,0.17141242,-1.4328575,-0.37794417,0.8596257,0.9010659,-2.8763776,0.0027775003,-0.14843766,-1.9394633,-1.0503694,-1.389899,-1.2550778,-1.591006,-2.2101126,-0.9966439,-0.8663174,-1.4720303,0.1041198,-1.6710305,-0.59232265}},
			{{0.17868066,0.3968088,-0.32711107,0.500245,0.40138695,-1.947908,0.48225534,0.013294742,0.91590655,0.30710095,-1.0642221,-0.40880543,-0.3643907,-1.3004667,0.29739082,-1.5294603,-0.8290949,-0.20907067,0.02971628,0.72539014,-0.5290843,-1.8680105,-0.12941937,0.11371845,0.50704503,-1.9391555,-0.5938542,-0.31486517,-0.8623714,-0.31860054,0.46083742,-0.96253544,-0.17391567,-1.600878,-0.5903991,-0.56952226,-0.93996537,0.35752985,-0.36092803,0.1442027}},
			{{-0.36193296,0.23762788,-1.6199563,-0.1371915,0.3874156,-1.5007792,-0.542417,0.444285,0.38761586,-0.78837514,-1.0093176,0.026056787,0.18573579,0.08489192,0.4951927,-1.325585,-1.1575735,-0.06763523,-0.9731889,0.54705787,-0.4151812,-2.170296,-0.023373606,0.20451435,0.5000915,-0.13018832,-1.277483,-0.5729135,0.3779225,0.6134905,0.5773906,-0.7246476,-0.1839227,-0.43690372,-0.40570882,0.72844666,0.48767212,0.17084299,0.36677387,0.14933585}},
			{{0.35629648,-1.0607796,-1.9969553,-1.014594,0.075808905,-0.8765599,-1.0094109,0.2840006,-0.54953986,-0.51227003,-1.1706514,-0.8402047,0.4304594,0.42236644,0.35250005,0.084090546,0.045072604,-0.6553035,-0.31243157,-0.36339974,1.630386,-1.657176,0.056087926,-0.02221653,0.44015124,0.4081467,-0.074407324,0.2956771,0.70635045,1.7413524,0.24602146,-0.9367578,-0.044196647,0.42355284,-0.5599012,-0.51233375,0.4761386,0.26551098,0.5962516,0.28490204}},
			{{-0.07891311,-1.2701489,-2.0594552,-1.0747534,-3.0504618,-0.63363373,-1.5071495,-0.78614527,-0.94718,0.19488579,-1.6413038,-1.6471457,0.1410053,-0.38305232,-3.2324886,0.67232394,-0.04863914,-1.7187983,-0.2766622,-2.3449578,3.3523684,-0.5353817,-0.28504717,-0.74430174,0.6568929,-0.24017361,0.6156749,0.9171513,0.30242717,1.5852578,-1.6570568,-1.2632096,0.8762831,0.5242066,0.15211563,-1.0282784,-0.06309557,0.36219442,0.19738443,0.72650605}},
			{{0.21554157,-0.52347004,-0.7042756,-0.13386717,-0.8429085,-0.6589497,-2.7066033,-1.8567371,-0.8128522,0.9477757,-2.6897879,-1.2226759,-0.36512893,-1.6210696,-6.5444613,0.32546908,-1.9747461,-1.5367572,-1.4554529,-2.9853113,2.6035304,0.37218016,-0.41758966,-0.72976464,0.586816,-1.1663465,-1.5722978,0.45672694,0.061024413,2.287487,-5.6545544,-1.7146158,-0.38204414,-0.05775898,0.46971244,-1.0349293,0.006964444,-0.13243884,-0.91289955,1.2174566}},
			{{0.35016355,1.2226416,0.60701203,-2.2833748,-0.46885112,-2.3742352,-0.18446767,-2.1675375,-1.0712116,1.0826823,-0.057815973,0.84567165,-0.005890375,-1.7008827,-5.1436,-1.1873724,-0.48379543,-2.6696835,-1.8653733,0.51003855,0.33603075,-1.6959423,-0.5499532,0.38024452,0.95911825,-1.1646099,-1.2351916,-0.5310007,-3.3619452,-0.41614255,-4.5653024,-1.9389584,-0.9370835,-3.5751505,-0.5367996,-1.3780853,-1.4558085,-0.5920101,-2.3751483,-3.4814932}},
			{{0.31537497,0.18434541,0.19174394,-1.5081836,0.061215404,-2.4112663,0.8033805,-1.7075245,-0.27497593,0.6731247,0.19662069,-0.31674013,0.052755002,-1.6466557,-3.5238323,-0.61150205,-1.6953835,-0.20027603,0.65878993,0.6394053,-0.47207955,-1.5450056,-0.51002616,0.3138481,1.0572151,-0.9224868,-0.1757411,-0.51795876,-2.3665113,-0.6949015,-1.3959796,-1.2214898,-0.3243092,-2.6818008,-0.53614706,-1.1845111,-1.3885942,-1.1560377,-0.9318976,-4.3760004}},
			{{0.082724705,0.29366654,-0.7963483,-0.5156014,0.6933228,-2.1523123,0.49232432,-1.3786528,0.65959895,-0.9046004,-0.022641532,-0.00438442,0.5348639,-0.54284835,-0.08831938,-1.1941682,-1.9277352,-0.24467376,0.2565373,0.41569415,-0.53899777,-1.7459722,-0.38586578,-0.85726637,0.87379795,-2.4661212,-0.83363533,-0.697994,-1.9109088,0.5133405,0.48014024,-1.50005,0.32345188,-1.3261826,-0.9098503,-0.84196544,-0.79672253,-1.1740284,0.23770726,-3.3639405}},
			{{0.14727508,0.47451562,-1.5197496,0.23147589,0.2726911,-1.8700318,-0.40345028,0.55717754,0.7890148,-1.893773,-0.57552075,0.4044069,0.45284227,0.55494636,0.47687057,-1.3628174,-1.1086782,-0.15469748,-0.9319723,-0.48667827,1.2315205,-1.4251915,-0.5313715,-2.1915636,0.6193657,-2.0194728,-1.2411963,-0.68873626,-1.010189,1.4531744,0.6283692,-0.5599085,-0.22362524,-0.19142497,-0.70709467,0.54484034,0.34388128,-1.0295393,0.5988485,-2.151653}},
			{{0.33135235,-0.9255019,-1.539942,-0.0056124013,-0.29782888,-1.5100348,-0.93829864,0.2487053,0.47303346,-1.6930319,-0.16967162,-0.093665905,0.28306544,-0.34016916,0.44298637,-0.26509,-0.8735726,-1.5237591,-1.0822583,-1.7662867,2.3190105,-1.9793222,-0.31058294,-2.9347723,0.88805616,-0.17379695,-0.118308924,0.27764592,0.32852057,1.3886973,0.33219913,-1.5764072,0.17857158,0.48478937,-1.2048072,-0.8331243,0.64452684,-1.2751071,0.098543525,-1.338314}},
			{{0.48274294,-1.4134488,-1.9894887,-0.938844,-4.365357,-0.97793305,-1.5486248,0.044473898,-0.39102313,-1.1917226,-0.36125916,-1.168365,-0.74096066,-1.5991333,-2.1911125,0.718411,0.49784392,-2.2301443,-0.14066139,-2.8097935,1.4191833,-2.1480348,-0.68999964,-4.2214804,1.1184009,0.3481675,0.3888762,0.6811217,0.89743835,1.7880303,-1.2458073,-1.1800377,0.56441146,0.46906504,-0.0542695,-1.1659963,0.09728465,-1.5184958,-0.7781694,-0.05770663}},
			{{0.08568255,-0.55257106,-2.2063255,-1.1021461,-0.53422123,-0.037770197,-2.9356668,-1.9578439,-0.6786873,0.64173865,-1.0474278,0.271697,-1.903657,-1.3189799,-4.3997064,0.974829,0.30974615,-2.8042896,-1.4103302,-3.2438097,1.6123159,-1.3708384,-1.2918755,-4.9694605,0.79259145,0.21342579,-0.98994523,0.52362126,0.7022921,3.889079,-5.0925813,-2.2353806,-0.067415975,-0.7079322,-0.5183093,-0.90240794,0.28676513,-1.3307742,-1.3561392,1.2502537}},
			{{-0.352396,1.0727116,0.25940338,-1.6182464,-0.38295195,-2.2680137,-0.36475524,-1.8146694,-1.4272474,0.3694264,-0.8518719,-0.37021714,-0.24798861,-0.93523836,-5.686219,-0.9898022,-1.1970892,-0.43559667,-1.6246586,0.29106334,-0.9284007,-1.5664124,0.569903,0.3352097,0.6749816,0.64473736,-0.9103799,-0.41431648,-3.7148535,-0.19539283,-3.8624327,-2.2829933,-0.0073664556,-3.635145,-1.2244163,-1.7422413,-0.8819342,-2.7835221,-1.4531819,-6.374755}},
			{{-0.88207346,1.0525044,0.18057647,-1.9676011,0.5690232,-3.2781396,0.08841189,-1.8350967,-1.122133,-0.5245188,0.30225593,-0.07682012,0.107272886,-1.1579537,-3.2804165,-1.7331408,-3.9420981,0.6569292,0.74836487,-0.029275792,-0.6219087,-1.8555555,1.0879544,0.28028163,0.4029883,-0.6587283,1.3169597,-0.96713775,-3.721867,0.27585864,-0.6308062,-1.982812,0.8144954,-2.4880676,-0.28415394,-1.5297729,-1.6600351,-3.3906329,-0.9352,-3.7365656}},
			{{-0.5326558,1.0494514,-0.4173681,-1.9528233,1.0575373,-3.2584357,0.050139442,-0.5994445,-0.20178325,-3.9294786,-0.5937769,0.3410185,-0.08954065,0.12205181,-0.12981655,-2.1285186,-0.14111505,0.4299586,0.3016326,-0.933837,0.344479,-1.0879198,1.2866209,-2.3957531,0.105012566,-2.8256278,-0.8995682,-0.7663423,-3.3685107,1.4737849,0.31718093,-1.7404232,0.70451635,-1.2782065,-0.83061254,-0.9522751,-0.8840578,-3.8000748,0.7328564,-1.2410307}},
			{{0.8518278,0.8832399,-2.0245771,-1.4488722,0.32415625,-2.766127,-0.15217759,0.47859547,0.1984193,-2.3728251,-0.9972496,0.5852062,-1.2325244,-0.11247631,0.56303805,-2.09347,-1.2605582,-0.20822036,-0.9061134,-1.7110981,2.2866457,-1.5328485,0.9679247,-3.7226624,0.2748626,-2.6933808,-1.2317966,-0.880876,-1.9315269,1.777479,0.13637754,-1.42926,-0.1807625,0.40422666,-1.2123044,0.22672486,0.41654927,-2.8485227,0.144548,-3.522054}},
			{{0.5127819,0.12835611,-2.284161,-0.3012693,-0.34026244,-2.5687284,-0.90804255,1.1040734,0.5814472,-2.4114392,-0.0683501,0.18614632,-0.25569516,-1.9519007,0.7780162,-0.4817024,-0.904606,-1.5262036,-1.1345704,-2.565118,1.9939835,0.53445643,2.0041997,-1.1999754,0.58835113,-1.1278987,0.15342917,-0.090892114,-0.64484996,1.9278051,0.11840716,-1.9058975,-0.2685222,0.410084,-1.4293921,-0.6933662,0.62609136,-3.6278455,-1.1862082,-5.317694}},
			{{-0.19769724,-1.3725735,-1.2309283,-0.5858765,-4.36708,-1.7735882,-1.3814981,1.0405912,-0.34488407,-0.9798943,0.40023622,-0.34344995,-0.98763734,-2.3776767,-0.35447145,0.27341238,-2.1280804,-2.7885635,1.4214381,-2.705322,0.51515776,-3.0762,1.5584209,-4.5627193,1.0554323,0.28894046,1.0075449,0.4436315,0.50164574,3.2338784,-0.67070264,-1.9141347,-0.17375854,-0.13504492,0.10786391,-1.2470511,0.23272513,-4.851023,-2.069014,-0.57184625}},
			{{-0.11409506,-1.0722939,-2.1577094,-0.93997836,-2.8468292,-1.2405633,-1.8056586,-0.3355574,-0.22365382,-0.51081127,-0.6902552,-0.5353284,-2.3142533,-1.2747204,-3.7146058,0.7790286,0.14322664,-2.3340712,-1.5738672,-2.502799,0.852757,-1.9917847,0.8398745,-5.3647213,0.9299384,0.9122402,-0.60290223,0.4131716,0.6350239,4.154455,-2.9596775,-2.1048498,-0.10134813,-1.2852371,0.23005983,-0.9954446,0.54648226,-3.7095375,-2.656844,-0.7088396}}
    }};

    b1 = {
			0.18592304, 0.02587129, 0.106040545, 0.31986082, -0.27301103, 0.31349945, 0.3449302, -0.49604246, -0.06325847, 0.15284745, 0.115237705, -0.24521114, 0.2257622, 0.13816711, -1.5181577, -0.06875812, -0.057673723, -0.051433273, 0.314043, 0.22988586, -0.25981423, -0.30067217, 0.048434548, 0.3224332, -0.2816996, 0.0010557825, -0.39102212, 0.31682366, 0.40963265, -0.033478826, 0.011725178, 0.29269242, 0.6210357, -0.34684235, -0.07217158, 0.27841115, 0.09590083, -0.38042548, -0.3313572, -0.25825462
    };

    b2 = {
			0.34609783, -0.16415963, 0.015894042, -0.184947, -0.3521153, 1.7931566, 0.79779553, 0.1504376, -0.24782255, 1.702889, -0.5620471, 0.28147635, 1.8375051, 2.1311142, 1.2211974, -0.67830586, -0.1327174, 0.14236045, 0.15276542, 0.8035319, 1.8951702, 0.9256746, 0.108525544, -0.45743698, -0.2684584, 1.0217106, 0.84547096, 0.83206356, 0.6336309, 0.5707386, -0.109215915, -0.33124495, 1.118417, 1.5825976, 0.39243716, 0.3147168, 0.29834428, -0.5213613, 1.9257401, 0.44891968
    };

    b3 = {
			1.8251084, -1.7065954, 3.1275852, -3.2318516, -2.1276698, -0.2763296, 3.0010395, 0.85641265, -1.0942386, -1.1300449, 1.459136, 1.1488037, -16.822851, -1.3079572, -0.34855682, 0.5324969, 2.3163912, 1.3876169, -0.025092784, 3.2761033, 2.027598, 1.8213508, -1.7554464, 3.3115826, -0.116091385, -0.8345453, -0.8728473, 5.1253657, 1.0953712, 2.5872486, -2.380869, -0.75922734, 2.278594, -1.1389908, -3.602015, 3.757105, 0.34028274, -3.0900834, -3.171452, 1.3802675
    };

    b4 = {
			-0.17007348, 0.53824675, -3.0561209, -4.42956, 0.1428583, 0.91972035, 1.5806519, 0.8388448, 0.5357138, -0.84236187, -5.006158, -4.6116195, -2.4606764, -4.693326, 1.4756737, -3.024433, -0.8648437, -4.1418147, -3.705241, 3.1053276, -2.0638118, -3.4329348, -2.8521318, 0.42987838, 2.5682447, -2.8527658, -5.334237, -0.26370254, 2.610373, 2.092405, 4.2654724, -5.156573, 1.3025029, 1.382578, 2.5677786, 0.8845901, 2.8277082, 3.295102, 1.4379078, 1.0941269
    };

    bout = {
			-3.0071292, -1.6336386, -1.3454999, -1.462221, -1.1733023, -1.5617065, -3.0235102, -2.3698654, -0.27903545, 0.107552394, 0.72102773, 0.057389807, -0.4225241, -2.5955677, -1.9636866, -0.121877894, 1.2549233, 1.3324838, 1.2550094, -0.23698346, -2.421143, -2.5989347, 0.18282166, 1.0236852, 1.6312503, 1.0756651, 0.13810089, -2.8371136, -2.2606525, -0.20727769, 1.185248, 1.3727633, 1.2185563, -0.22032484, -2.3201272, -2.5597563, -0.42448685, -0.0674921, 0.68296885, 0.019960515, -0.38980395, -2.412583, -2.8632317, -1.5494046, -1.2001604, -1.3157539, -1.1208155, -1.4793633, -2.6677868
    };

    BN_gamma_in = {
			0.43725246, 0.16657537, 0.3657288, 0.5514654, 0.107979774, 0.02552092, 0.59032476, 0.077227294, 0.22422338
    };

    BN_gamma_1 = {
			1.28642, 3.3322923, 3.6904316, 3.7299101, 7.5652747, 3.6257577, 3.729339, 8.566775, 6.6434097, 4.5147157, 7.952509, 4.7920957, 4.6384687, 3.9550579, 3.3648384, 8.414862, 7.1607976, 4.120683, 4.3586435, 5.095105, 8.211072, 4.083483, 3.883439, 4.1002083, 2.4925733, 4.834069, 9.7918005, 6.698794, -3.6320913, 6.8493505, 6.652826, 4.268459, 1.1342878, 0.3115316, 7.0752735, 3.2241528, 4.82169, 6.9625096, 0.7563557, 7.4901104
    };

    BN_gamma_2 = {
			0.32892382, 0.7801152, 0.6373586, 1.6455462, 0.5241028, 0.35613057, 0.47160172, 1.1945657, 0.6020794, 0.60542953, 0.8263599, 0.55193454, 0.2920539, 0.38472334, 0.3316714, 0.7323535, 0.9172628, 0.30187643, 0.65534115, 0.30318528, 0.32133988, 0.32092026, 0.43664274, 0.9934192, 0.8074458, 0.32267562, 0.4962903, 0.71806383, 0.38087022, 0.28130493, 0.64047265, 0.0839192, 0.39198047, 0.39632383, 0.30833462, 0.31473643, 0.9516786, 0.42665485, 0.3561912, 0.28198373
    };

    BN_gamma_3 = {
			0.17264584, 0.2700984, 0.19677636, 0.25267017, 0.30534977, 0.27997518, 0.20603238, 0.1860801, 0.29458982, 0.32200965, 0.20814227, 0.2265785, 0.28377575, 0.27985886, 0.22246945, 0.16799544, 0.1781815, 0.21891946, 0.1849845, 0.20287676, 0.20365176, 0.22184153, 0.2866017, 0.25207755, 0.20964082, 0.18690659, 0.19574547, 0.23235258, 0.19503273, 0.19424044, 0.27222967, 0.19683005, 0.21717916, 0.26217002, 0.2172495, 0.21207838, 0.18178502, 0.26346153, 0.1830003, 0.20416017
    };

    BN_gamma_4 = {
			0.11711193, 0.10920297, 0.1414631, 0.16323403, 0.0944875, 0.11552372, 0.12113591, 0.11444565, 0.1208488, 0.12173623, 0.12836789, 0.14589874, 0.11407483, 0.14902247, 0.09781362, 0.13376433, 0.11874042, 0.10298387, 0.14864346, 0.098186925, -0.11933415, 0.13023116, -0.1259986, 0.09397156, 0.1063153, 0.13180183, 0.14239256, 0.10517121, 0.10507496, -0.10327589, 0.08566015, 0.31987667, 0.10495091, 0.115365654, 0.11418131, 0.11840965, 0.107570946, 0.08729637, 0.10158519, 0.10270482
    };

    BN_beta_1 = {
			-0.07672354, -0.36599168, -0.46587777, -0.59542704, -0.08859556, -0.09150317, -0.5234004, -0.09047649, -0.2771153, -0.38885888, -0.30674705, -0.2000168, -0.45452812, -0.1702594, -0.0038276094, -0.08330532, -0.10810737, -0.13074405, -0.62460226, -0.69326395, -0.16694915, -0.00019820595, -0.2287493, -0.56012964, -0.5005164, -0.27785176, -0.11739189, -0.39893067, 0.79238665, -0.15944096, -0.38305587, -0.4360094, -0.026302554, -0.00031153634, -0.21426323, -0.29329672, -0.5225157, -0.14601986, 0.00052330527, -0.19134203
    };

    BN_beta_2 = {
			-0.32244578, -0.1350835, -0.18246286, -0.26116958, -0.101090975, -0.70347285, -0.37733033, -0.2919541, -0.13578586, -1.2111052, -0.09831439, -0.23199087, -0.56791145, -1.0959016, -0.6569072, -0.15490799, -0.1435991, -0.15423903, -0.32837528, -0.35403627, -0.5854368, -0.30257902, -0.25677866, -0.1075977, -0.18153605, -0.45910984, -0.3479651, -0.64075273, -0.45058376, -0.2814517, -0.24290392, 0.0008412074, -0.5047077, -0.6642563, -0.42243305, -0.18095028, -0.28760758, -0.28224167, -0.7687855, -0.27539787
    };

    BN_beta_3 = {
			-0.5325678, -0.14262185, -0.8219068, -0.08260809, -0.17839798, -0.1381972, -0.8372931, -0.5840225, -0.20711608, -0.21047975, -0.6691153, -0.8262167, 0.05727268, -0.09502531, -0.22823164, -0.18734226, -0.41326684, -0.21611546, -0.3306014, -0.9935782, -0.8924811, -0.27991652, -0.105837986, -0.8313254, -0.47029012, -0.16312371, -0.22014162, -0.95100397, -0.24572858, -0.74847174, -0.16857223, -0.23702016, -0.54469347, -0.25928923, -0.06096731, -1.0592043, -0.2458312, -0.028935011, -0.0976099, -0.62843746
    };

    BN_beta_4 = {
			-0.10588256, -0.12447508, -0.059577115, -0.06617432, -0.045822322, -0.16362856, -0.22030748, -0.16846082, -0.15109247, -0.081721395, -0.06693198, -0.09684815, -0.091856696, -0.05447427, -0.068446875, -0.071003735, -0.11245498, -0.064579055, -0.10472177, -0.19026813, 0.06866249, -0.07773696, 0.107048735, -0.04553064, -0.20900272, -0.07616737, -0.10317871, -0.292139, -0.18147787, 0.15465525, -0.18389563, -0.046551876, -0.24988006, -0.15056704, -0.3366493, -0.17813556, -0.2963759, -0.15394917, -0.12700397, -0.061223358
    };
    
    mean = {
      58121.79697777398,35982.63326206248,54126.034579215026,47099.84770860291,16918.041715461684,46786.465602280994,54394.190536420305,35557.42198730395,57916.08224750105
    };

    stdev = {
      209719.99252336434,156429.86517925534,193617.6018444604,183553.46721868264,127286.93783731306,182093.47999310683,194486.93364851017,155514.52171421162,208118.4647262227
    };
  }
  
}


__inline Void TEncSearch::xTZSearchHelp( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const Int iSearchX, const Int iSearchY, const UChar ucPointNr, const UInt uiDistance )
{
  Distortion  uiSad = 0;

  const Pel* const  piRefSrch = rcStruct.piRefY + iSearchY * rcStruct.iYStride + iSearchX;

  //-- jclee for using the SAD function pointer
  m_pcRdCost->setDistParam( pcPatternKey, piRefSrch, rcStruct.iYStride,  m_cDistParam );

  setDistParamComp(COMPONENT_Y);

  // distortion
  m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
  m_cDistParam.m_maximumDistortionForEarlyExit = rcStruct.uiBestSad;

  if((m_pcEncCfg->getRestrictMESampling() == false) && m_pcEncCfg->getMotionEstimationSearchMethod() == MESEARCH_SELECTIVE)
  {
    Int isubShift = 0;
    // motion cost
    Distortion uiBitCost = m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

    // Skip search if bit cost is already larger than best SAD
    if (uiBitCost < rcStruct.uiBestSad)
    {
      if ( m_cDistParam.iRows > 32 )
      {
        m_cDistParam.iSubShift = 4;
      }
      else if ( m_cDistParam.iRows > 16 )
      {
        m_cDistParam.iSubShift = 3;
      }
      else if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 2;
      }
      else
      {
        m_cDistParam.iSubShift = 1;
      }

      Distortion uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
      if((uiTempSad + uiBitCost) < rcStruct.uiBestSad)
      {
        uiSad += uiTempSad >>  m_cDistParam.iSubShift;
        while(m_cDistParam.iSubShift > 0)
        {
          isubShift         = m_cDistParam.iSubShift -1;
          m_cDistParam.pOrg = pcPatternKey->getROIY() + (pcPatternKey->getPatternLStride() << isubShift);
          m_cDistParam.pCur = piRefSrch + (rcStruct.iYStride << isubShift);
          uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
          uiSad += uiTempSad >>  m_cDistParam.iSubShift;
          if(((uiSad << isubShift) + uiBitCost) > rcStruct.uiBestSad)
          {
            break;
          }

          m_cDistParam.iSubShift--;
        }

        if(m_cDistParam.iSubShift == 0)
        {
          uiSad += uiBitCost;
          if( uiSad < rcStruct.uiBestSad )
          {
            rcStruct.uiBestSad      = uiSad;
            rcStruct.iBestX         = iSearchX;
            rcStruct.iBestY         = iSearchY;
            rcStruct.uiBestDistance = uiDistance;
            rcStruct.uiBestRound    = 0;
            rcStruct.ucPointNr      = ucPointNr;
            m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
          }
        }
      }
    }
  }
  else
  {
    // fast encoder decision: use subsampled SAD when rows > 8 for integer ME
    if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE3 )
    {
      if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 1;
      }
    }

    uiSad = m_cDistParam.DistFunc( &m_cDistParam );

    // EMI: Modification "array_e & counter_i"
    array_e[counter_i] = uiSad;
    
    // only add motion cost if uiSad is smaller than best. Otherwise pointless
    // to add motion cost.
    if( uiSad < rcStruct.uiBestSad )
    {
      // motion cost
      uiSad += m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

      if( uiSad < rcStruct.uiBestSad )
      {
        rcStruct.uiBestSad      = uiSad;
        rcStruct.iBestX         = iSearchX;
        rcStruct.iBestY         = iSearchY;
        rcStruct.uiBestDistance = uiDistance;
        rcStruct.uiBestRound    = 0;
        rcStruct.ucPointNr      = ucPointNr;
        m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
      }
    }
  }
  counter_i = counter_i + 1;
}

__inline Void TEncSearch::xTZ2PointSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB )
{
  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 2 point search,                   //   1 2 3
  // check only the 2 untested points  //   4 0 5
  // around the start point            //   6 7 8
  Int iStartX = rcStruct.iBestX;
  Int iStartY = rcStruct.iBestY;
  switch( rcStruct.ucPointNr )
  {
    case 1:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY, 0, 2 );
      }
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
    }
      break;
    case 2:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 3:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
    }
      break;
    case 4:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 5:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 6:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY , 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    case 7:
    {
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 8:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    default:
    {
      assert( false );
    }
      break;
  } // switch( rcStruct.ucPointNr )
}




__inline Void TEncSearch::xTZ8PointSquareSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iTop >= iSrchRngVerTop ) // check top
  {
    if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
    }
    // top middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );

    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
    }
  } // check top
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
  }
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
  }
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
    if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
    }
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );

    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
    }
  } // check bottom
}


//additing other square search

__inline Void TEncSearch::xTZ8PointSquareSearch2( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;
// check top
  if ( iTop >= iSrchRngVerTop ) // check top
  {
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iLeft, iTop, 9, iDist);
    }
	  
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iStartX - 1, iTop, 10, iDist);
    }
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 11, iDist );
	
	if (iRight <= iSrchRngHorRight) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX +1, iTop, 12, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 13, iDist );
    }
  }

  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY-1, 14, iDist );
  }

  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY-1, 15, iDist );
  }
  
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 16, iDist );
  }
  
  
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 17, iDist );
  }
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY+1, 18, iDist );
  }
  
  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY+1, 19, iDist );
  }
  
  
  
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 20, iDist );
    }  
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iBottom, 21, iDist );
    }   
	  
	  
    
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 22, iDist );

	if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iBottom, 23, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 24, iDist );
    }
  } 
  
  // check bottom
}











__inline Void TEncSearch::xTZ8PointDiamondSearch( const TComPattern*const  pcPatternKey,
                                                  IntTZSearchStruct& rcStruct,
                                                  const TComMv*const  pcMvSrchRngLT,
                                                  const TComMv*const  pcMvSrchRngRB,
                                                  const Int iStartX,
                                                  const Int iStartY,
                                                  const Int iDist,
                                                  const Bool bCheckCornersAtDist1 )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert ( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iDist == 1 )
  {
    if ( iTop >= iSrchRngVerTop ) // check top
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
      }
    }
    if ( iLeft >= iSrchRngHorLeft ) // check middle left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
    }
    if ( iRight <= iSrchRngHorRight ) // check middle right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
    }
    if ( iBottom <= iSrchRngVerBottom ) // check bottom
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
      }
    }
  }
  else
  {
    if ( iDist <= 8 )
    {
      const Int iTop_2      = iStartY - (iDist>>1);
      const Int iBottom_2   = iStartY + (iDist>>1);
      const Int iLeft_2     = iStartX - (iDist>>1);
      const Int iRight_2    = iStartX + (iDist>>1);

      if (  iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iTop,      2, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iTop_2,    1, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2,    3, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,    iStartY,   4, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,   iStartY,   5, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iBottom_2, 6, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iBottom,   7, iDist    );
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        }
        if ( iTop_2 >= iSrchRngVerTop ) // check half top
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iTop_2, 1, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2, 3, (iDist>>1) );
          }
        } // check half top
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
        }
        if ( iBottom_2 <= iSrchRngVerBottom ) // check half bottom
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iBottom_2, 6, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, (iDist>>1) );
          }
        } // check half bottom
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        }
      } // check border
    }
    else // iDist > 8
    {
      if ( iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop,    0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,   iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,  iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
        }
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 0, iDist );
        }
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 0, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 0, iDist );
        }
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        }
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);

          if ( iPosYT >= iSrchRngVerTop ) // check top
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
            }
          } // check top
          if ( iPosYB <= iSrchRngVerBottom ) // check bottom
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
            }
          } // check bottom
        } // for ...
      } // check border
    } // iDist <= 8
  } // iDist == 1
}

Distortion TEncSearch::xPatternRefinement( TComPattern* pcPatternKey,
                                           TComMv baseRefMv,
                                           Int iFrac, TComMv& rcMvFrac,
                                           Bool bAllowUseOfHadamard
                                         )
{
  Distortion  uiDist;
  Distortion  uiDistBest  = std::numeric_limits<Distortion>::max();
  UInt        uiDirecBest = 0;

  Pel*  piRefPos;
  Int iRefStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);

  m_pcRdCost->setDistParam( pcPatternKey, m_filteredBlock[0][0].getAddr(COMPONENT_Y), iRefStride, 1, m_cDistParam, m_pcEncCfg->getUseHADME() && bAllowUseOfHadamard );

  const TComMv* pcMvRefine = (iFrac == 2 ? s_acMvRefineH : s_acMvRefineQ);

  for (UInt i = 0; i < 9; i++)
  {
    TComMv cMvTest = pcMvRefine[i];
    cMvTest += baseRefMv;

    Int horVal = cMvTest.getHor() * iFrac;
    Int verVal = cMvTest.getVer() * iFrac;
    piRefPos = m_filteredBlock[ verVal & 3 ][ horVal & 3 ].getAddr(COMPONENT_Y);
    if ( horVal == 2 && ( verVal & 1 ) == 0 )
    {
      piRefPos += 1;
    }
    if ( ( horVal & 1 ) == 0 && verVal == 2 )
    {
      piRefPos += iRefStride;
    }
    cMvTest = pcMvRefine[i];
    cMvTest += rcMvFrac;

    setDistParamComp(COMPONENT_Y);

    m_cDistParam.pCur = piRefPos;
    m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
    uiDist = m_cDistParam.DistFunc( &m_cDistParam );
    uiDist += m_pcRdCost->getCostOfVectorWithPredictor( cMvTest.getHor(), cMvTest.getVer() );

    if ( uiDist < uiDistBest )
    {
      uiDistBest  = uiDist;
      uiDirecBest = i;
      m_cDistParam.m_maximumDistortionForEarlyExit = uiDist;
    }
  }

  rcMvFrac = pcMvRefine[uiDirecBest];

  return uiDistBest;
}



Void
TEncSearch::xEncSubdivCbfQT(TComTU      &rTu,
                            Bool         bLuma,
                            Bool         bChroma )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx         = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth            = rTu.GetTransformDepthRel();
  const UInt uiTrMode             = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt uiSubdiv             = ( uiTrMode > uiTrDepth ? 1 : 0 );
  const UInt uiLog2LumaTrafoSize  = rTu.GetLog2LumaTrSize();

  if( pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_NxN && uiTrDepth == 0 )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize > pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getSlice()->getSPS()->getQuadtreeTULog2MinSize() )
  {
    assert( !uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
  {
    assert( !uiSubdiv );
  }
  else
  {
    assert( uiLog2LumaTrafoSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );
    if( bLuma )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( uiSubdiv, 5 - uiLog2LumaTrafoSize );
    }
  }

  if ( bChroma )
  {
    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if( rTu.ProcessingAllQuadrants(compID) && (uiTrDepth==0 || pcCU->getCbf( uiAbsPartIdx, compID, uiTrDepth-1 ) ))
      {
        m_pcEntropyCoder->encodeQtCbf(rTu, compID, (uiSubdiv == 0));
      }
    }
  }

  if( uiSubdiv )
  {
    TComTURecurse tuRecurse(rTu, false);
    do
    {
      xEncSubdivCbfQT( tuRecurse, bLuma, bChroma );
    } while (tuRecurse.nextSection(rTu));
  }
  else
  {
    //===== Cbfs =====
    if( bLuma )
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }
}




Void
TEncSearch::xEncCoeffQT(TComTU &rTu,
                        const ComponentID  component,
                        Bool         bRealCoeff )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();

  const UInt  uiTrMode        = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt  uiSubdiv        = ( uiTrMode > uiTrDepth ? 1 : 0 );

  if( uiSubdiv )
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xEncCoeffQT( tuRecurseChild, component, bRealCoeff );
    } while (tuRecurseChild.nextSection(rTu) );
  }
  else if (rTu.ProcessComponentSection(component))
  {
    //===== coefficients =====
    const UInt  uiLog2TrafoSize = rTu.GetLog2LumaTrSize();
    UInt    uiCoeffOffset   = rTu.getCoefficientOffset(component);
    UInt    uiQTLayer       = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrafoSize;
    TCoeff* pcCoeff         = bRealCoeff ? pcCU->getCoeff(component) : m_ppcQTTempCoeff[component][uiQTLayer];

    if (isChroma(component) && (pcCU->getCbf( rTu.GetAbsPartIdxTU(), COMPONENT_Y, uiTrMode ) != 0) && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag() )
    {
      m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, component );
    }

    m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeff+uiCoeffOffset, component );
  }
}




Void
TEncSearch::xEncIntraHeader( TComDataCU*  pcCU,
                            UInt         uiTrDepth,
                            UInt         uiAbsPartIdx,
                            Bool         bLuma,
                            Bool         bChroma )
{
  if( bLuma )
  {
    // CU header
    if( uiAbsPartIdx == 0 )
    {
      if( !pcCU->getSlice()->isIntra() )
      {
        if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
        {
          m_pcEntropyCoder->encodeCUTransquantBypassFlag( pcCU, 0, true );
        }
        m_pcEntropyCoder->encodeSkipFlag( pcCU, 0, true );
        m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
      }
      m_pcEntropyCoder  ->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );

      if (pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_2Nx2N )
      {
        m_pcEntropyCoder->encodeIPCMInfo( pcCU, 0, true );

        if ( pcCU->getIPCMFlag (0))
        {
          return;
        }
      }
    }
    // luma prediction mode
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N )
    {
      if (uiAbsPartIdx==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, 0 );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      if (uiTrDepth>0 && (uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiAbsPartIdx );
      }
    }
  }

  if( bChroma )
  {
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N || !enable4ChromaPUsInIntraNxNCU(pcCU->getPic()->getChromaFormat()))
    {
      if(uiAbsPartIdx==0)
      {
         m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      assert(uiTrDepth>0);
      if ((uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
  }
}




UInt
TEncSearch::xGetIntraBitsQT(TComTU &rTu,
                            Bool         bLuma,
                            Bool         bChroma,
                            Bool         bRealCoeff /* just for test */ )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();
  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiTrDepth, uiAbsPartIdx, bLuma, bChroma );
  xEncSubdivCbfQT ( rTu, bLuma, bChroma );

  if( bLuma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Y,      bRealCoeff );
  }
  if( bChroma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Cb,  bRealCoeff );
    xEncCoeffQT   ( rTu, COMPONENT_Cr,  bRealCoeff );
  }
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  return uiBits;
}

UInt TEncSearch::xGetIntraBitsQTChroma(TComTU &rTu,
                                       ComponentID compID,
                                       Bool         bRealCoeff /* just for test */ )
{
  m_pcEntropyCoder->resetBits();
  xEncCoeffQT   ( rTu, compID,  bRealCoeff );
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  return uiBits;
}

Void TEncSearch::xIntraCodingTUBlock(       TComYuv*    pcOrgYuv,
                                            TComYuv*    pcPredYuv,
                                            TComYuv*    pcResiYuv,
                                            Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      const Bool        checkCrossCPrediction,
                                            Distortion& ruiDist,
                                      const ComponentID compID,
                                            TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug)
                                           ,Int         default0Save1Load2
                                     )
{
  if (!rTu.ProcessComponentSection(compID))
  {
    return;
  }
  const Bool           bIsLuma          = isLuma(compID);
  const TComRectangle &rect             = rTu.getRect(compID);
        TComDataCU    *pcCU             = rTu.getCU();
  const UInt           uiAbsPartIdx     = rTu.GetAbsPartIdxTU();
  const TComSPS       &sps              = *(pcCU->getSlice()->getSPS());

  const UInt           uiTrDepth        = rTu.GetTransformDepthRelAdj(compID);
  const UInt           uiFullDepth      = rTu.GetTransformDepthTotal();
  const UInt           uiLog2TrSize     = rTu.GetLog2LumaTrSize();
  const ChromaFormat   chFmt            = pcOrgYuv->getChromaFormat();
  const ChannelType    chType           = toChannelType(compID);
  const Int            bitDepth         = sps.getBitDepth(chType);

  const UInt           uiWidth          = rect.width;
  const UInt           uiHeight         = rect.height;
  const UInt           uiStride         = pcOrgYuv ->getStride (compID);
        Pel           *piOrg            = pcOrgYuv ->getAddr( compID, uiAbsPartIdx );
        Pel           *piPred           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piResi           = pcResiYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piReco           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
  const UInt           uiQTLayer        = sps.getQuadtreeTULog2MaxSize() - uiLog2TrSize;
        Pel           *piRecQt          = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
  const UInt           uiRecQtStride    = m_pcQTTempTComYuv[ uiQTLayer ].getStride(compID);
  const UInt           uiZOrder         = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
        Pel           *piRecIPred       = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
        UInt           uiRecIPredStride = pcCU->getPic()->getPicYuvRec()->getStride  ( compID );
        TCoeff        *pcCoeff          = m_ppcQTTempCoeff[compID][uiQTLayer] + rTu.getCoefficientOffset(compID);
        Bool           useTransformSkip = pcCU->getTransformSkip(uiAbsPartIdx, compID);

#if ADAPTIVE_QP_SELECTION
        TCoeff        *pcArlCoeff       = m_ppcQTTempArlCoeff[compID][ uiQTLayer ] + rTu.getCoefficientOffset(compID);
#endif

  const UInt           uiChPredMode     = pcCU->getIntraDir( chType, uiAbsPartIdx );
  const UInt           partsPerMinCU    = 1<<(2*(sps.getMaxTotalCUDepth() - sps.getLog2DiffMaxMinCodingBlockSize()));
  const UInt           uiChCodedMode    = (uiChPredMode==DM_CHROMA_IDX && !bIsLuma) ? pcCU->getIntraDir(CHANNEL_TYPE_LUMA, getChromasCorrespondingPULumaIdx(uiAbsPartIdx, chFmt, partsPerMinCU)) : uiChPredMode;
  const UInt           uiChFinalMode    = ((chFmt == CHROMA_422)       && !bIsLuma) ? g_chroma422IntraAngleMappingTable[uiChCodedMode] : uiChCodedMode;

  const Int            blkX                                 = g_auiRasterToPelX[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            blkY                                 = g_auiRasterToPelY[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            bufferOffset                         = blkX + (blkY * MAX_CU_SIZE);
        Pel  *const    encoderLumaResidual                  = resiLuma[RESIDUAL_ENCODER_SIDE ] + bufferOffset;
        Pel  *const    reconstructedLumaResidual            = resiLuma[RESIDUAL_RECONSTRUCTED] + bufferOffset;
  const Bool           bUseCrossCPrediction                 = isChroma(compID) && (uiChPredMode == DM_CHROMA_IDX) && checkCrossCPrediction;
  const Bool           bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
        Pel *const     lumaResidualForEstimate              = bUseReconstructedResidualForEstimate ? reconstructedLumaResidual : encoderLumaResidual;

#if DEBUG_STRING
  const Int debugPredModeMask=DebugStringGetPredModeMask(MODE_INTRA);
#endif

  //===== init availability pattern =====
  DEBUG_STRING_NEW(sTemp)

#if !DEBUG_STRING
  if( default0Save1Load2 != 2 )
#endif
  {
    const Bool bUseFilteredPredictions=TComPrediction::filteringIntraReferenceSamples(compID, uiChFinalMode, uiWidth, uiHeight, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

    initIntraPatternChType( rTu, compID, bUseFilteredPredictions DEBUG_STRING_PASS_INTO(sDebug) );

    //===== get prediction signal =====
    predIntraAng( compID, uiChFinalMode, piOrg, uiStride, piPred, uiStride, rTu, bUseFilteredPredictions );

    // save prediction
    if( default0Save1Load2 == 1 )
    {
      Pel*  pPred   = piPred;
      Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
      Int k = 0;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pPredBuf[ k ++ ] = pPred[ uiX ];
        }
        pPred += uiStride;
      }
    }
  }
#if !DEBUG_STRING
  else
  {
    // load prediction
    Pel*  pPred   = piPred;
    Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
    Int k = 0;
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pPred[ uiX ] = pPredBuf[ k ++ ];
      }
      pPred += uiStride;
    }
  }
#endif

  //===== get residual signal =====
  {
    // get residual
    Pel*  pOrg    = piOrg;
    Pel*  pPred   = piPred;
    Pel*  pResi   = piResi;

    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pResi[ uiX ] = pOrg[ uiX ] - pPred[ uiX ];
      }

      pOrg  += uiStride;
      pResi += uiStride;
      pPred += uiStride;
    }
  }

  if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
  {
    if (bUseCrossCPrediction)
    {
      if (xCalcCrossComponentPredictionAlpha( rTu, compID, lumaResidualForEstimate, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride ) == 0)
      {
        return;
      }
      TComTrQuant::crossComponentPrediction ( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, false );
    }
    else if (isLuma(compID) && !bUseReconstructedResidualForEstimate)
    {
      xStoreCrossComponentPredictionResult( encoderLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
    }
  }

  //===== transform and quantization =====
  //--- init rate estimation arrays for RDOQ ---
  if( useTransformSkip ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ() )
  {
    m_pcEntropyCoder->estimateBit( m_pcTrQuant->m_pcEstBitsSbac, uiWidth, uiHeight, chType );
  }

  //--- transform and quantization ---
  TCoeff uiAbsSum = 0;
  if (bIsLuma)
  {
    pcCU       ->setTrIdxSubParts ( uiTrDepth, uiAbsPartIdx, uiFullDepth );
  }

  const QpParam cQP(*pcCU, compID);

#if RDOQ_CHROMA_LAMBDA
  m_pcTrQuant->selectLambda     (compID);
#endif

  m_pcTrQuant->transformNxN     ( rTu, compID, piResi, uiStride, pcCoeff,
#if ADAPTIVE_QP_SELECTION
    pcArlCoeff,
#endif
    uiAbsSum, cQP
    );

  //--- inverse transform ---

#if DEBUG_STRING
  if ( (uiAbsSum > 0) || (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask) )
#else
  if ( uiAbsSum > 0 )
#endif
  {
    m_pcTrQuant->invTransformNxN ( rTu, compID, piResi, uiStride, pcCoeff, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sDebug, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );
  }
  else
  {
    Pel* pResi = piResi;
    memset( pcCoeff, 0, sizeof( TCoeff ) * uiWidth * uiHeight );
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      memset( pResi, 0, sizeof( Pel ) * uiWidth );
      pResi += uiStride;
    }
  }


  //===== reconstruction =====
  {
    Pel* pPred      = piPred;
    Pel* pResi      = piResi;
    Pel* pReco      = piReco;
    Pel* pRecQt     = piRecQt;
    Pel* pRecIPred  = piRecIPred;

    if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
    {
      if (bUseCrossCPrediction)
      {
        TComTrQuant::crossComponentPrediction( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, true );
      }
      else if (isLuma(compID))
      {
        xStoreCrossComponentPredictionResult( reconstructedLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
      }
    }

 #if DEBUG_STRING
    std::stringstream ss(stringstream::out);
    const Bool bDebugPred=((DebugOptionList::DebugString_Pred.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugResi=((DebugOptionList::DebugString_Resi.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugReco=((DebugOptionList::DebugString_Reco.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));

    if (bDebugPred || bDebugResi || bDebugReco)
    {
      ss << "###: " << "CompID: " << compID << " pred mode (ch/fin): " << uiChPredMode << "/" << uiChFinalMode << " absPartIdx: " << rTu.GetAbsPartIdxTU() << "\n";
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        ss << "###: ";
        if (bDebugPred)
        {
          ss << " - pred: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pPred[ uiX ] << ", ";
          }
        }
        if (bDebugResi)
        {
          ss << " - resi: ";
        }
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          if (bDebugResi)
          {
            ss << pResi[ uiX ] << ", ";
          }
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        if (bDebugReco)
        {
          ss << " - reco: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pReco[ uiX ] << ", ";
          }
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
        ss << "\n";
      }
      DEBUG_STRING_APPEND(sDebug, ss.str())
    }
    else
#endif
    {

      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }

  //===== update distortion =====
  ruiDist += m_pcRdCost->getDistPart( bitDepth, piReco, uiStride, piOrg, uiStride, uiWidth, uiHeight, compID );
}




Void
TEncSearch::xRecurIntraCodingLumaQT(TComYuv*    pcOrgYuv,
                                    TComYuv*    pcPredYuv,
                                    TComYuv*    pcResiYuv,
                                    Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                    Distortion& ruiDistY,
#if HHI_RQT_INTRA_SPEEDUP
                                    Bool        bCheckFirst,
#endif
                                    Double&     dRDCost,
                                    TComTU&     rTu
                                    DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU   *pcCU          = rTu.getCU();
  const UInt    uiAbsPartIdx  = rTu.GetAbsPartIdxTU();
  const UInt    uiFullDepth   = rTu.GetTransformDepthTotal();
  const UInt    uiTrDepth     = rTu.GetTransformDepthRel();
  const UInt    uiLog2TrSize  = rTu.GetLog2LumaTrSize();
        Bool    bCheckFull    = ( uiLog2TrSize  <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
        Bool    bCheckSplit   = ( uiLog2TrSize  >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

        Pel     resiLumaSplit [NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];
        Pel     resiLumaSingle[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

#if HHI_RQT_INTRA_SPEEDUP
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // don't check split if TU size is less or equal to max TU size
  Bool noSplitIntraMaxTuSize = bCheckFull;
  if(m_pcEncCfg->getRDpenalty() && ! isIntraSlice)
  {
    // in addition don't check split if TU size is less or equal to 16x16 TU size for non-intra slice
    noSplitIntraMaxTuSize = ( uiLog2TrSize  <= min(maxTuSize,4) );

    // if maximum RD-penalty don't check TU size 32x32
    if(m_pcEncCfg->getRDpenalty()==2)
    {
      bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
    }
  }
  if( bCheckFirst && noSplitIntraMaxTuSize )

  {
    bCheckSplit = false;
  }
#else
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // if maximum RD-penalty don't check TU size 32x32
  if((m_pcEncCfg->getRDpenalty()==2)  && !isIntraSlice)
  {
    bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
  }
#endif
  Double     dSingleCost                        = MAX_DOUBLE;
  Distortion uiSingleDistLuma                   = 0;
  UInt       uiSingleCbfLuma                    = 0;
  Bool       checkTransformSkip  = pcCU->getSlice()->getPPS()->getUseTransformSkip();
  Int        bestModeId[MAX_NUM_COMPONENT] = { 0, 0, 0};
  checkTransformSkip           &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());
  checkTransformSkip           &= (!pcCU->getCUTransquantBypass(0));

  assert (rTu.ProcessComponentSection(COMPONENT_Y));
  const UInt totalAdjustedDepthChan   = rTu.GetTransformDepthTotalAdj(COMPONENT_Y);

  if ( m_pcEncCfg->getUseTransformSkipFast() )
  {
    checkTransformSkip       &= (pcCU->getPartitionSize(uiAbsPartIdx)==SIZE_NxN);
  }

  if( bCheckFull )
  {
    if(checkTransformSkip == true)
    {
      //----- store original entropy coding status -----
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );

      Distortion singleDistTmpLuma                    = 0;
      UInt       singleCbfTmpLuma                     = 0;
      Double     singleCostTmp                        = 0;
      Int        firstCheckId                         = 0;

      for(Int modeId = firstCheckId; modeId < 2; modeId ++)
      {
        DEBUG_STRING_NEW(sModeString)
        Int  default0Save1Load2 = 0;
        singleDistTmpLuma=0;
        if(modeId == firstCheckId)
        {
          default0Save1Load2 = 1;
        }
        else
        {
          default0Save1Load2 = 2;
        }


        pcCU->setTransformSkipSubParts ( modeId, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
        xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, singleDistTmpLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sModeString), default0Save1Load2 );

        singleCbfTmpLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );

        //----- determine rate and r-d cost -----
        if(modeId == 1 && singleCbfTmpLuma == 0)
        {
          //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
          singleCostTmp = MAX_DOUBLE;
        }
        else
        {
          UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );
          singleCostTmp     = m_pcRdCost->calcRdCost( uiSingleBits, singleDistTmpLuma );
        }
        if(singleCostTmp < dSingleCost)
        {
          DEBUG_STRING_SWAP(sDebug, sModeString)
          dSingleCost   = singleCostTmp;
          uiSingleDistLuma = singleDistTmpLuma;
          uiSingleCbfLuma = singleCbfTmpLuma;

          bestModeId[COMPONENT_Y] = modeId;
          if(bestModeId[COMPONENT_Y] == firstCheckId)
          {
            xStoreIntraResultQT(COMPONENT_Y, rTu );
            m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
          }

          if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
          {
            const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
            const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
            for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
            {
              if (bMaintainResidual[storedResidualIndex])
              {
                xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
              }
            }
          }
        }
        if (modeId == firstCheckId)
        {
          m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
        }
      }

      pcCU ->setTransformSkipSubParts ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

      if(bestModeId[COMPONENT_Y] == firstCheckId)
      {
        xLoadIntraResultQT(COMPONENT_Y, rTu );
        pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, rTu.GetTransformDepthTotalAdj(COMPONENT_Y) );

        m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
      }
    }
    else
    {
      //----- store original entropy coding status -----
      if( bCheckSplit )
      {
        m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
      }
      //----- code luma/chroma block with given intra prediction mode and store Cbf-----
      dSingleCost   = 0.0;

      pcCU ->setTransformSkipSubParts ( 0, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
      xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, uiSingleDistLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sDebug));

      if( bCheckSplit )
      {
        uiSingleCbfLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );
      }
      //----- determine rate and r-d cost -----
      UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );

      if(m_pcEncCfg->getRDpenalty() && (uiLog2TrSize==5) && !isIntraSlice)
      {
        uiSingleBits=uiSingleBits*4;
      }

      dSingleCost       = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDistLuma );

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }
    }
  }

  if( bCheckSplit )
  {
    //----- store full entropy coding status, load original entropy coding status -----
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    else
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    //----- code splitted block -----
    Double     dSplitCost      = 0.0;
    Distortion uiSplitDistLuma = 0;
    UInt       uiSplitCbfLuma  = 0;

    TComTURecurse tuRecurseChild(rTu, false);
    DEBUG_STRING_NEW(sSplit)
    do
    {
      DEBUG_STRING_NEW(sChild)
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, bCheckFirst, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#endif
      DEBUG_STRING_APPEND(sSplit, sChild)
      uiSplitCbfLuma |= pcCU->getCbf( tuRecurseChild.GetAbsPartIdxTU(), COMPONENT_Y, tuRecurseChild.GetTransformDepthRel() );
    } while (tuRecurseChild.nextSection(rTu) );

    UInt    uiPartsDiv     = rTu.GetAbsPartIdxNumParts();
    {
      if (uiSplitCbfLuma)
      {
        const UInt flag=1<<uiTrDepth;
        UChar *pBase=pcCU->getCbf( COMPONENT_Y );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
    //----- restore context states -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    
    //----- determine rate and r-d cost -----
    UInt uiSplitBits = xGetIntraBitsQT( rTu, true, false, false );
    dSplitCost       = m_pcRdCost->calcRdCost( uiSplitBits, uiSplitDistLuma );

    //===== compare and set best =====
    if( dSplitCost < dSingleCost )
    {
      //--- update cost ---
      DEBUG_STRING_SWAP(sSplit, sDebug)
      ruiDistY += uiSplitDistLuma;
      dRDCost  += dSplitCost;

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSplit[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }

      return;
    }

    //----- set entropy coding status -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );

    //--- set transform index and Cbf values ---
    pcCU->setTrIdxSubParts( uiTrDepth, uiAbsPartIdx, uiFullDepth );
    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
    pcCU ->setTransformSkipSubParts  ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

    //--- set reconstruction for next intra prediction blocks ---
    const UInt  uiQTLayer   = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt  uiZOrder    = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
    const UInt  uiWidth     = tuRect.width;
    const UInt  uiHeight    = tuRect.height;
    Pel*  piSrc       = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( COMPONENT_Y, uiAbsPartIdx );
    UInt  uiSrcStride = m_pcQTTempTComYuv[ uiQTLayer ].getStride  ( COMPONENT_Y );
    Pel*  piDes       = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
    UInt  uiDesStride = pcCU->getPic()->getPicYuvRec()->getStride  ( COMPONENT_Y );

    for( UInt uiY = 0; uiY < uiHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        piDes[ uiX ] = piSrc[ uiX ];
      }
    }
  }
  ruiDistY += uiSingleDistLuma;
  dRDCost  += dSingleCost;
}


Void
TEncSearch::xSetIntraResultLumaQT(TComYuv* pcRecoYuv, TComTU &rTu)
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiTrDepth    = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====

    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    const UInt coeffOffset = rTu.getCoefficientOffset(COMPONENT_Y);
    const UInt numCoeffInBlock = tuRect.width * tuRect.height;

    if (numCoeffInBlock!=0)
    {
      const TCoeff* srcCoeff = m_ppcQTTempCoeff[COMPONENT_Y][uiQTLayer] + coeffOffset;
      TCoeff* destCoeff      = pcCU->getCoeff(COMPONENT_Y) + coeffOffset;
      ::memcpy( destCoeff, srcCoeff, sizeof(TCoeff)*numCoeffInBlock );
#if ADAPTIVE_QP_SELECTION
      const TCoeff* srcArlCoeff = m_ppcQTTempArlCoeff[COMPONENT_Y][ uiQTLayer ] + coeffOffset;
      TCoeff* destArlCoeff      = pcCU->getArlCoeff (COMPONENT_Y)               + coeffOffset;
      ::memcpy( destArlCoeff, srcArlCoeff, sizeof( TCoeff ) * numCoeffInBlock );
#endif
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Y, pcRecoYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }

  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultLumaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}


Void
TEncSearch::xStoreIntraResultQT(const ComponentID compID, TComTU &rTu )
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff    = tuRect.width * tuRect.height;
      TCoeff* pcCoeffSrc = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffDst = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffDst = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( compID, &m_pcQTTempTransformSkipTComYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }
  }
}


Void
TEncSearch::xLoadIntraResultQT(const ComponentID compID, TComTU &rTu)
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt uiZOrder     = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff = tuRect.width * tuRect.height;
      TCoeff* pcCoeffDst = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffSrc = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffDst = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffSrc = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTransformSkipTComYuv.copyPartToPartComponent( compID, &m_pcQTTempTComYuv[ uiQTLayer ], uiAbsPartIdx, tuRect.width, tuRect.height );

      Pel*    piRecIPred        = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
      UInt    uiRecIPredStride  = pcCU->getPic()->getPicYuvRec()->getStride (compID);
      Pel*    piRecQt           = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
      UInt    uiRecQtStride     = m_pcQTTempTComYuv[ uiQTLayer ].getStride  (compID);
      UInt    uiWidth           = tuRect.width;
      UInt    uiHeight          = tuRect.height;
      Pel* pRecQt               = piRecQt;
      Pel* pRecIPred            = piRecIPred;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pRecIPred[ uiX ] = pRecQt   [ uiX ];
        }
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }
}

Void
TEncSearch::xStoreCrossComponentPredictionResult(       Pel    *pResiDst,
                                                  const Pel    *pResiSrc,
                                                        TComTU &rTu,
                                                  const Int     xOffset,
                                                  const Int     yOffset,
                                                  const Int     strideDst,
                                                  const Int     strideSrc )
{
  const Pel *pSrc = pResiSrc + yOffset * strideSrc + xOffset;
        Pel *pDst = pResiDst + yOffset * strideDst + xOffset;

  for( Int y = 0; y < rTu.getRect( COMPONENT_Y ).height; y++ )
  {
    ::memcpy( pDst, pSrc, sizeof(Pel) * rTu.getRect( COMPONENT_Y ).width );
    pDst += strideDst;
    pSrc += strideSrc;
  }
}

SChar
TEncSearch::xCalcCrossComponentPredictionAlpha(       TComTU &rTu,
                                                const ComponentID compID,
                                                const Pel*        piResiL,
                                                const Pel*        piResiC,
                                                const Int         width,
                                                const Int         height,
                                                const Int         strideL,
                                                const Int         strideC )
{
  const Pel *pResiL = piResiL;
  const Pel *pResiC = piResiC;

        TComDataCU *pCU = rTu.getCU();
  const Int  absPartIdx = rTu.GetAbsPartIdxTU( compID );
  const Int diffBitDepth = pCU->getSlice()->getSPS()->getDifferentialLumaChromaBitDepth();

  SChar alpha = 0;
  Int SSxy  = 0;
  Int SSxx  = 0;

  for( UInt uiY = 0; uiY < height; uiY++ )
  {
    for( UInt uiX = 0; uiX < width; uiX++ )
    {
      const Pel scaledResiL = rightShift( pResiL[ uiX ], diffBitDepth );
      SSxy += ( scaledResiL * pResiC[ uiX ] );
      SSxx += ( scaledResiL * scaledResiL   );
    }

    pResiL += strideL;
    pResiC += strideC;
  }

  if( SSxx != 0 )
  {
    Double dAlpha = SSxy / Double( SSxx );
    alpha = SChar(Clip3<Int>(-16, 16, (Int)(dAlpha * 16)));

    static const SChar alphaQuant[17] = {0, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8};

    alpha = (alpha < 0) ? -alphaQuant[Int(-alpha)] : alphaQuant[Int(alpha)];
  }
  pCU->setCrossComponentPredictionAlphaPartRange( alpha, compID, absPartIdx, rTu.GetAbsPartIdxNumParts( compID ) );

  return alpha;
}

Void
TEncSearch::xRecurIntraChromaCodingQT(TComYuv*    pcOrgYuv,
                                      TComYuv*    pcPredYuv,
                                      TComYuv*    pcResiYuv,
                                      Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      Distortion& ruiDist,
                                      TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU         *pcCU                  = rTu.getCU();
  const UInt          uiTrDepth             = rTu.GetTransformDepthRel();
  const UInt          uiAbsPartIdx          = rTu.GetAbsPartIdxTU();
  const ChromaFormat  format                = rTu.GetChromaFormat();
  UInt                uiTrMode              = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt          numberValidComponents = getNumberValidComponents(format);

  if(  uiTrMode == uiTrDepth )
  {
    if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      return;
    }

    const UInt uiFullDepth = rTu.GetTransformDepthTotal();

    Bool checkTransformSkip = pcCU->getSlice()->getPPS()->getUseTransformSkip();
    checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Cb), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

    if ( m_pcEncCfg->getUseTransformSkipFast() )
    {
      checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

      if (checkTransformSkip)
      {
        Int nbLumaSkip = 0;
        const UInt maxAbsPartIdxSub=uiAbsPartIdx + (rTu.ProcessingAllQuadrants(COMPONENT_Cb)?1:4);
        for(UInt absPartIdxSub = uiAbsPartIdx; absPartIdxSub < maxAbsPartIdxSub; absPartIdxSub ++)
        {
          nbLumaSkip += pcCU->getTransformSkip(absPartIdxSub, COMPONENT_Y);
        }
        checkTransformSkip &= (nbLumaSkip > 0);
      }
    }


    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      DEBUG_STRING_NEW(sDebugBestMode)

      //use RDO to decide whether Cr/Cb takes TS
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[uiFullDepth][CI_QT_TRAFO_ROOT] );

      const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

      TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

      const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

      do
      {
        const UInt subTUAbsPartIdx   = TUIterator.GetAbsPartIdxTU(compID);

        Double     dSingleCost               = MAX_DOUBLE;
        Int        bestModeId                = 0;
        Distortion singleDistC               = 0;
        UInt       singleCbfC                = 0;
        Distortion singleDistCTmp            = 0;
        Double     singleCostTmp             = 0;
        UInt       singleCbfCTmp             = 0;
        SChar      bestCrossCPredictionAlpha = 0;
        Int        bestTransformSkipMode     = 0;

        const Bool checkCrossComponentPrediction =    (pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, subTUAbsPartIdx) == DM_CHROMA_IDX)
                                                   &&  pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                   && (pcCU->getCbf(subTUAbsPartIdx,  COMPONENT_Y, uiTrDepth) != 0);

        const Int  crossCPredictionModesToTest = checkCrossComponentPrediction ? 2 : 1;
        const Int  transformSkipModesToTest    = checkTransformSkip            ? 2 : 1;
        const Int  totalModesToTest            = crossCPredictionModesToTest * transformSkipModesToTest;
              Int  currModeId                  = 0;
              Int  default0Save1Load2          = 0;

        for(Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
        {
          for(Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
          {
            pcCU->setCrossComponentPredictionAlphaPartRange(0, compID, subTUAbsPartIdx, partIdxesPerSubTU);
            DEBUG_STRING_NEW(sDebugMode)
            pcCU->setTransformSkipPartRange( transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU );
            currModeId++;

            const Bool isOneMode  = (totalModesToTest == 1);
            const Bool isLastMode = (currModeId == totalModesToTest); // currModeId is indexed from 1

            if (isOneMode)
            {
              default0Save1Load2 = 0;
            }
            else if (!isOneMode && (transformSkipModeId == 0) && (crossCPredictionModeId == 0))
            {
              default0Save1Load2 = 1; //save prediction on first mode
            }
            else
            {
              default0Save1Load2 = 2; //load it on subsequent modes
            }

            singleDistCTmp = 0;

            xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, (crossCPredictionModeId != 0), singleDistCTmp, compID, TUIterator DEBUG_STRING_PASS_INTO(sDebugMode), default0Save1Load2);
            singleCbfCTmp = pcCU->getCbf( subTUAbsPartIdx, compID, uiTrDepth);

            if (  ((crossCPredictionModeId == 1) && (pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) == 0))
               || ((transformSkipModeId    == 1) && (singleCbfCTmp == 0))) //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
            {
              singleCostTmp = MAX_DOUBLE;
            }
            else if (!isOneMode)
            {
              UInt bitsTmp = xGetIntraBitsQTChroma( TUIterator, compID, false );
              singleCostTmp  = m_pcRdCost->calcRdCost( bitsTmp, singleDistCTmp);
            }

            if(singleCostTmp < dSingleCost)
            {
              DEBUG_STRING_SWAP(sDebugBestMode, sDebugMode)
              dSingleCost               = singleCostTmp;
              singleDistC               = singleDistCTmp;
              bestCrossCPredictionAlpha = (crossCPredictionModeId != 0) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;
              bestTransformSkipMode     = transformSkipModeId;
              bestModeId                = currModeId;
              singleCbfC                = singleCbfCTmp;

              if (!isOneMode && !isLastMode)
              {
                xStoreIntraResultQT(compID, TUIterator);
                m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
              }
            }

            if (!isOneMode && !isLastMode)
            {
              m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
            }
          }
        }

        if(bestModeId < totalModesToTest)
        {
          xLoadIntraResultQT(compID, TUIterator);
          pcCU->setCbfPartRange( singleCbfC << uiTrDepth, compID, subTUAbsPartIdx, partIdxesPerSubTU );

          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
        }

        DEBUG_STRING_APPEND(sDebug, sDebugBestMode)
        pcCU ->setTransformSkipPartRange                ( bestTransformSkipMode,     compID, subTUAbsPartIdx, partIdxesPerSubTU );
        pcCU ->setCrossComponentPredictionAlphaPartRange( bestCrossCPredictionAlpha, compID, subTUAbsPartIdx, partIdxesPerSubTU );
        ruiDist += singleDistC;
      } while (TUIterator.nextSection(rTu));

      if (splitIntoSubTUs)
      {
        offsetSubTUCBFs(rTu, compID);
      }
    }
  }
  else
  {
    UInt    uiSplitCbf[MAX_NUM_COMPONENT] = {0,0,0};

    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiTrDepthChild   = tuRecurseChild.GetTransformDepthRel();
    do
    {
      DEBUG_STRING_NEW(sChild)

      xRecurIntraChromaCodingQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, ruiDist, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );

      DEBUG_STRING_APPEND(sDebug, sChild)
      const UInt uiAbsPartIdxSub=tuRecurseChild.GetAbsPartIdxTU();

      for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
      {
        uiSplitCbf[ch] |= pcCU->getCbf( uiAbsPartIdxSub, ComponentID(ch), uiTrDepthChild );
      }
    } while ( tuRecurseChild.nextSection(rTu) );


    UInt uiPartsDiv = rTu.GetAbsPartIdxNumParts();
    for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      if (uiSplitCbf[ch])
      {
        const UInt flag=1<<uiTrDepth;
        ComponentID compID=ComponentID(ch);
        UChar *pBase=pcCU->getCbf( compID );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
  }
}




Void
TEncSearch::xSetIntraResultChromaQT(TComYuv*    pcRecoYuv, TComTU &rTu)
{
  if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
  {
    return;
  }
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth   = rTu.GetTransformDepthRel();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====
    const TComRectangle &tuRectCb=rTu.getRect(COMPONENT_Cb);
    UInt uiNumCoeffC    = tuRectCb.width*tuRectCb.height;//( pcCU->getSlice()->getSPS()->getMaxCUWidth() * pcCU->getSlice()->getSPS()->getMaxCUHeight() ) >> ( uiFullDepth << 1 );
    const UInt offset = rTu.getCoefficientOffset(COMPONENT_Cb);

    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID component = ComponentID(ch);
      const TCoeff* src           = m_ppcQTTempCoeff[component][uiQTLayer] + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      TCoeff* dest                = pcCU->getCoeff(component) + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      ::memcpy( dest, src, sizeof(TCoeff)*uiNumCoeffC );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[component][ uiQTLayer ] + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      TCoeff* pcArlCoeffDst = pcCU->getArlCoeff(component)                + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeffC );
#endif
    }

    //===== copy reconstruction =====

    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cb, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cr, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultChromaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}



Void
TEncSearch::estIntraPredLumaQT(TComDataCU* pcCU,
                               TComYuv*    pcOrgYuv,
                               TComYuv*    pcPredYuv,
                               TComYuv*    pcResiYuv,
                               TComYuv*    pcRecoYuv,
                               Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                               DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt         uiDepth               = pcCU->getDepth(0);
  const UInt         uiInitTrDepth         = pcCU->getPartitionSize(0) == SIZE_2Nx2N ? 0 : 1;
  const UInt         uiNumPU               = 1<<(2*uiInitTrDepth);
  const UInt         uiQNumParts           = pcCU->getTotalNumPart() >> 2;
  const UInt         uiWidthBit            = pcCU->getIntraSizeIdx(0);
  const ChromaFormat chFmt                 = pcCU->getPic()->getChromaFormat();
  const UInt         numberValidComponents = getNumberValidComponents(chFmt);
  const TComSPS     &sps                   = *(pcCU->getSlice()->getSPS());
  const TComPPS     &pps                   = *(pcCU->getSlice()->getPPS());
        Distortion   uiOverallDistY        = 0;
        UInt         CandNum;
        Double       CandCostList[ FAST_UDI_MAX_RDMODE_NUM ];
        Pel          resiLumaPU[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

  // Lambda calculation at equivalent Qp of 4 is recommended because at that Qp, the quantisation divisor is 1.
#if FULL_NBIT
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#else
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12 - 6 * (sps.getBitDepth(CHANNEL_TYPE_LUMA) - 8)) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#endif

  //===== set QP and clear Cbf =====
  if ( pps.getUseDQP() == true)
  {
    pcCU->setQPSubParts( pcCU->getQP(0), 0, uiDepth );
  }
  else
  {
    pcCU->setQPSubParts( pcCU->getSlice()->getSliceQp(), 0, uiDepth );
  }

  //===== loop over partitions =====
  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);

  do
  {
    const UInt uiPartOffset=tuRecurseWithPU.GetAbsPartIdxTU();
//  for( UInt uiPU = 0, uiPartOffset=0; uiPU < uiNumPU; uiPU++, uiPartOffset += uiQNumParts )
  //{
    //===== init pattern for luma prediction =====
    DEBUG_STRING_NEW(sTemp2)

    //===== determine set of modes to be tested (using prediction signal only) =====
    Int numModesAvailable     = 35; //total number of Intra modes
    UInt uiRdModeList[FAST_UDI_MAX_RDMODE_NUM];
    Int numModesForFullRD = m_pcEncCfg->getFastUDIUseMPMEnabled()?g_aucIntraModeNumFast_UseMPM[ uiWidthBit ] : g_aucIntraModeNumFast_NotUseMPM[ uiWidthBit ];

    // this should always be true
    assert (tuRecurseWithPU.ProcessComponentSection(COMPONENT_Y));
    initIntraPatternChType( tuRecurseWithPU, COMPONENT_Y, true DEBUG_STRING_PASS_INTO(sTemp2) );

    Bool doFastSearch = (numModesForFullRD != numModesAvailable);
    if (doFastSearch)
    {
      assert(numModesForFullRD < numModesAvailable);

      for( Int i=0; i < numModesForFullRD; i++ )
      {
        CandCostList[ i ] = MAX_DOUBLE;
      }
      CandNum = 0;

      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt uiAbsPartIdx=tuRecurseWithPU.GetAbsPartIdxTU();

      Pel* piOrg         = pcOrgYuv ->getAddr( COMPONENT_Y, uiAbsPartIdx );
      Pel* piPred        = pcPredYuv->getAddr( COMPONENT_Y, uiAbsPartIdx );
      UInt uiStride      = pcPredYuv->getStride( COMPONENT_Y );
      DistParam distParam;
      const Bool bUseHadamard=pcCU->getCUTransquantBypass(0) == 0;
      m_pcRdCost->setDistParam(distParam, sps.getBitDepth(CHANNEL_TYPE_LUMA), piOrg, uiStride, piPred, uiStride, puRect.width, puRect.height, bUseHadamard);
      distParam.bApplyWeight = false;
      for( Int modeIdx = 0; modeIdx < numModesAvailable; modeIdx++ )
      {
        UInt       uiMode = modeIdx;
        Distortion uiSad  = 0;

        const Bool bUseFilter=TComPrediction::filteringIntraReferenceSamples(COMPONENT_Y, uiMode, puRect.width, puRect.height, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

        predIntraAng( COMPONENT_Y, uiMode, piOrg, uiStride, piPred, uiStride, tuRecurseWithPU, bUseFilter, TComPrediction::UseDPCMForFirstPassIntraEstimation(tuRecurseWithPU, uiMode) );

        // use hadamard transform here
        uiSad+=distParam.DistFunc(&distParam);

        UInt   iModeBits = 0;

        // NB xModeBitsIntra will not affect the mode for chroma that may have already been pre-estimated.
        iModeBits+=xModeBitsIntra( pcCU, uiMode, uiPartOffset, uiDepth, CHANNEL_TYPE_LUMA );

        Double cost      = (Double)uiSad + (Double)iModeBits * sqrtLambdaForFirstPass;

#if DEBUG_INTRA_SEARCH_COSTS
        std::cout << "1st pass mode " << uiMode << " SAD = " << uiSad << ", mode bits = " << iModeBits << ", cost = " << cost << "\n";
#endif

        CandNum += xUpdateCandList( uiMode, cost, numModesForFullRD, uiRdModeList, CandCostList );
      }

      if (m_pcEncCfg->getFastUDIUseMPMEnabled())
      {
        Int uiPreds[NUM_MOST_PROBABLE_MODES] = {-1, -1, -1};

        Int iMode = -1;
        pcCU->getIntraDirPredictor( uiPartOffset, uiPreds, COMPONENT_Y, &iMode );

        const Int numCand = ( iMode >= 0 ) ? iMode : Int(NUM_MOST_PROBABLE_MODES);

        for( Int j=0; j < numCand; j++)
        {
          Bool mostProbableModeIncluded = false;
          Int mostProbableMode = uiPreds[j];

          for( Int i=0; i < numModesForFullRD; i++)
          {
            mostProbableModeIncluded |= (mostProbableMode == uiRdModeList[i]);
          }
          if (!mostProbableModeIncluded)
          {
            uiRdModeList[numModesForFullRD++] = mostProbableMode;
          }
        }
      }
    }
    else
    {
      for( Int i=0; i < numModesForFullRD; i++)
      {
        uiRdModeList[i] = i;
      }
    }

    //===== check modes (using r-d costs) =====
#if HHI_RQT_INTRA_SPEEDUP_MOD
    UInt   uiSecondBestMode  = MAX_UINT;
    Double dSecondBestPUCost = MAX_DOUBLE;
#endif
    DEBUG_STRING_NEW(sPU)
    UInt       uiBestPUMode  = 0;
    Distortion uiBestPUDistY = 0;
    Double     dBestPUCost   = MAX_DOUBLE;

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
    UInt max=numModesForFullRD;

    if (DebugOptionList::ForceLumaMode.isSet())
    {
      max=0;  // we are forcing a direction, so don't bother with mode check
    }
    for ( UInt uiMode = 0; uiMode < max; uiMode++)
#else
    for( UInt uiMode = 0; uiMode < numModesForFullRD; uiMode++ )
#endif
    {
      // set luma prediction mode
      UInt uiOrgMode = uiRdModeList[uiMode];

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );

      DEBUG_STRING_NEW(sMode)
      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, true, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#endif

#if DEBUG_INTRA_SEARCH_COSTS
      std::cout << "2nd pass [luma,chroma] mode [" << Int(pcCU->getIntraDir(CHANNEL_TYPE_LUMA, uiPartOffset)) << "," << Int(pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, uiPartOffset)) << "] cost = " << dPUCost << "\n";
#endif

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sMode)
#if HHI_RQT_INTRA_SPEEDUP_MOD
        uiSecondBestMode  = uiBestPUMode;
        dSecondBestPUCost = dBestPUCost;
#endif
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();

        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
#if HHI_RQT_INTRA_SPEEDUP_MOD
      else if( dPUCost < dSecondBestPUCost )
      {
        uiSecondBestMode  = uiOrgMode;
        dSecondBestPUCost = dPUCost;
      }
#endif
    } // Mode loop

#if HHI_RQT_INTRA_SPEEDUP
#if HHI_RQT_INTRA_SPEEDUP_MOD
    for( UInt ui =0; ui < 2; ++ui )
#endif
    {
#if HHI_RQT_INTRA_SPEEDUP_MOD
      UInt uiOrgMode   = ui ? uiSecondBestMode  : uiBestPUMode;
      if( uiOrgMode == MAX_UINT )
      {
        break;
      }
#else
      UInt uiOrgMode = uiBestPUMode;
#endif

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
      if (DebugOptionList::ForceLumaMode.isSet())
      {
        uiOrgMode = DebugOptionList::ForceLumaMode.getInt();
      }
#endif

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );
      DEBUG_STRING_NEW(sModeTree)

      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;

      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, false, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sModeTree));

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sModeTree)
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );

        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
    } // Mode loop
#endif

    DEBUG_STRING_APPEND(sDebug, sPU)

    //--- update overall distortion ---
    uiOverallDistY += uiBestPUDistY;

    //--- update transform index and cbf ---
    const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
    ::memcpy( pcCU->getTransformIdx()       + uiPartOffset, m_puhQTTempTrIdx,  uiQPartNum * sizeof( UChar ) );
    for (UInt component = 0; component < numberValidComponents; component++)
    {
      const ComponentID compID = ComponentID(component);
      ::memcpy( pcCU->getCbf( compID  ) + uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
      ::memcpy( pcCU->getTransformSkip( compID  ) + uiPartOffset, m_puhQTTempTransformSkipFlag[compID ], uiQPartNum * sizeof( UChar ) );
    }

    //--- set reconstruction for next intra prediction blocks ---
    if( !tuRecurseWithPU.IsLastSection() )
    {
      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt  uiCompWidth   = puRect.width;
      const UInt  uiCompHeight  = puRect.height;

      const UInt  uiZOrder      = pcCU->getZorderIdxInCtu() + uiPartOffset;
            Pel*  piDes         = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
      const UInt  uiDesStride   = pcCU->getPic()->getPicYuvRec()->getStride( COMPONENT_Y);
      const Pel*  piSrc         = pcRecoYuv->getAddr( COMPONENT_Y, uiPartOffset );
      const UInt  uiSrcStride   = pcRecoYuv->getStride( COMPONENT_Y);

      for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
      {
        for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
        {
          piDes[ uiX ] = piSrc[ uiX ];
        }
      }
    }

    //=== update PU data ====
    pcCU->setIntraDirSubParts     ( CHANNEL_TYPE_LUMA, uiBestPUMode, uiPartOffset, uiDepth + uiInitTrDepth );
	
  } while (tuRecurseWithPU.nextSection(tuRecurseCU));


  if( uiNumPU > 1 )
  { // set Cbf for all blocks
    UInt uiCombCbfY = 0;
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfY |= pcCU->getCbf( uiPartIdx, COMPONENT_Y,  1 );
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Y  )[ uiOffs ] |= uiCombCbfY;
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  //===== reset context models =====
  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  //===== set distortion (rate and r-d costs are determined later) =====
  pcCU->getTotalDistortion() = uiOverallDistY;
}




Void
TEncSearch::estIntraPredChromaQT(TComDataCU* pcCU,
                                 TComYuv*    pcOrgYuv,
                                 TComYuv*    pcPredYuv,
                                 TComYuv*    pcResiYuv,
                                 TComYuv*    pcRecoYuv,
                                 Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                                 DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt    uiInitTrDepth  = pcCU->getPartitionSize(0) != SIZE_2Nx2N && enable4ChromaPUsInIntraNxNCU(pcOrgYuv->getChromaFormat()) ? 1 : 0;

  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);
  const UInt    uiQNumParts    = tuRecurseWithPU.GetAbsPartIdxNumParts();
  const UInt    uiDepthCU=tuRecurseWithPU.getCUDepth();
  const UInt    numberValidComponents = pcCU->getPic()->getNumberValidComponents();

  do
  {
    UInt       uiBestMode  = 0;
    Distortion uiBestDist  = 0;
    Double     dBestCost   = MAX_DOUBLE;

    //----- init mode list -----
    if (tuRecurseWithPU.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      UInt uiModeList[FAST_UDI_MAX_RDMODE_NUM];
      const UInt  uiQPartNum     = uiQNumParts;
      const UInt  uiPartOffset   = tuRecurseWithPU.GetAbsPartIdxTU();
      {
        UInt  uiMinMode = 0;
        UInt  uiMaxMode = NUM_CHROMA_MODE;

        //----- check chroma modes -----
        pcCU->getAllowedChromaDir( uiPartOffset, uiModeList );

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
        if (DebugOptionList::ForceChromaMode.isSet())
        {
          uiMinMode=DebugOptionList::ForceChromaMode.getInt();
          if (uiModeList[uiMinMode]==34)
          {
            uiMinMode=4; // if the fixed mode has been renumbered because DM_CHROMA covers it, use DM_CHROMA.
          }
          uiMaxMode=uiMinMode+1;
        }
#endif

        DEBUG_STRING_NEW(sPU)

        for( UInt uiMode = uiMinMode; uiMode < uiMaxMode; uiMode++ )
        {
          //----- restore context models -----
          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          
          DEBUG_STRING_NEW(sMode)
          //----- chroma coding -----
          Distortion uiDist = 0;
          pcCU->setIntraDirSubParts  ( CHANNEL_TYPE_CHROMA, uiModeList[uiMode], uiPartOffset, uiDepthCU+uiInitTrDepth );
          xRecurIntraChromaCodingQT       ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );

          if( pcCU->getSlice()->getPPS()->getUseTransformSkip() )
          {
            m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          }

          UInt    uiBits = xGetIntraBitsQT( tuRecurseWithPU, false, true, false );
          Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );

          //----- compare -----
          if( dCost < dBestCost )
          {
            DEBUG_STRING_SWAP(sPU, sMode);
            dBestCost   = dCost;
            uiBestDist  = uiDist;
            uiBestMode  = uiModeList[uiMode];

            xSetIntraResultChromaQT( pcRecoYuv, tuRecurseWithPU );
            for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
            {
              const ComponentID compID = ComponentID(componentIndex);
              ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_puhQTTempTransformSkipFlag[compID], pcCU->getTransformSkip( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_phQTTempCrossComponentPredictionAlpha[compID], pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, uiQPartNum * sizeof( SChar ) );
            }
          }
        }

        DEBUG_STRING_APPEND(sDebug, sPU)

        //----- set data -----
        for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
        {
          const ComponentID compID = ComponentID(componentIndex);
          ::memcpy( pcCU->getCbf( compID )+uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getTransformSkip( compID )+uiPartOffset, m_puhQTTempTransformSkipFlag[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, m_phQTTempCrossComponentPredictionAlpha[compID], uiQPartNum * sizeof( SChar ) );
        }
      }

      if( ! tuRecurseWithPU.IsLastSection() )
      {
        for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
        {
          const ComponentID compID    = ComponentID(ch);
          const TComRectangle &tuRect = tuRecurseWithPU.getRect(compID);
          const UInt  uiCompWidth     = tuRect.width;
          const UInt  uiCompHeight    = tuRect.height;
          const UInt  uiZOrder        = pcCU->getZorderIdxInCtu() + tuRecurseWithPU.GetAbsPartIdxTU();
                Pel*  piDes           = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
          const UInt  uiDesStride     = pcCU->getPic()->getPicYuvRec()->getStride( compID);
          const Pel*  piSrc           = pcRecoYuv->getAddr( compID, uiPartOffset );
          const UInt  uiSrcStride     = pcRecoYuv->getStride( compID);

          for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
          {
            for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
            {
              piDes[ uiX ] = piSrc[ uiX ];
            }
          }
        }
      }

      pcCU->setIntraDirSubParts( CHANNEL_TYPE_CHROMA, uiBestMode, uiPartOffset, uiDepthCU+uiInitTrDepth );
      pcCU->getTotalDistortion      () += uiBestDist;
    }

  } while (tuRecurseWithPU.nextSection(tuRecurseCU));

  //----- restore context models -----

  if( uiInitTrDepth != 0 )
  { // set Cbf for all blocks
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
}




/** Function for encoding and reconstructing luma/chroma samples of a PCM mode CU.
 * \param pcCU pointer to current CU
 * \param uiAbsPartIdx part index
 * \param pOrg pointer to original sample arrays
 * \param pPCM pointer to PCM code arrays
 * \param pPred pointer to prediction signal arrays
 * \param pResi pointer to residual signal arrays
 * \param pReco pointer to reconstructed sample arrays
 * \param uiStride stride of the original/prediction/residual sample arrays
 * \param uiWidth block width
 * \param uiHeight block height
 * \param compID texture component type
 */
Void TEncSearch::xEncPCM (TComDataCU* pcCU, UInt uiAbsPartIdx, Pel* pOrg, Pel* pPCM, Pel* pPred, Pel* pResi, Pel* pReco, UInt uiStride, UInt uiWidth, UInt uiHeight, const ComponentID compID )
{
  const UInt uiReconStride   = pcCU->getPic()->getPicYuvRec()->getStride(compID);
  const UInt uiPCMBitDepth   = pcCU->getSlice()->getSPS()->getPCMBitDepth(toChannelType(compID));
  const Int  channelBitDepth = pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
  Pel* pRecoPic = pcCU->getPic()->getPicYuvRec()->getAddr(compID, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu()+uiAbsPartIdx);

  const Int pcmShiftRight=(channelBitDepth - Int(uiPCMBitDepth));

  assert(pcmShiftRight >= 0);

  for( UInt uiY = 0; uiY < uiHeight; uiY++ )
  {
    for( UInt uiX = 0; uiX < uiWidth; uiX++ )
    {
      // Reset pred and residual
      pPred[uiX] = 0;
      pResi[uiX] = 0;
      // Encode
      pPCM[uiX] = (pOrg[uiX]>>pcmShiftRight);
      // Reconstruction
      pReco   [uiX] = (pPCM[uiX]<<(pcmShiftRight));
      pRecoPic[uiX] = pReco[uiX];
    }
    pPred += uiStride;
    pResi += uiStride;
    pPCM += uiWidth;
    pOrg += uiStride;
    pReco += uiStride;
    pRecoPic += uiReconStride;
  }
}


//!  Function for PCM mode estimation.
Void TEncSearch::IPCMSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv )
{
  UInt              uiDepth      = pcCU->getDepth(0);
  const Distortion  uiDistortion = 0;
  UInt              uiBits;

  Double dCost;

  for (UInt ch=0; ch < pcCU->getPic()->getNumberValidComponents(); ch++)
  {
    const ComponentID compID  = ComponentID(ch);
    const UInt width  = pcCU->getWidth(0)  >> pcCU->getPic()->getComponentScaleX(compID);
    const UInt height = pcCU->getHeight(0) >> pcCU->getPic()->getComponentScaleY(compID);
    const UInt stride = pcPredYuv->getStride(compID);

    Pel * pOrig    = pcOrgYuv->getAddr  (compID, 0, width);
    Pel * pResi    = pcResiYuv->getAddr(compID, 0, width);
    Pel * pPred    = pcPredYuv->getAddr(compID, 0, width);
    Pel * pReco    = pcRecoYuv->getAddr(compID, 0, width);
    Pel * pPCM     = pcCU->getPCMSample (compID);

    xEncPCM ( pcCU, 0, pOrig, pPCM, pPred, pResi, pReco, stride, width, height, compID );

  }

  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiDepth, 0, true, false);
  uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  dCost = m_pcRdCost->calcRdCost( uiBits, uiDistortion );

  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  pcCU->getTotalBits()       = uiBits;
  pcCU->getTotalCost()       = dCost;
  pcCU->getTotalDistortion() = uiDistortion;

  pcCU->copyToPic(uiDepth);
}




Void TEncSearch::xGetInterPredictionError( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, Distortion& ruiErr, Bool /*bHadamard*/ )
{
  motionCompensation( pcCU, &m_tmpYuvPred, REF_PIC_LIST_X, iPartIdx );

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;
  pcCU->getPartIndexAndSize( iPartIdx, uiAbsPartIdx, iWidth, iHeight );

  DistParam cDistParam;

  cDistParam.bApplyWeight = false;


  m_pcRdCost->setDistParam( cDistParam, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA),
                            pcYuvOrg->getAddr( COMPONENT_Y, uiAbsPartIdx ), pcYuvOrg->getStride(COMPONENT_Y),
                            m_tmpYuvPred .getAddr( COMPONENT_Y, uiAbsPartIdx ), m_tmpYuvPred.getStride(COMPONENT_Y),
                            iWidth, iHeight, m_pcEncCfg->getUseHADME() && (pcCU->getCUTransquantBypass(iPartIdx) == 0) );

  ruiErr = cDistParam.DistFunc( &cDistParam );
}

//! estimation of best merge coding
Void TEncSearch::xMergeEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPUIdx, UInt& uiInterDir, TComMvField* pacMvField, UInt& uiMergeIndex, Distortion& ruiCost, TComMvField* cMvFieldNeighbours, UChar* uhInterDirNeighbours, Int& numValidMergeCand )
{

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;

 
  pcCU->getPartIndexAndSize( iPUIdx, uiAbsPartIdx, iWidth, iHeight );
  UInt uiDepth = pcCU->getDepth( uiAbsPartIdx );

  PartSize partSize = pcCU->getPartitionSize( 0 );
  if ( pcCU->getSlice()->getPPS()->getLog2ParallelMergeLevelMinus2() && partSize != SIZE_2Nx2N && pcCU->getWidth( 0 ) <= 8 )
  {
    if ( iPUIdx == 0 )
    {
      pcCU->setPartSizeSubParts( SIZE_2Nx2N, 0, uiDepth ); // temporarily set
      pcCU->getInterMergeCandidates( 0, 0, cMvFieldNeighbours,uhInterDirNeighbours, numValidMergeCand );
      pcCU->setPartSizeSubParts( partSize, 0, uiDepth ); // restore
    }
  }
  else
  {
    pcCU->getInterMergeCandidates( uiAbsPartIdx, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );
  }

  xRestrictBipredMergeCand( pcCU, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );

  ruiCost = std::numeric_limits<Distortion>::max();
  for( UInt uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )
  {
    Distortion uiCostCand = std::numeric_limits<Distortion>::max();
    UInt       uiBitsCand = 0;

    PartSize ePartSize = pcCU->getPartitionSize( 0 );

    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( cMvFieldNeighbours[0 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( cMvFieldNeighbours[1 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );

    xGetInterPredictionError( pcCU, pcYuvOrg, iPUIdx, uiCostCand, m_pcEncCfg->getUseHADME() );
    uiBitsCand = uiMergeCand + 1;
    if (uiMergeCand == m_pcEncCfg->getMaxNumMergeCand() -1)
    {
        uiBitsCand--;
    }
    uiCostCand = uiCostCand + m_pcRdCost->getCost( uiBitsCand );
    if ( uiCostCand < ruiCost )
    {
      ruiCost = uiCostCand;
      pacMvField[0] = cMvFieldNeighbours[0 + 2*uiMergeCand];
      pacMvField[1] = cMvFieldNeighbours[1 + 2*uiMergeCand];
      uiInterDir = uhInterDirNeighbours[uiMergeCand];
      uiMergeIndex = uiMergeCand;
    }
  }
 
}

/** convert bi-pred merge candidates to uni-pred
 * \param pcCU
 * \param puIdx
 * \param mvFieldNeighbours
 * \param interDirNeighbours
 * \param numValidMergeCand
 * \returns Void
 */
Void TEncSearch::xRestrictBipredMergeCand( TComDataCU* pcCU, UInt puIdx, TComMvField* mvFieldNeighbours, UChar* interDirNeighbours, Int numValidMergeCand )
{
	
  if ( pcCU->isBipredRestriction(puIdx) )
  {
    for( UInt mergeCand = 0; mergeCand < numValidMergeCand; ++mergeCand )
    {
      if ( interDirNeighbours[mergeCand] == 3 )
      {
        interDirNeighbours[mergeCand] = 1;
        mvFieldNeighbours[(mergeCand << 1) + 1].setMvField(TComMv(0,0), -1);
      }
    }
  }
}

//! search of the best candidate for inter prediction
#if AMP_MRG
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv DEBUG_STRING_FN_DECLARE(sDebug), Bool bUseRes, Bool bUseMRG )
#else
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv, Bool bUseRes )
#endif
{
  for(UInt i=0; i<NUM_REF_PIC_LIST_01; i++)
  {
    m_acYuvPred[i].clear();
  }
  m_cYuvPredTemp.clear();
  pcPredYuv->clear();

  if ( !bUseRes )
  {
    pcResiYuv->clear();
  }

  pcRecoYuv->clear();
  
  TComMv       cMvSrchRngLT;
  TComMv       cMvSrchRngRB;

  TComMv       cMvZero;
  TComMv       TempMv; //kolya

  TComMv       cMv[2];
  TComMv       cMvBi[2];
  TComMv       cMvTemp[2][33];

  Int          iNumPart    = pcCU->getNumPartitions();
  Int          iNumPredDir = pcCU->getSlice()->isInterP() ? 1 : 2;

  TComMv       cMvPred[2][33];

  TComMv       cMvPredBi[2][33];
  Int          aaiMvpIdxBi[2][33];

  Int          aaiMvpIdx[2][33];
  Int          aaiMvpNum[2][33];

  AMVPInfo     aacAMVPInfo[2][33];

  Int          iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
  Int          iRefIdxBi[2];

  UInt         uiPartAddr;
  Int          iRoiWidth, iRoiHeight;

  UInt         uiMbBits[3] = {1, 1, 0};

  UInt         uiLastMode = 0;
  Int          iRefStart, iRefEnd;

  PartSize     ePartSize = pcCU->getPartitionSize( 0 );

  Int          bestBiPRefIdxL1 = 0;
  Int          bestBiPMvpL1 = 0;
  Distortion   biPDistTemp = std::numeric_limits<Distortion>::max();

  TComMvField cMvFieldNeighbours[MRG_MAX_NUM_CANDS << 1]; // double length for mv of both lists
  UChar uhInterDirNeighbours[MRG_MAX_NUM_CANDS];
  Int numValidMergeCand = 0 ;

  for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
  {
    Distortion   uiCost[2] = { std::numeric_limits<Distortion>::max(), std::numeric_limits<Distortion>::max() };
    Distortion   uiCostBi  =   std::numeric_limits<Distortion>::max();
    Distortion   uiCostTemp;

    UInt         uiBits[3];
    UInt         uiBitsTemp;
    Distortion   bestBiPDist = std::numeric_limits<Distortion>::max();

    Distortion   uiCostTempL0[MAX_NUM_REF];
    for (Int iNumRef=0; iNumRef < MAX_NUM_REF; iNumRef++)
    {
      uiCostTempL0[iNumRef] = std::numeric_limits<Distortion>::max();
    }
    UInt         uiBitsTempL0[MAX_NUM_REF];

    TComMv       mvValidList1;
    Int          refIdxValidList1 = 0;
    UInt         bitsValidList1 = MAX_UINT;
    Distortion   costValidList1 = std::numeric_limits<Distortion>::max();

    xGetBlkBits( ePartSize, pcCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);

    pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
	
	
#if AMP_MRG
    Bool bTestNormalMC = true;

    if ( bUseMRG && pcCU->getWidth( 0 ) > 8 && iNumPart == 2 )
    {
      bTestNormalMC = false;
    }

    if (bTestNormalMC)
    {
#endif

    //  Uni-directional prediction
    for ( Int iRefList = 0; iRefList < iNumPredDir; iRefList++ )
    {
      RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

      for ( Int iRefIdxTemp = 0; iRefIdxTemp < pcCU->getSlice()->getNumRefIdx(eRefPicList); iRefIdxTemp++ )
      {
        uiBitsTemp = uiMbBits[iRefList];
        if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
        {
          uiBitsTemp += iRefIdxTemp+1;
          if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
          {
            uiBitsTemp--;
          }
        }
        xEstimateMvPredAMVP( pcCU, pcOrgYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
        aaiMvpIdx[iRefList][iRefIdxTemp] = pcCU->getMVPIdx(eRefPicList, uiPartAddr);
        aaiMvpNum[iRefList][iRefIdxTemp] = pcCU->getMVPNum(eRefPicList, uiPartAddr);

        if(pcCU->getSlice()->getMvdL1ZeroFlag() && iRefList==1 && biPDistTemp < bestBiPDist)
        {
          bestBiPDist = biPDistTemp;
          bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
          bestBiPRefIdxL1 = iRefIdxTemp;
        }

        uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];

        if ( m_pcEncCfg->getFastMEForGenBLowDelayEnabled() && iRefList == 1 )    // list 1
        {
          if ( pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) >= 0 )
          {
            cMvTemp[1][iRefIdxTemp] = cMvTemp[0][pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            uiCostTemp = uiCostTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            /*first subtract the bit-rate part of the cost of the other list*/
            uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )] );
            /*correct the bit-rate part of the current ref*/
            m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
            uiBitsTemp += m_pcRdCost->getBitsOfVectorWithPredictor( cMvTemp[1][iRefIdxTemp].getHor(), cMvTemp[1][iRefIdxTemp].getVer() );
            /*calculate the correct cost*/
            uiCostTemp += m_pcRdCost->getCost( uiBitsTemp );
          }
          else
          {
            xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
          }
        }
        else
        {
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
        }
        xCopyAMVPInfo(pcCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
        xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

        if ( iRefList == 0 )
        {
          uiCostTempL0[iRefIdxTemp] = uiCostTemp;
          uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
        }
        if ( uiCostTemp < uiCost[iRefList] )
        {
          uiCost[iRefList] = uiCostTemp;
          uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

          // set motion
          cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
          iRefIdx[iRefList] = iRefIdxTemp;
        }

        if ( iRefList == 1 && uiCostTemp < costValidList1 && pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
        {
          costValidList1 = uiCostTemp;
          bitsValidList1 = uiBitsTemp;

          // set motion
          mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
          refIdxValidList1 = iRefIdxTemp;
        }
      }
    }

    //  Bi-predictive Motion estimation
    if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )
    {

      cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
      iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];

      ::memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
      ::memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));

      UInt uiMotBits[2];

      if(pcCU->getSlice()->getMvdL1ZeroFlag())
      {
        xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
        pcCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
        cMvPredBi[1][bestBiPRefIdxL1]   = pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo()->m_acMvCand[bestBiPMvpL1];

        cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
        iRefIdxBi[1] = bestBiPRefIdxL1;
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        TComYuv* pcYuvPred = &m_acYuvPred[REF_PIC_LIST_1];
        motionCompensation( pcCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );

        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiMbBits[1];

        if ( pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1) > 1 )
        {
          uiMotBits[1] += bestBiPRefIdxL1+1;
          if ( bestBiPRefIdxL1 == pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1)-1 )
          {
            uiMotBits[1]--;
          }
        }

        uiMotBits[1] += m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][AMVP_MAX_NUM_CANDS];

        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

        cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
      }
      else
      {
        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiBits[1] - uiMbBits[1];
        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
      }

      // 4-times iteration (default)
      Int iNumIter = 4;

      // fast encoder setting: only one iteration
      if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 || pcCU->getSlice()->getMvdL1ZeroFlag() )
      {
        iNumIter = 1;
      }

      for ( Int iIter = 0; iIter < iNumIter; iIter++ )
      {
        Int         iRefList    = iIter % 2;

        if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 )
        {
          if( uiCost[0] <= uiCost[1] )
          {
            iRefList = 1;
          }
          else
          {
            iRefList = 0;
          }
        }
        else if ( iIter == 0 )
        {
          iRefList = 0;
        }
        if ( iIter == 0 && !pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllMv( cMv[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllRefIdx( iRefIdx[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          TComYuv*  pcYuvPred = &m_acYuvPred[1-iRefList];
          motionCompensation ( pcCU, pcYuvPred, RefPicList(1-iRefList), iPartIdx );
        }

        RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

        if(pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          iRefList = 0;
          eRefPicList = REF_PIC_LIST_0;
        }

        Bool bChanged = false;

        iRefStart = 0;
        iRefEnd   = pcCU->getSlice()->getNumRefIdx(eRefPicList)-1;

        for ( Int iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
        {
          uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
          if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
          {
            uiBitsTemp += iRefIdxTemp+1;
            if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
            {
              uiBitsTemp--;
            }
          }
          uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];
          // call ME
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );

          xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], pcCU->getCUMvField(eRefPicList)->getAMVPInfo());
          xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

          if ( uiCostTemp < uiCostBi )
          {
            bChanged = true;

            cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
            iRefIdxBi[iRefList] = iRefIdxTemp;

            uiCostBi            = uiCostTemp;
            uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
            uiBits[2]           = uiBitsTemp;

            if(iNumIter!=1)
            {
              //  Set motion
              pcCU->getCUMvField( eRefPicList )->setAllMv( cMvBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
              pcCU->getCUMvField( eRefPicList )->setAllRefIdx( iRefIdxBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );

              TComYuv* pcYuvPred = &m_acYuvPred[iRefList];
              motionCompensation( pcCU, pcYuvPred, eRefPicList, iPartIdx );
            }
          }
        } // for loop-iRefIdxTemp

        if ( !bChanged )
        {
          if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
          {
            xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
            xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
            if(!pcCU->getSlice()->getMvdL1ZeroFlag())
            {
              xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
              xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
            }
          }
          break;
        }
      } // for loop-iter
    } // if (B_SLICE)

#if AMP_MRG
    } //end if bTestNormalMC
#endif
    //  Clear Motion Field
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );

    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

    UInt uiMEBits = 0;
    // Set Motion Field_
    cMv[1] = mvValidList1;
	
    iRefIdx[1] = refIdxValidList1;
    uiBits[1] = bitsValidList1;
    uiCost[1] = costValidList1;

#if AMP_MRG
    if (bTestNormalMC)
    {
#endif
    if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
    {
      uiLastMode = 2;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMvBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdxBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 3, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[2];
    }
    else if ( uiCost[0] <= uiCost[1] )
    {
      uiLastMode = 0;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[0];
    }
    else
    {
      uiLastMode = 1;
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMv[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdx[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 2, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[1];
    }
#if AMP_MRG
    } // end if bTestNormalMC
#endif

    if ( pcCU->getPartitionSize( uiPartAddr ) != SIZE_2Nx2N )
    {
      UInt uiMRGInterDir = 0;
      TComMvField cMRGMvField[2];
      UInt uiMRGIndex = 0;

      UInt uiMEInterDir = 0;
      TComMvField cMEMvField[2];

      m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

#if AMP_MRG
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      Distortion uiMECost  = std::numeric_limits<Distortion>::max();

      if (bTestNormalMC)
      {
        xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
        uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
      }
#else
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
      Distortion uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
#endif
      // save ME result.
      uiMEInterDir = pcCU->getInterDir( uiPartAddr );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

      // find Merge result
      Distortion uiMRGCost = std::numeric_limits<Distortion>::max();

      xMergeEstimation( pcCU, pcOrgYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);

      if ( uiMRGCost < uiMECost )
      {
        // set Merge result
        pcCU->setMergeFlagSubParts ( true,          uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setMergeIndexSubParts( uiMRGIndex,    uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts  ( uiMRGInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMRGMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMRGMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      }
      else
      {
        // set ME result
        pcCU->setMergeFlagSubParts( false,        uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts ( uiMEInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMEMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMEMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );
      }
    }

    //  MC
    motionCompensation ( pcCU, pcPredYuv, REF_PIC_LIST_X, iPartIdx );

  } //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )

  setWpScalingDistParam( pcCU, -1, REF_PIC_LIST_X );
 // CTUW = iRoiWidth;
 // CTUH = iRoiHeight;
 // myfile << CTUH << ',' << CTUW << endl;
  return;
}


// AMVP
Void TEncSearch::xEstimateMvPredAMVP( TComDataCU* pcCU, TComYuv* pcOrgYuv, UInt uiPartIdx, RefPicList eRefPicList, Int iRefIdx, TComMv& rcMvPred, Bool bFilled, Distortion* puiDistBiP )
{

  AMVPInfo*  pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();

  TComMv     cBestMv;
  Int        iBestIdx   = 0;
  TComMv     cZeroMv;
  TComMv     cMvPred;
  Distortion uiBestCost = std::numeric_limits<Distortion>::max();
  UInt       uiPartAddr = 0;
  Int        iRoiWidth, iRoiHeight;
  Int        i;
 
  pcCU->getPartIndexAndSize( uiPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
 

  // Fill the MV Candidates
  if (!bFilled)
  {
    pcCU->fillMvpCand( uiPartIdx, uiPartAddr, eRefPicList, iRefIdx, pcAMVPInfo );
  }

  // initialize Mvp index & Mvp
  iBestIdx = 0;
  cBestMv  = pcAMVPInfo->m_acMvCand[0];
  if (pcAMVPInfo->iN <= 1)
  {
    rcMvPred = cBestMv;

    pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));

    if(pcCU->getSlice()->getMvdL1ZeroFlag() && eRefPicList==REF_PIC_LIST_1)
    {
      (*puiDistBiP) = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, rcMvPred, 0, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    }
    return;
  }

  if (bFilled)
  {
    assert(pcCU->getMVPIdx(eRefPicList,uiPartAddr) >= 0);
    rcMvPred = pcAMVPInfo->m_acMvCand[pcCU->getMVPIdx(eRefPicList,uiPartAddr)];
    return;
  }

  m_cYuvPredTemp.clear();
  //-- Check Minimum Cost.
  for ( i = 0 ; i < pcAMVPInfo->iN; i++)
  {
    Distortion uiTmpCost;
    uiTmpCost = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, pcAMVPInfo->m_acMvCand[i], i, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    if ( uiBestCost > uiTmpCost )
    {
      uiBestCost = uiTmpCost;
      cBestMv   = pcAMVPInfo->m_acMvCand[i];
      iBestIdx  = i;
      (*puiDistBiP) = uiTmpCost;
    }
  }

  m_cYuvPredTemp.clear();

  // Setting Best MVP
  rcMvPred = cBestMv;
  pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  return;
  
}

UInt TEncSearch::xGetMvpIdxBits(Int iIdx, Int iNum)
{
  assert(iIdx >= 0 && iNum >= 0 && iIdx < iNum);

  if (iNum == 1)
  {
    return 0;
  }

  UInt uiLength = 1;
  Int iTemp = iIdx;
  if ( iTemp == 0 )
  {
    return uiLength;
  }

  Bool bCodeLast = ( iNum-1 > iTemp );

  uiLength += (iTemp-1);

  if( bCodeLast )
  {
    uiLength++;
  }

  return uiLength;
}

Void TEncSearch::xGetBlkBits( PartSize eCUMode, Bool bPSlice, Int iPartIdx, UInt uiLastMode, UInt uiBlkBit[3])
{
  if ( eCUMode == SIZE_2Nx2N )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else if ( (eCUMode == SIZE_2NxN || eCUMode == SIZE_2NxnU) || eCUMode == SIZE_2NxnD )
  {
    UInt aauiMbBits[2][3][3] = { { {0,0,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7,5,7}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( (eCUMode == SIZE_Nx2N || eCUMode == SIZE_nLx2N) || eCUMode == SIZE_nRx2N )
  {
    UInt aauiMbBits[2][3][3] = { { {0,2,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7-2,7-2,9-2}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( eCUMode == SIZE_NxN )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else
  {
    printf("Wrong!\n");
    assert( 0 );
  }
}

Void TEncSearch::xCopyAMVPInfo (AMVPInfo* pSrc, AMVPInfo* pDst)
{
  pDst->iN = pSrc->iN;
  for (Int i = 0; i < pSrc->iN; i++)
  {
    pDst->m_acMvCand[i] = pSrc->m_acMvCand[i];
  }
}

Void TEncSearch::xCheckBestMVP ( TComDataCU* pcCU, RefPicList eRefPicList, TComMv cMv, TComMv& rcMvPred, Int& riMVPIdx, UInt& ruiBits, Distortion& ruiCost )
{
  AMVPInfo* pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();
  
  assert(pcAMVPInfo->m_acMvCand[riMVPIdx] == rcMvPred);

  if (pcAMVPInfo->iN < 2)
  {
    return;
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(0) );
  m_pcRdCost->setCostScale ( 0    );

  Int iBestMVPIdx = riMVPIdx;

  m_pcRdCost->setPredictor( rcMvPred );
  Int iOrgMvBits  = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
  iOrgMvBits += m_auiMVPIdxCost[riMVPIdx][AMVP_MAX_NUM_CANDS];
  Int iBestMvBits = iOrgMvBits;

  for (Int iMVPIdx = 0; iMVPIdx < pcAMVPInfo->iN; iMVPIdx++)
  {
    if (iMVPIdx == riMVPIdx)
    {
      continue;
    }

    m_pcRdCost->setPredictor( pcAMVPInfo->m_acMvCand[iMVPIdx] );

    Int iMvBits = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
    iMvBits += m_auiMVPIdxCost[iMVPIdx][AMVP_MAX_NUM_CANDS];

    if (iMvBits < iBestMvBits)
    {
      iBestMvBits = iMvBits;
      iBestMVPIdx = iMVPIdx;
    }
  }

  if (iBestMVPIdx != riMVPIdx)  //if changed
  {
    rcMvPred = pcAMVPInfo->m_acMvCand[iBestMVPIdx];

    riMVPIdx = iBestMVPIdx;
    UInt uiOrgBits = ruiBits;
    ruiBits = uiOrgBits - iOrgMvBits + iBestMvBits;
    ruiCost = (ruiCost - m_pcRdCost->getCost( uiOrgBits ))  + m_pcRdCost->getCost( ruiBits );
  }
  
}


Distortion TEncSearch::xGetTemplateCost( TComDataCU* pcCU,
                                         UInt        uiPartAddr,
                                         TComYuv*    pcOrgYuv,
                                         TComYuv*    pcTemplateCand,
                                         TComMv      cMvCand,
                                         Int         iMVPIdx,
                                         Int         iMVPNum,
                                         RefPicList  eRefPicList,
                                         Int         iRefIdx,
                                         Int         iSizeX,
                                         Int         iSizeY
                                         )
{
  Distortion uiCost = std::numeric_limits<Distortion>::max();

  TComPicYuv* pcPicYuvRef = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdx )->getPicYuvRec();

  pcCU->clipMv( cMvCand );

  // prediction pattern
  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, true, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }
  else
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, false, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }

  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xWeightedPredictionUni( pcCU, pcTemplateCand, uiPartAddr, iSizeX, iSizeY, eRefPicList, pcTemplateCand, iRefIdx );
  }

  // calc distortion

  uiCost = m_pcRdCost->getDistPart( pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA), pcTemplateCand->getAddr(COMPONENT_Y, uiPartAddr), pcTemplateCand->getStride(COMPONENT_Y), pcOrgYuv->getAddr(COMPONENT_Y, uiPartAddr), pcOrgYuv->getStride(COMPONENT_Y), iSizeX, iSizeY, COMPONENT_Y, DF_SAD );
  uiCost = (UInt) m_pcRdCost->calcRdCost( m_auiMVPIdxCost[iMVPIdx][iMVPNum], uiCost, DF_SAD );
  return uiCost;
}


Void TEncSearch::xMotionEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, RefPicList eRefPicList, TComMv* pcMvPred, Int iRefIdxPred, TComMv& rcMv, UInt& ruiBits, Distortion& ruiCost, Bool bBi  )
{
  UInt          uiPartAddr;
  Int           iRoiWidth;
  Int           iRoiHeight;

  TComMv        cMvHalf, cMvQter;
  TComMv        cMvSrchRngLT;
  TComMv        cMvSrchRngRB;
  // Distortion   INTCOST=0;
  TComYuv*      pcYuv = pcYuvOrg;
   
  assert(eRefPicList < MAX_NUM_REF_LIST_ADAPT_SR && iRefIdxPred<Int(MAX_IDX_ADAPT_SR));
  m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];

  Int           iSrchRng      = ( bBi ? m_bipredSearchRange : m_iSearchRange );
  TComPattern   tmpPattern;
  TComPattern*  pcPatternKey  = &tmpPattern;

  Double        fWeight       = 1.0;

  pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );

  if ( bBi ) // Bipredictive ME
  {
    TComYuv*  pcYuvOther = &m_acYuvPred[1-(Int)eRefPicList];
    pcYuv                = &m_cYuvPredTemp;

    pcYuvOrg->copyPartToPartYuv( pcYuv, uiPartAddr, iRoiWidth, iRoiHeight );

    pcYuv->removeHighFreq( pcYuvOther, uiPartAddr, iRoiWidth, iRoiHeight, pcCU->getSlice()->getSPS()->getBitDepths().recon, m_pcEncCfg->getClipForBiPredMeEnabled() );

    fWeight = 0.5;
  }
  m_cDistParam.bIsBiPred = bBi;

  //  Search key pattern initialization
  pcPatternKey->initPattern( pcYuv->getAddr  ( COMPONENT_Y, uiPartAddr ),
                             iRoiWidth,
                             iRoiHeight,
                             pcYuv->getStride(COMPONENT_Y),
                             pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );

  Pel*        piRefY      = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu() + uiPartAddr );
  Int         iRefStride  = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getStride(COMPONENT_Y);

  TComMv      cMvPred = *pcMvPred;

  if ( bBi )
  {
	  
    xSetSearchRange   ( pcCU, rcMv   , iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }
  else
  {
	  
    xSetSearchRange   ( pcCU, cMvPred, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }

  m_pcRdCost->selectMotionLambda(true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setPredictor  ( *pcMvPred );
  m_pcRdCost->setCostScale  ( 2 );

  setWpScalingDistParam( pcCU, iRefIdxPred, eRefPicList );
  //  Do integer search
  if ( (m_motionEstimationSearchMethod==MESEARCH_FULL) || bBi )
  {
    xPatternSearch      ( pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost );
  }
  else
  {
    rcMv = *pcMvPred;
    const TComMv *pIntegerMv2Nx2NPred=0;
    if (pcCU->getPartitionSize(0) != SIZE_2Nx2N || pcCU->getDepth(0) != 0)
    {
      pIntegerMv2Nx2NPred = &(m_integerMv2Nx2N[eRefPicList][iRefIdxPred]);
    }
    
    // EMI: Save Block width and height in global variables, to use in our NN
    // TODO: Code Cleaning
    PUHeight = iRoiHeight;
    PUWidth = iRoiWidth;


    xPatternSearchFast  ( pcCU, pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost, pIntegerMv2Nx2NPred );
    if (pcCU->getPartitionSize(0) == SIZE_2Nx2N)
    {
      m_integerMv2Nx2N[eRefPicList][iRefIdxPred] = rcMv;
    }
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setCostScale ( 1 );
    
  const Bool bIsLosslessCoded = pcCU->getCUTransquantBypass(uiPartAddr) != 0;
  xPatternSearchFracDIF( bIsLosslessCoded, pcPatternKey, piRefY, iRefStride, &rcMv, cMvHalf, cMvQter, ruiCost );

  m_pcRdCost->setCostScale( 0 );

  // EMI: Modification
  
  /* 
  Fractional Motion Estimation values computed by standard are stored in TComMv variables cMvHalf & cMvQter
  We create other TComMv variables, and replace the standard values with our NN predicted values
  Our NN modifies global variables MVX_HALF & MVX_QRTER, which in return are set used to set our new Mv
  */
  TComMv MV_HALF, MV_QRTER;
  MV_HALF.setHor(MVX_HALF);
  MV_HALF.setVer(MVY_HALF);
  MV_QRTER.setHor(MVX_QRTER);
  MV_QRTER.setVer(MVY_QRTER);

  // For finding Integer Motion Estimation, Set Horizontal and Vertical values to zero:

  // MV_HALF.setHor(0);
  // MV_HALF.setVer(0);
  // MV_QRTER.setHor(0);
  // MV_QRTER.setVer(0);

  /* 
  EMI: To Write the errors and output MV in a CSV file:
  Real values for errors: U,V,H           - NN values for errors: IN[]
  Real values for MV: cMvHalf, cMvQter    - NN values for MV: MV_HALF, MV_QRTER
  Block Width and Height: iRoiWidth, iRoiHeight
  */
  
  // ofstream mv_nn;
  // ofstream errors;
  // errors.open("/home/emi/git-repos/data/HM16.9/extract_data/SSE_errors.csv", ios::app);
  // mv_nn.open("/home/emi/git-repos/data/HM16.9/extract_data/mv_nn.csv", ios::app);
  // errors << U1 << ',' << V1 << ',' << U2 << ',' << H1 << ',' << C << ',' << H2 << ',' << U3 << ',' << V2 << ',' << U4 << ',' << iRoiHeight << ',' << iRoiWidth << endl;
  // errors << ',' << xP << ',' << yP << ',' << PIdx  << ',' << PAddr << endl;
  // errors << ',' << uiPartAddr << ',' << iPartIdx << endl;
  
  /*
  Write the values of the output class directly instead of coordinates:
  Half * 0.5 + Quarter * 0.25:  results in range from -0.75->0.75
  Add both X & Y + 0.75:        range is now 0->1.5
  Multiply X by 4:              X values are now [0, 1, 2, 3, 4, 5, 6]
  Multiply Y by 4*7=28:         Y values are now [0, 7, 14, 21, 28, 35, 42]
  Adding X+Y results in the desired output class, given that the mapping starts from 
  0 for top left corner, 24 center, and 48 for bottom right corner
  */
  
  // int MV_X = (((cMvHalf.getHor() * 0.5) + (cMvQter.getHor() * 0.25)) + 0.75) * 4;
  // int MV_Y = (((cMvHalf.getVer() * 0.5) + (cMvQter.getVer() * 0.25)) + 0.75) * 28;
  // int OUT_CLASS = MV_Y + MV_X;
  // mv_nn << OUT_CLASS << endl;

  // Replace Motion Vector with values computed by our NN

  rcMv <<= 2;
  // rcMv += (cMvHalf <<= 1);
  // rcMv += cMvQter;
  rcMv += (MV_HALF <<= 1);
  rcMv += MV_QRTER;
  
  // End of modification

  UInt uiMvBits = m_pcRdCost->getBitsOfVectorWithPredictor( rcMv.getHor(), rcMv.getVer() );

  ruiBits      += uiMvBits;
  ruiCost       = (Distortion)( floor( fWeight * ( (Double)ruiCost - (Double)m_pcRdCost->getCost( uiMvBits ) ) ) + (Double)m_pcRdCost->getCost( ruiBits ) );
}


Void TEncSearch::xSetSearchRange ( const TComDataCU* const pcCU, const TComMv& cMvPred, const Int iSrchRng,
                                   TComMv& rcMvSrchRngLT, TComMv& rcMvSrchRngRB )
{
  Int  iMvShift = 2;
  TComMv cTmpMvPred = cMvPred;
  pcCU->clipMv( cTmpMvPred );

  rcMvSrchRngLT.setHor( cTmpMvPred.getHor() - (iSrchRng << iMvShift) );
  rcMvSrchRngLT.setVer( cTmpMvPred.getVer() - (iSrchRng << iMvShift) );

  rcMvSrchRngRB.setHor( cTmpMvPred.getHor() + (iSrchRng << iMvShift) );
  rcMvSrchRngRB.setVer( cTmpMvPred.getVer() + (iSrchRng << iMvShift) );
  pcCU->clipMv        ( rcMvSrchRngLT );
  pcCU->clipMv        ( rcMvSrchRngRB );

#if ME_ENABLE_ROUNDING_OF_MVS
  rcMvSrchRngLT.divideByPowerOf2(iMvShift);
  rcMvSrchRngRB.divideByPowerOf2(iMvShift);
#else
  rcMvSrchRngLT >>= iMvShift;
  rcMvSrchRngRB >>= iMvShift;
#endif
}


Void TEncSearch::xPatternSearch(const TComPattern* const pcPatternKey,
	const Pel*               piRefY,
	const Int                iRefStride,
	const TComMv* const      pcMvSrchRngLT,
	const TComMv* const      pcMvSrchRngRB,
	TComMv&      rcMv,
	Distortion&  ruiSAD)
{
	Int   iSrchRngHorLeft = pcMvSrchRngLT->getHor();
	Int   iSrchRngHorRight = pcMvSrchRngRB->getHor();
	Int   iSrchRngVerTop = pcMvSrchRngLT->getVer();
	Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

	Distortion  uiSad;
	Distortion  uiSadBest = std::numeric_limits<Distortion>::max();
	Int         iBestX = 0;
	Int         iBestY = 0;


	m_pcRdCost->setDistParam(pcPatternKey, piRefY, iRefStride, m_cDistParam);

	// fast encoder decision: use subsampled SAD for integer ME
	if (m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE3)
	{
		if (m_cDistParam.iRows > 8)
		{
			m_cDistParam.iSubShift = 1;
		}
	}

	piRefY += (iSrchRngVerTop * iRefStride);

	for (Int y = iSrchRngVerTop; y <= iSrchRngVerBottom; y++)
	{
		for (Int x = iSrchRngHorLeft; x <= iSrchRngHorRight; x++)
		{
			//  find min. distortion position
			m_cDistParam.pCur = piRefY + x;

			setDistParamComp(COMPONENT_Y);

			m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
			uiSad = m_cDistParam.DistFunc(&m_cDistParam);

			// motion cost
			uiSad += m_pcRdCost->getCostOfVectorWithPredictor(x, y);

			if (uiSad < uiSadBest)
			{
				uiSadBest = uiSad;
				iBestX = x;
				iBestY = y;
				m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
			}
		}
		piRefY += iRefStride;
	}




		rcMv.set(iBestX, iBestY);


		ruiSAD = uiSadBest - m_pcRdCost->getCostOfVectorWithPredictor(iBestX, iBestY);

		//getchar();
		return;
	}


Void TEncSearch::xPatternSearchFast( const TComDataCU* const  pcCU,
                                     const TComPattern* const pcPatternKey,
                                     const Pel* const         piRefY,
                                     const Int                iRefStride,
                                     const TComMv* const      pcMvSrchRngLT,
                                     const TComMv* const      pcMvSrchRngRB,
                                     TComMv&                  rcMv,
                                     Distortion&              ruiSAD,
                                     const TComMv* const      pIntegerMv2Nx2NPred )
{
  assert (MD_LEFT < NUM_MV_PREDICTORS);
  pcCU->getMvPredLeft       ( m_acMvPredictors[MD_LEFT] );
  assert (MD_ABOVE < NUM_MV_PREDICTORS);
  pcCU->getMvPredAbove      ( m_acMvPredictors[MD_ABOVE] );
  assert (MD_ABOVE_RIGHT < NUM_MV_PREDICTORS);
  pcCU->getMvPredAboveRight ( m_acMvPredictors[MD_ABOVE_RIGHT] );

  switch ( m_motionEstimationSearchMethod )
  {
    case MESEARCH_DIAMOND:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, false );
	  
      C = array_e[0];
      for (int i = 1; i <=index_ref - 1; i++)
      {
        if (array_e[i] < C)
          C = array_e[i];

      }
	 
      // index_ref = index_ref + 1;
      U1 = array_e[index_ref];
      V1 = array_e[index_ref + 1];
      U2 = array_e[index_ref + 2];
      H1 = array_e[index_ref + 3];	  
      H2 = array_e[index_ref + 4];
      U3 = array_e[index_ref + 5];
      V2 = array_e[index_ref + 6];
      U4 = array_e[index_ref + 7];
      	  
      // EMI: neural network implementation
      
      // Reset all values of arrays

      memset(IN, 0, sizeof(IN));
      memset(X1, 0, sizeof(X1));
      memset(X2, 0, sizeof(X2));
      memset(OUT, 0, sizeof(OUT));
      memset(array_e, 0, sizeof(array_e));
      N = 0; NN_out = 0; counter_i = 0; index_ref = 0;


      // Normalize input values using the computed mean and standard deviations

      IN[8] = (U1 - mean[0]) / stdev[0];
      IN[9] = (V1 - mean[1]) / stdev[1];
      IN[10] = (U2 - mean[2]) / stdev[2];
      IN[11] = (H1 - mean[3]) / stdev[3];
      IN[12] = (C - mean[4]) / stdev[4];
      IN[13] = (H2 - mean[5]) / stdev[5];
      IN[14] = (U3 - mean[6]) / stdev[6];
      IN[15] = (V2 - mean[7]) / stdev[7];
      IN[16] = (U4 - mean[8]) / stdev[8];

      // Input layer also consists of categorical variables, in which we will use embedding matrices depending on block Height and Width

      switch (PUHeight) {
        case 4:   IN[0] = embs0[1][0];  IN[1] = embs0[1][1];   IN[2] = embs0[1][2];   IN[3] = embs0[1][3];		break;
        case 8:   IN[0] = embs0[2][0];  IN[1] = embs0[2][1];   IN[2] = embs0[2][2];   IN[3] = embs0[2][3];		break;
        case 12:  IN[0] = embs0[3][0];  IN[1] = embs0[3][1];   IN[2] = embs0[3][2];   IN[3] = embs0[3][3];	  break;
        case 16:  IN[0] = embs0[4][0];  IN[1] = embs0[4][1];   IN[2] = embs0[4][2];   IN[3] = embs0[4][3];		break;
        case 24:  IN[0] = embs0[5][0];  IN[1] = embs0[5][1];   IN[2] = embs0[5][2];   IN[3] = embs0[5][3];	  break;
        case 32:  IN[0] = embs0[6][0];  IN[1] = embs0[6][1];   IN[2] = embs0[6][2];   IN[3] = embs0[6][3];		break;
        case 64:  IN[0] = embs0[7][0];  IN[1] = embs0[7][1];   IN[2] = embs0[7][2];   IN[3] = embs0[7][3];		break;
        default:  IN[0] = embs0[0][0];  IN[1] = embs0[0][1];   IN[2] = embs0[0][2];   IN[3] = embs0[0][3];		break;
      }

      switch (PUWidth) {
        case 4:   IN[4] = embs1[1][0];  IN[5] = embs1[1][1];   IN[6] = embs1[1][2];   IN[7] = embs1[1][3];		break;
        case 8:   IN[4] = embs1[2][0];  IN[5] = embs1[2][1];   IN[6] = embs1[2][2];   IN[7] = embs1[2][3];		break;
        case 12:  IN[4] = embs1[3][0];  IN[5] = embs1[3][1];   IN[6] = embs1[3][2];   IN[7] = embs1[3][3];	  break;
        case 16:  IN[4] = embs1[4][0];  IN[5] = embs1[4][1];   IN[6] = embs1[4][2];   IN[7] = embs1[4][3];		break;
        case 24:  IN[4] = embs1[5][0];  IN[5] = embs1[5][1];   IN[6] = embs1[5][2];   IN[7] = embs1[5][3];	  break;
        case 32:  IN[4] = embs1[6][0];  IN[5] = embs1[6][1];   IN[6] = embs1[6][2];   IN[7] = embs1[6][3];		break;
        case 64:  IN[4] = embs1[7][0];  IN[5] = embs1[7][1];   IN[6] = embs1[7][2];   IN[7] = embs1[7][3];		break;
        default:  IN[4] = embs1[0][0];  IN[5] = embs1[0][1];   IN[6] = embs1[0][2];   IN[7] = embs1[0][3];		break;
      }

      // Input Layer
      for(int i=0;i<9;i++){
        IN[i+8] = (IN[i+8] * BN_gamma_in[i]);	  
      }

      
      // First Hidden Layer
      for (int i = 0; i < 40; i++) {
        for (int j = 0; j < 17; j++) {
          X1[i] += (in_h1[i][j] * IN[j]);
        }
        X1[i] += b1[i];
        X1[i] = (relu(X1[i]) * BN_gamma_1[i]) + BN_beta_1[i];
      }

      // Second Hidden Layer
      for (int i = 0; i < 40; i++) {
        for (int j = 0; j < 40; j++) {
          X2[i] += (h1_h2[i][j] * X1[j]);
        }
        X2[i] += b2[i];
        X2[i] = (relu(X2[i]) * BN_gamma_2[i]) + BN_beta_2[i];
      }

      for (int i = 0; i < 40; i++) {
        for (int j = 0; j < 40; j++) {
          X3[i] += (h2_h3[i][j] * X2[j]);
        }
        X3[i] += b3[i];
        X3[i] = (relu(X3[i]) * BN_gamma_3[i]) + BN_beta_3[i];
      }

      for (int i = 0; i < 40; i++) {
        for (int j = 0; j < 40; j++) {
          X4[i] += (h3_h4[i][j] * X3[j]);
        }
        X4[i] += b4[i];
        X4[i] = (relu(X4[i]) * BN_gamma_4[i]) + BN_beta_4[i];
      }

      // OUTPUT LAYER
      for (int i = 0; i < 49; i++) {
        for (int j = 0; j < 40; j++) {
          OUT[i] += (h4_out[i][j] * X4[j]);
        }
        OUT[i] += bout[i];
      }
      
      // Decision: NN_out holds the index of the maximum element

      N = sizeof(OUT) / sizeof(float); // Size of OUT[] array, used in next step
      NN_out = std::distance(OUT, std::max_element(OUT, OUT + N));
      
      switch (NN_out) {
        case 0: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 1: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 2: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 3: MVX_HALF = 0;   MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 4: MVX_HALF = 0;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 5: MVX_HALF = 1;   MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 6: MVX_HALF = 1;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;

        case 7: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 8: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 9: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 10: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 11: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 12: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 13: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;

        case 14: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 15: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 16: MVX_HALF = 0;  MVX_QRTER = -1;   MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 17: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 18: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 19: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 20: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;

        case 21: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 22: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 23: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 24: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 25: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 26: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 27: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;

        case 28: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 29: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 30: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 31: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 32: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 33: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 34: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;

        case 35: MVX_HALF = -1; MVX_QRTER = -1;   MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 36: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 37: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 38: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 0;		break;
        case 39: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 40: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 41: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;

        case 42: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 43: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 44: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 45: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 1;	  break;
        case 46: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 47: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 48: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        default: MVX_HALF = 0;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
      }


      //end of neural network code

      break;



    case MESEARCH_SELECTIVE:
      xTZSearchSelective( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred );
      break;

    case MESEARCH_DIAMOND_ENHANCED:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, true );
      break;

    case MESEARCH_FULL: // shouldn't get here.
    default:
      break;
  }
}


Void TEncSearch::xTZSearch( const TComDataCU* const pcCU,
                            const TComPattern* const pcPatternKey,
                            const Pel* const         piRefY,
                            const Int                iRefStride,
                            const TComMv* const      pcMvSrchRngLT,
                            const TComMv* const      pcMvSrchRngRB,
                            TComMv&                  rcMv,
                            Distortion&              ruiSAD,
                            const TComMv* const      pIntegerMv2Nx2NPred,
                            const Bool               bExtendedSettings)
{
  const Bool bUseAdaptiveRaster                      = bExtendedSettings;
  const Int  iRaster                                 = 5;
  const Bool bTestOtherPredictedMV                   = bExtendedSettings;
  const Bool bTestZeroVector                         = true;
  const Bool bTestZeroVectorStart                    = bExtendedSettings;
  const Bool bTestZeroVectorStop                     = false;
  const Bool bFirstSearchDiamond                     = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bFirstCornersForDiamondDist1            = bExtendedSettings;
  const Bool bFirstSearchStop                        = m_pcEncCfg->getFastMEAssumingSmootherMVEnabled();
  const UInt uiFirstSearchRounds                     = 3;     // first search stop X rounds after best match (must be >=1)
  const Bool bEnableRasterSearch                     = true;
  const Bool bAlwaysRasterSearch                     = bExtendedSettings;  // true: BETTER but factor 2 slower
  const Bool bRasterRefinementEnable                 = false; // enable either raster refinement or star refinement
  const Bool bRasterRefinementDiamond                = false; // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bRasterRefinementCornersForDiamondDist1 = bExtendedSettings;
  const Bool bStarRefinementEnable                   = true;  // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond                  = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementCornersForDiamondDist1   = bExtendedSettings;
  const Bool bStarRefinementStop                     = false;
  const UInt uiStarRefinementRounds                  = 2;  // star refinement stop X rounds after best match (must be >=1)
  const Bool bNewZeroNeighbourhoodTest               = bExtendedSettings;

  UInt uiSearchRange = m_iSearchRange;
  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;

  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      if (cMv != rcMv && (cMv.getHor() != cStruct.iBestX && cMv.getVer() != cStruct.iBestY))
      {
        // only test cMV if not obviously previously tested.
        xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
      }
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    if ((rcMv.getHor() != 0 || rcMv.getVer() != 0) &&
        (0 != cStruct.iBestX || 0 != cStruct.iBestY))
    {
      // only test 0-vector if not obviously previously tested.
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
    }
  }

  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  if (pIntegerMv2Nx2NPred != 0)
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    if ((rcMv != integerMv2Nx2NPred) &&
        (integerMv2Nx2NPred.getHor() != cStruct.iBestX || integerMv2Nx2NPred.getVer() != cStruct.iBestY))
    {
      // only test integerMv2Nx2NPred if not obviously previously tested.
      xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);
    }

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // start search
  Int  iDist = 0;
  Int  iStartX = cStruct.iBestX;
  Int  iStartY = cStruct.iBestY;

  const Bool bBestCandidateZero = (cStruct.iBestX == 0) && (cStruct.iBestY == 0);

  // first search around best position up to now.
  // The following works as a "subsampled/log" window search around the best candidate
  for (iDist = 1; iDist <= (Int)uiSearchRange; iDist *= 2)
	  
  {
    if ( bFirstSearchDiamond == 1 )
    {
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bFirstCornersForDiamondDist1 );
    }
    else
    {
      xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
    }

    if ( bFirstSearchStop && ( cStruct.uiBestRound >= uiFirstSearchRounds ) ) // stop criterion
    {
      break;
    }
  }

  if (!bNewZeroNeighbourhoodTest)
  {
    // test whether zero Mv is a better start point than Median predictor
    if ( bTestZeroVectorStart && ((cStruct.iBestX != 0) || (cStruct.iBestY != 0)) )
    {
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
      if ( (cStruct.iBestX == 0) && (cStruct.iBestY == 0) )
      {
        // test its neighborhood
        for ( iDist = 1; iDist <= (Int)uiSearchRange; iDist*=2 )
        {
          xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
          if ( bTestZeroVectorStop && (cStruct.uiBestRound > 0) ) // stop criterion
          {
            break;
          }
        }
      }
    }
  }
  else
  {
    // Test also zero neighbourhood but with half the range
    // It was reported that the original (above) search scheme using bTestZeroVectorStart did not
    // make sense since one would have already checked the zero candidate earlier
    // and thus the conditions for that test would have not been satisfied
    if (bTestZeroVectorStart == true && bBestCandidateZero != true)
    {
      for ( iDist = 1; iDist <= ((Int)uiSearchRange >> 1); iDist*=2 )
      {
        xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
        if ( bTestZeroVectorStop && (cStruct.uiBestRound > 2) ) // stop criterion
        {
          break;
        }
      }
    }
  }

  // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
  if ( cStruct.uiBestDistance == 1 )
  {
    cStruct.uiBestDistance = 0;
    xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
  }

  // raster search if distance is too big
  if (bUseAdaptiveRaster)
  {
    int iWindowSize = iRaster;
    Int   iSrchRngRasterLeft   = iSrchRngHorLeft;
    Int   iSrchRngRasterRight  = iSrchRngHorRight;
    Int   iSrchRngRasterTop    = iSrchRngVerTop;
    Int   iSrchRngRasterBottom = iSrchRngVerBottom;

    if (!(bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster))))
    {
      iWindowSize ++;
      iSrchRngRasterLeft /= 2;
      iSrchRngRasterRight /= 2;
      iSrchRngRasterTop /= 2;
      iSrchRngRasterBottom /= 2;
    }
    cStruct.uiBestDistance = iWindowSize;
    for ( iStartY = iSrchRngRasterTop; iStartY <= iSrchRngRasterBottom; iStartY += iWindowSize )
    {
      for ( iStartX = iSrchRngRasterLeft; iStartX <= iSrchRngRasterRight; iStartX += iWindowSize )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iWindowSize );
      }
    }
  }
  else
  {
    if ( bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster) || bAlwaysRasterSearch ) )
    {
      cStruct.uiBestDistance = iRaster;
      for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += iRaster )
      {
        for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += iRaster )
        {
          xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iRaster );
        }
      }
    }
  }

  // raster refinement

  if ( bRasterRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      if ( cStruct.uiBestDistance > 1 )
      {
        iDist = cStruct.uiBestDistance >>= 1;
        if ( bRasterRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bRasterRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
      }

      // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // star refinement
  if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bStarRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }


  // EMI: BIG DIFFERENCE!
  // getting the 8 SAD points
  iDist = 1;
  iStartX = cStruct.iBestX;
  iStartY = cStruct.iBestY;
  index_ref = counter_i;
  
  xTZ8PointSquareSearch(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  iDist = 2;
  xTZ8PointSquareSearch2(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );
}


Void TEncSearch::xTZSearchSelective( const TComDataCU* const   pcCU,
                                     const TComPattern* const  pcPatternKey,
                                     const Pel* const          piRefY,
                                     const Int                 iRefStride,
                                     const TComMv* const       pcMvSrchRngLT,
                                     const TComMv* const       pcMvSrchRngRB,
                                     TComMv                   &rcMv,
                                     Distortion               &ruiSAD,
                                     const TComMv* const       pIntegerMv2Nx2NPred )
{
  const Bool bTestOtherPredictedMV    = true;
  const Bool bTestZeroVector          = true;
  const Bool bEnableRasterSearch      = true;
  const Bool bAlwaysRasterSearch      = false;  // 1: BETTER but factor 15x slower
  const Bool bStarRefinementEnable    = true;   // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond   = true;   // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementStop      = false;
  const UInt uiStarRefinementRounds   = 2;  // star refinement stop X rounds after best match (must be >=1)
  const UInt uiSearchRange            = m_iSearchRange;
  const Int  uiSearchRangeInitial     = m_iSearchRange >> 2;
  const Int  uiSearchStep             = 4;
  const Int  iMVDistThresh            = 8;

  Int   iSrchRngHorLeft         = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight        = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop          = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom       = pcMvSrchRngRB->getVer();
  Int   iFirstSrchRngHorLeft    = 0;
  Int   iFirstSrchRngHorRight   = 0;
  Int   iFirstSrchRngVerTop     = 0;
  Int   iFirstSrchRngVerBottom  = 0;
  Int   iStartX                 = 0;
  Int   iStartY                 = 0;
  Int   iBestX                  = 0;
  Int   iBestY                  = 0;
  Int   iDist                   = 0;

  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;
  cStruct.iBestX = 0;
  cStruct.iBestY = 0;


  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
  }

  if ( pIntegerMv2Nx2NPred != 0 )
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // Initial search
  iBestX = cStruct.iBestX;
  iBestY = cStruct.iBestY; 
  iFirstSrchRngHorLeft    = ((iBestX - uiSearchRangeInitial) > iSrchRngHorLeft)   ? (iBestX - uiSearchRangeInitial) : iSrchRngHorLeft;
  iFirstSrchRngVerTop     = ((iBestY - uiSearchRangeInitial) > iSrchRngVerTop)    ? (iBestY - uiSearchRangeInitial) : iSrchRngVerTop;
  iFirstSrchRngHorRight   = ((iBestX + uiSearchRangeInitial) < iSrchRngHorRight)  ? (iBestX + uiSearchRangeInitial) : iSrchRngHorRight;  
  iFirstSrchRngVerBottom  = ((iBestY + uiSearchRangeInitial) < iSrchRngVerBottom) ? (iBestY + uiSearchRangeInitial) : iSrchRngVerBottom;    

  for ( iStartY = iFirstSrchRngVerTop; iStartY <= iFirstSrchRngVerBottom; iStartY += uiSearchStep )
  {
    for ( iStartX = iFirstSrchRngHorLeft; iStartX <= iFirstSrchRngHorRight; iStartX += uiSearchStep )
    {
      xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 0 );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 1, false );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 2, false );
    }
  }

  Int iMaxMVDistToPred = (abs(cStruct.iBestX - iBestX) > iMVDistThresh || abs(cStruct.iBestY - iBestY) > iMVDistThresh);

  //full search with early exit if MV is distant from predictors
  if ( bEnableRasterSearch && (iMaxMVDistToPred || bAlwaysRasterSearch) )
  {
    for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += 1 )
    {
      for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += 1 )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 1 );
      }
    }
  }
  //Smaller MV, refine around predictor
  else if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    // start refinement
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, false );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );

}


Void TEncSearch::xPatternSearchFracDIF(
                                       Bool         bIsLosslessCoded,
                                       TComPattern* pcPatternKey,
                                       Pel*         piRefY,
                                       Int          iRefStride,
                                       TComMv*      pcMvInt,
                                       TComMv&      rcMvHalf,
                                       TComMv&      rcMvQter,
                                       Distortion&  ruiCost
                                      )
{
  //  Reference pattern initialization (integer scale)
	
  TComPattern cPatternRoi;
  Int         iOffset    = pcMvInt->getHor() + pcMvInt->getVer() * iRefStride;
  cPatternRoi.initPattern(piRefY + iOffset,
                          pcPatternKey->getROIYWidth(),
                          pcPatternKey->getROIYHeight(),
                          iRefStride,
                          pcPatternKey->getBitDepthY());

  //  Half-pel refinement
  xExtDIFUpSamplingH ( &cPatternRoi );

  rcMvHalf = *pcMvInt;   rcMvHalf <<= 1;    // for mv-cost
  TComMv baseRefMv(0, 0);
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 2, rcMvHalf, !bIsLosslessCoded );

  m_pcRdCost->setCostScale( 0 );

  xExtDIFUpSamplingQ ( &cPatternRoi, rcMvHalf );
  baseRefMv = rcMvHalf;
  baseRefMv <<= 1;

  rcMvQter = *pcMvInt;   rcMvQter <<= 1;    // for mv-cost
  rcMvQter += rcMvHalf;  rcMvQter <<= 1;
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 1, rcMvQter, !bIsLosslessCoded );
}


//! encode residual and calculate rate-distortion for a CU block
Void TEncSearch::encodeResAndCalcRdInterCU( TComDataCU* pcCU, TComYuv* pcYuvOrg, TComYuv* pcYuvPred,
                                            TComYuv* pcYuvResi, TComYuv* pcYuvResiBest, TComYuv* pcYuvRec,
                                            Bool bSkipResidual DEBUG_STRING_FN_DECLARE(sDebug) )
{
  assert ( !pcCU->isIntra(0) );

  const UInt cuWidthPixels      = pcCU->getWidth ( 0 );
  const UInt cuHeightPixels     = pcCU->getHeight( 0 );
  const Int  numValidComponents = pcCU->getPic()->getNumberValidComponents();
  const TComSPS &sps=*(pcCU->getSlice()->getSPS());

  // The pcCU is not marked as skip-mode at this point, and its m_pcTrCoeff, m_pcArlCoeff, m_puhCbf, m_puhTrIdx will all be 0.
  // due to prior calls to TComDataCU::initEstData(  );

  if ( bSkipResidual ) //  No residual coding : SKIP mode
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    pcYuvResi->clear();

    pcYuvPred->copyToPartYuv( pcYuvRec, 0 );
    Distortion distortion = 0;

    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID compID=ComponentID(comp);
      const UInt csx=pcYuvOrg->getComponentScaleX(compID);
      const UInt csy=pcYuvOrg->getComponentScaleY(compID);
      distortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID), pcYuvRec->getStride(compID), pcYuvOrg->getAddr(compID),
                                               pcYuvOrg->getStride(compID), cuWidthPixels >> csx, cuHeightPixels >> csy, compID);
    }

    m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST]);
    m_pcEntropyCoder->resetBits();

    if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex( pcCU, 0, true );

    UInt uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    pcCU->getTotalBits()       = uiBits;
    pcCU->getTotalDistortion() = distortion;
    pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( uiBits, distortion );

    m_pcRDGoOnSbacCoder->store(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_TEMP_BEST]);

#if DEBUG_STRING
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif

    return;
  }

  //  Residual coding.

   pcYuvResi->subtract( pcYuvOrg, pcYuvPred, 0, cuWidthPixels );

  TComTURecurse tuLevel0(pcCU, 0);

  Double     nonZeroCost       = 0;
  UInt       nonZeroBits       = 0;
  Distortion nonZeroDistortion = 0;
  Distortion zeroDistortion    = 0;

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_CURR_BEST ] );

  xEstimateInterResidualQT( pcYuvResi,  nonZeroCost, nonZeroBits, nonZeroDistortion, &zeroDistortion, tuLevel0 DEBUG_STRING_PASS_INTO(sDebug) );

  // -------------------------------------------------------
  // set the coefficients in the pcCU, and also calculates the residual data.
  // If a block full of 0's is efficient, then just use 0's.
  // The costs at this point do not include header bits.

  m_pcEntropyCoder->resetBits();
  m_pcEntropyCoder->encodeQtRootCbfZero( );
  const UInt   zeroResiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  const Double zeroCost     = (pcCU->isLosslessCoded( 0 )) ? (nonZeroCost+1) : (m_pcRdCost->calcRdCost( zeroResiBits, zeroDistortion ));

  if ( zeroCost < nonZeroCost || !pcCU->getQtRootCbf(0) )
  {
    const UInt uiQPartNum = tuLevel0.GetAbsPartIdxNumParts();
    ::memset( pcCU->getTransformIdx()     , 0, uiQPartNum * sizeof(UChar) );
    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID component = ComponentID(comp);
      ::memset( pcCU->getCbf( component ) , 0, uiQPartNum * sizeof(UChar) );
      ::memset( pcCU->getCrossComponentPredictionAlpha(component), 0, ( uiQPartNum * sizeof(SChar) ) );
    }
    static const UInt useTS[MAX_NUM_COMPONENT]={0,0,0};
    pcCU->setTransformSkipSubParts ( useTS, 0, pcCU->getDepth(0) );
#if DEBUG_STRING
    sDebug.clear();
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif
  }
  else
  {
    xSetInterResidualQTData( NULL, false, tuLevel0); // Call first time to set coefficients.
  }

  // all decisions now made. Fully encode the CU, including the headers:
  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST] );

  UInt finalBits = 0;
  xAddSymbolBitsInter( pcCU, finalBits );
  // we've now encoded the pcCU, and so have a valid bit cost

  if ( !pcCU->getQtRootCbf( 0 ) )
  {
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
  }
  else
  {
    xSetInterResidualQTData( pcYuvResiBest, true, tuLevel0 ); // else set the residual image data pcYUVResiBest from the various temp images.
  }
  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_TEMP_BEST ] );

  pcYuvRec->addClip ( pcYuvPred, pcYuvResiBest, 0, cuWidthPixels, sps.getBitDepths() );

  // update with clipped distortion and cost (previously unclipped reconstruction values were used)

  Distortion finalDistortion = 0;
  for(Int comp=0; comp<numValidComponents; comp++)
  {
    const ComponentID compID=ComponentID(comp);
    finalDistortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID ), pcYuvRec->getStride(compID ), pcYuvOrg->getAddr(compID ), pcYuvOrg->getStride(compID), cuWidthPixels >> pcYuvOrg->getComponentScaleX(compID), cuHeightPixels >> pcYuvOrg->getComponentScaleY(compID), compID);
  }

  pcCU->getTotalBits()       = finalBits;
  pcCU->getTotalDistortion() = finalDistortion;
  pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( finalBits, finalDistortion );
}



Void TEncSearch::xEstimateInterResidualQT( TComYuv    *pcResi,
                                           Double     &rdCost,
                                           UInt       &ruiBits,
                                           Distortion &ruiDist,
                                           Distortion *puiZeroDist,
                                           TComTU     &rTu
                                           DEBUG_STRING_FN_DECLARE(sDebug) )
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiDepth      = rTu.GetTransformDepthTotal();
  const UInt uiTrMode     = rTu.GetTransformDepthRel();
  const UInt subTUDepth   = uiTrMode + 1;
  const UInt numValidComp = pcCU->getPic()->getNumberValidComponents();
  DEBUG_STRING_NEW(sSingleStringComp[MAX_NUM_COMPONENT])

  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  UInt SplitFlag = ((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && pcCU->isInter(uiAbsPartIdx) && ( pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N ));
#if DEBUG_STRING
  const Int debugPredModeMask = DebugStringGetPredModeMask(pcCU->getPredictionMode(uiAbsPartIdx));
#endif

  Bool bCheckFull;

  if ( SplitFlag && uiDepth == pcCU->getDepth(uiAbsPartIdx) && ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) ) )
  {
    bCheckFull = false;
  }
  else
  {
    bCheckFull =  ( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
  }

  const Bool bCheckSplit  = ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

  assert( bCheckFull || bCheckSplit );

  // code full block
  Double     dSingleCost = MAX_DOUBLE;
  UInt       uiSingleBits                                                                                                        = 0;
  Distortion uiSingleDistComp            [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  Distortion uiSingleDist                                                                                                        = 0;
  TCoeff     uiAbsSum                    [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  UInt       uiBestTransformMode         [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  //  Stores the best explicit RDPCM mode for a TU encoded without split
  UInt       bestExplicitRdpcmModeUnSplit[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{3,3}, {3,3}, {3,3}};
  SChar      bestCrossCPredictionAlpha   [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};

  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );

  if( bCheckFull )
  {
    Double minCost[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/];
    Bool checkTransformSkip[MAX_NUM_COMPONENT];
    pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

    m_pcEntropyCoder->resetBits();

    memset( m_pTempPel, 0, sizeof( Pel ) * rTu.getRect(COMPONENT_Y).width * rTu.getRect(COMPONENT_Y).height ); // not necessary needed for inside of recursion (only at the beginning)

    const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    TCoeff *pcCoeffCurr[MAX_NUM_COMPONENT];
#if ADAPTIVE_QP_SELECTION
    TCoeff *pcArlCoeffCurr[MAX_NUM_COMPONENT];
#endif

    for(UInt i=0; i<numValidComp; i++)
    {
      minCost[i][0] = MAX_DOUBLE;
      minCost[i][1] = MAX_DOUBLE;
    }

    Pel crossCPredictedResidualBuffer[ MAX_TU_SIZE * MAX_TU_SIZE ];

    for(UInt i=0; i<numValidComp; i++)
    {
      checkTransformSkip[i]=false;
      const ComponentID compID=ComponentID(i);
      const Int channelBitDepth=pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
      pcCoeffCurr[compID]    = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
#if ADAPTIVE_QP_SELECTION
      pcArlCoeffCurr[compID] = m_ppcQTTempArlCoeff[compID ][uiQTTempAccessLayer] +  rTu.getCoefficientOffset(compID);
#endif

      if(rTu.ProcessComponentSection(compID))
      {
        const QpParam cQP(*pcCU, compID);

        checkTransformSkip[compID] = pcCU->getSlice()->getPPS()->getUseTransformSkip() &&
                                     TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(compID), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize()) &&
                                     (!pcCU->isLosslessCoded(0));

        const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

        TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

        const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

        do
        {
          const UInt           subTUIndex             = TUIterator.GetSectionNumber();
          const UInt           subTUAbsPartIdx        = TUIterator.GetAbsPartIdxTU(compID);
          const TComRectangle &tuCompRect             = TUIterator.getRect(compID);
          const UInt           subTUBufferOffset      = tuCompRect.width * tuCompRect.height * subTUIndex;

                TCoeff        *currentCoefficients    = pcCoeffCurr[compID] + subTUBufferOffset;
#if ADAPTIVE_QP_SELECTION
                TCoeff        *currentARLCoefficients = pcArlCoeffCurr[compID] + subTUBufferOffset;
#endif
          const Bool isCrossCPredictionAvailable      =    isChroma(compID)
                                                         && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                         && (pcCU->getCbf(subTUAbsPartIdx, COMPONENT_Y, uiTrMode) != 0);

          SChar preCalcAlpha = 0;
          const Pel *pLumaResi = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( COMPONENT_Y, rTu.getRect( COMPONENT_Y ).x0, rTu.getRect( COMPONENT_Y ).y0 );

          if (isCrossCPredictionAvailable)
          {
            const Bool bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
            const Pel  *const lumaResidualForEstimate       = bUseReconstructedResidualForEstimate ? pLumaResi                                                     : pcResi->getAddrPix(COMPONENT_Y, tuCompRect.x0, tuCompRect.y0);
            const UInt        lumaResidualStrideForEstimate = bUseReconstructedResidualForEstimate ? m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y) : pcResi->getStride(COMPONENT_Y);

            preCalcAlpha = xCalcCrossComponentPredictionAlpha(TUIterator,
                                                              compID,
                                                              lumaResidualForEstimate,
                                                              pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                              tuCompRect.width,
                                                              tuCompRect.height,
                                                              lumaResidualStrideForEstimate,
                                                              pcResi->getStride(compID));
          }

          const Int transformSkipModesToTest    = checkTransformSkip[compID] ? 2 : 1;
          const Int crossCPredictionModesToTest = (preCalcAlpha != 0)        ? 2 : 1; // preCalcAlpha cannot be anything other than 0 if isCrossCPredictionAvailable is false

          const Bool isOneMode                  = (crossCPredictionModesToTest == 1) && (transformSkipModesToTest == 1);

          for (Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
          {
            pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);

            for (Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
            {
              const Bool isFirstMode          = (transformSkipModeId == 0) && (crossCPredictionModeId == 0);
              const Bool bUseCrossCPrediction = crossCPredictionModeId != 0;

              m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
              m_pcEntropyCoder->resetBits();

              pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);
              pcCU->setCrossComponentPredictionAlphaPartRange((bUseCrossCPrediction ? preCalcAlpha : 0), compID, subTUAbsPartIdx, partIdxesPerSubTU );

              if ((compID != COMPONENT_Cr) && ((transformSkipModeId == 1) ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ()))
              {
                m_pcEntropyCoder->estimateBit(m_pcTrQuant->m_pcEstBitsSbac, tuCompRect.width, tuCompRect.height, toChannelType(compID));
              }

#if RDOQ_CHROMA_LAMBDA
              m_pcTrQuant->selectLambda(compID);
#endif

              Pel *pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
              UInt resiStride     = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);

              TCoeff bestCoeffComp   [MAX_TU_SIZE*MAX_TU_SIZE];
              Pel    bestResiComp    [MAX_TU_SIZE*MAX_TU_SIZE];

#if ADAPTIVE_QP_SELECTION
              TCoeff bestArlCoeffComp[MAX_TU_SIZE*MAX_TU_SIZE];
#endif
              TCoeff     currAbsSum   = 0;
              UInt       currCompBits = 0;
              Distortion currCompDist = 0;
              Double     currCompCost = 0;
              UInt       nonCoeffBits = 0;
              Distortion nonCoeffDist = 0;
              Double     nonCoeffCost = 0;

              if(!isOneMode && !isFirstMode)
              {
                memcpy(bestCoeffComp,    currentCoefficients,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(bestArlCoeffComp, currentARLCoefficients, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for(Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy(&bestResiComp[y * tuCompRect.width], (pcResiCurrComp + (y * resiStride)), (sizeof(Pel) * tuCompRect.width));
                }
              }

              if (bUseCrossCPrediction)
              {
                TComTrQuant::crossComponentPrediction(TUIterator,
                                                      compID,
                                                      pLumaResi,
                                                      pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                      crossCPredictedResidualBuffer,
                                                      tuCompRect.width,
                                                      tuCompRect.height,
                                                      m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                      pcResi->getStride(compID),
                                                      tuCompRect.width,
                                                      false);

                m_pcTrQuant->transformNxN(TUIterator, compID, crossCPredictedResidualBuffer, tuCompRect.width, currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }
              else
              {
                m_pcTrQuant->transformNxN(TUIterator, compID, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ), pcResi->getStride(compID), currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }

              if(isFirstMode || (currAbsSum == 0))
              {
                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pTempPel,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        tuCompRect.width,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        true);

                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride( compID ), pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }
                else
                {
                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pTempPel, tuCompRect.width, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }

                m_pcEntropyCoder->encodeQtCbfZero( TUIterator, toChannelType(compID) );

                if ( isCrossCPredictionAvailable )
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                nonCoeffBits = m_pcEntropyCoder->getNumberOfWrittenBits();
                nonCoeffCost = m_pcRdCost->calcRdCost( nonCoeffBits, nonCoeffDist );
              }

              if((puiZeroDist != NULL) && isFirstMode)
              {
                *puiZeroDist += nonCoeffDist; // initialized with zero residual distortion
              }

              DEBUG_STRING_NEW(sSingleStringTest)

              if( currAbsSum > 0 ) //if non-zero coefficients are present, a residual needs to be derived for further prediction
              {
                if (isFirstMode)
                {
                  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
                  m_pcEntropyCoder->resetBits();
                }

                m_pcEntropyCoder->encodeQtCbf( TUIterator, compID, true );

                if (isCrossCPredictionAvailable)
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                m_pcEntropyCoder->encodeCoeffNxN( TUIterator, currentCoefficients, compID );
                currCompBits = m_pcEntropyCoder->getNumberOfWrittenBits();

                pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 );

                m_pcTrQuant->invTransformNxN( TUIterator, compID, pcResiCurrComp, m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID), currentCoefficients, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sSingleStringTest, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );

                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        true);
                }

                currCompDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        pcResi->getStride(compID),
                                                        tuCompRect.width, tuCompRect.height, compID);

                currCompCost = m_pcRdCost->calcRdCost(currCompBits, currCompDist);
                  
                if (pcCU->isLosslessCoded(0))
                {
                  nonCoeffCost = MAX_DOUBLE;
                }
              }
              else if ((transformSkipModeId == 1) && !bUseCrossCPrediction)
              {
                currCompCost = MAX_DOUBLE;
              }
              else
              {
                currCompBits = nonCoeffBits;
                currCompDist = nonCoeffDist;
                currCompCost = nonCoeffCost;
              }

              // evaluate
              if ((currCompCost < minCost[compID][subTUIndex]) || ((transformSkipModeId == 1) && (currCompCost == minCost[compID][subTUIndex])))
              {
                bestExplicitRdpcmModeUnSplit[compID][subTUIndex] = pcCU->getExplicitRdpcmMode(compID, subTUAbsPartIdx);

                if(isFirstMode) //check for forced null
                {
                  if((nonCoeffCost < currCompCost) || (currAbsSum == 0))
                  {
                    memset(currentCoefficients, 0, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));

                    currAbsSum   = 0;
                    currCompBits = nonCoeffBits;
                    currCompDist = nonCoeffDist;
                    currCompCost = nonCoeffCost;
                  }
                }

#if DEBUG_STRING
                if (currAbsSum > 0)
                {
                  DEBUG_STRING_SWAP(sSingleStringComp[compID], sSingleStringTest)
                }
                else
                {
                  sSingleStringComp[compID].clear();
                }
#endif

                uiAbsSum                 [compID][subTUIndex] = currAbsSum;
                uiSingleDistComp         [compID][subTUIndex] = currCompDist;
                minCost                  [compID][subTUIndex] = currCompCost;
                uiBestTransformMode      [compID][subTUIndex] = transformSkipModeId;
                bestCrossCPredictionAlpha[compID][subTUIndex] = (crossCPredictionModeId == 1) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;

                if (uiAbsSum[compID][subTUIndex] == 0)
                {
                  if (bUseCrossCPrediction)
                  {
                    TComTrQuant::crossComponentPrediction(TUIterator,
                                                          compID,
                                                          pLumaResi,
                                                          m_pTempPel,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                          tuCompRect.width,
                                                          tuCompRect.height,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                          tuCompRect.width,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                          true);
                  }
                  else
                  {
                    pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
                    const UInt uiStride = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);
                    for(UInt uiY = 0; uiY < tuCompRect.height; uiY++)
                    {
                      memset(pcResiCurrComp, 0, (sizeof(Pel) * tuCompRect.width));
                      pcResiCurrComp += uiStride;
                    }
                  }
                }
              }
              else
              {
                // reset
                memcpy(currentCoefficients,    bestCoeffComp,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(currentARLCoefficients, bestArlCoeffComp, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for (Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy((pcResiCurrComp + (y * resiStride)), &bestResiComp[y * tuCompRect.width], (sizeof(Pel) * tuCompRect.width));
                }
              }
            }
          }

          pcCU->setExplicitRdpcmModePartRange            (   bestExplicitRdpcmModeUnSplit[compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU);
          pcCU->setTransformSkipPartRange                (   uiBestTransformMode         [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCbfPartRange                          ((((uiAbsSum                    [compID][subTUIndex] > 0) ? 1 : 0) << uiTrMode), compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCrossComponentPredictionAlphaPartRange(   bestCrossCPredictionAlpha   [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
        } while (TUIterator.nextSection(rTu)); //end of sub-TU loop
      } // processing section
    } // component loop

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      if (rTu.ProcessComponentSection(compID) && (rTu.getRect(compID).width != rTu.getRect(compID).height))
      {
        offsetSubTUCBFs(rTu, compID); //the CBFs up to now have been defined for two sub-TUs - shift them down a level and replace with the parent level CBF
      }
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    if( uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( 0, 5 - uiLog2TrSize );
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const UInt chOrderChange = ((ch + 1) == numValidComp) ? 0 : (ch + 1);
      const ComponentID compID=ComponentID(chOrderChange);
      if( rTu.ProcessComponentSection(compID) )
      {
        m_pcEntropyCoder->encodeQtCbf( rTu, compID, true );
      }
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if (rTu.ProcessComponentSection(compID))
      {
        if(isChroma(compID) && (uiAbsSum[COMPONENT_Y][0] != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, compID );
        }

        m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr[compID], compID );
        for (UInt subTUIndex = 0; subTUIndex < 2; subTUIndex++)
        {
          uiSingleDist += uiSingleDistComp[compID][subTUIndex];
        }
      }
    }

    uiSingleBits = m_pcEntropyCoder->getNumberOfWrittenBits();

    dSingleCost = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDist );
  } // check full

  // code sub-blocks
  if( bCheckSplit )
  {
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    Distortion uiSubdivDist = 0;
    UInt       uiSubdivBits = 0;
    Double     dSubdivCost = 0.0;

    //save the non-split CBFs in case we need to restore them later

    UInt bestCBF     [MAX_NUM_COMPONENT];
    UInt bestsubTUCBF[MAX_NUM_COMPONENT][2];
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);

      if (rTu.ProcessComponentSection(compID))
      {
        bestCBF[compID] = pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode);

        const TComRectangle &tuCompRect = rTu.getRect(compID);
        if (tuCompRect.width != tuCompRect.height)
        {
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

          for (UInt subTU = 0; subTU < 2; subTU++)
          {
            bestsubTUCBF[compID][subTU] = pcCU->getCbf ((uiAbsPartIdx + (subTU * partIdxesPerSubTU)), compID, subTUDepth);
          }
        }
      }
    }


    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiQPartNumSubdiv = tuRecurseChild.GetAbsPartIdxNumParts();

    DEBUG_STRING_NEW(sSplitString[MAX_NUM_COMPONENT])

    do
    {
      DEBUG_STRING_NEW(childString)
      xEstimateInterResidualQT( pcResi, dSubdivCost, uiSubdivBits, uiSubdivDist, bCheckFull ? NULL : puiZeroDist,  tuRecurseChild DEBUG_STRING_PASS_INTO(childString));
#if DEBUG_STRING
      // split the string by component and append to the relevant output (because decoder decodes in channel order, whereas this search searches by TU-order)
      std::size_t lastPos=0;
      const std::size_t endStrng=childString.find(debug_reorder_data_inter_token[MAX_NUM_COMPONENT], lastPos);
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        if (lastPos!=std::string::npos && childString.find(debug_reorder_data_inter_token[ch], lastPos)==lastPos)
        {
          lastPos+=strlen(debug_reorder_data_inter_token[ch]); // skip leading string
        }
        std::size_t pos=childString.find(debug_reorder_data_inter_token[ch+1], lastPos);
        if (pos!=std::string::npos && pos>endStrng)
        {
          lastPos=endStrng;
        }
        sSplitString[ch]+=childString.substr(lastPos, (pos==std::string::npos)? std::string::npos : (pos-lastPos) );
        lastPos=pos;
      }
#endif
    } while ( tuRecurseChild.nextSection(rTu) ) ;

    UInt uiCbfAny=0;
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      UInt uiYUVCbf = 0;
      for( UInt ui = 0; ui < 4; ++ui )
      {
        uiYUVCbf |= pcCU->getCbf( uiAbsPartIdx + ui * uiQPartNumSubdiv, ComponentID(ch),  uiTrMode + 1 );
      }
      UChar *pBase=pcCU->getCbf( ComponentID(ch) );
      const UInt flags=uiYUVCbf << uiTrMode;
      for( UInt ui = 0; ui < 4 * uiQPartNumSubdiv; ++ui )
      {
        pBase[uiAbsPartIdx + ui] |= flags;
      }
      uiCbfAny|=uiYUVCbf;
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    // when compID isn't a channel, code Cbfs:
    xEncodeInterResidualQT( MAX_NUM_COMPONENT, rTu );
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      xEncodeInterResidualQT( ComponentID(ch), rTu );
    }

    uiSubdivBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    dSubdivCost  = m_pcRdCost->calcRdCost( uiSubdivBits, uiSubdivDist );

    if (!bCheckFull || (uiCbfAny && (dSubdivCost < dSingleCost)))
    {
      rdCost += dSubdivCost;
      ruiBits += uiSubdivBits;
      ruiDist += uiSubdivDist;
#if DEBUG_STRING
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        DEBUG_STRING_APPEND(sDebug, sSplitString[ch])
      }
#endif
    }
    else
    {
      rdCost  += dSingleCost;
      ruiBits += uiSingleBits;
      ruiDist += uiSingleDist;

      //restore state to unsplit

      pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        const ComponentID compID=ComponentID(ch);

        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        if (rTu.ProcessComponentSection(compID))
        {
          DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])

          const Bool splitIntoSubTUs   = rTu.getRect(compID).width != rTu.getRect(compID).height;
          const UInt numberOfSections  = splitIntoSubTUs ? 2 : 1;
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> (splitIntoSubTUs ? 1 : 0);

          for (UInt subTUIndex = 0; subTUIndex < numberOfSections; subTUIndex++)
          {
            const UInt  uisubTUPartIdx = uiAbsPartIdx + (subTUIndex * partIdxesPerSubTU);

            if (splitIntoSubTUs)
            {
              const UChar combinedCBF = (bestsubTUCBF[compID][subTUIndex] << subTUDepth) | (bestCBF[compID] << uiTrMode);
              pcCU->setCbfPartRange(combinedCBF, compID, uisubTUPartIdx, partIdxesPerSubTU);
            }
            else
            {
              pcCU->setCbfPartRange((bestCBF[compID] << uiTrMode), compID, uisubTUPartIdx, partIdxesPerSubTU);
            }

            pcCU->setCrossComponentPredictionAlphaPartRange(bestCrossCPredictionAlpha[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setTransformSkipPartRange(uiBestTransformMode[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setExplicitRdpcmModePartRange(bestExplicitRdpcmModeUnSplit[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
          }
        }
      }

      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
    }
  }
  else
  {
    rdCost  += dSingleCost;
    ruiBits += uiSingleBits;
    ruiDist += uiSingleDist;
#if DEBUG_STRING
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[compID])

      if (rTu.ProcessComponentSection(compID))
      {
        DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])
      }
    }
#endif
  }
  DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[MAX_NUM_COMPONENT])
}



Void TEncSearch::xEncodeInterResidualQT( const ComponentID compID, TComTU &rTu )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  const UInt uiCurrTrMode = rTu.GetTransformDepthRel();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );

  const Bool bSubdiv = uiCurrTrMode != uiTrMode;

  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  if (compID==MAX_NUM_COMPONENT)  // we are not processing a channel, instead we always recurse and code the CBFs
  {
    if( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() && uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      if((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && (pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N))
      {
        assert(bSubdiv); // Inferred splitting rule - see derivation and use of interSplitFlag in the specification.
      }
      else
      {
        m_pcEntropyCoder->encodeTransformSubdivFlag( bSubdiv, 5 - uiLog2TrSize );
      }
    }

    assert( !pcCU->isIntra(uiAbsPartIdx) );

    const Bool bFirstCbfOfCU = uiCurrTrMode == 0;

    for (UInt ch=COMPONENT_Cb; ch<pcCU->getPic()->getNumberValidComponents(); ch++)
    {
      const ComponentID compIdInner=ComponentID(ch);
      if( bFirstCbfOfCU || rTu.ProcessingAllQuadrants(compIdInner) )
      {
        if( bFirstCbfOfCU || pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) )
        {
          m_pcEntropyCoder->encodeQtCbf( rTu, compIdInner, !bSubdiv );
        }
      }
      else
      {
        assert( pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode ) == pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) );
      }
    }

    if (!bSubdiv)
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }

  if( !bSubdiv )
  {
    if (compID != MAX_NUM_COMPONENT) // we have already coded the CBFs, so now we code coefficients
    {
      if (rTu.ProcessComponentSection(compID))
      {
        if (isChroma(compID) && (pcCU->getCbf(uiAbsPartIdx, COMPONENT_Y, uiTrMode) != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction(rTu, compID);
        }

        if (pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode) != 0)
        {
          const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
          TCoeff *pcCoeffCurr = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
          m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr, compID );
        }
      }
    }
  }
  else
  {
    if( compID==MAX_NUM_COMPONENT || pcCU->getCbf( uiAbsPartIdx, compID, uiCurrTrMode ) )
    {
      TComTURecurse tuRecurseChild(rTu, false);
      do
      {
        xEncodeInterResidualQT( compID, tuRecurseChild );
      } while (tuRecurseChild.nextSection(rTu));
    }
  }
}




Void TEncSearch::xSetInterResidualQTData( TComYuv* pcResi, Bool bSpatial, TComTU &rTu ) // TODO: turn this into two functions for bSpatial=true and false.
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiCurrTrMode=rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );
  const TComSPS *sps=pcCU->getSlice()->getSPS();

  if( uiCurrTrMode == uiTrMode )
  {
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTTempAccessLayer = sps->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if( bSpatial )
    {
      // Data to be copied is in the spatial domain, i.e., inverse-transformed.

      for(UInt i=0; i<pcResi->getNumberValidComponents(); i++)
      {
        const ComponentID compID=ComponentID(i);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          m_pcQTTempTComYuv[uiQTTempAccessLayer].copyPartToPartComponentMxN    ( compID, pcResi, rectCompTU );
        }
      }
    }
    else
    {
      for (UInt ch=0; ch < getNumberValidComponents(sps->getChromaFormatIdc()); ch++)
      {
        const ComponentID compID   = ComponentID(ch);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          const UInt numCoeffInBlock    = rectCompTU.width * rectCompTU.height;
          const UInt offset             = rTu.getCoefficientOffset(compID);
          TCoeff* dest                  = pcCU->getCoeff(compID)                        + offset;
          const TCoeff* src             = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + offset;
          ::memcpy( dest, src, sizeof(TCoeff)*numCoeffInBlock );

#if ADAPTIVE_QP_SELECTION
          TCoeff* pcArlCoeffSrc            = m_ppcQTTempArlCoeff[compID][uiQTTempAccessLayer] + offset;
          TCoeff* pcArlCoeffDst            = pcCU->getArlCoeff(compID)                        + offset;
          ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * numCoeffInBlock );
#endif
        }
      }
    }
  }
  else
  {

    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetInterResidualQTData( pcResi, bSpatial, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}




UInt TEncSearch::xModeBitsIntra( TComDataCU* pcCU, UInt uiMode, UInt uiPartOffset, UInt uiDepth, const ChannelType chType )
{
  // Reload only contexts required for coding intra mode information
  m_pcRDGoOnSbacCoder->loadIntraDirMode( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST], chType );

  // Temporarily set the intra dir being tested, and only
  // for absPartIdx, since encodeIntraDirModeLuma/Chroma only use
  // the entry at absPartIdx.

  UChar &rIntraDirVal=pcCU->getIntraDir( chType )[uiPartOffset];
  UChar origVal=rIntraDirVal;
  rIntraDirVal = uiMode;
  //pcCU->setIntraDirSubParts ( chType, uiMode, uiPartOffset, uiDepth + uiInitTrDepth );

  m_pcEntropyCoder->resetBits();
  if (isLuma(chType))
  {
    m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiPartOffset);
  }
  else
  {
    m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiPartOffset);
  }

  rIntraDirVal = origVal; // restore

  return m_pcEntropyCoder->getNumberOfWrittenBits();
}




UInt TEncSearch::xUpdateCandList( UInt uiMode, Double uiCost, UInt uiFastCandNum, UInt * CandModeList, Double * CandCostList )
{
  UInt i;
  UInt shift=0;

  while ( shift<uiFastCandNum && uiCost<CandCostList[ uiFastCandNum-1-shift ] )
  {
    shift++;
  }

  if( shift!=0 )
  {
    for(i=1; i<shift; i++)
    {
      CandModeList[ uiFastCandNum-i ] = CandModeList[ uiFastCandNum-1-i ];
      CandCostList[ uiFastCandNum-i ] = CandCostList[ uiFastCandNum-1-i ];
    }
    CandModeList[ uiFastCandNum-shift ] = uiMode;
    CandCostList[ uiFastCandNum-shift ] = uiCost;
    return 1;
  }

  return 0;
}





/** add inter-prediction syntax elements for a CU block
 * \param pcCU
 * \param uiQp
 * \param uiTrMode
 * \param ruiBits
 * \returns Void
 */
Void  TEncSearch::xAddSymbolBitsInter( TComDataCU* pcCU, UInt& ruiBits )
{
  if(pcCU->getMergeFlag( 0 ) && pcCU->getPartitionSize( 0 ) == SIZE_2Nx2N && !pcCU->getQtRootCbf( 0 ))
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    m_pcEntropyCoder->resetBits();
    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }
    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex(pcCU, 0, true);

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
  else
  {
    m_pcEntropyCoder->resetBits();

    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag ( pcCU, 0, true );
    m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
    m_pcEntropyCoder->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );
    m_pcEntropyCoder->encodePredInfo( pcCU, 0 );

    Bool codeDeltaQp = false;
    Bool codeChromaQpAdj = false;
    m_pcEntropyCoder->encodeCoeff   ( pcCU, 0, pcCU->getDepth(0), codeDeltaQp, codeChromaQpAdj );

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
}





/**
 * \brief Generate half-sample interpolated block
 *
 * \param pattern Reference picture ROI
 * \param biPred    Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingH( TComPattern* pattern )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;
  Int halfFilterSize = (filterSize>>1);
  Pel *srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[0].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 0, false, chFmt, pattern->getBitDepthY());
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[2].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 2, false, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + halfFilterSize * intStride + 1;
  dstPtr = m_filteredBlock[0][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
  dstPtr = m_filteredBlock[2][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+1, 2, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
  dstPtr = m_filteredBlock[0][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[2][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+1, 2, false, true, chFmt, pattern->getBitDepthY());
}





/**
 * \brief Generate quarter-sample interpolated blocks
 *
 * \param pattern    Reference picture ROI
 * \param halfPelRef Half-pel mv
 * \param biPred     Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingQ( TComPattern* pattern, TComMv halfPelRef )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Pel *srcPtr;
  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;

  Int halfFilterSize = (filterSize>>1);

  Int extHeight = (halfPelRef.getVer() == 0) ? height + filterSize : height + filterSize-1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  // Horizontal filter 1/4
  srcPtr = pattern->getROIY() - halfFilterSize * srcStride - 1;
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() >= 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 1, false, chFmt, pattern->getBitDepthY());

  // Horizontal filter 3/4
  srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() > 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 3, false, chFmt, pattern->getBitDepthY());

  // Generate @ 1,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][1].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());

  if (halfPelRef.getVer() != 0)
  {
    // Generate @ 2,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][1].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 2,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][3].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 0,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][1].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 0,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][3].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());
  }

  if (halfPelRef.getHor() != 0)
  {
    // Generate @ 1,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[1][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[3][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 1,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[1][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[3][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }

  // Generate @ 1,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][3].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
}





//! set wp tables
Void  TEncSearch::setWpScalingDistParam( TComDataCU* pcCU, Int iRefIdx, RefPicList eRefPicListCur )
{
  if ( iRefIdx<0 )
  {
    m_cDistParam.bApplyWeight = false;
    return;
  }

  TComSlice       *pcSlice  = pcCU->getSlice();
  WPScalingParam  *wp0 , *wp1;

  m_cDistParam.bApplyWeight = ( pcSlice->getSliceType()==P_SLICE && pcSlice->testWeightPred() ) || ( pcSlice->getSliceType()==B_SLICE && pcSlice->testWeightBiPred() ) ;

  if ( !m_cDistParam.bApplyWeight )
  {
    return;
  }

  Int iRefIdx0 = ( eRefPicListCur == REF_PIC_LIST_0 ) ? iRefIdx : (-1);
  Int iRefIdx1 = ( eRefPicListCur == REF_PIC_LIST_1 ) ? iRefIdx : (-1);

  getWpScaling( pcCU, iRefIdx0, iRefIdx1, wp0 , wp1 );

  if ( iRefIdx0 < 0 )
  {
    wp0 = NULL;
  }
  if ( iRefIdx1 < 0 )
  {
    wp1 = NULL;
  }

  m_cDistParam.wpCur  = NULL;

  if ( eRefPicListCur == REF_PIC_LIST_0 )
  {
    m_cDistParam.wpCur = wp0;
  }
  else
  {
    m_cDistParam.wpCur = wp1;
  }
}



//! \}
