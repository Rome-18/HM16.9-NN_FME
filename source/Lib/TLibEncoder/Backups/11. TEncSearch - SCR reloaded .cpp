/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2016, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     TEncSearch.cpp
 \brief    encoder search class
 */

#include "TLibCommon/CommonDef.h"
#include "TLibCommon/TComRom.h"
#include "TLibCommon/TComMotionInfo.h"
#include "TEncSearch.h"
#include "TLibCommon/TComTU.h"
#include "TLibCommon/Debug.h"
#include <math.h>
#include <limits>
#include <fstream>
#include <iostream>
#include <algorithm>


// EMI: Parameters declaration

signed short MVX_HALF, MVX_QRTER, MVY_HALF, MVY_QRTER = 0;
float  C, H1, H2, V1, V2, U1, U2, U3, U4;
long int array_e[100000];

float IN[17] = {};
float X1[22] = {};
float X2[20] = {};
float OUT[49] = {};
int N, NN_out, index_ref, counter_i, PUHeight, PUWidth, PIdx, PAddr;

/*
The next group of variables are all 1D and 2D arrays. The reason why I declared them as std::array is because that
way they can be assigned in a cleaner manner. These arrays are assigned values in TEncSearch::init() function depending
on the chosen Quantization Parameter
https://stackoverflow.com/questions/16059781/2d-array-value-assign-after-declaration-in-c for more info on 2D array assignment
*/
std::array<std::array<float,4>,8> embs0, embs1;
std::array<std::array<float,2>,3> embs2;
std::array<std::array<float,7>,14> embs3;
std::array<std::array<float,17>,22> in_h1;
std::array<std::array<float,22>,20> h1_h2;
std::array<std::array<float,20>,49> h2_out;
std::array<float ,22> b1, BN_gamma_1, BN_beta_1;
std::array<float ,20> b2, BN_gamma_2, BN_beta_2;
std::array<float ,49> bout;
std::array<float ,9> BN_gamma_in, mean, stdev;

// Helper Functions

float relu(float x){
	if (x>0)	{	return x; }
	else { return 0; }
}

float sigmoid(float x){
  return (1 / (1 + std::exp(-x)));
}

//end of modification


//! \ingroup TLibEncoder
//! \{

static const TComMv s_acMvRefineH[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static const TComMv s_acMvRefineQ[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static Void offsetSubTUCBFs(TComTU &rTu, const ComponentID compID)
{
        TComDataCU *pcCU              = rTu.getCU();
  const UInt        uiTrDepth         = rTu.GetTransformDepthRel();
  const UInt        uiAbsPartIdx      = rTu.GetAbsPartIdxTU(compID);
  const UInt        partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

  //move the CBFs down a level and set the parent CBF

  UChar subTUCBF[2];
  UChar combinedSubTUCBF = 0;

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);

    subTUCBF[subTU]   = pcCU->getCbf(subTUAbsPartIdx, compID, uiTrDepth);
    combinedSubTUCBF |= subTUCBF[subTU];
  }

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);
    const UChar compositeCBF = (subTUCBF[subTU] << 1) | combinedSubTUCBF;

    pcCU->setCbfPartRange((compositeCBF << uiTrDepth), compID, subTUAbsPartIdx, partIdxesPerSubTU);
  }
}


TEncSearch::TEncSearch()
: m_puhQTTempTrIdx(NULL)
, m_pcQTTempTComYuv(NULL)
, m_pcEncCfg (NULL)
, m_pcTrQuant (NULL)
, m_pcRdCost (NULL)
, m_pcEntropyCoder (NULL)
, m_iSearchRange (0)
, m_bipredSearchRange (0)
, m_motionEstimationSearchMethod (MESEARCH_FULL)
, m_pppcRDSbacCoder (NULL)
, m_pcRDGoOnSbacCoder (NULL)
, m_pTempPel (NULL)
, m_isInitialized (false)
{
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    m_ppcQTTempCoeff[ch]                           = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]                        = NULL;
#endif
    m_puhQTTempCbf[ch]                             = NULL;
    m_phQTTempCrossComponentPredictionAlpha[ch]    = NULL;
    m_pSharedPredTransformSkip[ch]                 = NULL;
    m_pcQTTempTUCoeff[ch]                          = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = NULL;
#endif
    m_puhQTTempTransformSkipFlag[ch]               = NULL;
  }

  for (Int i=0; i<MAX_NUM_REF_LIST_ADAPT_SR; i++)
  {
    memset (m_aaiAdaptSR[i], 0, MAX_IDX_ADAPT_SR * sizeof (Int));
  }
  for (Int i=0; i<AMVP_MAX_NUM_CANDS+1; i++)
  {
    memset (m_auiMVPIdxCost[i], 0, (AMVP_MAX_NUM_CANDS+1) * sizeof (UInt) );
  }

  setWpScalingDistParam( NULL, -1, REF_PIC_LIST_X );
}


Void TEncSearch::destroy()
{
  assert (m_isInitialized);
  if ( m_pTempPel )
  {
    delete [] m_pTempPel;
    m_pTempPel = NULL;
  }

  if ( m_pcEncCfg )
  {
    const UInt uiNumLayersAllocated = m_pcEncCfg->getQuadtreeTULog2MaxSize()-m_pcEncCfg->getQuadtreeTULog2MinSize()+1;

    for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
    {
      for (UInt layer = 0; layer < uiNumLayersAllocated; layer++)
      {
        delete[] m_ppcQTTempCoeff[ch][layer];
#if ADAPTIVE_QP_SELECTION
        delete[] m_ppcQTTempArlCoeff[ch][layer];
#endif
      }
      delete[] m_ppcQTTempCoeff[ch];
      delete[] m_puhQTTempCbf[ch];
#if ADAPTIVE_QP_SELECTION
      delete[] m_ppcQTTempArlCoeff[ch];
#endif
    }

    for( UInt layer = 0; layer < uiNumLayersAllocated; layer++ )
    {
      m_pcQTTempTComYuv[layer].destroy();
    }
  }

  delete[] m_puhQTTempTrIdx;
  delete[] m_pcQTTempTComYuv;

  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    delete[] m_pSharedPredTransformSkip[ch];
    delete[] m_pcQTTempTUCoeff[ch];
#if ADAPTIVE_QP_SELECTION
    delete[] m_ppcQTTempTUArlCoeff[ch];
#endif
    delete[] m_phQTTempCrossComponentPredictionAlpha[ch];
    delete[] m_puhQTTempTransformSkipFlag[ch];
  }
  m_pcQTTempTransformSkipTComYuv.destroy();

  m_tmpYuvPred.destroy();
  m_isInitialized = false;
}

TEncSearch::~TEncSearch()
{
  if (m_isInitialized)
  {
    destroy();
  }
}




Void TEncSearch::init(TEncCfg*       pcEncCfg,
                      TComTrQuant*   pcTrQuant,
                      Int            iSearchRange,
                      Int            bipredSearchRange,
                      MESearchMethod motionEstimationSearchMethod,
                      const UInt     maxCUWidth,
                      const UInt     maxCUHeight,
                      const UInt     maxTotalCUDepth,
                      TEncEntropy*   pcEntropyCoder,
                      TComRdCost*    pcRdCost,
                      TEncSbac***    pppcRDSbacCoder,
                      TEncSbac*      pcRDGoOnSbacCoder
                      )
{
  assert (!m_isInitialized);
  m_pcEncCfg                     = pcEncCfg;
  m_pcTrQuant                    = pcTrQuant;
  m_iSearchRange                 = iSearchRange;
  m_bipredSearchRange            = bipredSearchRange;
  m_motionEstimationSearchMethod = motionEstimationSearchMethod;
  m_pcEntropyCoder               = pcEntropyCoder;
  m_pcRdCost                     = pcRdCost;

  m_pppcRDSbacCoder              = pppcRDSbacCoder;
  m_pcRDGoOnSbacCoder            = pcRDGoOnSbacCoder;
  
  for (UInt iDir = 0; iDir < MAX_NUM_REF_LIST_ADAPT_SR; iDir++)
  {
    for (UInt iRefIdx = 0; iRefIdx < MAX_IDX_ADAPT_SR; iRefIdx++)
    {
      m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange;
    }
  }

  // initialize motion cost
  for( Int iNum = 0; iNum < AMVP_MAX_NUM_CANDS+1; iNum++)
  {
    for( Int iIdx = 0; iIdx < AMVP_MAX_NUM_CANDS; iIdx++)
    {
      if (iIdx < iNum)
      {
        m_auiMVPIdxCost[iIdx][iNum] = xGetMvpIdxBits(iIdx, iNum);
      }
      else
      {
        m_auiMVPIdxCost[iIdx][iNum] = MAX_INT;
      }
    }
  }

  const ChromaFormat cform=pcEncCfg->getChromaFormatIdc();
  initTempBuff(cform);

  m_pTempPel = new Pel[maxCUWidth*maxCUHeight];

  const UInt uiNumLayersToAllocate = pcEncCfg->getQuadtreeTULog2MaxSize()-pcEncCfg->getQuadtreeTULog2MinSize()+1;
  const UInt uiNumPartitions = 1<<(maxTotalCUDepth<<1);
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    const UInt csx=::getComponentScaleX(ComponentID(ch), cform);
    const UInt csy=::getComponentScaleY(ComponentID(ch), cform);
    m_ppcQTTempCoeff[ch] = new TCoeff* [uiNumLayersToAllocate];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]  = new TCoeff*[uiNumLayersToAllocate];
#endif
    m_puhQTTempCbf[ch] = new UChar  [uiNumPartitions];

    for (UInt layer = 0; layer < uiNumLayersToAllocate; layer++)
    {
      m_ppcQTTempCoeff[ch][layer] = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy)];
#if ADAPTIVE_QP_SELECTION
      m_ppcQTTempArlCoeff[ch][layer]  = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy) ];
#endif
    }

    m_phQTTempCrossComponentPredictionAlpha[ch]    = new SChar  [uiNumPartitions];
    m_pSharedPredTransformSkip[ch]                 = new Pel   [MAX_CU_SIZE*MAX_CU_SIZE];
    m_pcQTTempTUCoeff[ch]                          = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#endif
    m_puhQTTempTransformSkipFlag[ch]               = new UChar [uiNumPartitions];
  }
  m_puhQTTempTrIdx   = new UChar  [uiNumPartitions];
  m_pcQTTempTComYuv  = new TComYuv[uiNumLayersToAllocate];
  for( UInt ui = 0; ui < uiNumLayersToAllocate; ++ui )
  {
    m_pcQTTempTComYuv[ui].create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  }
  m_pcQTTempTransformSkipTComYuv.create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  m_tmpYuvPred.create(MAX_CU_SIZE, MAX_CU_SIZE, pcEncCfg->getChromaFormatIdc());
  m_isInitialized = true;

  // EMI: Weights and Bias Initialization based on QP

  if(m_pcEncCfg->getQP() == 27){
    
    embs0 = {{
      {{0.25177416,-0.036222547,0.17589924,-0.035948217}},
      {{-0.0039288467,-0.009967148,0.00061845494,0.03391284}},
      {{0.0015507163,0.009595569,-0.00017507379,-0.004489012}},
      {{-0.08815347,0.022648545,0.027756015,0.028374994}},
      {{0.015098863,-0.030876251,-0.0019252484,-0.04009868}},
      {{-0.16063382,0.013880995,0.05471383,0.014029399}},
      {{-0.10455205,-0.020470828,0.04358833,-0.06525971}},
      {{-0.22582364,-0.09360033,-0.20402938,-0.20040235}}
    }};

    embs1 = {{
      {{-0.07178575,-0.0815168,0.14168933,-0.17563705}},
      {{-0.00096665643,0.0023496673,0.03617068,0.007223126}},
      {{0.0015105064,-0.00049548066,-0.0049202554,-0.007813423}},
      {{-0.09878103,0.04850585,0.028485555,-0.0064707277}},
      {{-0.004485716,-0.029146163,-0.039357327,0.02233457}},
      {{-0.10656375,-0.010653638,0.013093942,-0.012504869}},
      {{0.013660128,0.09716101,-0.06701876,0.034677967}},
      {{-0.026460808,0.14956445,-0.13144499,0.19771545}}
    }};

    in_h1 = {{
      {{-0.061569564,0.122774065,-0.10092519,-0.35533348,0.06969879,0.018857792,-0.38257462,-0.10065871,-0.28740093,0.07401767,0.5535343,0.8140032,-5.4626894,0.6981737,1.8398362,-0.24559167,0.27334565}},
      {{-0.030956754,-0.024635542,-0.0066128504,0.04287406,0.022998016,0.009549619,0.04281383,0.034808416,-1.4023836,-0.8180681,-1.568118,-1.2485976,-1.2989365,-1.0976391,-0.7168747,0.665966,-0.5519376}},
      {{0.012353755,0.0060795248,-0.00016455096,-0.022074256,0.028729618,-0.009146274,-0.020483393,-0.0369559,-1.6406218,0.41616207,1.4157829,0.16227601,0.47699848,0.4552019,2.7636611,0.07157448,-0.76940095}},
      {{0.44186205,0.8982489,-0.9599152,0.66895217,-1.5499299,-0.5818944,1.0426372,-1.1880968,0.76627636,2.0837908,1.4848974,-0.7076533,-1.180555,-0.43033352,0.047972035,1.2110351,0.37441286}},
      {{-0.068230174,-0.058734674,-0.039994616,-0.07011047,-0.08448859,0.061089747,-0.06354007,0.084252864,0.37383947,0.14087063,-2.3385966,0.68968123,-0.95149004,-2.386658,-0.19357422,-0.1528871,1.6453764}},
      {{0.1725091,0.22129957,0.3008047,-0.40786642,0.24941677,-0.12795839,-0.43376786,-0.30406788,-0.40993974,-0.018897904,-0.4699268,-2.1919253,-2.1960526,-0.5364589,0.17939185,0.49021313,-0.5633077}},
      {{-0.13767582,-0.087909386,-0.012940841,-0.09901078,-0.0046017645,0.12645297,-0.07841935,0.18336485,-0.5755393,0.53467345,0.8762725,0.1330643,2.1164584,-2.8529422,-0.7012518,0.50002867,-1.2403758}},
      {{0.37760478,0.584137,0.07268583,1.0132815,0.10425307,0.04646392,0.92215097,-0.4846582,0.04359794,0.15201753,0.58437145,-0.0464826,-7.6368017,-0.3956015,0.5379073,-0.36762598,0.2781859}},
      {{0.047158733,-0.0035117462,0.07474149,0.06293351,-0.00249085,-0.02723506,0.052001636,-0.025092535,-2.6494627,-1.1821086,0.40483823,-0.039356966,1.8969592,0.2860891,1.6568774,0.14425138,-0.5605433}},
      {{-0.0029356314,-0.022277413,-0.03948471,0.04515746,-0.060913656,-0.012453481,0.050874926,0.028446585,0.20101216,-3.082028,0.06393523,-0.062187053,0.34588128,-0.029329995,0.43734235,1.4800501,0.12301203}},
      {{0.004348134,0.02614145,-0.014594044,0.067264885,0.08966077,-0.009000899,0.064467594,-0.009902277,-0.1594805,0.01267139,-0.0854081,0.24956737,2.582992,0.18669957,-1.4902756,-2.7596586,-0.16066666}},
      {{0.03462007,0.020282501,0.025782742,0.026962714,0.038187694,-0.027546782,0.019958898,-0.050315537,0.69736576,-1.2040445,-2.6475122,-0.17239754,1.5150691,-0.40165472,-2.8452754,-0.3681949,1.3127513}},
      {{-0.07512009,-0.051008027,-0.016875748,-0.025967304,0.035241652,0.049271822,-0.028693723,0.094294555,-0.24675573,0.9193959,-1.1143146,-2.0651681,1.5659462,-1.7513473,-0.73139113,0.008040878,-0.42688265}},
      {{-0.012165237,-0.02641584,-0.008754455,-0.019284284,-0.05660089,0.0074568396,-0.01645174,0.028358521,-0.0040121973,2.8974328,-0.12369524,-0.07200214,0.09318358,-0.017152224,0.6767766,-2.1773977,0.08394191}},
      {{-0.11911343,0.028063467,0.020647537,0.29388186,0.018139293,0.12077846,0.28833967,0.015827077,-0.09994818,0.35860258,-0.14661013,0.06429436,7.4281616,-0.06967298,-0.09537334,-0.19967544,0.28947628}},
      {{-0.26694128,-0.21681888,0.1179356,-0.8642257,0.03871442,0.2855853,-0.8049037,0.34548363,0.40698865,0.36176148,0.06502176,1.04492,-1.9609675,-0.0508169,0.7143057,-0.57600987,0.293074}},
      {{1.209877,0.28955755,-0.20519035,1.7094101,0.13132343,-0.61369526,1.7051772,-0.45025826,0.2425122,-0.062218167,1.3263651,-0.11488888,7.0283656,0.6156361,0.4826262,-0.21352269,-0.43866512}},
      {{-0.007391724,-0.0044572437,-0.008129245,-0.0038706139,-0.011755523,0.0053600776,-0.004868139,0.0072189285,0.27786735,3.695977,1.1356672,-0.27254388,-1.6692615,-0.8172309,1.2697997,-0.24076632,0.50122446}},
      {{0.042864844,-0.078978725,-0.076828055,-0.12147091,-0.10711399,-0.048431918,-0.12112615,-0.054695398,0.8974056,1.6823366,-0.88762784,-0.888175,-2.3944626,1.9159318,-0.06491267,0.1375542,0.89990103}},
      {{0.029909052,0.073119536,0.0022920694,-0.040295564,0.021713234,-0.006019651,-0.04987379,-0.07469022,-0.064122885,0.32428217,-0.46651423,-2.3599963,2.3918183,1.22302,-0.6098848,-0.04091953,0.037384685}},
      {{0.018877866,-0.001980776,-0.00017978568,-0.0111099295,-0.0020392346,-0.016994294,-0.0099521475,-0.0029484916,-1.3651834,-0.5065605,-1.0150142,-1.1711577,2.7058573,-1.3384174,-0.84470195,-0.40699047,-1.4676565}},
      {{0.024946034,0.03213619,0.0064143525,-0.02090343,0.011205881,-0.016656112,-0.029372923,-0.05534313,-0.10923541,0.07914173,0.12693442,1.565237,0.028576976,-2.611292,-0.74958825,0.08724581,-0.04599796}}
    }};

    h1_h2 = {{
      {{-1.3906994,-3.5578208,-1.4019026,0.046629436,-1.4125978,0.676351,5.2388005,-0.22689402,0.4863456,-0.27571857,-0.6503289,-1.2644774,-1.2626585,-0.80997026,-0.40020183,-0.59956974,-0.46628907,0.067741215,-0.97094357,-3.1485808,1.9909576,1.134407}},
      {{0.108105406,4.6348157,-0.26985508,-0.8691695,0.20781319,0.9218722,0.17902464,1.3164041,-1.5569274,-0.2269251,-3.7290306,-0.6236399,-1.0177256,-2.453519,0.0748794,0.07886243,-0.2600229,1.7326429,0.20512348,-0.027157651,-4.805071,-0.07745433}},
      {{-0.25194892,2.3618417,0.57099086,-0.6084183,-1.7036362,0.050275594,-0.14913908,0.18440093,1.3860759,-1.250298,0.24465846,-6.1352825,0.31303647,-0.5764382,-0.047709357,0.3988247,-0.30123496,0.6892769,-0.58094513,-1.3619983,-3.9591856,0.53475857}},
      {{-0.23717062,1.7373753,0.61670387,-1.0847104,0.5668531,1.0391226,-1.2925675,1.3434411,-0.05474904,-0.3691493,0.50288767,0.98536795,1.808042,-1.9330797,-0.07159196,0.51650435,-0.083559565,-7.7213264,-0.0025953257,-0.105224706,-5.9533515,-0.21912193}},
      {{0.87965846,-0.041628677,-0.3466077,0.10383697,-0.585176,-0.33640596,-2.3034189,0.40889734,0.20888813,0.21437907,0.47601512,-1.1865304,-4.174665,-0.44227347,0.22603469,1.5792856,-0.22101107,0.28504726,-1.1984398,-2.7538245,1.7663968,-0.7401912}},
      {{0.6767815,-0.20201685,-0.2722028,-0.10453357,-3.0356817,-0.49868214,-1.6293018,-0.29177642,-0.91836286,-0.053064045,0.6495739,-1.5343667,-0.9767556,-0.11658624,0.4591992,0.41716376,-0.57126606,-0.026369072,0.9691946,-2.0458856,1.7738019,-2.9011579}},
      {{0.2426493,0.038953178,-0.31860575,0.06175327,0.18706791,-2.4096394,-0.87438405,-1.7491702,-3.280903,0.013345196,0.83382595,0.3288242,-0.90088034,0.13212878,0.30872357,-0.3327219,-0.65778697,0.1634304,-1.1328659,-4.884295,-0.06908583,0.5793439}},
      {{-0.8516253,-2.4820328,0.25520954,0.026624693,-0.5775327,-0.37634492,-1.4239072,-0.9151394,-0.21903177,-0.17172186,-0.06555058,-0.018740285,-0.82299715,-0.07973232,0.11084151,-0.2060489,-0.33115482,-0.063374564,0.56371003,0.3512051,3.233361,-8.0487175}},
      {{-0.40891308,1.0537637,-0.039124276,-0.902985,-0.3140353,1.1852394,0.32564172,1.8916341,-1.4080515,-0.99186844,1.0947105,-0.6152618,1.4376467,-2.2496123,-0.35166714,0.76960295,-0.38073316,0.8043863,0.13764624,0.023550175,-5.7343335,-0.022443043}},
      {{-0.05745457,-0.13654622,-0.37941945,-0.14992683,-0.2377545,0.049602564,0.677959,-0.45221242,-0.10956582,-0.095382035,0.15802403,-0.13344337,-0.03405485,-0.46333477,-0.5122415,-0.05203812,-0.008264851,-0.15133575,-0.386108,0.18102671,0.08228856,-0.3412083}},
      {{0.11022642,0.66767037,-0.061622296,-0.979434,0.03291167,0.18144163,-0.25224978,0.6041664,-1.0927936,-0.18506567,-0.533171,-0.27867755,-2.0473454,-0.99450123,0.04707147,0.0898016,-0.2350037,-5.285319,-0.21674569,-0.35381472,7.5487967,-0.101130195}},
      {{-3.1228476,1.1324323,-0.24721566,0.20395595,0.84675455,0.44582823,0.74085563,0.7018255,4.4931026,-0.96962506,0.26210594,0.95211965,1.6868422,0.40317038,-1.5046952,-0.59509873,-1.256601,-0.27745178,-1.0133538,0.58748317,-2.2622426,0.3021271}},
      {{0.49454263,4.2433577,-0.7853968,-0.48142236,0.65103054,1.0995344,-1.8637071,1.8202193,-1.3287048,-3.3642492,0.6892548,0.26595965,-3.1285906,0.2952615,0.34230834,0.8287573,-0.4578367,0.4234601,-0.6670478,0.23205087,-4.5560265,-0.6391227}},
      {{-0.116165675,0.41982964,0.05538902,-0.42939517,-0.026615083,-0.009296647,-0.5552804,0.31255254,-0.1313657,0.6840419,-2.969964,-0.05399105,-0.41423306,-6.367611,0.16116899,0.5123568,-0.4348092,0.45191073,-0.49169657,0.09379823,-2.9693668,-0.23344903}},
      {{1.1039406,0.23916295,-0.033677522,0.15830247,-0.28731233,-1.2392344,-1.5765443,0.42486733,-0.6205514,-0.012733973,-2.394347,-1.8008397,1.649193,-0.0024104367,-2.820448,-1.2412136,-0.20466156,-0.07273422,0.19381402,0.76044124,-1.183368,0.5562098}},
      {{0.3859257,2.4740765,-2.0298357,-0.83626163,-0.90477145,0.60923994,0.63829136,1.6082749,-2.1339,-1.2488513,-0.9646205,0.83629656,0.96459526,-2.1826086,-0.46606934,0.3629055,-0.5829434,-1.2044189,-0.12799528,-1.2272198,-6.1979628,-0.38255718}},
      {{0.4940686,-2.317285,-0.4943139,-0.012419115,-0.6708324,-2.106205,-1.2532029,2.3650937,-2.4687483,-0.061812904,0.57738805,-0.4690506,-3.0279303,0.29929826,-1.9464147,1.0632405,-1.2150145,-0.22401348,1.3466011,0.93199956,2.9268982,0.2222969}},
      {{-2.4493704,1.3574831,-0.7112547,-0.4743364,0.68886644,0.58972174,0.6743142,-0.20565112,-1.6141052,-1.9862444,0.16214547,-0.17492685,-1.707768,0.17021485,0.064627096,-0.8896132,-0.33261827,0.23613392,0.0060272645,0.34986266,6.9137444,0.26385424}},
      {{0.6031922,0.358764,-0.79011023,-1.0005015,0.56449395,0.25161642,0.5688104,1.9085717,-1.534347,0.84296215,-2.0034592,-0.28578243,-0.5678059,0.5540522,-3.0268378,-0.47063583,-0.77494097,0.69502753,0.4075534,-1.4048176,4.9620996,-0.24942045}},
      {{-0.9208601,1.3440858,-3.8428154,-1.0262246,0.28192022,0.2236234,-1.3877455,0.21331136,-3.0899034,-0.70127696,-0.94942594,0.96340746,1.1968635,-0.9837567,0.2447961,0.6625652,-0.3366258,0.31562868,1.2108177,-0.22137488,-2.9710023,-1.7335837}}
    }};

    h2_out = {{
      {{0.9696203,-0.8938026,0.95222485,-1.0216738,-0.20561159,0.104802735,-2.448042,0.5267557,0.31382078,1.4844536,0.05425533,-8.004914,-1.4781302,-0.13149609,0.023009518,-3.1267855,-3.8541963,-0.56548333,-1.2367866,-5.7030377}},
      {{0.82626027,-2.495569,1.0229567,0.46608618,0.30866954,0.5729905,-0.95249236,1.3619244,-0.61939865,1.1019686,0.80123925,-5.42909,-1.8911076,0.3656081,-0.9686595,-0.96855,-2.805368,-1.5933573,-2.6451716,-5.0669923}},
      {{0.3684765,-3.5910583,0.62066865,1.1060541,0.61567986,0.72653836,-0.38001183,0.7083993,-1.624598,0.52108645,2.8030097,-4.307063,-2.2001598,1.0338064,0.06220168,-0.62891024,-0.4916415,-2.322567,-2.7844841,-2.4649923}},
      {{-0.14248183,-3.4085634,-0.22090419,1.7698301,0.7202712,0.46285653,-0.20154034,-0.5379121,-1.9733984,0.087119274,3.1540287,-4.0744724,-1.8832604,0.44596735,0.92650163,-0.06052509,0.5882293,-0.5630999,-1.1345364,0.17938654}},
      {{-0.01988016,-2.179846,-3.0919652,1.4367689,0.44013605,-1.109883,1.1893289,-0.28557703,-2.5044415,0.6409606,3.365448,-5.1187954,-0.82131356,0.5398678,-1.4970654,1.4426802,-0.35249284,-0.82089764,-2.509242,0.63540566}},
      {{1.7410167,-0.9258734,-5.309526,0.49337336,-0.6253273,-1.6259812,1.4950042,-0.074032344,-1.5641737,0.7364634,1.3999656,-4.6636887,0.12214979,-0.0016033594,-3.0938306,0.90133405,-1.3731984,-0.61816955,-1.2222207,0.59222704}},
      {{1.4646215,-0.20238689,-5.753962,-0.9985308,-1.9428576,-3.4898689,0.37367362,-0.152654,-0.4237166,1.4839542,1.3465308,-7.195416,0.11198368,-0.16202118,-2.8906617,0.75562227,-0.3848335,-0.1878631,-0.2233659,0.5033709}},
      {{1.1946068,0.2400393,0.69790655,-1.4728023,-2.6460555,-0.116335176,-1.9687154,0.75969875,0.5502344,1.2697086,-1.1929082,-5.3581014,-1.4645622,1.0698904,0.4269414,-2.4142542,-4.609738,0.24919477,-1.8034425,-4.115117}},
      {{0.6671766,-0.5069919,0.8261893,0.1076109,-0.0713152,0.3394519,-1.7322613,1.4032477,-0.41265595,0.3441968,-0.6408424,1.9230651,-1.3169559,1.084338,-0.8459554,2.806538,-4.246584,-0.8878437,-2.3151314,-2.7262356}},
      {{0.6407256,-1.3952599,0.37824717,-0.042418435,0.3403217,0.8735434,-0.8136008,0.88527584,-0.8770937,0.3922336,1.4460377,-0.5850396,-2.0063925,1.3864408,-0.7229896,1.99627,-1.318269,-1.2806281,-4.1263657,-1.0656785}},
      {{0.12042351,-1.4789279,-0.075243555,1.7633761,0.7053646,0.39103442,0.0674085,-0.363392,-1.1175219,-0.3043772,1.3302963,1.6459814,-2.3379233,1.3852713,0.6517859,1.3426981,0.5739774,-0.94101715,-3.2562044,0.2926329}},
      {{0.62520754,-0.85672414,-1.8472762,-0.42632687,0.22706988,-1.3889385,1.2687417,-0.16420726,-0.77090526,0.33135518,2.0183032,-1.235025,-0.86360556,1.1566366,-1.1141801,1.7741063,-1.3241287,-1.1042262,-3.013607,0.36977106}},
      {{2.1296327,0.09867171,-2.8856645,0.15414986,-1.604573,-2.710096,1.4436533,-0.28523755,-0.9245444,0.15970781,0.20708033,-0.45807746,0.22373572,0.70530033,-1.3876998,1.1084274,-1.6604302,-0.31376502,-1.0250944,0.32060885}},
      {{1.9717991,0.3911568,-3.8896523,-1.2291049,-3.7190387,-4.6591067,0.49768105,-0.36191323,-0.18403955,1.1505811,0.21457672,-5.0342693,-0.23536466,0.8788461,-1.5067824,-0.019922156,-0.5818967,0.8368037,-0.7268446,0.32490414}},
      {{0.7814604,0.53548306,0.4466797,-1.9731606,-6.5338993,0.21971655,-2.0680392,0.94724184,0.9423009,0.83615476,-0.03370753,-4.4713736,-1.6351832,0.6754161,0.7385242,-1.0288937,-3.7926805,0.8049127,-0.416537,-2.2239602}},
      {{0.37637132,0.4534315,0.5238563,-0.7402102,-1.8050671,0.53930396,-1.6228431,1.6374612,-0.08018111,0.24309818,-0.39623147,0.7516336,-1.0619633,0.7437653,-0.6274618,1.2198431,-4.961666,-0.5901286,-1.3705163,-1.0554304}},
      {{0.0653183,0.38277745,0.513567,-0.33041528,0.3518625,0.87209314,-0.7678409,0.78141665,-0.6995627,-0.19506238,0.18635653,0.56459635,-1.0639498,0.6949316,-0.10892113,0.8980505,-1.199082,-0.98753756,-0.97558516,-0.11271842}},
      {{0.1005729,0.1469925,0.1524972,0.5134299,0.7339441,0.4480269,0.088082366,-0.41711447,-1.0136136,-0.37548596,0.32125685,0.37201184,-1.057912,1.1803644,1.0425915,0.008838861,0.58894616,-0.12952733,-0.78644323,0.47334445}},
      {{0.98494494,0.5588469,-0.7402439,-0.19136137,0.30869558,-1.1560079,1.3236738,-0.32658783,-0.694462,-0.32935718,0.05332235,0.61391544,0.28363347,0.65078634,-1.0757859,0.6018476,-0.7879221,-0.8613227,-0.3492572,0.21037824}},
      {{2.5223174,0.59977925,-1.7865461,-0.6338923,-1.8498526,-3.365136,1.4567978,-0.67383033,-0.05634304,0.11867812,-0.14518541,-1.5535727,-0.3468471,0.5193515,-0.3431661,-0.074571006,-2.2734354,0.80174756,-1.0735139,-0.079335235}},
      {{2.043714,0.6330769,-2.0196996,-1.178831,-3.3391802,-5.1203284,0.49014,-1.1124189,0.46955025,0.9231722,0.2899216,-4.848173,-1.3428243,0.52677447,0.31449437,-1.4208,-1.345928,2.0721362,-0.35565704,0.08758966}},
      {{-0.8497447,0.730933,-0.16582687,-1.2039217,-6.2124057,0.13612184,-3.4932036,0.5382622,1.0013182,0.3299027,0.96631634,-4.5806184,-1.5383459,-0.05766653,0.4753919,-2.3993895,-0.8627471,1.0968475,0.7029234,0.17330527}},
      {{-0.8274112,0.7158988,0.04267366,0.031617656,-2.571008,0.41287896,-2.0761478,1.5837362,0.92982376,-0.16608664,-1.8173331,1.7972778,-0.7362435,-0.05978964,-1.1123729,0.087842874,-2.675343,-0.046972327,0.8705227,0.1588521}},
      {{-0.9441897,0.75551325,0.13856952,-0.77514505,0.11474091,0.82606405,-0.9536154,0.9217609,0.8643075,-0.40815738,-0.015032919,0.026035206,-0.3626065,-0.111427814,-0.37594736,-0.6790789,-0.57817906,-0.6383059,0.7624045,0.39669}},
      {{-0.17907226,0.71384704,0.15501383,0.47141528,0.73056275,0.42328987,-0.08891595,-0.5357448,1.0322773,-0.33965105,-1.6619017,2.1304183,0.56784123,0.14721955,1.5794626,-0.5165233,0.6120498,-1.0379639,0.73969793,0.3798904}},
      {{1.0456997,0.7589225,0.11630522,-0.2095453,0.41344061,-1.117005,1.2335124,-0.64116436,0.86375225,-0.48916468,-0.6535038,0.9814124,0.1592277,-0.010045501,-0.27554438,-1.4284606,-0.5220744,0.07736713,0.6936891,-0.075014435}},
      {{2.6443455,0.7051607,-0.15706213,0.11302569,-2.3544,-3.131994,1.2948481,-1.6286901,1.0543883,-0.2872179,-0.98018986,0.4699821,-0.7963882,-0.32257703,-0.43840584,-1.8848284,-2.3325608,1.2005433,0.809975,-0.43577874}},
      {{2.2280636,0.7219916,0.030056736,-0.8560054,-3.4125645,-3.5622125,-0.3137054,-1.4186319,1.0630233,0.1235241,0.7745175,-4.047708,-1.5161258,-0.08360763,0.09408299,-3.2116086,-1.1774583,1.8091819,0.69581777,-0.33101305}},
      {{-2.5351617,0.5688058,-1.5509472,-1.7812434,-7.1245494,-0.7276366,-1.9423194,0.90296286,0.18702275,0.95197874,1.1110717,-5.425423,-0.7870129,-0.33589408,0.45025623,-0.45442492,-2.0452478,1.9360104,-0.17152719,0.5822044}},
      {{-0.7371539,0.4414177,-1.279209,-0.49311575,-1.9688898,0.33558497,-1.0780914,1.4790742,-0.39592582,0.44406408,-0.96100587,1.0075598,0.033947952,-0.85445565,-0.7293264,1.8020948,-2.8338418,0.9999785,-0.8548121,0.63262826}},
      {{-1.8585709,0.5515263,-0.59005964,-0.1917737,0.08029897,0.84227055,-0.11024681,0.504717,-0.7552229,-0.22227877,-0.56601685,1.2944156,0.540337,-0.76867604,-1.8300062,0.9874642,-0.5995638,0.21635088,0.097082354,0.60667527}},
      {{-0.77327937,0.4400126,0.22575355,-0.52224565,0.751907,0.4145885,0.23608041,-0.42441544,-0.62271154,-0.49624538,-0.76787347,0.7046003,0.84186417,-1.2998261,0.8471423,-0.7324507,0.59868586,-0.4725667,-0.80416566,0.28644076}},
      {{0.16432989,0.39973882,0.688508,-0.672762,0.4855132,-0.40221775,1.2125211,-0.5656006,-0.07826057,-0.24622704,-0.24699171,1.0089256,0.14928904,-0.60039425,0.2540544,0.2738502,-1.0618993,0.59386927,-0.718646,-0.93907464}},
      {{2.3665295,0.18029954,0.87947136,-0.8194193,-2.0418534,-2.0305586,1.1902766,-0.63538486,0.3388311,0.33488244,-0.17291565,-1.2549078,-0.8861748,-1.0454396,-0.10618242,-0.73193467,-3.1373742,1.4330593,-0.92676526,-1.3291597}},
      {{2.76298,0.42350662,0.6668484,-1.6284264,-3.516064,-1.5828595,-0.50897086,-1.3744502,0.84665465,0.97394836,0.28213832,-4.210157,-1.7900566,-0.6379944,0.5298301,-2.0398755,-4.0516825,2.3543181,-0.35544527,-1.7555287}},
      {{-2.287736,0.31808165,-2.0313702,-1.398327,-4.0400796,-0.7252582,-0.65574247,0.5701043,-0.38662842,1.4094516,0.10957891,-5.5324264,-0.067849204,-0.6447305,-1.4996363,-0.22771886,-0.6805738,1.7005835,-0.40884846,0.67641884}},
      {{-1.5609332,-0.2537616,-1.9527961,0.18369907,-1.5824072,0.49968034,-0.2731182,0.91970104,-1.0793085,0.35539636,-0.7652849,-0.17081326,0.7137217,-1.0193015,-1.4736371,1.1861807,-1.839276,0.79907423,-0.18454017,0.7990719}},
      {{-1.8564556,-1.0903794,-1.1754674,-0.4020238,-0.15548794,0.91654897,-0.0033057595,0.44876707,-1.1121505,0.34678414,0.5318586,-1.8077116,0.9806338,-2.0903897,-2.1565237,1.2363024,-0.8398484,0.6824603,-1.7564977,0.6674795}},
      {{-1.1035048,-4.052321,0.35881516,0.41175413,0.7273096,0.39993522,0.41131544,-0.41799748,-0.41343373,-0.272991,-0.34777084,-0.06466746,0.9516548,-3.0850108,0.42148402,0.18879071,0.60391384,0.22004461,-2.281004,0.28948614}},
      {{0.24387005,-1.6731762,1.2361187,-0.7648999,0.19728172,-0.36292705,0.8394488,-0.526634,-0.7304179,0.3509622,0.9175662,-2.5900571,0.48489898,-1.8894771,-1.0874885,-0.07147638,-0.5634025,0.54813695,-3.7653,-1.5741649}},
      {{1.3835398,-0.7649767,1.3395035,-0.27253577,-0.63292575,-1.082738,0.90027976,-0.35026267,0.021987181,0.3542693,-0.15848708,-0.84582514,-0.9993323,-1.1191305,0.51603025,0.46462536,-3.269281,1.6358881,-2.6716871,-2.6201007}},
      {{1.985947,-0.06820955,1.1440777,-1.5109544,-2.4254355,-0.91542226,-0.54352355,-0.6344893,0.5380179,1.419539,-0.72316027,-5.297476,-1.4028089,-0.72578055,0.47053564,-2.508009,-3.9286222,2.2338498,-1.3995568,-3.0183887}},
      {{-2.384579,-0.26399744,-4.690161,-1.3099697,-2.0645268,-0.70307726,-0.3934363,0.2934499,-0.65242946,1.5228139,1.312051,-7.571163,0.25753996,-0.84179217,-3.1643925,1.3291155,-0.237713,0.35047162,-0.09898686,0.6379401}},
      {{-0.14584665,-0.80871564,-5.182479,0.16426937,-1.1508006,0.6190735,0.45430544,0.9618068,-1.0001963,0.7920894,0.2773534,-4.559449,0.6019781,-1.8564546,-3.5387347,1.8908504,-1.4951538,-0.08814844,-0.3552037,0.88188815}},
      {{-2.2650619,-3.5654945,-3.1792657,-0.26576316,0.06325617,0.8144424,0.63526577,0.3323992,-0.24985181,0.5577534,1.1976204,-4.566658,0.7686721,-3.2482562,-2.1353586,0.9422716,-0.20161226,-0.037927683,-1.6118119,0.83941275}},
      {{-1.0023701,-5.578132,-0.024063174,0.20409542,0.7628225,0.44049817,0.2781503,-0.53274864,-0.5838515,-0.10572698,1.1371033,-3.5865026,0.45736834,-2.7773046,0.998499,-0.45194513,0.5793354,0.06254382,-1.3845537,0.1947992}},
      {{-0.047635954,-4.3071847,1.0649581,-0.6174835,0.6353601,0.14680818,0.87162125,-0.57304555,-0.23385897,0.46124896,1.568183,-4.2876472,0.08934088,-2.654133,-0.51137334,0.005176634,-0.14272377,-0.31658876,-2.89048,-3.3014832}},
      {{1.0342388,-1.5413604,1.306,-0.40143815,-0.049600787,-0.43994814,1.1305263,-0.038018208,-0.09748258,0.8622053,0.83714837,-5.1229773,-1.2686498,-1.7128613,-0.13944694,-1.4007312,-2.7286637,0.4442138,-2.5164614,-5.0290966}},
      {{1.2744968,-0.829947,1.1424714,-1.4618088,-0.38395622,-0.63321316,-0.834738,-0.65559167,0.42983136,1.4812515,0.83314025,-7.4022646,-1.7964066,-1.175138,0.5621668,-2.3498478,-3.17672,1.4673338,-2.6427488,-5.029476}}
    }};

    b1 = {
      0.12058548, -0.38964507, 0.010062542, -0.04017353, 0.008516064, -0.25639796, 0.041518375, -0.054787662, -0.20425256, 0.010797472, -0.16337135, -0.0795959, -0.32974595, -0.015242144, 0.09448933, 0.23266329, 0.08275605, 0.16981529, 0.17073895, -0.15663236, -0.45369312, 0.0310234
    };

    b2 = {
      -0.08644574, 0.18361238, 0.09385555, 0.39887336, 0.021271061, 0.031299587, 0.12261919, 0.03721044, 0.49419248, -0.42214864, 0.01909562, -1.0284956, 0.50627637, 0.22490095, -0.058088537, -0.096080236, -0.1071517, 0.026980398, -0.24670495, 0.13076682
    };

    bout = {
      -2.700903, -2.2434425, -1.7718883, -0.9148538, -1.5254322, -1.8727661, -2.4317026, -2.5522563, -0.9364292, -1.2555697, -0.008499888, -0.943501, -0.6793058, -2.3733137, -1.9256113, -1.0793402, 0.044736326, 0.6726169, 0.29233074, -0.9189597, -1.887189, -1.2874042, -0.12752995, 0.64139766, 3.5031056, 0.8852484, -0.06798297, -1.1515955, -2.1316721, -1.0514842, -0.0014888446, 0.8545073, 0.30163136, -1.1135811, -2.0056314, -2.4375665, -0.88657206, -1.2549306, -0.034274645, -1.2045654, -0.87586504, -2.4871895, -2.5240996, -1.9391407, -1.6246585, -0.8906634, -1.5706227, -1.9895381, -2.6724384
    };

    BN_gamma_in = {
      0.69228804, 0.52327603, 0.23502928, 0.92414474, 0.2223782, 0.43777, 0.14183277, 0.8400403, 0.5274037
    };

    BN_gamma_1 = {
      1.8246508, 8.638701, 3.1295838, 2.0249991, 2.753779, 1.9556818, 1.1983881, 1.8526546, 3.4338088, 3.8626895, 2.815175, 3.8347974, 5.5777993, 4.3906174, 2.9392765, 1.3542987, 2.4314284, 3.627949, 1.2208736, 3.2266638, -14.383635, 4.0411534
    };

    BN_gamma_2 = {
      3.5076163, 1.3571366, 3.1612434, 2.135291, 2.4406126, 3.576523, 1.5471442, 3.4308653, 1.8492379, 0.1824422, 3.2358377, 7.908889, 1.5220567, 1.7203679, 1.8347247, 3.940696, 2.3635435, 2.8255863, 2.4838831, 2.6116188
    };

    BN_beta_1 = {
      -0.050734974, -0.004086153, -0.10610877, -0.00243468, -0.027222877, -0.09117042, -0.22948264, -0.06269112, -0.0427508, -0.08098805, -0.06968115, -0.04187392, -0.01734784, -0.025279803, -0.09732825, -0.15496144, -0.051393554, -0.012227597, -0.01897968, -0.06130917, 0.0054377215, -0.02869027
    };

    BN_beta_2 = {
      -0.090566896, -0.24229343, -0.30156508, -0.87203634, -0.08782627, -0.12812655, -0.20935802, -0.28287217, -0.90476966, -0.079654336, -0.28079042, 0.01203432, -0.84724534, -0.41407964, -0.18011743, -0.113612995, -0.03427398, -0.26063228, -0.03151546, -0.24580842
    };
    
    mean = {
      29413.86215673105,14444.318278456156,29459.63732133561,20027.833619340214,1627.4898399674162,19968.25107178404,29337.181316854447,14227.719285639147,29199.16346520579
    };

    stdev = {
      256530.43446733567,159913.93525268522,254235.72859848003,172449.89124960327,31779.256630701733,171936.16973749298,254689.66251499098,159851.3677639325,256163.06806407517
    };
  }

  else if(m_pcEncCfg->getQP() == 32){
    
    embs0 = {{
      {{0.36824402,0.12518433,-0.23822026,-0.34727794}},
      {{-0.0058528464,-0.003717341,0.0004799814,0.02420344}},
      {{0.0049996525,0.003943817,-0.00068706967,-0.001127338}},
      {{0.0036661038,0.013195969,0.21107745,0.0976734}},
      {{0.009904035,-0.006445224,0.0021152636,-0.038386576}},
      {{0.05879204,0.04234694,0.17239852,0.1065481}},
      {{-0.024810344,-0.03482786,0.010268783,-0.09986017}},
      {{-0.15281774,0.05348781,0.027186995,-0.23744106}}
    }};

    embs1 = {{
      {{0.12090954,-0.025566489,-0.16305009,0.0004104972}},
      {{-0.0058162427,0.006319236,-0.024953978,-0.0007451083}},
      {{0.0049259067,-0.006457593,0.0007193385,-0.0014524594}},
      {{0.3033957,0.098848686,-0.104439765,0.15003826}},
      {{-0.0063907253,-0.008971474,0.03645603,0.012458259}},
      {{0.19969647,0.0957398,-0.029490383,0.020470262}},
      {{0.0075624334,0.044827152,0.09536274,0.021542128}},
      {{-0.013352811,0.12110112,0.23404403,-0.10911602}}
    }};

    in_h1 = {{
      {{0.017201481,0.07276897,0.09420307,0.0037231345,-0.04589251,-0.026057938,0.061787765,-0.11291293,1.5733627,0.066964805,-0.6389873,-3.5780232,-0.571711,1.7491955,0.5041949,0.8898071,-2.982129}},
      {{0.036601357,-0.49940673,0.66992855,0.06876372,0.3978693,0.15160927,-0.34907746,-0.5497281,1.3775712,0.25867143,0.5419814,0.35997105,-5.8356905,-0.06458556,-0.19428244,0.9214894,2.048193}},
      {{-0.09620989,0.122258656,0.34476244,-0.18159905,-0.19876806,0.030109407,0.03758946,-0.32447737,-0.29390728,-0.73159814,-0.64609754,-1.1967046,-5.22959,-0.56504065,-0.47794563,-0.46627048,-0.17063025}},
      {{-0.069343515,0.1258837,0.39689517,0.2139321,-0.14706823,-0.21214037,-0.06875462,-0.28638518,1.1424184,1.2611034,-1.6506294,-2.1474597,0.17811541,-1.1164279,-2.0121539,2.070097,2.0953438}},
      {{0.09091489,-0.16263461,0.33675992,0.017231101,0.17455566,0.044335824,-0.059992284,-0.31968886,-3.5263138,-0.052387662,1.0512671,-2.6882362,-0.27924207,-1.2533208,0.0009425388,0.6395248,-3.7626538}},
      {{0.008890882,0.06637834,-0.04949364,-0.04587153,-0.009396825,0.018577846,0.03488878,0.0067732898,2.4016988,1.6297526,-0.5299889,1.2115855,-0.7937119,0.39070287,-0.71233064,1.1165831,7.906009}},
      {{0.016386481,-0.03752287,0.026809558,-0.036281593,0.039069414,0.03881515,-0.065278515,-0.06648813,0.1542914,1.2536203,0.324437,-0.14037631,0.7984971,-0.1126685,0.10061336,-5.049289,-2.9887567}},
      {{-0.04180383,-0.33116052,-0.19587661,0.21794607,0.39440995,0.10786513,0.09822501,0.30917755,0.133434,0.21600051,1.1051201,0.0013282945,3.2697752,0.6568743,0.8209552,0.65647733,-1.7689737}},
      {{-0.06985171,-0.020218188,-0.33759475,-0.07668297,-0.014199108,0.045599435,-0.120362885,0.30885828,-3.2827435,0.8536931,0.006126639,-4.0539913,1.146752,-0.24688089,0.4918904,0.69373006,-4.6851363}},
      {{0.01973163,0.017749801,0.01987908,-0.026994457,-0.03374051,0.021314768,-0.0046749585,-0.0132364025,-0.47360194,-3.4434774,0.0043667722,0.49612176,2.1200325,0.062950365,-0.17393234,0.3589915,-1.3511096}},
      {{0.005810286,0.08738155,0.13869038,0.06337057,-0.08037449,-0.12769072,0.06308165,-0.11265315,0.8262431,-0.041250624,-0.24705355,3.238444,-0.32498866,-1.7813557,0.8251276,0.30180788,3.439371}},
      {{0.0051609995,0.10820177,0.20230904,0.047488723,-0.06514307,-0.050095767,0.035622697,-0.22177541,-0.75012046,0.18758643,1.4460732,0.45695755,-1.5325358,-0.9772214,1.1398997,1.9534355,-0.50889236}},
      {{-0.011341732,0.018604985,-0.014344705,-0.00036389733,-0.027939025,-0.01316483,-0.005662223,0.02389275,-3.7235107,-0.6073003,1.5843375,-0.57416046,0.78354317,-0.84539765,1.0913093,-1.1293563,-5.434104}},
      {{0.020267986,-0.00945991,-0.049292583,0.0062131835,0.024858406,0.12062696,-0.0024242823,0.055138636,-1.2561685,-0.20208071,-1.1407635,-0.5300799,-1.9717455,-1.6835963,-0.62114686,0.1795985,-1.0520184}},
      {{0.002170759,-0.0051245503,0.0266043,0.001043,0.015248963,0.001006645,-0.014265007,-0.043623094,0.5843303,-1.328514,0.051983755,-0.31542957,-0.22490042,-0.026913647,0.079051204,3.7888627,-0.5932828}},
      {{-0.82774717,-0.09817975,-2.3677795,0.34927997,-0.8769542,-0.068571866,-0.40714714,3.1192505,-0.25673893,1.1229682,0.5438307,0.3089343,-0.24367994,-0.13507156,0.030413108,2.3043358,0.6197688}},
      {{0.008288836,-0.019046327,-0.00849001,-0.016166613,0.019520644,0.040546596,-0.0006804493,-0.0089868205,0.2814804,0.11441712,0.014441657,3.4835784,0.42121542,-2.2072499,0.29098848,-0.3091998,-1.7613711}},
      {{0.007222633,0.04822962,0.028351724,-0.10125083,-0.05164321,0.10682092,-0.013876223,-0.011296302,1.1457121,0.027702086,-0.08779762,0.0987036,-4.490909,-0.21970104,1.6310828,0.37283355,0.21683905}},
      {{-0.012882142,0.02953791,0.12863159,-0.020738674,-0.036990892,-0.041299984,0.062978536,-0.1427986,-0.88764787,0.8504053,0.48521742,-1.4866191,-3.5063467,0.74621683,-0.9986296,-0.9040728,0.671051}},
      {{-0.075309634,0.20541306,0.0070575373,0.01620939,-0.20656842,-0.075893514,-0.06712249,0.0071230493,0.2250739,-2.1662946,-0.6297552,2.62288,0.033377543,1.0689849,0.5657722,-0.8123682,1.5038888}},
      {{-0.30061188,0.031697273,-0.3502058,-0.095782936,-0.29206094,-0.1068976,-0.106408015,0.2721382,-0.81160134,-0.051935207,0.43278387,0.3688119,-5.695372,-0.30974823,0.117057055,1.0990396,1.6318885}},
      {{0.00026696225,0.0038963098,0.0463167,0.004892191,-0.0044370354,-0.008934019,0.0033025031,-0.045421276,-1.4096749,-0.72767675,-1.3892064,-1.029561,1.8603953,-1.2935731,-0.8770855,-0.14650753,-1.5504819}}
    }};

    h1_h2 = {{
      {{0.16074237,-2.2663832,-0.6020127,2.7593317,2.848122,-1.491753,-0.521619,-1.5186541,2.5881436,-0.116419636,-2.9104977,-0.7442328,-0.6264564,-0.13625854,0.08571997,-0.16009939,-1.0576801,2.896373,1.2555416,-0.83523923,-0.13140666,1.4710021}},
      {{0.5282247,0.4474313,0.55225086,-0.71152276,-0.4767533,0.23520224,0.24992289,-0.064365424,-0.8639282,-0.66795385,-1.0145081,0.9667964,-0.4194863,2.142638,-0.2991813,-0.47840953,-3.3208764,0.08706852,-0.22175352,0.5452572,-0.15998189,1.1675829}},
      {{-0.2743717,1.3951104,1.0918554,-0.4378949,-0.27360752,0.02584989,0.048545416,-0.46780124,0.044277772,-1.4286262,-0.6140469,-0.99410486,-0.7716531,1.6144656,0.0535444,0.075871535,0.039437197,1.6031393,0.31869388,-0.5162232,0.79136854,3.4717488}},
      {{0.23733698,0.3416826,0.42175123,-0.435465,-0.117107384,0.08957261,-3.1139748,-0.14300384,-0.0922618,-1.8874968,0.15601712,0.5226181,-0.14462948,-0.68841624,0.04755615,-0.62533087,-0.16490968,-0.20734051,-0.41801918,-0.11114999,-0.6564751,-4.132302}},
      {{0.11579686,0.25847134,0.38264185,0.22853135,-0.7796128,-0.66521716,0.7063935,0.189077,-1.9518589,2.6583695,-0.5242471,-1.0074949,-1.3452023,-1.2742131,-0.06732647,-0.6597853,-0.96134704,-3.170379,-2.120168,-0.91896784,0.7028387,-1.4327235}},
      {{0.033391256,3.299729,0.7024202,-1.1765847,-0.68021834,-0.4916775,-0.09474848,-0.014140502,-1.7002659,-0.45471832,-0.8642822,-0.26272908,-0.8211428,1.1705269,-0.21510594,-0.96807885,0.7148324,0.8408311,0.006260337,-0.019766903,1.9315609,-4.1724734}},
      {{0.5091468,1.1598363,-1.4429796,-0.07337059,0.6856053,-0.7562601,0.9733669,-0.2632675,-0.8407194,0.035806537,0.44634447,0.5167972,-1.031568,-1.6119493,-0.52318704,-0.738842,-0.35944897,0.057303894,-0.16682705,-0.4208716,2.1809478,-1.5243607}},
      {{0.23066351,0.3349139,0.67967033,-0.9930581,0.32550174,-0.47290683,-1.1281184,0.24344198,0.033875845,0.24659881,0.047108117,2.1379275,-0.7136732,-0.08437721,-1.4439884,-0.7974111,-0.1967539,-0.15631595,0.085971385,-1.1180294,0.8479413,-2.4968843}},
      {{-1.0860184,0.9564145,-0.80841565,-1.3023962,-1.759972,0.4785925,0.033061035,-0.08919225,-2.6059952,-0.028793108,1.010857,0.8249433,-0.62933356,-0.75479734,-0.24539995,-0.52847886,-1.4542087,-0.3602359,-0.08013524,0.5238815,0.102832034,-1.1908826}},
      {{0.03564981,0.54303205,-2.249543,1.4947617,-1.430504,0.08579687,-0.36168855,-0.8002892,0.31231242,3.6635177,-0.55712193,0.54190356,-0.7389522,0.5645315,-0.05511523,-1.3427659,0.7138819,1.2097722,0.6971473,-2.4598167,-0.15253073,1.823332}},
      {{0.3132756,0.64105713,0.49544728,-0.13926777,-0.93435645,0.25162965,-0.3569572,-0.16952951,-1.07701,-1.4300624,0.8198483,-0.43255484,-6.9891286,-0.73697376,-0.2421063,-0.29876837,-0.7958221,-0.5267638,-0.38100323,-0.23550925,0.7984384,-2.0248628}},
      {{1.6122924,0.03363676,-0.37071335,-0.20746581,-0.49294645,-0.4053005,-0.52858853,-0.29316545,-0.7723069,-0.55754775,-1.4712003,0.3837967,-0.21258786,1.24514,-0.447464,-0.6662715,-2.8709702,-0.08521361,-2.110896,-0.7999351,-0.57891685,2.6089907}},
      {{-3.1803932,0.3039598,-0.3639735,-0.8684431,-0.15138455,-2.0230742,-0.14913341,-0.28859213,-0.11956492,-0.4382914,0.21932727,-0.0783119,-0.2893437,-0.14787704,-0.7151906,-1.1430022,-1.0581899,-2.8408065,0.37928224,-0.053644788,0.7233264,-0.8000484}},
      {{0.31177372,0.30499482,0.74944687,-0.17905405,-0.04616809,0.64080715,-1.3491677,-0.27368647,0.028734293,-4.643817,-0.03173913,0.8658451,-0.23918897,-0.35473695,-1.6221565,-0.8282284,-0.09661342,0.009397673,-0.33507535,-0.48462185,0.07957345,-2.1268415}},
      {{0.31141484,0.56408244,-0.6773531,-0.6274322,-0.091751985,0.82137996,-2.120569,-0.30957884,-0.6020768,0.098908044,0.08143609,1.0419643,-0.97293216,3.4398172,-0.4483761,-0.59523654,-0.12780635,-0.17576915,-0.10854106,-0.78662825,0.13856642,4.4453874}},
      {{1.006815,-0.3743705,-0.65077776,0.583785,0.9174705,-0.073647395,0.3183887,-0.49411005,3.1990705,-3.280853,-0.8190528,0.11943467,-0.1867084,-0.6644717,-0.25657037,-0.5920647,-2.3724551,0.024088716,-0.4510655,-0.4960293,-0.34307435,-3.2569177}},
      {{0.18739736,0.048742414,-0.32963884,-0.025257314,-0.7587791,0.10220362,0.6334806,-0.23800537,-0.30441478,-0.5829311,0.21250974,0.24144457,-0.0059852595,0.07789875,-6.3744345,-0.2456785,-0.33735743,-0.07196608,-0.5243619,-0.028753141,-1.5534958,-0.5062695}},
      {{-0.09957538,0.54575807,-0.3786342,-1.8571488,0.20199923,-0.8447385,-1.2827426,0.38944623,-2.0854404,-0.0886808,0.71883696,1.4357065,0.5288756,-1.7273252,-1.4244074,-1.7012703,-1.8582338,-0.43896616,-1.3488165,-0.48918176,0.9051154,-1.3893659}},
      {{-0.7046376,-1.0503936,-0.24141015,0.18251058,-0.6325252,-1.277667,0.89984053,-1.629412,1.3232952,0.119480096,-0.75238997,-1.701126,0.027944246,0.21824616,-1.1217754,0.009154369,0.5180753,-0.81732714,-1.2374818,-0.3028797,-0.8579356,8.910579}},
      {{-4.049985,-0.61421037,1.6705347,-0.55011487,0.17709687,0.14802581,-0.23369665,-0.46390012,-1.3679756,0.53632534,0.24351285,1.0429593,-0.33735824,1.5901693,-0.10954413,-0.89381874,0.1404779,-1.0499059,-3.9841619,-0.64942175,-0.15442789,-0.17852725}}
    }};

    h2_out = {{
      {{-4.9390163,-0.58171165,-1.1516864,0.808964,-0.49794558,-2.8870988,1.1151581,0.14641328,-3.294506,-2.3637488,-2.9848402,-0.15506686,2.8439193,-0.6014103,-3.099512,0.47936165,-0.46027663,0.80526143,-5.247915,-0.616879}},
      {{-2.3722868,0.015270171,-0.38795778,0.8535039,-0.15799032,-2.052276,0.08783579,0.27264443,-1.2644212,-2.4512858,-3.7635393,1.1504467,3.0899994,-1.5624082,-5.4697313,-0.81920403,-0.34801003,0.6742108,-3.9261534,-0.0521771}},
      {{-1.7463946,0.44243902,-0.21492393,1.2602278,-0.6451174,-0.49500623,0.41996944,-0.93863034,-0.04854638,-2.328122,-2.536982,0.75073034,1.8856611,-3.4965546,-5.05147,-1.4988607,-0.5406254,0.9367349,-4.0127845,-0.5408395}},
      {{-0.2758059,0.44780308,0.2434343,0.6418089,-1.6790065,0.58895314,0.685383,-1.7122618,0.5938675,-1.4216588,0.42358783,-0.124319024,0.25515467,-5.967449,-2.7634344,0.4948388,-0.5551298,0.7954677,-5.5454106,-0.39430073}},
      {{-0.5179624,-0.28141993,0.15526088,1.2864261,-0.05777354,-0.180696,-0.6945019,-6.3265176,0.74380094,-1.3472974,1.6729957,-0.5549678,2.5721831,-3.794572,-2.6965027,-0.6410695,-0.7388985,0.060373705,-4.6021295,0.7760362}},
      {{-1.5780789,-1.349119,-0.12396591,0.9192642,1.0071275,-1.5662049,-1.1283222,-8.148547,0.34762886,-1.717645,1.9519167,-0.60430855,3.9262745,-1.3503839,-1.0142214,-0.35440373,-0.4255982,-2.064416,-4.9142413,1.340597}},
      {{-1.412244,-2.4491937,-0.3370555,0.8295252,0.84523183,-0.675379,-1.1750803,-6.508269,-0.88139826,-0.25087804,2.47189,-0.9682543,3.9565651,-0.3952387,-1.3901913,0.91644365,-0.4639496,-4.312161,-5.663252,-0.6071465}},
      {{-3.1091232,-1.6814071,-1.1437153,1.3024327,0.4061584,-1.7945101,0.59890425,0.3398087,-7.3771386,-1.3990548,-3.1179981,0.047883548,2.5350683,-0.31488216,-1.0044197,1.565422,-0.40337262,0.52113795,-3.7713418,-0.26059797}},
      {{0.15606296,0.3309379,0.78422487,0.9002346,0.37180027,-3.072678,-0.6419587,0.45907313,-2.566997,-1.1655606,-2.588613,0.84400713,-2.8922853,-0.8702139,-1.2542232,0.16411985,-0.43672976,0.5000685,2.7480927,-0.08868356}},
      {{-0.6868242,0.4577397,-0.02226257,1.6803702,-0.00888999,-1.0715024,-0.40355626,-0.18148269,-0.6089737,-1.2692327,-1.8625264,0.6851663,-0.053964682,-2.0307689,-1.4898758,-0.91367203,-0.24841607,0.57379735,1.1812117,-0.65984076}},
      {{1.7860917,0.43951324,0.066625044,1.061096,-0.07681824,0.57617885,-0.32541978,-1.0380653,0.5867725,-0.17612404,-0.122921154,-0.15063937,-1.9630442,-3.7194505,-0.708272,-1.0124557,-0.7972463,0.70415837,1.776982,-0.17424762}},
      {{-0.65852183,-0.849081,0.04057603,1.5217754,-0.12816386,-1.2373078,-0.9446548,-3.0662699,0.7109362,-0.71012765,0.8773363,-0.58277285,0.20987944,-2.2422316,-0.05506389,-0.3007945,-0.38617107,-0.33273286,0.8312741,0.5400008}},
      {{0.595106,-1.6456149,0.3307133,0.9317444,0.038582098,-2.0135076,-1.3176055,-4.142926,0.23510833,-0.061665606,0.9241049,-0.544187,0.783544,-0.6192672,0.59108424,-0.30168712,-0.37496045,-2.5486116,-1.194718,1.2655406}},
      {{-0.9899293,-4.4473653,-0.22196884,1.2677872,0.093500376,-2.3288672,-0.96440256,-3.3344674,-1.4632949,0.42797083,1.5905411,-0.47533065,3.0082467,-0.23551783,0.24771531,1.3476741,-0.46387842,-4.9679832,-5.010381,0.2758734}},
      {{-3.372594,-1.9996098,-0.5599225,0.25753182,0.65098876,-4.0179086,0.31434065,0.43116248,-7.852242,-0.63324106,-2.1996732,0.45268342,1.6391237,-0.0569991,0.21444082,1.9161593,-0.41216248,0.09416498,-3.1825576,-0.8267436}},
      {{-0.4590295,-0.33586723,-0.017743351,0.2910455,0.6652456,-3.5581226,-0.62946737,0.54502916,-3.1345298,-0.33794644,-1.8179586,1.3282304,-1.6154785,-0.45379874,-0.09916407,0.9706894,-0.48682302,0.2074273,1.8667603,-0.5372378}},
      {{-0.59580845,0.5878856,-0.33383602,0.5382109,0.2739121,-0.52644515,-0.5322849,0.44341066,-0.3598379,-0.16329837,-1.1229584,0.6655283,-1.0591407,-0.55946195,0.07153311,-0.4666234,-0.36266536,0.45732236,1.123772,-0.8342181}},
      {{0.14215149,0.47366306,-0.28397286,0.6854874,-0.70206,0.576914,0.053101365,0.21648288,0.60401326,0.095351666,0.16063108,-0.2696277,-1.727306,-1.3662198,0.22772384,-0.5439355,-0.6595718,0.49410132,0.25537235,-0.64693826}},
      {{0.81565356,-0.689175,0.38705784,0.6645365,-0.11355013,-0.6013345,-1.5186957,-0.09872253,0.74390435,0.4068279,0.6771393,-0.80471635,-1.6170915,-0.6841018,0.5077849,-0.5166701,-0.2042682,-0.15928337,0.6223401,0.43500215}},
      {{0.61399,-2.7033925,-0.47362682,0.6689195,-0.27632537,-3.4158528,-0.9355228,-0.5218454,-0.3348507,0.21493408,0.6102593,-0.3992711,0.851667,-0.12091349,0.8829335,-0.30461144,-0.33828855,-2.6540694,-1.1005498,1.6181678}},
      {{-0.84056574,-4.604528,-0.5831359,0.7293485,0.75803477,-1.9576226,-0.7684133,-0.59664,-2.4586387,0.6643457,0.84723014,-0.9610229,3.6849904,0.011673544,0.75280887,0.86841786,-0.31453422,-4.2458563,-5.5624633,1.1659653}},
      {{-6.6774807,-1.3788137,0.46441272,-0.8026139,1.6147949,-1.9598103,0.9175984,0.4004522,-8.931015,0.630705,-0.23335458,0.647164,1.7292173,0.26167735,0.5968316,1.4802794,-0.6513754,-0.6110687,-4.406389,-1.5391297}},
      {{-0.3662315,-0.58888775,0.16927527,-0.7927582,1.2002664,-1.9017085,0.19447263,0.45278826,-3.127476,0.5233278,-0.8649975,1.4500041,-1.4273851,0.15144733,0.60508513,1.1314952,-0.52687776,-0.56652045,0.8853547,-1.371651}},
      {{-2.0366797,0.40145198,-0.037104715,-0.5524736,0.39317414,-0.27122763,0.4743825,0.5065848,-0.020839509,0.5800585,-0.37103096,0.86572236,-1.1977453,0.18652534,0.51689947,0.17961314,-0.4718102,0.09897187,-0.12562853,-1.7126131}},
      {{2.6106791,0.4571823,1.2031767,-0.24875228,-1.446815,0.5826271,1.2402843,0.4546026,0.62259597,0.6920548,0.06294573,-0.37544942,-1.9475509,0.2945681,0.4938977,-0.73981935,-0.48071435,0.42863718,1.7047732,-0.86424375}},
      {{0.21088439,-0.9510574,-0.6374871,0.16783173,-0.2933132,-0.57521456,0.45758373,0.4308929,0.556658,0.73746175,0.09800596,-1.2125889,-0.7118386,0.27835175,0.53324807,-1.167187,-0.18898632,0.14986905,0.0077627585,0.2945864}},
      {{0.9629457,-2.9790864,-0.3242161,0.112945266,-0.28024194,-2.6863935,0.6467866,0.3984065,-0.74121284,0.6233319,-0.4333907,-1.30495,0.4093795,0.23607108,0.5833009,-0.38270795,-0.29317328,-1.2046155,-1.5435848,1.6444829}},
      {{-0.555435,-3.695091,-0.55662787,-0.053996082,1.1777139,-0.20879345,1.3151584,0.4465074,-2.933531,0.52768695,-0.24562131,-2.29067,2.923513,0.3229249,0.5182718,0.9987851,-0.493343,-1.1928502,-6.006828,1.1058578}},
      {{-3.950629,-1.3808403,-0.15893093,-0.89555156,1.3024766,-3.4683821,-0.9662718,-0.14854082,-4.6243725,0.6400503,0.4931115,0.63585633,2.1500063,0.5797786,0.3114337,1.8650565,-0.3585484,-3.405488,-3.905204,-0.9319697}},
      {{-0.08926534,-0.14671795,-0.19158483,-0.9200041,1.2040964,-3.7352393,-1.2898221,-0.16104804,-1.6931415,0.24732743,0.27232656,1.1366104,-1.6649786,0.6421234,0.3594749,1.0670692,0.04538076,-1.9193435,2.1595752,-0.7592672}},
      {{-0.20124878,0.5766755,-0.15823582,-1.12096,0.9696692,-0.006819048,-1.5664749,0.27764684,0.19112638,0.5870009,0.41711646,0.5734995,-1.7742049,0.3803461,0.33013466,0.021951608,0.1709331,-0.3123417,1.1417235,-0.78822255}},
      {{0.026195142,0.43528327,-0.52916276,-0.60022616,-0.37122485,0.57226884,0.40198967,0.4106243,0.64406383,0.23360339,0.10509596,-0.4332364,-1.7092916,0.25047496,0.38037008,-0.5885267,0.66038865,0.35669956,0.5070314,-0.73113364}},
      {{0.22629823,-0.34925228,-0.46324795,-0.726346,-0.09592544,-1.015064,-0.39797708,0.58019024,0.63495576,0.093607254,-0.59610766,-1.3146815,-1.0364304,0.28345433,0.13285965,-0.22821754,0.16704665,0.48672867,0.93967444,0.67610484}},
      {{0.7593991,-2.4633846,-0.7935388,-0.2234313,-0.3005972,-4.3405952,-0.21120007,0.6125625,-0.9901695,-0.14632513,-1.10405,-1.0427182,0.90110606,0.48546576,-0.09621423,-0.0170496,0.19137795,-0.07899704,-0.9306724,1.9158981}},
      {{-1.0105325,-4.4428816,-1.1078633,0.26988304,0.38622555,-2.230271,0.6041721,0.5552109,-3.8157606,-0.32650465,-1.7806644,-1.7869545,3.1679046,0.64861625,-0.17904659,1.0268638,0.17774035,-0.22637115,-5.350226,1.2472881}},
      {{-2.8131855,-1.1015446,-0.5004012,-0.6183457,1.1116171,-3.1358333,-1.6703929,-1.5913526,-2.109494,0.5992175,1.056159,0.1571747,2.522344,0.8222209,-0.26477042,1.62896,0.19114287,-5.474362,-4.4086003,-0.8963399}},
      {{-0.87783086,0.2916238,0.47107786,-1.3391027,1.4813288,-0.81395614,-1.8620621,-1.6396933,-0.721351,0.11058716,0.5945687,0.76513237,-0.2576744,0.50628626,0.23100404,0.58468014,0.504432,-2.9166,-0.27806732,-0.26825753}},
      {{-1.0220234,0.58983135,-0.92662567,-1.744723,1.5766727,-0.5483688,-1.0563567,-1.0205612,0.08502632,-0.49304515,0.4777313,0.44397023,0.7413359,0.25990242,0.025892707,-0.20238347,1.1260742,-0.9703286,-1.5963408,-0.43257058}},
      {{0.99665886,0.42447317,-0.25804284,-2.3351724,-0.47220382,0.5359962,0.33398482,-0.2771116,0.6589578,-0.5897285,0.22489336,-0.17611083,-1.0153424,-1.0140266,-1.1693261,-0.57491326,1.2097206,0.3859347,-0.7036397,-0.100620635}},
      {{-1.3887975,-0.27768302,-0.9181412,-1.4025881,-0.69648147,-1.4431657,0.06189276,0.6650589,0.63535553,-0.8677807,-0.93551385,-0.76466066,1.3920909,-0.45970577,-2.0589902,-0.18380609,0.8696993,0.2743752,-1.2812248,1.1380622}},
      {{0.19885439,-1.0377032,0.05934441,-0.7805359,-0.62887216,-3.6559823,-0.5961446,0.6626824,-0.60036594,-0.28974858,-1.6265146,-1.196311,0.43307146,0.2640425,-1.7977792,0.010368621,0.24123389,0.5185848,-0.61529875,1.9164689}},
      {{-2.13892,-3.0621357,-1.1071572,0.21494433,-0.3771223,-3.6076014,0.35778663,0.5479112,-3.675107,-0.8121794,-2.4804413,-1.6879627,3.1137435,0.6478999,-1.4120803,1.3073095,0.38900352,0.28335524,-4.9966536,1.3614466}},
      {{-4.7491937,-1.4173541,-0.17201321,-0.63893735,1.976255,-0.039470814,-1.8538256,-3.0568924,-0.93061244,-0.10170218,2.0311332,-0.20740199,3.4991875,0.4582002,-1.3943372,1.3996607,-0.2293525,-5.7851744,-4.750527,-1.1071765}},
      {{-2.8118422,0.029424189,-0.52502215,-1.3761692,2.9283202,-0.53886956,-2.026859,-4.174,-0.5347557,-1.035108,1.6720144,0.49309877,3.0428386,0.49487877,-1.0708356,0.23802496,0.36481622,-2.2977624,-3.8086386,-0.016755048}},
      {{-2.2742343,0.5521716,-0.480201,-2.382116,1.555458,0.25640044,-1.0225505,-4.3271914,0.19685338,-1.3666378,1.3399932,0.40762442,2.2450771,0.17011723,-2.6393938,-0.4919791,0.6793691,-0.13151373,-4.540269,0.052955218}},
      {{-0.06459966,0.41737932,0.03274346,-1.5913008,-1.2243404,0.5596753,0.70993394,-1.1722342,0.65317446,-1.2070998,0.41282073,-0.2844579,0.1317455,-1.677752,-3.1447587,-0.26932836,0.8809083,0.57219493,-5.15879,-0.6530455}},
      {{-1.5080628,-0.09287488,-0.38406274,-1.7560071,-1.7734413,-0.689397,0.5578533,0.11592344,0.7152952,-2.2271543,-1.5451202,-0.3855559,2.045817,-1.4899963,-6.087451,-0.6120642,0.9121867,0.61536366,-3.8563256,0.9946667}},
      {{-2.5901294,-0.667339,-0.92090124,-1.0030836,-1.4463104,-2.2244446,-0.011081213,0.64726925,0.03159407,-1.4365525,-2.513172,-0.32626322,3.6252673,-0.29782197,-6.5813246,-0.60007995,0.09766815,0.54562026,-3.9369738,1.8083273}},
      {{-3.480122,-1.5252063,-1.4233897,0.019598987,-1.201422,-2.731052,0.42191204,0.105781265,-2.040015,-1.2716148,-2.381319,-1.2285318,3.4084153,0.5998707,-4.8880086,0.40321958,-0.23817042,0.8087669,-5.756633,0.8391932}}
    }};

    b1 = {
      0.07595624, 0.18452492, -0.35345992, -0.19333413, -0.13518335, 0.20778848, -0.014401906, 0.30193132, 0.11825716, -0.23821123, 0.102081224, 0.2627901, -0.0330793, -0.38213006, 0.052555796, -0.08048325, -0.034497675, 0.0923231, -0.06257836, 0.05227252, 0.015994126, -0.4193249
    };

    b2 = {
      -0.027404727, 0.44492984, 0.32216653, 0.10675493, 0.00044722087, -0.06829317, 0.7514024, -0.004155566, -0.027662, 0.29286632, 0.02900024, 0.17130737, -0.6228874, -0.05910156, 0.07341758, 0.09427044, 0.19949628, -0.0507653, -0.08548947, 0.21069951
    };

    bout = {
      -2.0057948, -1.8666831, -1.5253894, -0.31524488, -1.4793553, -2.0100884, -2.509358, -2.3020678, -0.6356973, -1.0078833, -0.027483484, -1.2069905, -0.8545662, -2.4023862, -1.7732012, -1.0379341, 0.033678327, 0.46166217, -0.17538525, -1.1047946, -1.7779564, -0.5895038, 0.08354942, 0.52233773, 3.3641195, 0.62386537, 0.09967023, -0.4550918, -1.7337558, -1.0706427, -0.3151316, 0.53967184, 0.082770474, -0.9643009, -1.8142934, -2.478633, -0.8939161, -1.2565131, 0.051179685, -1.1848533, -0.7746627, -2.2306476, -2.6390867, -2.0760546, -1.57408, -0.28033456, -1.4509203, -1.9536061, -2.2828374
    };

    BN_gamma_in = {
      0.17512327, 0.93472445, 0.74384403, 0.31208503, 0.27033335, 0.78237873, 0.7988953, 0.41651535, 0.03203422
    };

    BN_gamma_1 = {
      2.974633, 1.5313437, 5.460141, 1.8765786, 2.3846762, 2.1831586, 2.3343675, 1.2431514, 1.3747947, 4.033284, 2.8631618, 2.6619208, 4.238877, 3.733905, 4.1955876, 1.8734524, 4.468265, 2.7182345, 4.4682713, 1.849998, 1.7894864, 9.997613
    };

    BN_gamma_2 = {
      5.286528, 1.1956214, 1.4729164, 1.9035555, 3.9734406, 1.8816931, 1.3077893, 1.8378401, 1.9040852, 2.002263, 3.9219902, 2.2631357, 6.80057, 2.772526, 1.605489, 2.0754173, 2.1942616, 2.2424822, 8.288177, 1.5616555
    };

    BN_beta_1 = {
      -0.026443774, -0.21291995, -0.004418362, -0.15619777, -0.103859015, -0.004243179, -0.098527946, -0.002721676, -0.2899336, -0.03362646, -0.17078844, -0.16101658, -0.017004564, -0.017284608, -0.09050844, 0.004350703, -0.032753658, -0.0012722051, -0.008482086, -0.13672581, -0.06923049, -0.012721032
    };

    BN_beta_2 = {
      -0.07852479, -0.5010738, -0.41062868, -0.36312371, -0.15012245, -0.014761447, -0.89460033, -0.079151146, -0.0537617, -0.4733017, -0.22817814, -0.37768248, -0.019660529, -0.123307325, -0.12464835, -0.2383718, -0.5941663, -0.061366126, -0.020345584, -0.4196211
    };
    
    mean = {
      29192.797943175487,14592.526713728088,29262.738563904524,19940.08074678151,1944.0432456829724,19894.383956247995,29069.324172281114,14309.17194875009,28948.555352745476
    };

    stdev = {
      256869.05289660723,160129.43884245644,254307.62196992838,173226.57274217487,31935.87374724543,172479.47161329084,254629.885567268,159614.81314715123,255957.14041221823
    };
  }
  
  else if(m_pcEncCfg->getQP() == 37){
    
    embs0 = {{
      {{-0.041091263,-0.215475,0.35943595,0.033290476}},
      {{-0.0029196865,-0.00072023406,-0.025328094,-0.012487809}},
      {{0.005868021,0.0005879806,0.002561261,0.0118167745}},
      {{0.16622515,-0.6392592,-0.07682711,0.0014886528}},
      {{-0.014864151,-0.0026687682,0.047665104,0.019410815}},
      {{0.14855628,-0.6744753,-0.05214838,-0.060979605}},
      {{-0.026472155,0.014046636,0.10391524,-0.05412223}},
      {{0.1896569,0.023379894,0.16710794,-0.18606615}}
    }};

    embs1 = {{
      {{-0.028194964,0.2729014,0.07025862,0.2972915}},
      {{-0.030724598,-0.0024098004,-0.00060112384,-0.00029125356}},
      {{0.005123975,0.0043186517,0.00040610172,0.009429354}},
      {{-0.02395863,0.054514144,-0.3572415,0.11553701}},
      {{0.052530035,-0.013376611,-0.0032342526,-0.012784343}},
      {{-0.029495962,-0.04644039,-0.38005337,0.14742416}},
      {{0.069734715,-0.016823186,0.021028126,-0.09847043}},
      {{0.059315924,0.17536752,-0.011595306,-0.28211802}}
    }};

    in_h1 = {{
      {{0.07797378,-0.13630264,0.21084353,0.39966142,0.29835773,0.014367909,-0.1840309,0.30036303,0.024676396,-0.18206915,0.09927351,0.5092785,-7.7418704,-0.6236826,-0.23852473,-0.15132912,0.60779166}},
      {{-0.9953725,0.41541004,-3.160631,0.22056611,-2.5590453,-0.41853157,0.2899571,0.7286444,0.33307704,1.0220166,0.8576955,1.0323497,-0.9008081,0.43619138,0.6339406,-0.11232054,-0.5392479}},
      {{-0.041298334,-0.024635777,0.124523096,0.038373187,0.12777345,-0.04059691,-0.011770508,-0.027286438,-1.353605,-0.4687369,-2.3622189,-0.8919266,-0.27380595,-1.7089108,-0.97367394,-1.0467392,-1.6147777}},
      {{-0.12274462,-0.0070544304,0.1060498,-0.13170153,0.025448162,-0.12555036,0.016454874,-0.16796683,-0.662029,0.524873,1.1476332,-0.9382066,-6.390977,1.4870768,-0.5987754,0.039350078,0.8089003}},
      {{0.104398035,-0.3216999,-0.038199358,0.42608222,0.1504805,0.10213819,-0.58772516,0.39576724,1.2850121,1.3615048,0.761607,-1.1073921,1.9030615,0.07137605,0.726881,0.6524165,0.66900575}},
      {{-0.014195863,-0.014361484,0.040844664,-0.009788508,0.036559183,-0.008400375,0.029757487,-0.008735693,-0.2929695,0.4708091,0.7490824,-2.3151622,1.3255849,2.2943742,1.0019957,-0.12661256,0.1642216}},
      {{-0.04749992,-0.32234043,0.90334594,0.23602659,0.44607133,-0.42817137,-0.785357,-0.3650118,0.7552014,-0.8526185,1.9443183,-0.057339486,2.181565,0.95166546,1.6088588,-2.0146055,-0.47739238}},
      {{0.0013609277,-0.006706646,0.007609731,-5.4565877e-05,0.014125053,0.001575906,0.006708285,-0.0012824446,-0.9857733,1.5943173,-1.1625917,-2.220489,2.6873522,0.21146066,-1.0897278,1.7070901,-1.0912306}},
      {{-0.12389328,0.104880095,-0.084085844,-0.0052398336,-0.035764128,0.023463208,0.10132809,-0.03893383,0.4201902,1.0089616,1.3342181,-0.4574791,-4.794375,0.092787676,0.738576,2.0404313,-1.026277}},
      {{0.0057335845,-0.04193325,-0.013501841,0.06340758,0.005021682,-0.006537437,-0.080867454,0.056899,0.4848264,-4.4265842,-0.0760025,-0.33087033,1.558798,-0.17650071,0.47350237,3.7120593,0.00025615163}},
      {{0.0033887047,-0.0097504705,0.004488631,-0.002444032,-0.0005900527,0.002021802,-0.0034744577,-0.004209254,-0.97237927,-0.043798096,3.6689415,-0.01674886,0.3998524,-0.41896048,1.8611209,-0.8029492,-1.6384178}},
      {{-1.2426372,-0.015007025,-2.5466008,1.790625,-1.4539702,-1.5931755,0.47864684,2.3930862,-0.6133693,1.1618205,-1.2825192,0.77158314,3.3681738,0.16228421,-1.062531,1.8612934,-0.28421116}},
      {{-0.057294425,0.010362979,0.007834333,-0.16749713,-0.025583113,-0.045442954,0.15002054,-0.11890855,0.6773181,-0.32126248,-1.8848976,0.096282735,1.4809414,0.6775928,-1.2707483,-3.0890875,0.57667416}},
      {{0.005444264,-0.039105847,0.007331934,0.0362605,0.033710916,0.004157255,-0.06537744,0.035927355,-0.040434897,0.6014298,0.89884555,0.9704783,0.51136595,-2.8892834,0.15143904,-1.4371297,1.7275224}},
      {{-0.051772952,0.031561177,-0.27811873,-0.26141065,-0.08929124,0.011636176,-0.107378736,-0.14252496,-0.63301456,-0.6457345,1.1386809,0.36758462,-2.7906823,2.4075446,-0.19759479,0.43294406,1.692079}},
      {{-0.01134395,-0.007749809,-0.00034155592,-0.020331496,-0.0013202477,-0.033370897,-0.0074291374,-0.026696023,-0.25119048,0.6116415,-1.0209864,0.46237808,1.5609114,-3.6550448,-0.08763799,0.27855033,-0.099152826}},
      {{-0.20397666,-0.0147245005,-0.05648244,-0.54088265,-0.34603927,-0.20613852,0.071716614,-0.41875574,-0.3450172,-0.577955,-1.6766934,-0.8315699,-2.8999982,-1.6372254,-1.1372654,-0.82786214,-2.0776074}},
      {{0.019365154,0.007506553,-0.035462264,0.08245458,-0.05884659,-0.016088357,-0.13532783,0.042889677,0.2545955,0.40174273,-0.88971704,-1.1876462,0.52686995,0.63924855,-2.559754,1.4316695,1.7657211}},
      {{-0.0031834673,-0.028267425,0.06308167,-0.035853896,0.05191908,-0.014421927,-0.042690124,-0.038620017,0.24238674,-1.7225314,0.98163706,0.0707259,-1.9523565,-0.38478172,0.26655996,5.1715956,0.5618617}},
      {{0.026967894,-0.007325313,0.00050413195,-0.0053897253,0.0031852168,-0.013420004,-0.077333,-0.013677757,-0.22081211,0.62937874,1.0019537,0.05370305,-2.0311081,1.8538287,0.6950628,-2.2377565,2.2539139}},
      {{0.019568732,0.012159857,-0.0062311306,0.05135678,0.019027578,0.03257268,-0.012360072,0.047549713,-0.9896139,-2.5637133,-0.21094023,0.88968426,3.0975683,0.81471723,-0.60290843,-2.2960303,-1.0161502}},
      {{0.0424804,0.037416555,-0.067399256,0.0135390535,-0.044043012,0.032436784,0.015934903,0.026727032,-0.49331254,1.0731971,-1.2691967,-2.0552154,-2.186576,-1.9670463,0.025475571,1.0155249,-1.3508787}}
    }};

    h1_h2 = {{
      {{-0.046463624,-0.01966083,-0.72899,-0.141255,0.5426733,-0.13168809,0.36489165,-0.23881668,0.14628354,-3.2784824,0.0047565373,-0.51706886,-0.90232646,0.56736594,-0.12351473,-0.17145438,-0.06965346,0.082014866,0.71118575,0.3718026,-2.3153956,0.09247886}},
      {{0.25195113,-0.014514409,-0.1667046,0.1485355,-0.47091073,-0.14779831,-0.10321882,-0.4253297,-0.42671236,0.8092045,0.0049025007,-0.8692384,-1.0926913,-0.4923637,-0.0059977667,-0.33993572,0.070528805,0.0071337377,-1.7798196,-0.11135167,-2.0800195,0.49852264}},
      {{-0.07427686,-0.23150946,1.1972073,0.068244934,0.41985366,-0.3991518,0.09701641,1.478731,0.9576534,-2.3397307,-0.62526196,-0.32667652,-0.24874927,-0.08009579,-0.197312,0.9158647,0.13156009,0.5876187,-1.6908867,-0.036074348,-0.40338737,1.4514025}},
      {{-0.56196505,-0.78757405,2.0193634,-0.8028769,-0.10946453,-2.499308,-0.19998023,1.5319582,0.109421246,0.046017326,0.19413322,-0.38514102,-0.4651447,1.7285205,-0.62045175,-0.59377074,0.4612858,-1.6430523,-0.6205724,0.16529182,0.42908975,1.1661599}},
      {{0.64294034,-0.23918591,1.5031269,-0.13238892,0.111666255,-0.24468608,-0.21766514,1.9655768,-0.12493023,0.4147233,-7.06289,-0.083274595,1.192264,-0.083277814,-0.45216835,1.0634717,0.17357497,0.24778083,0.07140442,0.744074,-0.7553857,2.0429015}},
      {{-0.05600901,-0.51832044,1.8241571,1.0833901,0.0021044514,-2.17225,-0.11297389,-2.2950811,-1.0688728,-1.9868696,-1.5699897,-0.27680007,-0.077629216,0.8478977,-0.6698663,-0.09885496,-0.17135754,0.43548068,0.40742332,0.46257806,-0.047423404,-2.0256255}},
      {{0.31203455,-1.2440506,-1.0613133,0.380533,-0.29513708,-1.432742,0.41862717,-0.59126014,0.3456741,0.0045108953,-0.35368747,-0.56527555,-0.35933027,-0.47787422,-1.3509029,0.05128291,-0.41236085,-1.2379946,-0.2350961,2.7316837,0.02447762,0.874141}},
      {{0.03858819,0.09617225,1.8956581,0.22759822,-1.723428,-0.6112966,-0.4030796,-0.8229579,1.6611408,0.001226379,-0.29048297,-0.4524238,0.22763345,-0.054661877,-0.33663327,-0.17317249,0.46387213,0.1243631,0.021680579,0.6331957,-0.35727957,-0.3273685}},
      {{0.58161116,-0.062441994,1.7352129,0.6229103,-0.37304625,-0.43377423,1.124186,0.58473074,0.35362884,-1.9992049,0.22216561,-0.1970427,-1.4644017,-0.48565528,-0.3988133,-1.322002,0.28016886,-1.4678862,-1.0903277,-0.09773706,0.34990805,-0.16870533}},
      {{1.4871323,-0.19473447,-1.8835312,1.032035,-0.9969912,-1.228483,1.1772466,0.55931026,0.40408182,-0.5100844,-0.10505796,-0.22363193,0.27585885,-0.70577824,-1.395143,2.0407913,-0.78743994,-0.7170236,-0.41997147,1.1934036,0.51305217,-0.85226744}},
      {{0.083643734,-0.20556705,-0.21670747,0.53136265,-1.6510398,-0.62843263,0.3010045,0.4535821,-0.6559808,0.569481,-1.7635237,-1.4331948,0.061531212,-1.0407637,-0.85752124,-0.09124931,0.078261726,0.1828374,-0.7107088,-0.6013795,9.750994,-0.79816276}},
      {{2.2204132,-0.7646788,-2.4536343,1.2264835,-0.5832969,-0.8610283,-1.409852,-0.40444645,2.089309,0.42448992,-0.46534544,-0.53340894,-0.48928478,-0.6726801,0.31286684,1.064088,-0.3679434,-0.37486866,0.6827257,-1.0915247,-0.49633682,0.33239663}},
      {{0.81872016,-0.3638124,2.4112222,0.9747679,-2.188746,-1.4470677,0.60010886,0.697261,-0.2957135,-1.2103196,-1.3753483,-1.5797161,-0.0169674,-0.34426078,-0.7691503,-2.1829712,-0.18234774,0.17435533,-1.4108108,0.37878507,-1.0507059,2.3705277}},
      {{0.67580825,-0.4846374,-2.1823297,-1.4525857,-0.6468654,-0.98514235,0.46153092,0.33005932,-0.89236116,2.1036463,0.47403282,-0.23636799,1.4669769,-0.4907296,-0.155041,-1.9745896,0.7025191,0.34262103,1.5223427,-0.008826526,1.2404864,0.29521278}},
      {{0.18977839,-0.08325692,0.42838332,-0.24183875,0.000294426,-0.14537866,0.28453186,-0.0876594,-0.058450967,0.10872833,-7.0959806,-0.05857813,0.28720045,-0.71838486,-0.24113195,-0.82325166,0.18920986,0.46282175,-0.044335768,0.04689044,-0.24694173,0.015307824}},
      {{-0.37686822,-0.52719766,1.9661394,-0.47359008,0.57419,-0.020546693,-0.15179329,1.6713744,-0.25809297,-0.020224875,-0.12725474,-0.36788714,-0.047868397,-1.9084696,-0.99432445,-0.43196428,-0.047283467,-0.710831,-0.06792718,1.9308975,0.17151679,1.4447515}},
      {{0.43522006,-0.043870937,6.032113,-7.688444,-0.5252524,-1.447347,-0.48589185,0.37566665,1.0352776,0.684716,-0.5186622,0.108342186,-0.6420172,0.05325659,-0.059132256,0.17462546,3.023775,-1.0178531,0.69094276,0.54797906,0.7586045,1.3881588}},
      {{0.5268189,-0.05313014,0.98184556,1.006087,-0.5557827,-1.7325466,0.3860827,-0.82473767,-0.7211474,-2.0205,-2.7621908,-0.20168944,0.3644601,-0.56487155,-0.9791737,-2.2705934,-0.13820747,0.8755389,-1.8531525,0.11517608,-0.3365631,-1.5976971}},
      {{0.2624997,-0.14888348,0.51512873,0.06617581,-0.1404677,-0.7479597,0.686522,-0.68532187,0.19766557,-0.031174148,-0.05086811,-0.08041918,0.19639443,-0.56709373,-0.5292543,-3.412356,0.31440884,-0.22899371,-0.27321288,1.281383,-0.22694609,-0.66299397}},
      {{-0.268288,0.044538412,0.07761955,0.3619315,-0.37311634,-0.5958352,0.33938146,4.08404,-0.66928566,-0.71389014,-1.2764188,-3.7987428,-0.80444413,-1.9787114,-0.6948605,-1.6632507,-0.25227958,0.8034393,0.21987607,0.13113877,-0.28848407,0.046395615}}
    }};

    h2_out = {{
      {{-0.09313172,0.25949413,-3.4734278,-0.36491367,-2.169298,-2.112104,-2.2299142,1.1949263,0.69457024,-3.209305,-1.4407519,-1.857328,1.3233595,-2.5611374,-0.36829308,-0.10730711,-2.5442042,-2.393982,-0.75875515,-3.3560886}},
      {{-0.5984928,0.0040512295,-5.238717,-0.1582505,-1.4350749,-2.2930064,-0.73579454,0.46070603,0.6783451,-1.5614089,-1.3243519,-2.3027034,1.3630472,0.36562306,-0.68800366,1.0867105,-2.4002101,-1.865992,-0.2792621,-0.72654265}},
      {{-1.8679789,0.16669254,-4.2409644,-0.27153385,-0.85891557,-1.6384262,0.39039665,0.15163878,0.50581574,-0.46488026,-1.4647379,-1.7594091,1.2020285,1.0870407,-0.60799307,0.8128767,-2.5833933,-1.7210723,0.16125198,-0.69321585}},
      {{-4.3467026,-0.24142556,-1.1189343,0.018936483,0.23984143,-0.05423776,0.76043975,0.7775019,-0.19156085,0.7834005,-4.534018,-1.0005952,-0.7191327,-0.91664743,-0.03379889,-0.050473463,-2.0765254,-0.36200154,0.3856309,1.9255464}},
      {{-2.3843303,0.17305194,-2.1539247,0.5096749,0.9620407,1.0384698,0.7599603,-0.78545207,-2.8320444,-0.92344636,-1.5297304,-1.8669649,-0.9259647,0.647112,0.86555165,-0.7323551,-2.6114902,0.49534103,0.16228473,0.7846268}},
      {{-1.3974894,-0.17468797,-1.2481072,0.7299817,1.0928735,0.7295202,0.20310724,-1.2422835,-4.168047,-2.46672,-1.217371,-1.9441562,-0.7996914,0.1990825,1.0669698,-1.7171552,-2.5417354,1.1782663,-0.38147777,0.3211178}},
      {{-0.6419534,-0.3488147,-0.5823568,0.13812621,0.5724468,0.44162738,-0.6962292,-0.6359073,-5.2018356,-2.3400402,-1.7107692,-1.9273179,-0.7480466,-1.3628644,2.2405255,-2.9297564,-3.3069928,1.1508411,-0.8717398,0.98810303}},
      {{-0.01545641,0.5687917,-0.8566849,-0.37992135,-2.5297308,-1.1532581,-5.2117324,0.054111287,0.64629054,-1.1286522,0.6651811,-1.0464289,0.85503364,-1.7844559,0.48189402,-0.06362606,-2.1206465,-2.5989287,-1.3186258,-3.4537246}},
      {{-0.39526108,0.5906358,-2.1595898,-0.45213535,-0.9502138,-1.5231363,-2.10498,0.021293547,0.57136333,-0.81167924,0.98545146,-1.4544644,1.306503,-0.08105175,-0.011551353,1.1345243,1.5866114,-2.1316566,-0.6578498,-1.0725602}},
      {{-0.9172985,0.5739247,-2.0137057,-0.27437806,-1.1457114,-1.3776679,0.117525525,-0.42614445,0.17576781,-1.02956,0.47632793,-1.6066654,1.2954369,-0.09250834,0.3724797,0.8349819,1.0649861,-1.1759691,0.1484128,-0.17284033}},
      {{-2.454912,0.42807734,-0.7834684,-0.033824068,0.25610393,-0.33040076,0.5773261,-0.19195569,-0.16803218,0.84345376,0.2280068,-1.0218179,-0.48952243,0.9327766,0.08119165,-0.007958199,0.69691986,-0.47044536,0.39354247,1.1263553}},
      {{-1.4236219,0.35367247,-0.30582726,0.5276988,0.41491446,0.62365764,0.40258378,-1.2485834,-1.6503384,-1.378415,0.5468213,-1.831058,0.19683477,-0.22435465,0.6580471,-1.0095544,0.7850108,0.34666896,0.16293183,-0.2109337}},
      {{-0.93592584,0.21541494,0.048540782,0.71822953,0.9200082,0.50291085,-0.4915281,-1.0178055,-2.5892491,-2.3948183,1.010583,-1.5343261,-0.37243292,-1.0051342,0.20138462,-1.6635733,-0.561866,0.7038124,-0.8273425,0.97124624}},
      {{-0.2068939,0.25424019,-0.061155014,0.32240504,0.36449078,-0.26482528,-2.4893463,-0.9890707,-4.131789,-2.4494016,0.39281094,-1.0978053,-0.24046686,-1.9736277,1.1486092,-2.943009,-2.8323698,1.3968207,-2.1624458,-0.042295694}},
      {{-0.07772935,0.5166348,0.041757215,-1.5020704,-2.2280653,-0.5683436,-4.622249,-0.2661675,0.55052173,-1.1504477,0.8719155,-0.6646152,0.27386668,-1.0759302,0.56006306,0.70658106,-1.5520694,-1.4416906,-2.8635683,-4.2820463}},
      {{-0.29319787,0.47724572,-0.032218773,-0.86121505,-1.4493518,-0.122288264,-2.3764987,-0.43458346,0.5086922,-0.8098681,1.3416766,-1.0579337,-0.7346437,-0.4939715,0.74920404,1.3237988,1.2404333,-1.3159939,-1.2495109,-1.3320792}},
      {{-0.43183005,0.41524574,0.081164986,-0.4622815,-0.54949576,-1.0582964,0.03037888,-0.4618524,0.4982416,-0.35408556,0.66578895,-0.8125009,0.45836446,0.6671849,0.5434571,0.79820204,0.37740982,-1.162895,0.1298522,-0.83550906}},
      {{-0.69685286,0.36251763,0.30201823,-0.074156195,0.2304817,-0.5609454,0.6203349,-0.12831372,0.276831,0.81927496,-1.2723818,-0.3581936,-0.37522832,0.5356067,-0.091536455,-0.10322387,-0.110196576,0.11144264,0.35888264,0.5192186}},
      {{-0.61004204,0.21794964,0.42001367,0.58523595,0.49749455,0.16476405,0.33321753,-0.993889,-0.53622603,-1.0134515,0.5519103,-0.8691547,-0.4298962,-0.16290967,-0.17074163,-1.2650652,0.67923933,0.5727533,0.058577847,0.11497248}},
      {{-0.48749492,0.11524215,0.57170343,0.840452,0.30248585,0.49822533,-0.23318428,-1.1604685,-1.0961312,-2.2849321,1.1933678,-0.9988006,-1.1472374,-1.6491275,0.33011535,-2.0824125,-0.6047961,0.5214463,-1.9808185,0.7971606}},
      {{-0.14805615,0.20045425,0.5649608,0.3471997,0.065737255,0.18307236,-1.0407454,-1.0663123,-1.9785883,-3.3730786,0.92097265,-0.35669595,-0.3330207,-0.5344202,0.5767181,-3.230681,-3.6709604,1.0529317,-5.0070395,0.2971183}},
      {{-0.011881293,0.1941012,0.6024729,-3.6690805,-2.0876381,-1.0598553,-5.846258,1.572003,0.12336545,-0.77787876,1.3878758,0.33043176,-0.3179774,-1.4819766,1.3987427,-0.30575863,-0.20194767,0.5316493,-2.8630729,-6.492305}},
      {{-0.08904783,0.09341898,0.67255825,-1.7818897,-0.6627317,-1.0116518,-2.7532406,0.12590134,0.12512161,-0.67219114,1.2857947,0.5513251,-0.6039855,0.07698771,0.7665921,1.2152932,0.70789474,0.023617022,-1.4016309,-1.2242982}},
      {{-0.05358877,0.08509725,0.6464764,-1.336175,-0.34430835,-1.2623777,0.13803273,0.010085495,0.26620364,-0.58177465,0.9050287,0.54203653,-0.3051266,-0.005089153,0.17965364,0.7783558,0.14782175,0.49911845,-0.07803343,-2.0807366}},
      {{0.003572058,0.091680445,0.5852436,-0.20982814,0.2524812,-0.35323396,0.5277463,1.2928916,0.39419937,0.81857485,0.31657007,0.6969967,-1.0960375,-1.9876279,-1.4757882,-0.059432954,1.5392692,0.6323752,0.3760658,1.5341414}},
      {{-0.10864383,0.06405361,0.6643861,0.5382581,-0.015383344,0.36316666,0.36944392,-0.04617839,0.2317502,-0.7904649,0.75234914,0.5364389,-0.9530201,-0.25696552,-1.5631009,-1.3440204,-0.04899474,0.43039024,-0.35599613,-0.23001324}},
      {{-0.21827826,0.008911715,0.6891124,0.76585,-0.21804479,0.59894556,-0.64263827,-0.23387507,0.16261216,-1.2693987,1.1768914,0.65441847,-1.135178,-0.44869664,-1.1669722,-1.5620153,-0.76100206,0.19594704,-3.436152,-0.07910169}},
      {{-0.0115864165,0.18653716,0.58619964,0.03450042,-2.323907,0.5120846,-0.5134343,0.6282349,0.31276572,-3.1203187,1.363894,0.6166883,-0.31626374,0.18811911,2.348323,-1.8089905,-3.1583428,0.5328025,-9.272441,0.13756257}},
      {{0.37162223,0.12343787,0.44439262,-3.0075216,-0.384373,-0.7061379,-5.5217814,-0.4926482,-1.5510896,-1.4539208,1.099016,-0.55547345,-0.101090364,-0.68023294,1.2861551,-0.3924183,-1.14327,0.81303823,-1.9685524,-4.773015}},
      {{0.31402177,-0.33312905,0.5884402,-1.3466071,-0.05001926,0.03100009,-2.6430662,-0.8720562,-1.5597012,-1.319048,1.0215768,-1.2489537,0.055138186,-0.42805746,1.4647034,0.95835865,0.7590419,0.36562678,-0.6487432,-1.7586616}},
      {{0.30936778,-0.5960143,0.5146026,-0.75726146,0.35351256,-0.20911968,0.1273094,-1.0567628,-0.57263786,-0.8659962,0.6792638,-0.81692016,-0.26961553,0.7562047,0.027881518,0.63757944,0.7059506,0.660207,0.13100733,-0.90226376}},
      {{0.4571654,-0.4941728,0.3047708,-0.22263658,0.23079042,0.3335607,0.5820859,0.00720122,0.25287783,0.7891017,-0.6643633,-0.431931,-1.1362993,0.60606897,-1.0246437,-0.02207079,0.18951817,0.026498353,0.36191198,0.5419701}},
      {{0.19615519,-0.5617088,0.20815429,0.4471691,-0.36145788,0.8288818,0.1337661,-0.59730697,0.64296377,-0.7860653,0.73361766,-0.8000188,-0.15743825,0.50925225,-0.9696168,-0.6924971,0.23320496,-1.0931307,-0.024568701,-0.07803148}},
      {{0.17215012,-0.19038318,-0.020873863,0.83383375,-1.2464256,0.95061845,-1.168892,-0.54084015,0.5738561,-2.3741226,1.1256514,-0.785642,-0.51919764,-0.34664187,-0.25933257,-1.3797776,-0.9821776,-1.1922601,-2.1351213,0.09277454}},
      {{0.23903705,0.1145849,0.087365724,0.4190909,-2.372255,0.48419583,-1.9546329,-0.4077962,0.6358801,-3.026439,0.9235209,-0.20899758,-0.00015146646,0.022125155,0.94656986,-1.8677996,-3.3691678,-1.721244,-4.920886,0.4962619}},
      {{0.4208889,-0.5754123,0.3679146,-1.4855092,0.3499302,-0.10499644,-4.1600924,-1.1896148,-3.7183614,-1.5118521,0.39584947,-1.6167365,0.31531382,-0.476572,1.4611534,-0.33334672,-2.059354,1.3188547,-2.374003,-3.5587714}},
      {{0.3655832,-1.1340536,0.1988437,-0.7755093,0.90553975,-0.12887596,-1.8366843,-1.1640552,-2.1514137,-0.9987067,1.1468688,-1.184245,-0.2273252,0.38934782,1.1850834,0.7608397,0.13466954,0.49654508,-0.52842,-2.2821379}},
      {{0.58297676,-2.1515975,-0.22230704,-0.95290345,0.3922245,0.67419904,0.15281464,-1.0564876,-1.6442853,-1.0969983,0.41831282,-1.7504009,0.51101434,1.30183,1.0828964,0.5281352,-1.0438913,-0.2441628,0.20026702,-1.1244752}},
      {{0.54595476,-3.216858,-0.8102517,-0.32289308,0.21038727,0.7292915,0.53570604,0.069981165,-0.029308463,0.9357043,0.24383283,-0.89238054,-1.0199271,0.66838443,-0.23217025,0.06556589,-0.59770423,-0.8243913,0.36409852,0.62874466}},
      {{0.60297334,-1.9782487,-1.3588204,0.41341445,-1.08958,0.9729724,0.15429278,-0.5510717,0.29773247,-0.9855772,0.6210545,-1.6089821,-0.21447429,0.37244117,-1.3028761,-0.49881566,-0.68815356,-1.3422701,0.017672013,-0.4761806}},
      {{0.4008684,-0.6465047,-1.4503152,0.77738744,-0.9075472,0.96796,-1.5834551,-0.08674094,0.7372318,-1.9912897,0.90698504,-1.113971,-0.22434746,0.18930508,-0.46832603,-0.8851661,-0.4638985,-2.256362,-1.2856833,0.8373921}},
      {{0.48884887,-0.05627176,-0.97864664,0.32770234,-2.5908113,0.7140834,-3.4166098,-0.0022471524,0.70830995,-2.7066083,0.7247824,-1.2613174,-0.18617098,-1.0946703,-0.40509167,-1.3116407,-2.9373298,-2.3282545,-2.566407,-0.24785927}},
      {{0.001810392,-1.0570838,-0.45883232,-1.5603224,1.0092872,0.46811777,-1.489742,-0.8185672,-5.4943705,-3.12543,-1.416612,-2.1648495,-0.19173509,-0.28531793,2.0276453,-0.9348998,-2.579723,1.1499733,-1.4304936,-3.287908}},
      {{-0.0656998,-2.078612,-0.88302726,-0.92256755,1.0383214,0.68933564,-0.5461005,-1.3602718,-3.632248,-2.771825,-0.6369287,-1.7530913,0.3505428,1.4691275,1.9086139,0.6369638,-2.8760707,0.89566046,-0.23249671,-2.315899}},
      {{0.2482418,-3.668751,-1.5678426,-0.5513061,0.6528435,0.90018106,0.37318388,-1.0003295,-2.3533804,-0.07909092,-1.2628429,-2.0910192,-0.14658731,1.1570315,1.6580286,0.5113227,-2.5743275,0.29696774,0.19528407,-1.0107995}},
      {{0.23724836,-6.4963117,-1.1434214,-0.13357747,0.17037378,0.3766801,0.68756545,0.6227872,-0.26875284,0.8715889,-3.2190728,-0.6422289,-0.39310992,-0.29289317,0.100767665,0.01590179,-2.0755084,-0.7451007,0.38902652,1.6624931}},
      {{0.40215376,-3.807208,-2.8336985,0.48143983,-1.1603847,0.9285838,0.5626623,-0.168465,0.46673855,-0.5361572,-1.3198018,-1.485735,0.1970098,0.6574997,-1.0404779,-0.23612642,-2.5711796,-2.3744984,0.119433984,0.5476332}},
      {{0.32201758,-1.1968104,-3.474484,0.79328525,-1.6329322,1.3115436,-0.6020958,0.16079967,0.6690338,-1.6062428,-1.011962,-1.8175502,0.35570005,0.7890542,-1.5365133,-0.3611831,-2.4080472,-3.0062988,-0.621418,0.33024344}},
      {{0.4244427,-0.2999631,-3.281546,0.2912403,-2.6326027,0.92283195,-2.0956087,0.73395365,0.69731474,-3.2422686,-1.409251,-2.1280427,1.1313113,-0.60101056,-1.0638283,-0.8599673,-3.6380444,-2.716333,-1.4825794,0.2590922}}
    }};

    b1 = {
      0.015903419, -0.60227036, -0.55468005, -0.092626445, 0.25415, -0.027518466, 0.110175, -0.30450475, 0.14090793, 0.039055273, -0.011192674, -0.047886033, 0.015466831, 0.0694157, 0.0547248, -0.13115668, -0.4684244, -0.044441625, 0.14837587, 0.17050004, -0.057538223, -0.39718202
    };

    b2 = {
      -0.05894364, -0.009287893, 0.31300798, 0.20167714, 0.166974, -0.06104298, 0.02484285, 0.9545253, 0.13052164, -0.023447916, 0.0117404945, -0.114925675, -0.1679526, 0.0012036092, -0.0055525647, 0.11263925, -0.041200027, 0.12127178, 0.004521281, -0.14416924
    };

    bout = {
      -2.1688132, -2.1378198, -1.7170479, 0.04054696, -1.5470332, -2.093737, -2.1390905, -2.5344722, -0.87187, -1.2215066, 0.2607326, -1.2872977, -1.0571953, -2.4269404, -1.9501182, -0.924637, -0.11113739, 0.54489005, -0.24165875, -1.1616825, -1.9048964, -0.30332357, 0.3134155, 0.6277467, 3.6006234, 0.65275115, 0.077199504, -0.3257294, -1.9795984, -1.1438103, -0.2621404, 0.44964087, -0.21798725, -1.3237076, -2.0459216, -2.5359042, -1.1175456, -1.4588938, 0.04668859, -1.5874739, -1.088992, -2.5471063, -2.3225977, -2.1284974, -1.6312981, -0.13153136, -1.7595754, -2.1337929, -2.269642
    };

    BN_gamma_in = {
      0.8995777, 0.4539498, 0.24130994, 0.9252809, 0.13256377, 0.4301898, 0.48184597, 0.34613717, 0.39175862
    };

    BN_gamma_1 = {
      1.8756747, 1.8137974, 7.3869457, 5.1261106, 1.2804216, 2.406234, 0.88521385, 6.0907087, 2.0778127, 2.2600336, 5.901325, 3.1423426, 2.1669235, 2.6387956, 1.7489253, 4.1758647, 4.217316, 1.6245921, -2.0819702, 1.5803133, 2.1015813, 5.2583113
    };

    BN_gamma_2 = {
      2.2312465, 1.5140718, 1.2027915, 1.6486337, 2.373938, 2.9412482, 2.115393, 1.0767844, 1.6430639, 2.655902, 6.407349, 6.207337, 4.5662827, 2.9203968, 3.2246392, 2.4315975, 4.47328, 2.0654826, 1.9718106, 4.91613
    };

    BN_beta_1 = {
      -0.10211888, 0.0021640966, -0.013352622, -0.020952128, -0.08686178, -0.05816717, -0.01763134, -0.024228236, -0.11299755, -0.15098272, -0.012911666, -0.0015145397, -0.20436394, -0.06575097, -0.0029313562, -0.040411692, -0.04532595, -0.06954603, 0.020386782, -0.0122187985, -0.28957677, -0.015291243
    };

    BN_beta_2 = {
      -0.09967562, -0.06911084, -0.35003337, -0.3430136, -0.39764857, -0.08613968, -0.051904004, -0.94047904, -0.1641568, -0.05744048, -0.18505529, -0.027283385, -0.043995462, -0.093776286, -0.09398964, -0.32448474, -0.09626618, -0.1955627, -0.07213301, -0.11135348
    };
    
    mean = {
      28934.678928730336,14898.819258388328,28928.550954853097,19992.62621922142,2668.0555968414565,19848.724334111426,28842.245188912773,14626.770800248936,28639.980444933626
    };

    stdev = {
      255999.8559999595,160010.5468523872,252341.39262514978,173461.22379367673,32798.269222628194,171455.79096665123,253796.88811331,159361.63854579307,254188.62363213662
    };
  }

  else { // QP=22 and Default
    
    embs0 = {{
      {{-0.16975532,0.045363814,0.32513246,0.015320927}},
      {{-0.0066220653,-0.021806102,-0.000798176,0.000571859}},
      {{0.004426548,0.0006039556,0.0003705724,-0.00056983775}},
      {{-0.043807168,-0.003985219,-0.06480355,0.08762049}},
      {{0.0020846543,0.026479902,-0.0007006448,0.0027451382}},
      {{-0.070605755,0.020090405,-0.06008874,0.12078819}},
      {{-0.037274115,0.07327984,0.02377873,-0.0014188477}},
      {{-0.100148864,0.12777038,-0.089711905,-0.07731894}}
    }};

    embs1 = {{
      {{0.11903641,0.18147233,0.25847718,0.14534524}},
      {{0.0013263059,0.008399924,0.020855973,-0.0011777143}},
      {{-0.0006782994,-0.005206597,0.000113541704,0.00040282382}},
      {{0.028266627,0.06784024,0.0059771687,0.08320835}},
      {{-0.0011163371,-0.006017297,-0.026648302,-0.00043667332}},
      {{-0.07999833,0.07754565,0.0013394062,0.04605185}},
      {{-0.01864941,0.026707733,-0.07785518,-0.027559327}},
      {{0.07634293,0.064105876,-0.13089725,0.013749864}}
    }};

    in_h1 = {{
      {{0.032233328,-0.04320315,0.011435049,0.023491226,-0.04682137,-0.013816372,0.04212266,0.06884688,1.7332525,-0.31359783,-0.16956565,-1.6821268,0.65157336,1.2578125,-1.409745,0.35645607,0.49610272}},
      {{-0.021283515,-0.03335793,0.010010695,-0.010469985,0.0051552244,0.028044678,0.028789,-0.004923572,0.7845162,-0.47945943,-1.9494275,0.2264626,0.122951955,-0.1011556,-0.64519906,-0.14166372,2.2050562}},
      {{-0.016696798,-0.2538565,0.17137755,-0.0007199288,-0.08713363,0.026295122,0.23937565,-0.10585505,-0.26025766,1.0252137,0.21080025,0.1217798,-4.780523,-0.55787855,-0.3380482,-0.2597643,0.52381486}},
      {{0.0025118766,-0.0005271777,-0.0053496663,0.007323361,-0.008572172,-0.008306092,-0.001273721,0.013129395,-0.18717335,0.39846373,-0.6384277,1.5180126,-0.11338599,-5.2165055,-0.102409475,0.676358,-1.0209342}},
      {{-0.005579716,0.006419695,0.002827593,0.0033286759,0.0030397978,0.0023810072,-0.008418035,-0.0024628148,-0.94672376,0.94476163,-0.17992967,-1.9317445,0.57235813,-0.6665414,-0.28801432,0.49358606,-0.16198277}},
      {{-0.33879793,1.0259217,0.078596905,0.08090454,-0.21344936,0.15381175,-1.0060829,-0.097772084,-0.9705085,0.36709464,-0.21020119,-0.67135966,-4.235701,-1.6253436,-0.12623546,0.42821336,-0.13050124}},
      {{0.07612994,-0.038495306,-0.050565436,-0.014066159,0.06120887,-0.07173688,0.042028155,0.014371674,1.3743534,0.2575935,-1.1004016,1.5444047,-0.29826322,-1.2943006,0.93901825,-0.5509126,0.19935346}},
      {{-0.012749178,0.0071581206,-0.00077100476,-0.004692591,0.0072094887,0.011577212,-0.008603788,-0.0062436266,0.0677901,2.7970192,0.2634592,-0.10732266,-0.86610913,-1.2452245,0.14387701,-0.08602971,0.43696725}},
      {{-0.03709573,-2.0179868,0.269702,-0.009200274,-0.953544,0.017633999,2.1653974,-0.14133406,0.5058977,2.3494105,-0.3168477,-0.32520884,-1.0166553,-0.088583454,0.41849828,2.3504438,0.18108195}},
      {{-0.020203952,0.040662922,-0.028689234,0.022200108,-0.032574557,0.016773945,-0.018440675,-0.0075720665,0.72853255,-1.0607656,0.32145596,-0.3691024,-0.32130828,1.4760427,0.39017242,2.5298522,0.5197744}},
      {{-0.34666914,0.6965142,-0.09404293,0.11233076,-0.0708878,0.15495427,-0.6989886,0.036501665,1.4680347,2.086068,0.16309582,-0.6183052,-2.361371,1.363266,0.11290442,0.17563908,0.22471696}},
      {{-0.17529902,0.28637654,-0.06104469,0.021615522,0.015615795,0.115461916,-0.27054548,-0.024039922,-0.1315489,-2.3046482,-0.061666127,0.3123662,-0.6444722,-0.5264839,-0.27585223,2.267938,0.13781442}},
      {{-0.23634875,0.9223627,0.067730896,-0.054158825,-0.14642686,0.07988294,-0.8630254,-0.22624724,0.37537816,-0.36021355,0.59166914,0.35275915,-5.0570564,0.9651406,-0.29421738,0.13887765,0.08352071}},
      {{0.011040403,0.06371087,-0.006785396,0.0037060836,0.004986658,-0.018342165,-0.059465438,0.01661684,-1.2915161,-0.51760495,-1.2500687,-1.6538452,0.21689314,-1.6900631,-0.91432637,-0.08998069,-1.2032403}},
      {{0.11678858,0.29279447,-0.11468549,-0.04230383,-0.0653149,0.014950071,-0.14393914,0.046500813,-0.47051084,1.4948831,0.8869894,0.54798454,-3.457722,-2.4582431,-0.35350782,1.1761938,-0.14209864}},
      {{0.044621233,0.15169649,-0.017571531,0.015270152,0.017826814,-0.059648897,-0.14409606,0.04635145,0.9733506,1.4323511,0.74398565,-0.6907784,-3.8535478,0.29486537,0.54092443,1.2688438,1.4234442}},
      {{0.014522916,-0.7412382,0.06048211,-0.269744,0.18545242,-0.020079037,0.7161165,-0.26562908,2.7158425,1.3743815,1.6383133,-0.8445368,-0.23139969,1.4878063,0.8575202,-0.38330114,2.6684337}},
      {{-0.017726243,-0.024935527,-0.0018399662,-0.009656428,0.006873364,0.023999028,0.024526741,-0.0013124445,-1.3384358,-0.79949504,1.7145252,-0.33724985,0.20182994,0.48634297,1.4491612,-0.20465717,-1.3636613}},
      {{0.16284826,0.13254888,-0.016002111,-0.018582815,0.07776952,-0.18360133,-0.109188095,0.022046087,0.34467506,0.14975765,-0.4595508,0.0023108586,-6.231635,0.13145943,1.1112989,-0.048205957,0.4159165}},
      {{-0.009820897,0.018256418,-0.008292567,0.004545182,-0.0013562569,0.008913817,-0.015045762,0.0060626324,-0.16298327,2.453882,-0.04692776,0.098332964,0.12763879,0.18820195,-0.079631805,-3.6923184,-0.044379283}},
      {{-0.42861167,1.6259239,-0.102072835,0.34505773,0.038589202,0.42440563,-1.4468919,0.11981008,0.34342194,-0.18455619,0.5859436,0.20932741,1.4032136,0.15673392,0.9556269,-0.9303994,0.7715805}},
      {{0.1233189,0.15507144,-0.008091618,0.048107766,0.16004395,-0.059134223,-0.04123528,-0.19776572,-0.97081494,0.3858582,-1.6488861,-1.4034482,1.5553182,-1.774487,-0.025341187,0.7592326,-0.72303575}}
    }};

    h1_h2 = {{
      {{-0.28315648,-0.20422919,0.9419162,-0.08831924,-0.7402545,-0.25295857,0.20870277,1.6931331,-1.952392,-0.6703491,2.6242852,-2.9681544,-0.11217717,2.6494405,0.7180346,-0.045319226,-0.20025092,-0.12274363,0.14891209,-3.4228933,0.07361022,-0.009135329}},
      {{0.786492,-0.7769711,1.1824418,1.054066,-1.102863,0.64994925,-0.7825104,-0.36148325,-0.655182,-0.7066175,-0.5634551,-0.28135648,0.0043252804,3.0329497,0.5359624,2.9186118,-1.4055561,-0.6792484,-0.15823258,0.20345847,-0.30974993,0.2823251}},
      {{0.15865995,0.3129444,-0.5677205,2.6743057,2.9831383,0.97722715,-5.967382,-1.8317051,-0.2151648,-1.9874098,-0.6078692,0.23177886,-0.70344496,-3.9731321,0.085664175,-6.061704,-1.4335587,-1.2965509,-1.5090865,0.057565022,-0.35051122,2.0767105}},
      {{0.003950957,0.035530355,-1.2605325,1.1424065,0.011689649,0.020336432,-1.1492133,0.27769533,-0.18186018,0.45974377,0.0666821,-0.5248943,-1.8453363,4.7569737,0.5739451,-0.37313828,-0.20236762,-0.3892698,-3.9836977,0.07974759,0.087126344,-1.6381361}},
      {{-2.8823957,-8.296007,0.7518061,-0.23727974,0.039282005,0.45731747,-0.42373654,1.5803483,-0.5469308,-0.51256186,-0.25349754,-0.5847966,-0.47822872,-0.836424,1.294126,-0.47805816,-0.8299666,0.53871393,-0.4811632,-1.1874125,0.44534197,-1.9691998}},
      {{-3.0582092,-2.7366533,0.4102309,-0.5359205,-1.215145,-1.0431371,0.72610927,0.6310809,-0.42905083,0.3289294,0.49609596,0.9669648,0.4833895,-2.1437416,1.0823671,-0.3088614,-0.4466171,-0.062574975,-0.13218783,-0.24066964,0.14081264,-4.619614}},
      {{0.2092907,1.0487279,0.8348733,-0.11841189,-0.42407706,-0.21728337,0.29259723,1.100265,-0.43304113,-0.13932009,0.44980407,-0.22565085,0.13813193,-1.7217455,1.2947867,-0.5444364,-0.86363906,-11.04666,-1.5720185,-1.04475,0.2147227,-1.3528901}},
      {{-0.3985284,0.06872173,-0.23652698,-0.021021226,-11.238359,-0.28455603,0.003075325,-3.8918579,-0.6568047,0.20088395,-0.2994245,0.9698908,-0.011021242,2.173491,-0.088005304,-0.085342236,-0.06966288,0.066929474,-0.0050485823,-0.8335625,0.050042585,-0.35748225}},
      {{-0.6409357,-0.018066777,0.23871346,-2.1850443,-1.585433,-1.9531934,1.4884738,0.1820263,-0.3155417,0.40281194,0.60334694,0.8359887,1.8480275,2.7740726,0.86647755,-0.3035952,-0.50131065,-1.6018208,0.66296196,0.0034629044,0.14279446,-3.7189157}},
      {{0.8171365,-0.52078414,0.14613944,0.34991968,1.4835998,-0.96070147,-0.31495413,-0.99639666,-0.11320342,-0.9206678,-0.85249996,-0.050265066,2.5024316,0.9759661,-1.0836477,1.1362749,-0.20433685,-0.036217943,0.7731926,0.058990024,-0.6185296,-0.34445176}},
      {{-0.20346463,-0.0041064867,-0.46478593,-10.40052,-0.7399569,0.33968994,-0.25674352,-0.2789612,-0.008909983,0.1413448,1.308826,-0.0015697569,-0.48273328,-0.96679455,0.030193506,-0.3851358,0.08765422,-0.2561354,-0.8389337,-0.019710848,-0.08873287,-0.7489742}},
      {{-0.17920211,-0.10235866,-0.12087621,-0.07473235,-0.33991262,-0.6360049,0.019748341,0.1291814,-0.30421862,0.75437385,1.2478162,0.1591721,0.025271302,-2.4925358,0.36672494,-0.29449287,-0.22560905,0.015344853,0.006844574,-7.248268,0.023168745,-0.111932114}},
      {{-2.1965857,-0.38165805,-0.38354278,-0.5482256,-2.1399927,-0.66764855,0.48317018,0.48310068,-0.4690119,-1.9275362,1.566639,-1.152644,0.78797907,0.4511022,1.0409966,-0.7317495,0.015297818,-0.41386607,-0.15316074,-0.21229054,0.43826848,-0.21742196}},
      {{-1.7419335,-1.0288858,0.92282605,-1.954201,0.23168927,-0.048856746,1.2041346,0.758646,-0.95575595,-0.94800866,-0.7196553,1.2780895,-0.3111288,0.98341656,0.0057521025,1.4758384,-1.1720613,-1.9230107,2.5814,-0.4876572,0.4602648,-1.2647597}},
      {{0.62576866,-1.6110976,-1.144015,-5.0753665,-0.30427605,-1.2266376,0.042779725,0.16150211,-0.25261423,1.3486894,0.7585472,-0.82221085,-0.28482693,4.6429257,-0.010644701,-0.126993,-0.5082447,-0.11047809,0.582141,0.28065082,0.40828106,-1.6806253}},
      {{-0.19546793,-0.41180655,-0.61060226,0.012557871,-1.2787187,1.1276016,0.126601,0.37909606,-0.8719247,1.3135947,-0.067191936,1.1562586,-1.3484828,2.3055696,1.3825496,-0.20414858,-0.26194292,-0.52521986,-4.720687,-4.623654,-0.21323615,-0.023361381}},
      {{-0.4447127,0.12070506,0.6606197,-0.04952881,-0.64438415,-1.6118245,-0.39832237,-0.15273601,-0.45512128,-0.37631997,0.34565872,0.03232515,1.9702544,-6.5877223,1.0269915,0.5616777,-0.50177985,-0.07821682,1.9633906,0.12303919,-2.342274,-0.8111677}},
      {{-0.17130426,-0.20285657,0.46596137,-0.037429202,-0.15225525,0.51346195,0.032440122,1.880274,-0.9572986,0.68229294,0.7719894,-0.31837913,-0.07329823,0.29470152,1.3723587,0.0037909881,-0.26983464,-0.35373938,0.110210635,-1.1162235,0.16358565,-0.22838373}},
      {{-2.0341308,1.4208394,1.1490445,-1.6554028,-6.814843,0.5795591,1.2992609,-0.34525064,-1.4922628,-1.8775127,-0.55022454,0.8481847,-0.7128967,2.5936863,0.561838,0.65712667,-1.2201917,0.84848493,-0.03951934,-0.0720509,0.6655109,-1.4787341}},
      {{-0.76172763,0.30283746,0.5334521,-0.34971872,0.68348485,-0.0567325,0.13198255,-9.481619,-1.2378404,-1.4008526,-0.08334683,1.2369635,0.5782641,1.1156771,0.587692,-0.287089,0.04063968,0.17015554,-0.059686173,-2.0124092,0.29268566,-0.20993502}}
    }};

    h2_out = {{
      {{-0.19302931,-0.7515498,-6.7233844,-1.4304606,1.500284,-0.77261704,-4.086735,-1.2846141,-7.7005534,-1.5174807,0.88826543,0.17011651,-1.3953522,-4.4301867,0.14087948,-0.17194541,-1.5730603,1.7754402,0.13529363,0.07898791}},
      {{-1.0962442,-1.1836363,-4.220842,-0.5992543,1.5845023,0.089515395,-3.4519598,0.09456855,-3.519966,-1.2596396,1.4173827,0.49487635,-1.4763361,-5.4034314,0.6646157,-0.6017467,-1.2743416,2.8594525,0.25727773,1.3863492}},
      {{-3.6743946,-1.8360484,-5.1180377,-0.90792954,1.241614,0.43380845,-2.5114927,0.5408967,-0.2634203,-0.16925162,0.8301155,1.0988995,-1.6996,-2.5458534,0.50971967,0.37951192,-1.5968858,4.9502215,0.49204826,3.2809918}},
      {{-4.0139494,-2.4575899,-3.410823,-0.6360099,-0.2749623,0.3453271,0.015879638,1.4153315,0.50135565,0.9972174,-0.25010642,0.07949457,-1.915503,0.54305243,0.20951039,0.5019919,-0.3099615,4.06699,0.45281523,4.4252453}},
      {{-3.3904235,-2.1341126,-4.9782176,-0.1593353,-3.4501672,-0.27097252,1.475111,1.4441036,0.45506102,-0.84918433,-0.67895913,0.44873032,-1.4400958,0.2516752,-1.3018076,1.0856615,-2.1510618,5.273245,0.9377068,3.3102112}},
      {{-0.67876506,-1.737471,-4.997851,1.2623321,-4.3203883,-1.9946742,1.7294923,1.4098674,0.094904564,-2.08286,-0.83443606,-0.35565025,-1.1252253,-2.4746017,-1.9841322,0.3568817,-1.4066098,2.5104685,0.73591965,1.8221215}},
      {{0.2156104,-1.2464952,-6.786638,0.26700753,-4.5592833,-6.1217995,1.1296978,0.35171002,-0.17296213,-1.6430585,-1.3535001,-0.2508802,-0.98273593,-1.7118332,-1.7846104,0.4431542,-1.2506377,0.99817127,-0.40091926,0.39670753}},
      {{-0.5311861,-0.42823195,-4.953603,-0.84050435,1.4038681,-1.0026665,-3.6508703,-3.5369422,-9.876617,-1.0584979,1.0113225,0.7222895,-1.0370414,-3.3348653,0.42886227,1.0180756,-1.8752656,0.25860173,-1.3921458,-0.32506317}},
      {{-0.7081668,-1.1049185,3.0472674,-0.7748431,1.2239861,-0.330538,-2.493556,-0.75449544,-5.7926807,-0.46865422,1.7714472,0.47279328,-1.5230575,-3.325804,0.8167401,1.3098218,1.3580499,0.7588852,-0.0342558,-0.047043845}},
      {{-2.286962,-1.298621,-2.5909085,-1.0667332,0.99780416,0.25510633,-1.6961603,-0.11077459,-0.45916972,-1.3321866,1.189774,1.038744,-1.7620237,-1.6344857,0.5929657,1.4686526,0.58362156,1.6075176,-0.46080545,1.5572326}},
      {{-4.7648554,-1.9315935,2.6824331,-0.67517936,0.4820401,0.37700784,0.38825357,0.7803566,0.4903371,1.0162829,-0.021754397,1.2777116,-2.0804203,0.5381217,-0.09039199,1.4803953,0.5810815,2.7991436,0.61228734,3.4968748}},
      {{-1.9376945,-1.9631119,-2.9190154,0.14525609,-2.3552043,-0.059339825,1.022034,0.64311415,0.40183192,-1.4538149,-1.0613698,0.40836188,-1.1623544,-0.7310907,-1.2732611,1.8857414,0.096678026,1.275182,0.29394904,1.6698322}},
      {{-0.32800755,-1.1691048,-1.900123,1.3766613,-2.9064145,-2.0686684,1.2784606,0.25861976,-0.051853843,-1.5906551,-1.2781851,-0.17259575,-0.8295782,-3.0663059,-2.2895458,1.7725326,0.13897036,0.5162619,0.28396657,0.96209884}},
      {{-0.061069623,-0.73346776,-5.6232433,0.6156727,-3.174257,-5.536052,1.1960504,-1.2902792,-0.96459734,-1.6943566,-1.7576053,0.26588553,-0.674033,-2.1250544,-1.5508149,1.5125798,-1.491924,0.058916982,-1.7626542,-0.4007074}},
      {{-0.0066050496,-0.39399093,-4.451856,-0.26292872,1.3373294,-1.9591925,-2.3688264,-2.5380745,-10.385635,-0.88212436,1.3537333,0.038535453,-1.727968,-0.38520825,0.40531513,0.72679687,-1.6104522,-0.07169747,-5.949309,-0.8627968}},
      {{-0.09114392,-0.76007956,-0.5692998,-0.2784813,0.8314196,-0.6716191,-1.7707615,-1.3791224,-4.3589363,-0.8246344,2.0384169,0.104601815,-1.5305567,-1.1531358,0.8525469,1.12102,0.2914242,-0.027926195,-2.341272,-0.45817044}},
      {{-0.101117104,-0.61678016,-1.79327,-0.9569333,0.4806465,0.2532377,-0.96543485,-0.8071444,-0.10524435,-1.2774816,1.22962,0.19757348,-1.4657041,-1.0277673,0.6435607,1.0829644,0.23507743,-0.17776418,0.28120667,-0.186897}},
      {{-0.6579556,-1.1655052,-2.2287188,-0.9818442,0.33619887,0.54238695,0.34388107,-0.08879888,0.4951574,1.0107507,-0.16984622,1.0778086,-0.9306468,0.53230405,-0.016578283,0.98766273,0.033652574,-0.0012900532,0.7227481,0.5098539}},
      {{0.05250555,-0.85866964,-0.020847375,0.24394825,-1.2420974,0.41803622,0.6232826,0.014752978,0.40612411,-1.3208896,-1.1140977,-0.18362929,-0.4813931,-0.29087305,-1.2721221,1.5219749,0.15642148,-0.32813188,0.7411333,-0.38024577}},
      {{0.18440841,-0.49170485,-2.8602233,1.5872208,-1.9723476,-0.9333548,0.91012615,-0.22704318,-1.593162,-1.6843603,-1.9739077,-0.032567896,0.012045151,-1.1854634,-2.703058,1.394249,-0.9530054,-0.26781538,-1.2730318,-0.22763316}},
      {{0.5159404,0.16935083,-4.9467087,1.2402835,-2.3330956,-3.4186277,0.7366493,-1.2690704,-3.5852873,-1.7072394,-2.8499312,0.07427565,0.19997033,-0.6401098,-2.3163867,1.1868842,-1.6827347,-0.32862407,-3.3350408,-0.8335786}},
      {{0.6298013,0.39260346,-2.3248909,-0.19904903,0.29068217,-2.9845119,-0.29690945,-1.7284857,-4.855898,-0.81074893,1.1428498,-0.5193474,-1.6615301,0.6124705,0.2520527,-0.027652062,-1.9481361,-0.3760097,-7.8508105,0.30500543}},
      {{0.60778934,0.29166967,2.172038,0.1663631,0.23555161,-1.3677244,-0.38255185,-1.3406013,-2.995688,-1.1715003,2.0870695,-0.2909385,-1.283027,0.6205111,0.6868735,-0.17865784,-0.37150213,-0.37505552,-5.43637,0.5806076}},
      {{0.65446466,0.44928572,-2.220764,-1.0972114,0.2075122,-0.023036558,-0.28481403,-0.88064075,0.11462906,-1.0249244,1.4878287,-0.18237673,-0.5770003,0.523052,0.53949386,-0.25995395,-0.81531626,-0.43158737,-1.9177543,-0.40627557}},
      {{0.77186877,0.6152887,6.102398,-1.9358509,-1.910665e-05,0.5396179,0.1420089,-1.3562571,0.4851364,1.046402,-0.22768678,0.13416597,0.601249,0.53476787,0.042624336,-0.20122522,1.460554,-0.3900511,0.532629,-0.45801926}},
      {{0.7515069,0.6959691,0.055169668,0.33859944,-0.16279432,0.6441767,0.20235786,-0.5320668,0.22764316,-1.3359299,-0.9931141,-0.24992454,0.43197003,0.46285725,-1.879491,0.19998755,-0.8501056,-0.41259697,-0.4478164,-0.37839103}},
      {{0.6716581,0.53958815,0.9436397,1.5324157,-0.30441743,-0.075347476,0.3895718,-0.07867039,-3.761732,-1.1604602,-2.1595318,-0.26726902,0.64974195,0.5233856,-2.6802611,0.29230618,-1.2664102,-0.4058593,-3.6065063,0.1679291}},
      {{0.71369576,0.44813722,-1.1180058,0.98727244,0.04453269,-1.5042367,0.14757168,-0.5552687,-5.672888,-0.86411613,-2.6767948,-0.5012283,-0.1219469,0.54047906,-1.9628416,0.18223764,-2.197968,-0.4093715,-4.591992,0.32013133}},
      {{0.74934286,0.09900592,-5.292239,0.10184767,-0.9883267,-6.513913,0.6931756,-2.1549716,-5.1431065,-1.0877622,1.4201174,-0.8835911,-2.0326724,-0.5398031,0.45709282,-0.21440512,-1.7295556,-0.30220288,-6.110393,-1.4468286}},
      {{0.6774014,-0.5476846,0.026819041,0.48144767,-1.2497747,-2.382431,0.51325023,-0.8075577,-1.5972208,-1.0962598,2.1483607,-1.158091,-0.99644196,-0.66467535,0.7408176,-0.8004236,0.5348873,-0.31736234,-4.3950305,-1.0843729}},
      {{0.5860552,0.0019740069,-0.09488072,-0.042676207,-1.1366754,-0.18254098,0.4652139,-0.37080327,0.46494943,-1.6433225,1.2380494,-1.0145174,-0.01160194,-0.65944225,0.6935889,-1.2596893,0.22143787,-0.39493042,-0.54952914,-1.2234641}},
      {{0.2024442,-0.832916,-1.4439023,-0.6807919,-0.019262085,0.61038715,0.25156033,-0.9403517,0.49891594,0.9926009,-0.14153324,-1.7162217,0.6530905,0.53414536,0.10714009,-0.3208246,0.23513547,-0.3611997,0.7480634,-1.3542144}},
      {{0.45189962,-0.15883334,-1.0508248,0.6565984,0.40544096,0.9068277,-0.37441716,-0.2506884,0.17752889,-1.1718559,-1.3915365,-0.69138557,0.8656193,-1.3171374,-0.7950921,-1.3258601,0.23091602,-0.29981354,0.36516514,-1.2600774}},
      {{0.29448986,0.052661575,-1.5325136,1.5863289,0.6530212,0.33952206,-0.39211684,-0.07891102,-4.97265,-1.3817039,-2.1519234,-0.7595405,0.88832545,-2.0078168,-2.008744,-0.56156003,-1.0647004,-0.20412028,-1.9998506,-1.1981181}},
      {{0.3631556,0.4266488,-3.0786195,1.3837614,0.8497178,-0.7487834,-1.1964815,-1.0871058,-10.947409,-0.9457581,-3.1215208,-0.6349785,0.5592954,-1.1268573,-1.809752,0.01930455,-2.2649403,-0.3394126,-4.2745714,-1.4254353}},
      {{0.4845078,-0.24922086,-5.8554177,0.28192738,-2.9493003,-7.578339,0.99785227,-2.5773492,-1.428455,-1.7232015,0.95565563,-1.392912,-0.66192573,-1.796365,0.5867451,-0.73216796,-1.0058364,-0.20298626,-5.129286,-0.9938623}},
      {{-0.01574628,-0.7096299,-2.480221,0.37950426,-2.7546628,-3.7542973,0.95401853,-0.38864046,0.028196538,-1.4126263,1.6004133,-1.3914359,-0.29212525,-2.7962568,0.8194277,-2.23241,0.619298,-0.057765044,-2.5018759,-0.05766718}},
      {{-0.754908,-1.2353824,-3.8645146,0.02543145,-2.8579226,-0.65978533,0.47545427,-0.14378484,0.4917872,-0.9680709,1.4083838,-2.0502734,1.0483361,-1.0572549,0.6223128,-2.291778,-0.37295777,0.16293216,-1.3628124,-0.6262058}},
      {{-7.445612,-1.1524004,0.6875417,-0.14500588,-0.036551226,0.52642053,0.25104368,-0.5281446,0.48701835,0.9978953,-0.0984483,-2.4400785,1.2344483,0.5418268,0.22818252,-1.7153773,-0.13589041,1.1659389,0.71120757,-0.13994399}},
      {{-1.5300859,-0.6663509,-3.7516906,0.8349214,0.81539005,0.8819385,-1.1633791,-0.24738266,0.059140094,-1.1740355,-1.2463803,-1.7160852,1.2634096,-2.6281846,-0.50535256,-2.49252,-0.20458612,0.8110015,-0.30072543,0.081487745}},
      {{-0.20238875,-0.33876202,-1.7878486,1.4198511,1.1209422,0.63611174,-1.3800108,-0.12345929,-5.3107934,-0.8341782,-1.5796361,-0.80308914,1.1127512,-5.384439,-1.0503993,-2.1682856,-0.12711124,0.48557416,-0.32070443,-0.333001}},
      {{-0.16920114,0.06572343,-4.552634,1.2896836,1.3836622,-0.54904056,-2.3045268,-2.1870522,-11.884629,-0.87842405,-2.2825108,-0.8340119,0.990419,-4.2219176,-1.0493922,-0.7568219,-2.2624245,0.002542218,-1.7792917,-1.1323271}},
      {{0.34302917,-1.4528688,-7.387528,-0.6390693,-4.4245987,-10.257381,1.0499983,-0.31342295,-0.24182592,-1.239453,0.48566723,-1.2785277,-1.0636041,-1.314969,0.047958057,-1.279736,-0.3471236,0.85090834,-1.306139,-0.33313715}},
      {{-0.09554737,-1.7891018,-4.894749,0.7355022,-5.175484,-2.751931,1.1838948,0.7592072,0.36536455,-1.3394023,1.5397204,-1.9465622,-0.84340733,-2.6095722,0.5187399,-2.8280594,-0.81397384,0.95467913,-0.69989884,1.2230994}},
      {{-3.6685936,-2.103574,-5.7433376,-0.055330522,-5.0712004,-0.35780144,0.6711001,0.44327593,0.5136526,-0.31068686,1.5579373,-2.481374,0.9928912,-1.0905266,0.14045677,-3.1930146,-1.310689,1.8584175,0.24073666,-0.1506111}},
      {{-9.715645,-1.8924562,-2.9094734,-0.58527017,-0.43494388,0.4630878,-0.018969323,0.85767925,0.50638694,0.97596616,-0.1223058,-2.4500206,0.81657475,0.5400292,0.20303734,-1.9084512,-0.18503559,2.4701357,0.649465,0.46936646}},
      {{-4.3746896,-1.3106753,-3.9952757,0.46556637,1.1090621,0.900584,-2.1792905,0.44059482,0.18405022,-0.120158486,-1.0197699,-2.4170823,1.0995198,-2.3664927,-0.37471914,-2.7228298,-0.8149275,3.3034725,0.77738416,0.63842523}},
      {{-0.33951798,-1.0346898,-5.1861076,1.1875279,1.5249485,0.85164994,-2.659481,0.44424328,-2.7878034,-1.0391582,-1.084828,-1.2103856,0.6505218,-7.0958605,-0.92576057,-2.8930142,-1.5536288,2.3506036,0.21426189,0.9584585}},
      {{-0.015934031,-0.7842258,-6.88783,-0.10316179,1.5515921,-0.20564237,-3.240258,-0.48085248,-8.176993,-1.0100412,-1.4515845,-0.8937371,0.04788541,-5.5961986,-0.75326306,-1.4196275,-1.3947527,1.2765785,-0.37625894,-0.5920235}}
    }};

    b1 = {
      -0.15302889, -0.022067228, -0.047579266, 0.0016544743, -0.2281183, -0.18095395, 0.23059486, 0.18570669, 0.12061182, 0.23334998, 0.29809132, 0.010060728, 0.022047125, -0.5635208, 0.15654963, 0.24981137, 0.44064677, -0.002185989, -0.016035296, -0.037360612, 0.23978657, 0.053540543
    };

    b2 = {
      -0.04120072, 0.10054103, -0.30635148, -0.09492328, 0.04831406, 0.11468069, 0.10426238, 0.030597722, 0.010573565, 0.08534406, 0.09290256, 0.30147794, 0.24244602, 0.05203082, 0.03911608, -0.025086675, -0.02679363, 0.21310383, 5.9703656e-05, 0.08469171
    };

    bout = {
      -2.9316995, -1.9483619, -1.6923574, -1.0767716, -1.8274308, -2.2066736, -2.9844897, -2.8035924, -0.39908397, -0.7883736, 0.39697823, -0.8945331, -0.92659646, -2.6911945, -2.3278687, -0.7285928, 0.29274067, 0.7942254, 0.32248378, -1.1435056, -2.314017, -1.424918, 0.37830916, 0.8381494, 3.5325813, 0.82859087, -0.012287823, -1.570831, -2.5329018, -0.7832534, 0.25615388, 0.8832899, 0.13256536, -1.190722, -2.5884511, -2.9804583, -0.84499323, -0.9955795, 0.0784727, -1.1458503, -0.9774447, -3.0961013, -3.1351047, -2.1113884, -1.8350405, -1.3624231, -1.9263557, -2.2262855, -3.1979396
    };

    BN_gamma_in = {
      0.5014661, 0.76870716, 0.5499533, 0.9804121, 0.51607955, 0.19299918, 0.7853586, 0.63348967, 0.5063346
    };

    BN_gamma_1 = {
      4.30222, 3.9594362, 2.822631, 5.494215, 7.2154727, 2.2776344, 2.5172348, 3.7453477, 2.9831553, 2.2843995, 1.5883828, 2.1012979, 2.252703, -10.010248, 1.6323367, 3.0914707, 2.4409642, 4.4116793, 3.2101724, 5.8907704, 1.2607505, 1.149722
    };

    BN_gamma_2 = {
      4.30222, 3.9594362, 2.822631, 5.494215, 7.2154727, 2.2776344, 2.5172348, 3.7453477, 2.9831553, 2.2843995, 1.5883828, 2.1012979, 2.252703, -10.010248, 1.6323367, 3.0914707, 2.4409642, 4.4116793, 3.2101724, 5.8907704, 1.2607505, 1.149722
    };

    BN_beta_1 = {
      -0.023121208, -0.012979688, -0.017841464, -0.018023038, -0.011482779, -0.1039467, -0.04383424, -0.0038515062, -0.0011848912, -0.12457614, -0.18342735, -0.121862836, -0.07980894, 0.019922817, -0.1025441, -0.016639765, -0.002619453, -0.013612571, -0.0043284306, -0.026489507, -0.059766304, -0.40103132
    };

    BN_beta_2 = {
      -0.05089958, -0.3739665, -0.0643257, -0.14164335, -0.18348758, -0.09065176, -0.34628183, -0.2554615, -0.041310083, -0.28031358, -0.39292976, -0.76488936, -0.62342167, -0.038405426, -0.2811197, -0.12173906, -0.15111843, 0.28513375, -0.047327127, -0.31178948
    };
    
    mean = {
      29399.300583080498,14318.203565548843,29480.87822874806,20000.565122546792,1491.075400210116,19996.878566931184,29362.43210456565,14171.993571666819,29280.433639232095
    };

    stdev = {
      255805.55015089098,159473.2063764945,253776.56036758004,171764.17246911535,31669.903441595776,171635.74602046044,254184.71595278895,159578.54893437275,255845.69749753462
    };
  }
  
}


__inline Void TEncSearch::xTZSearchHelp( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const Int iSearchX, const Int iSearchY, const UChar ucPointNr, const UInt uiDistance )
{
  Distortion  uiSad = 0;

  const Pel* const  piRefSrch = rcStruct.piRefY + iSearchY * rcStruct.iYStride + iSearchX;

  //-- jclee for using the SAD function pointer
  m_pcRdCost->setDistParam( pcPatternKey, piRefSrch, rcStruct.iYStride,  m_cDistParam );

  setDistParamComp(COMPONENT_Y);

  // distortion
  m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
  m_cDistParam.m_maximumDistortionForEarlyExit = rcStruct.uiBestSad;

  if((m_pcEncCfg->getRestrictMESampling() == false) && m_pcEncCfg->getMotionEstimationSearchMethod() == MESEARCH_SELECTIVE)
  {
    Int isubShift = 0;
    // motion cost
    Distortion uiBitCost = m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

    // Skip search if bit cost is already larger than best SAD
    if (uiBitCost < rcStruct.uiBestSad)
    {
      if ( m_cDistParam.iRows > 32 )
      {
        m_cDistParam.iSubShift = 4;
      }
      else if ( m_cDistParam.iRows > 16 )
      {
        m_cDistParam.iSubShift = 3;
      }
      else if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 2;
      }
      else
      {
        m_cDistParam.iSubShift = 1;
      }

      Distortion uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
      if((uiTempSad + uiBitCost) < rcStruct.uiBestSad)
      {
        uiSad += uiTempSad >>  m_cDistParam.iSubShift;
        while(m_cDistParam.iSubShift > 0)
        {
          isubShift         = m_cDistParam.iSubShift -1;
          m_cDistParam.pOrg = pcPatternKey->getROIY() + (pcPatternKey->getPatternLStride() << isubShift);
          m_cDistParam.pCur = piRefSrch + (rcStruct.iYStride << isubShift);
          uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
          uiSad += uiTempSad >>  m_cDistParam.iSubShift;
          if(((uiSad << isubShift) + uiBitCost) > rcStruct.uiBestSad)
          {
            break;
          }

          m_cDistParam.iSubShift--;
        }

        if(m_cDistParam.iSubShift == 0)
        {
          uiSad += uiBitCost;
          if( uiSad < rcStruct.uiBestSad )
          {
            rcStruct.uiBestSad      = uiSad;
            rcStruct.iBestX         = iSearchX;
            rcStruct.iBestY         = iSearchY;
            rcStruct.uiBestDistance = uiDistance;
            rcStruct.uiBestRound    = 0;
            rcStruct.ucPointNr      = ucPointNr;
            m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
          }
        }
      }
    }
  }
  else
  {
    // fast encoder decision: use subsampled SAD when rows > 8 for integer ME
    if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE3 )
    {
      if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 1;
      }
    }

    uiSad = m_cDistParam.DistFunc( &m_cDistParam );

    // EMI: Modification "array_e & counter_i"
    array_e[counter_i] = uiSad;
    
    // only add motion cost if uiSad is smaller than best. Otherwise pointless
    // to add motion cost.
    if( uiSad < rcStruct.uiBestSad )
    {
      // motion cost
      uiSad += m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

      if( uiSad < rcStruct.uiBestSad )
      {
        rcStruct.uiBestSad      = uiSad;
        rcStruct.iBestX         = iSearchX;
        rcStruct.iBestY         = iSearchY;
        rcStruct.uiBestDistance = uiDistance;
        rcStruct.uiBestRound    = 0;
        rcStruct.ucPointNr      = ucPointNr;
        m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
      }
    }
  }
  counter_i = counter_i + 1;
}

__inline Void TEncSearch::xTZ2PointSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB )
{
  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 2 point search,                   //   1 2 3
  // check only the 2 untested points  //   4 0 5
  // around the start point            //   6 7 8
  Int iStartX = rcStruct.iBestX;
  Int iStartY = rcStruct.iBestY;
  switch( rcStruct.ucPointNr )
  {
    case 1:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY, 0, 2 );
      }
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
    }
      break;
    case 2:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 3:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
    }
      break;
    case 4:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 5:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 6:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY , 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    case 7:
    {
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 8:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    default:
    {
      assert( false );
    }
      break;
  } // switch( rcStruct.ucPointNr )
}




__inline Void TEncSearch::xTZ8PointSquareSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iTop >= iSrchRngVerTop ) // check top
  {
    if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
    }
    // top middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );

    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
    }
  } // check top
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
  }
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
  }
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
    if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
    }
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );

    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
    }
  } // check bottom
}


//additing other square search

__inline Void TEncSearch::xTZ8PointSquareSearch2( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;
// check top
  if ( iTop >= iSrchRngVerTop ) // check top
  {
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iLeft, iTop, 9, iDist);
    }
	  
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iStartX - 1, iTop, 10, iDist);
    }
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 11, iDist );
	
	if (iRight <= iSrchRngHorRight) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX +1, iTop, 12, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 13, iDist );
    }
  }

  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY-1, 14, iDist );
  }

  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY-1, 15, iDist );
  }
  
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 16, iDist );
  }
  
  
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 17, iDist );
  }
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY+1, 18, iDist );
  }
  
  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY+1, 19, iDist );
  }
  
  
  
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 20, iDist );
    }  
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iBottom, 21, iDist );
    }   
	  
	  
    
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 22, iDist );

	if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iBottom, 23, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 24, iDist );
    }
  } 
  
  // check bottom
}











__inline Void TEncSearch::xTZ8PointDiamondSearch( const TComPattern*const  pcPatternKey,
                                                  IntTZSearchStruct& rcStruct,
                                                  const TComMv*const  pcMvSrchRngLT,
                                                  const TComMv*const  pcMvSrchRngRB,
                                                  const Int iStartX,
                                                  const Int iStartY,
                                                  const Int iDist,
                                                  const Bool bCheckCornersAtDist1 )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert ( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iDist == 1 )
  {
    if ( iTop >= iSrchRngVerTop ) // check top
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
      }
    }
    if ( iLeft >= iSrchRngHorLeft ) // check middle left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
    }
    if ( iRight <= iSrchRngHorRight ) // check middle right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
    }
    if ( iBottom <= iSrchRngVerBottom ) // check bottom
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
      }
    }
  }
  else
  {
    if ( iDist <= 8 )
    {
      const Int iTop_2      = iStartY - (iDist>>1);
      const Int iBottom_2   = iStartY + (iDist>>1);
      const Int iLeft_2     = iStartX - (iDist>>1);
      const Int iRight_2    = iStartX + (iDist>>1);

      if (  iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iTop,      2, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iTop_2,    1, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2,    3, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,    iStartY,   4, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,   iStartY,   5, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iBottom_2, 6, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iBottom,   7, iDist    );
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        }
        if ( iTop_2 >= iSrchRngVerTop ) // check half top
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iTop_2, 1, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2, 3, (iDist>>1) );
          }
        } // check half top
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
        }
        if ( iBottom_2 <= iSrchRngVerBottom ) // check half bottom
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iBottom_2, 6, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, (iDist>>1) );
          }
        } // check half bottom
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        }
      } // check border
    }
    else // iDist > 8
    {
      if ( iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop,    0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,   iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,  iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
        }
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 0, iDist );
        }
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 0, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 0, iDist );
        }
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        }
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);

          if ( iPosYT >= iSrchRngVerTop ) // check top
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
            }
          } // check top
          if ( iPosYB <= iSrchRngVerBottom ) // check bottom
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
            }
          } // check bottom
        } // for ...
      } // check border
    } // iDist <= 8
  } // iDist == 1
}

Distortion TEncSearch::xPatternRefinement( TComPattern* pcPatternKey,
                                           TComMv baseRefMv,
                                           Int iFrac, TComMv& rcMvFrac,
                                           Bool bAllowUseOfHadamard
                                         )
{
  Distortion  uiDist;
  Distortion  uiDistBest  = std::numeric_limits<Distortion>::max();
  UInt        uiDirecBest = 0;

  Pel*  piRefPos;
  Int iRefStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);

  m_pcRdCost->setDistParam( pcPatternKey, m_filteredBlock[0][0].getAddr(COMPONENT_Y), iRefStride, 1, m_cDistParam, m_pcEncCfg->getUseHADME() && bAllowUseOfHadamard );

  const TComMv* pcMvRefine = (iFrac == 2 ? s_acMvRefineH : s_acMvRefineQ);

  for (UInt i = 0; i < 9; i++)
  {
    TComMv cMvTest = pcMvRefine[i];
    cMvTest += baseRefMv;

    Int horVal = cMvTest.getHor() * iFrac;
    Int verVal = cMvTest.getVer() * iFrac;
    piRefPos = m_filteredBlock[ verVal & 3 ][ horVal & 3 ].getAddr(COMPONENT_Y);
    if ( horVal == 2 && ( verVal & 1 ) == 0 )
    {
      piRefPos += 1;
    }
    if ( ( horVal & 1 ) == 0 && verVal == 2 )
    {
      piRefPos += iRefStride;
    }
    cMvTest = pcMvRefine[i];
    cMvTest += rcMvFrac;

    setDistParamComp(COMPONENT_Y);

    m_cDistParam.pCur = piRefPos;
    m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
    uiDist = m_cDistParam.DistFunc( &m_cDistParam );
    uiDist += m_pcRdCost->getCostOfVectorWithPredictor( cMvTest.getHor(), cMvTest.getVer() );

    if ( uiDist < uiDistBest )
    {
      uiDistBest  = uiDist;
      uiDirecBest = i;
      m_cDistParam.m_maximumDistortionForEarlyExit = uiDist;
    }
  }

  rcMvFrac = pcMvRefine[uiDirecBest];

  return uiDistBest;
}



Void
TEncSearch::xEncSubdivCbfQT(TComTU      &rTu,
                            Bool         bLuma,
                            Bool         bChroma )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx         = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth            = rTu.GetTransformDepthRel();
  const UInt uiTrMode             = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt uiSubdiv             = ( uiTrMode > uiTrDepth ? 1 : 0 );
  const UInt uiLog2LumaTrafoSize  = rTu.GetLog2LumaTrSize();

  if( pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_NxN && uiTrDepth == 0 )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize > pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getSlice()->getSPS()->getQuadtreeTULog2MinSize() )
  {
    assert( !uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
  {
    assert( !uiSubdiv );
  }
  else
  {
    assert( uiLog2LumaTrafoSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );
    if( bLuma )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( uiSubdiv, 5 - uiLog2LumaTrafoSize );
    }
  }

  if ( bChroma )
  {
    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if( rTu.ProcessingAllQuadrants(compID) && (uiTrDepth==0 || pcCU->getCbf( uiAbsPartIdx, compID, uiTrDepth-1 ) ))
      {
        m_pcEntropyCoder->encodeQtCbf(rTu, compID, (uiSubdiv == 0));
      }
    }
  }

  if( uiSubdiv )
  {
    TComTURecurse tuRecurse(rTu, false);
    do
    {
      xEncSubdivCbfQT( tuRecurse, bLuma, bChroma );
    } while (tuRecurse.nextSection(rTu));
  }
  else
  {
    //===== Cbfs =====
    if( bLuma )
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }
}




Void
TEncSearch::xEncCoeffQT(TComTU &rTu,
                        const ComponentID  component,
                        Bool         bRealCoeff )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();

  const UInt  uiTrMode        = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt  uiSubdiv        = ( uiTrMode > uiTrDepth ? 1 : 0 );

  if( uiSubdiv )
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xEncCoeffQT( tuRecurseChild, component, bRealCoeff );
    } while (tuRecurseChild.nextSection(rTu) );
  }
  else if (rTu.ProcessComponentSection(component))
  {
    //===== coefficients =====
    const UInt  uiLog2TrafoSize = rTu.GetLog2LumaTrSize();
    UInt    uiCoeffOffset   = rTu.getCoefficientOffset(component);
    UInt    uiQTLayer       = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrafoSize;
    TCoeff* pcCoeff         = bRealCoeff ? pcCU->getCoeff(component) : m_ppcQTTempCoeff[component][uiQTLayer];

    if (isChroma(component) && (pcCU->getCbf( rTu.GetAbsPartIdxTU(), COMPONENT_Y, uiTrMode ) != 0) && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag() )
    {
      m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, component );
    }

    m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeff+uiCoeffOffset, component );
  }
}




Void
TEncSearch::xEncIntraHeader( TComDataCU*  pcCU,
                            UInt         uiTrDepth,
                            UInt         uiAbsPartIdx,
                            Bool         bLuma,
                            Bool         bChroma )
{
  if( bLuma )
  {
    // CU header
    if( uiAbsPartIdx == 0 )
    {
      if( !pcCU->getSlice()->isIntra() )
      {
        if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
        {
          m_pcEntropyCoder->encodeCUTransquantBypassFlag( pcCU, 0, true );
        }
        m_pcEntropyCoder->encodeSkipFlag( pcCU, 0, true );
        m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
      }
      m_pcEntropyCoder  ->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );

      if (pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_2Nx2N )
      {
        m_pcEntropyCoder->encodeIPCMInfo( pcCU, 0, true );

        if ( pcCU->getIPCMFlag (0))
        {
          return;
        }
      }
    }
    // luma prediction mode
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N )
    {
      if (uiAbsPartIdx==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, 0 );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      if (uiTrDepth>0 && (uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiAbsPartIdx );
      }
    }
  }

  if( bChroma )
  {
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N || !enable4ChromaPUsInIntraNxNCU(pcCU->getPic()->getChromaFormat()))
    {
      if(uiAbsPartIdx==0)
      {
         m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      assert(uiTrDepth>0);
      if ((uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
  }
}




UInt
TEncSearch::xGetIntraBitsQT(TComTU &rTu,
                            Bool         bLuma,
                            Bool         bChroma,
                            Bool         bRealCoeff /* just for test */ )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();
  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiTrDepth, uiAbsPartIdx, bLuma, bChroma );
  xEncSubdivCbfQT ( rTu, bLuma, bChroma );

  if( bLuma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Y,      bRealCoeff );
  }
  if( bChroma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Cb,  bRealCoeff );
    xEncCoeffQT   ( rTu, COMPONENT_Cr,  bRealCoeff );
  }
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  return uiBits;
}

UInt TEncSearch::xGetIntraBitsQTChroma(TComTU &rTu,
                                       ComponentID compID,
                                       Bool         bRealCoeff /* just for test */ )
{
  m_pcEntropyCoder->resetBits();
  xEncCoeffQT   ( rTu, compID,  bRealCoeff );
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  return uiBits;
}

Void TEncSearch::xIntraCodingTUBlock(       TComYuv*    pcOrgYuv,
                                            TComYuv*    pcPredYuv,
                                            TComYuv*    pcResiYuv,
                                            Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      const Bool        checkCrossCPrediction,
                                            Distortion& ruiDist,
                                      const ComponentID compID,
                                            TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug)
                                           ,Int         default0Save1Load2
                                     )
{
  if (!rTu.ProcessComponentSection(compID))
  {
    return;
  }
  const Bool           bIsLuma          = isLuma(compID);
  const TComRectangle &rect             = rTu.getRect(compID);
        TComDataCU    *pcCU             = rTu.getCU();
  const UInt           uiAbsPartIdx     = rTu.GetAbsPartIdxTU();
  const TComSPS       &sps              = *(pcCU->getSlice()->getSPS());

  const UInt           uiTrDepth        = rTu.GetTransformDepthRelAdj(compID);
  const UInt           uiFullDepth      = rTu.GetTransformDepthTotal();
  const UInt           uiLog2TrSize     = rTu.GetLog2LumaTrSize();
  const ChromaFormat   chFmt            = pcOrgYuv->getChromaFormat();
  const ChannelType    chType           = toChannelType(compID);
  const Int            bitDepth         = sps.getBitDepth(chType);

  const UInt           uiWidth          = rect.width;
  const UInt           uiHeight         = rect.height;
  const UInt           uiStride         = pcOrgYuv ->getStride (compID);
        Pel           *piOrg            = pcOrgYuv ->getAddr( compID, uiAbsPartIdx );
        Pel           *piPred           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piResi           = pcResiYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piReco           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
  const UInt           uiQTLayer        = sps.getQuadtreeTULog2MaxSize() - uiLog2TrSize;
        Pel           *piRecQt          = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
  const UInt           uiRecQtStride    = m_pcQTTempTComYuv[ uiQTLayer ].getStride(compID);
  const UInt           uiZOrder         = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
        Pel           *piRecIPred       = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
        UInt           uiRecIPredStride = pcCU->getPic()->getPicYuvRec()->getStride  ( compID );
        TCoeff        *pcCoeff          = m_ppcQTTempCoeff[compID][uiQTLayer] + rTu.getCoefficientOffset(compID);
        Bool           useTransformSkip = pcCU->getTransformSkip(uiAbsPartIdx, compID);

#if ADAPTIVE_QP_SELECTION
        TCoeff        *pcArlCoeff       = m_ppcQTTempArlCoeff[compID][ uiQTLayer ] + rTu.getCoefficientOffset(compID);
#endif

  const UInt           uiChPredMode     = pcCU->getIntraDir( chType, uiAbsPartIdx );
  const UInt           partsPerMinCU    = 1<<(2*(sps.getMaxTotalCUDepth() - sps.getLog2DiffMaxMinCodingBlockSize()));
  const UInt           uiChCodedMode    = (uiChPredMode==DM_CHROMA_IDX && !bIsLuma) ? pcCU->getIntraDir(CHANNEL_TYPE_LUMA, getChromasCorrespondingPULumaIdx(uiAbsPartIdx, chFmt, partsPerMinCU)) : uiChPredMode;
  const UInt           uiChFinalMode    = ((chFmt == CHROMA_422)       && !bIsLuma) ? g_chroma422IntraAngleMappingTable[uiChCodedMode] : uiChCodedMode;

  const Int            blkX                                 = g_auiRasterToPelX[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            blkY                                 = g_auiRasterToPelY[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            bufferOffset                         = blkX + (blkY * MAX_CU_SIZE);
        Pel  *const    encoderLumaResidual                  = resiLuma[RESIDUAL_ENCODER_SIDE ] + bufferOffset;
        Pel  *const    reconstructedLumaResidual            = resiLuma[RESIDUAL_RECONSTRUCTED] + bufferOffset;
  const Bool           bUseCrossCPrediction                 = isChroma(compID) && (uiChPredMode == DM_CHROMA_IDX) && checkCrossCPrediction;
  const Bool           bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
        Pel *const     lumaResidualForEstimate              = bUseReconstructedResidualForEstimate ? reconstructedLumaResidual : encoderLumaResidual;

#if DEBUG_STRING
  const Int debugPredModeMask=DebugStringGetPredModeMask(MODE_INTRA);
#endif

  //===== init availability pattern =====
  DEBUG_STRING_NEW(sTemp)

#if !DEBUG_STRING
  if( default0Save1Load2 != 2 )
#endif
  {
    const Bool bUseFilteredPredictions=TComPrediction::filteringIntraReferenceSamples(compID, uiChFinalMode, uiWidth, uiHeight, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

    initIntraPatternChType( rTu, compID, bUseFilteredPredictions DEBUG_STRING_PASS_INTO(sDebug) );

    //===== get prediction signal =====
    predIntraAng( compID, uiChFinalMode, piOrg, uiStride, piPred, uiStride, rTu, bUseFilteredPredictions );

    // save prediction
    if( default0Save1Load2 == 1 )
    {
      Pel*  pPred   = piPred;
      Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
      Int k = 0;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pPredBuf[ k ++ ] = pPred[ uiX ];
        }
        pPred += uiStride;
      }
    }
  }
#if !DEBUG_STRING
  else
  {
    // load prediction
    Pel*  pPred   = piPred;
    Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
    Int k = 0;
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pPred[ uiX ] = pPredBuf[ k ++ ];
      }
      pPred += uiStride;
    }
  }
#endif

  //===== get residual signal =====
  {
    // get residual
    Pel*  pOrg    = piOrg;
    Pel*  pPred   = piPred;
    Pel*  pResi   = piResi;

    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pResi[ uiX ] = pOrg[ uiX ] - pPred[ uiX ];
      }

      pOrg  += uiStride;
      pResi += uiStride;
      pPred += uiStride;
    }
  }

  if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
  {
    if (bUseCrossCPrediction)
    {
      if (xCalcCrossComponentPredictionAlpha( rTu, compID, lumaResidualForEstimate, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride ) == 0)
      {
        return;
      }
      TComTrQuant::crossComponentPrediction ( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, false );
    }
    else if (isLuma(compID) && !bUseReconstructedResidualForEstimate)
    {
      xStoreCrossComponentPredictionResult( encoderLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
    }
  }

  //===== transform and quantization =====
  //--- init rate estimation arrays for RDOQ ---
  if( useTransformSkip ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ() )
  {
    m_pcEntropyCoder->estimateBit( m_pcTrQuant->m_pcEstBitsSbac, uiWidth, uiHeight, chType );
  }

  //--- transform and quantization ---
  TCoeff uiAbsSum = 0;
  if (bIsLuma)
  {
    pcCU       ->setTrIdxSubParts ( uiTrDepth, uiAbsPartIdx, uiFullDepth );
  }

  const QpParam cQP(*pcCU, compID);

#if RDOQ_CHROMA_LAMBDA
  m_pcTrQuant->selectLambda     (compID);
#endif

  m_pcTrQuant->transformNxN     ( rTu, compID, piResi, uiStride, pcCoeff,
#if ADAPTIVE_QP_SELECTION
    pcArlCoeff,
#endif
    uiAbsSum, cQP
    );

  //--- inverse transform ---

#if DEBUG_STRING
  if ( (uiAbsSum > 0) || (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask) )
#else
  if ( uiAbsSum > 0 )
#endif
  {
    m_pcTrQuant->invTransformNxN ( rTu, compID, piResi, uiStride, pcCoeff, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sDebug, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );
  }
  else
  {
    Pel* pResi = piResi;
    memset( pcCoeff, 0, sizeof( TCoeff ) * uiWidth * uiHeight );
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      memset( pResi, 0, sizeof( Pel ) * uiWidth );
      pResi += uiStride;
    }
  }


  //===== reconstruction =====
  {
    Pel* pPred      = piPred;
    Pel* pResi      = piResi;
    Pel* pReco      = piReco;
    Pel* pRecQt     = piRecQt;
    Pel* pRecIPred  = piRecIPred;

    if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
    {
      if (bUseCrossCPrediction)
      {
        TComTrQuant::crossComponentPrediction( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, true );
      }
      else if (isLuma(compID))
      {
        xStoreCrossComponentPredictionResult( reconstructedLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
      }
    }

 #if DEBUG_STRING
    std::stringstream ss(stringstream::out);
    const Bool bDebugPred=((DebugOptionList::DebugString_Pred.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugResi=((DebugOptionList::DebugString_Resi.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugReco=((DebugOptionList::DebugString_Reco.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));

    if (bDebugPred || bDebugResi || bDebugReco)
    {
      ss << "###: " << "CompID: " << compID << " pred mode (ch/fin): " << uiChPredMode << "/" << uiChFinalMode << " absPartIdx: " << rTu.GetAbsPartIdxTU() << "\n";
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        ss << "###: ";
        if (bDebugPred)
        {
          ss << " - pred: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pPred[ uiX ] << ", ";
          }
        }
        if (bDebugResi)
        {
          ss << " - resi: ";
        }
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          if (bDebugResi)
          {
            ss << pResi[ uiX ] << ", ";
          }
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        if (bDebugReco)
        {
          ss << " - reco: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pReco[ uiX ] << ", ";
          }
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
        ss << "\n";
      }
      DEBUG_STRING_APPEND(sDebug, ss.str())
    }
    else
#endif
    {

      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }

  //===== update distortion =====
  ruiDist += m_pcRdCost->getDistPart( bitDepth, piReco, uiStride, piOrg, uiStride, uiWidth, uiHeight, compID );
}




Void
TEncSearch::xRecurIntraCodingLumaQT(TComYuv*    pcOrgYuv,
                                    TComYuv*    pcPredYuv,
                                    TComYuv*    pcResiYuv,
                                    Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                    Distortion& ruiDistY,
#if HHI_RQT_INTRA_SPEEDUP
                                    Bool        bCheckFirst,
#endif
                                    Double&     dRDCost,
                                    TComTU&     rTu
                                    DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU   *pcCU          = rTu.getCU();
  const UInt    uiAbsPartIdx  = rTu.GetAbsPartIdxTU();
  const UInt    uiFullDepth   = rTu.GetTransformDepthTotal();
  const UInt    uiTrDepth     = rTu.GetTransformDepthRel();
  const UInt    uiLog2TrSize  = rTu.GetLog2LumaTrSize();
        Bool    bCheckFull    = ( uiLog2TrSize  <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
        Bool    bCheckSplit   = ( uiLog2TrSize  >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

        Pel     resiLumaSplit [NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];
        Pel     resiLumaSingle[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

#if HHI_RQT_INTRA_SPEEDUP
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // don't check split if TU size is less or equal to max TU size
  Bool noSplitIntraMaxTuSize = bCheckFull;
  if(m_pcEncCfg->getRDpenalty() && ! isIntraSlice)
  {
    // in addition don't check split if TU size is less or equal to 16x16 TU size for non-intra slice
    noSplitIntraMaxTuSize = ( uiLog2TrSize  <= min(maxTuSize,4) );

    // if maximum RD-penalty don't check TU size 32x32
    if(m_pcEncCfg->getRDpenalty()==2)
    {
      bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
    }
  }
  if( bCheckFirst && noSplitIntraMaxTuSize )

  {
    bCheckSplit = false;
  }
#else
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // if maximum RD-penalty don't check TU size 32x32
  if((m_pcEncCfg->getRDpenalty()==2)  && !isIntraSlice)
  {
    bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
  }
#endif
  Double     dSingleCost                        = MAX_DOUBLE;
  Distortion uiSingleDistLuma                   = 0;
  UInt       uiSingleCbfLuma                    = 0;
  Bool       checkTransformSkip  = pcCU->getSlice()->getPPS()->getUseTransformSkip();
  Int        bestModeId[MAX_NUM_COMPONENT] = { 0, 0, 0};
  checkTransformSkip           &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());
  checkTransformSkip           &= (!pcCU->getCUTransquantBypass(0));

  assert (rTu.ProcessComponentSection(COMPONENT_Y));
  const UInt totalAdjustedDepthChan   = rTu.GetTransformDepthTotalAdj(COMPONENT_Y);

  if ( m_pcEncCfg->getUseTransformSkipFast() )
  {
    checkTransformSkip       &= (pcCU->getPartitionSize(uiAbsPartIdx)==SIZE_NxN);
  }

  if( bCheckFull )
  {
    if(checkTransformSkip == true)
    {
      //----- store original entropy coding status -----
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );

      Distortion singleDistTmpLuma                    = 0;
      UInt       singleCbfTmpLuma                     = 0;
      Double     singleCostTmp                        = 0;
      Int        firstCheckId                         = 0;

      for(Int modeId = firstCheckId; modeId < 2; modeId ++)
      {
        DEBUG_STRING_NEW(sModeString)
        Int  default0Save1Load2 = 0;
        singleDistTmpLuma=0;
        if(modeId == firstCheckId)
        {
          default0Save1Load2 = 1;
        }
        else
        {
          default0Save1Load2 = 2;
        }


        pcCU->setTransformSkipSubParts ( modeId, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
        xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, singleDistTmpLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sModeString), default0Save1Load2 );

        singleCbfTmpLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );

        //----- determine rate and r-d cost -----
        if(modeId == 1 && singleCbfTmpLuma == 0)
        {
          //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
          singleCostTmp = MAX_DOUBLE;
        }
        else
        {
          UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );
          singleCostTmp     = m_pcRdCost->calcRdCost( uiSingleBits, singleDistTmpLuma );
        }
        if(singleCostTmp < dSingleCost)
        {
          DEBUG_STRING_SWAP(sDebug, sModeString)
          dSingleCost   = singleCostTmp;
          uiSingleDistLuma = singleDistTmpLuma;
          uiSingleCbfLuma = singleCbfTmpLuma;

          bestModeId[COMPONENT_Y] = modeId;
          if(bestModeId[COMPONENT_Y] == firstCheckId)
          {
            xStoreIntraResultQT(COMPONENT_Y, rTu );
            m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
          }

          if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
          {
            const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
            const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
            for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
            {
              if (bMaintainResidual[storedResidualIndex])
              {
                xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
              }
            }
          }
        }
        if (modeId == firstCheckId)
        {
          m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
        }
      }

      pcCU ->setTransformSkipSubParts ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

      if(bestModeId[COMPONENT_Y] == firstCheckId)
      {
        xLoadIntraResultQT(COMPONENT_Y, rTu );
        pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, rTu.GetTransformDepthTotalAdj(COMPONENT_Y) );

        m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
      }
    }
    else
    {
      //----- store original entropy coding status -----
      if( bCheckSplit )
      {
        m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
      }
      //----- code luma/chroma block with given intra prediction mode and store Cbf-----
      dSingleCost   = 0.0;

      pcCU ->setTransformSkipSubParts ( 0, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
      xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, uiSingleDistLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sDebug));

      if( bCheckSplit )
      {
        uiSingleCbfLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );
      }
      //----- determine rate and r-d cost -----
      UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );

      if(m_pcEncCfg->getRDpenalty() && (uiLog2TrSize==5) && !isIntraSlice)
      {
        uiSingleBits=uiSingleBits*4;
      }

      dSingleCost       = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDistLuma );

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }
    }
  }

  if( bCheckSplit )
  {
    //----- store full entropy coding status, load original entropy coding status -----
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    else
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    //----- code splitted block -----
    Double     dSplitCost      = 0.0;
    Distortion uiSplitDistLuma = 0;
    UInt       uiSplitCbfLuma  = 0;

    TComTURecurse tuRecurseChild(rTu, false);
    DEBUG_STRING_NEW(sSplit)
    do
    {
      DEBUG_STRING_NEW(sChild)
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, bCheckFirst, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#endif
      DEBUG_STRING_APPEND(sSplit, sChild)
      uiSplitCbfLuma |= pcCU->getCbf( tuRecurseChild.GetAbsPartIdxTU(), COMPONENT_Y, tuRecurseChild.GetTransformDepthRel() );
    } while (tuRecurseChild.nextSection(rTu) );

    UInt    uiPartsDiv     = rTu.GetAbsPartIdxNumParts();
    {
      if (uiSplitCbfLuma)
      {
        const UInt flag=1<<uiTrDepth;
        UChar *pBase=pcCU->getCbf( COMPONENT_Y );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
    //----- restore context states -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    
    //----- determine rate and r-d cost -----
    UInt uiSplitBits = xGetIntraBitsQT( rTu, true, false, false );
    dSplitCost       = m_pcRdCost->calcRdCost( uiSplitBits, uiSplitDistLuma );

    //===== compare and set best =====
    if( dSplitCost < dSingleCost )
    {
      //--- update cost ---
      DEBUG_STRING_SWAP(sSplit, sDebug)
      ruiDistY += uiSplitDistLuma;
      dRDCost  += dSplitCost;

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSplit[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }

      return;
    }

    //----- set entropy coding status -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );

    //--- set transform index and Cbf values ---
    pcCU->setTrIdxSubParts( uiTrDepth, uiAbsPartIdx, uiFullDepth );
    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
    pcCU ->setTransformSkipSubParts  ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

    //--- set reconstruction for next intra prediction blocks ---
    const UInt  uiQTLayer   = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt  uiZOrder    = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
    const UInt  uiWidth     = tuRect.width;
    const UInt  uiHeight    = tuRect.height;
    Pel*  piSrc       = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( COMPONENT_Y, uiAbsPartIdx );
    UInt  uiSrcStride = m_pcQTTempTComYuv[ uiQTLayer ].getStride  ( COMPONENT_Y );
    Pel*  piDes       = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
    UInt  uiDesStride = pcCU->getPic()->getPicYuvRec()->getStride  ( COMPONENT_Y );

    for( UInt uiY = 0; uiY < uiHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        piDes[ uiX ] = piSrc[ uiX ];
      }
    }
  }
  ruiDistY += uiSingleDistLuma;
  dRDCost  += dSingleCost;
}


Void
TEncSearch::xSetIntraResultLumaQT(TComYuv* pcRecoYuv, TComTU &rTu)
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiTrDepth    = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====

    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    const UInt coeffOffset = rTu.getCoefficientOffset(COMPONENT_Y);
    const UInt numCoeffInBlock = tuRect.width * tuRect.height;

    if (numCoeffInBlock!=0)
    {
      const TCoeff* srcCoeff = m_ppcQTTempCoeff[COMPONENT_Y][uiQTLayer] + coeffOffset;
      TCoeff* destCoeff      = pcCU->getCoeff(COMPONENT_Y) + coeffOffset;
      ::memcpy( destCoeff, srcCoeff, sizeof(TCoeff)*numCoeffInBlock );
#if ADAPTIVE_QP_SELECTION
      const TCoeff* srcArlCoeff = m_ppcQTTempArlCoeff[COMPONENT_Y][ uiQTLayer ] + coeffOffset;
      TCoeff* destArlCoeff      = pcCU->getArlCoeff (COMPONENT_Y)               + coeffOffset;
      ::memcpy( destArlCoeff, srcArlCoeff, sizeof( TCoeff ) * numCoeffInBlock );
#endif
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Y, pcRecoYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }

  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultLumaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}


Void
TEncSearch::xStoreIntraResultQT(const ComponentID compID, TComTU &rTu )
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff    = tuRect.width * tuRect.height;
      TCoeff* pcCoeffSrc = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffDst = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffDst = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( compID, &m_pcQTTempTransformSkipTComYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }
  }
}


Void
TEncSearch::xLoadIntraResultQT(const ComponentID compID, TComTU &rTu)
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt uiZOrder     = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff = tuRect.width * tuRect.height;
      TCoeff* pcCoeffDst = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffSrc = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffDst = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffSrc = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTransformSkipTComYuv.copyPartToPartComponent( compID, &m_pcQTTempTComYuv[ uiQTLayer ], uiAbsPartIdx, tuRect.width, tuRect.height );

      Pel*    piRecIPred        = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
      UInt    uiRecIPredStride  = pcCU->getPic()->getPicYuvRec()->getStride (compID);
      Pel*    piRecQt           = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
      UInt    uiRecQtStride     = m_pcQTTempTComYuv[ uiQTLayer ].getStride  (compID);
      UInt    uiWidth           = tuRect.width;
      UInt    uiHeight          = tuRect.height;
      Pel* pRecQt               = piRecQt;
      Pel* pRecIPred            = piRecIPred;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pRecIPred[ uiX ] = pRecQt   [ uiX ];
        }
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }
}

Void
TEncSearch::xStoreCrossComponentPredictionResult(       Pel    *pResiDst,
                                                  const Pel    *pResiSrc,
                                                        TComTU &rTu,
                                                  const Int     xOffset,
                                                  const Int     yOffset,
                                                  const Int     strideDst,
                                                  const Int     strideSrc )
{
  const Pel *pSrc = pResiSrc + yOffset * strideSrc + xOffset;
        Pel *pDst = pResiDst + yOffset * strideDst + xOffset;

  for( Int y = 0; y < rTu.getRect( COMPONENT_Y ).height; y++ )
  {
    ::memcpy( pDst, pSrc, sizeof(Pel) * rTu.getRect( COMPONENT_Y ).width );
    pDst += strideDst;
    pSrc += strideSrc;
  }
}

SChar
TEncSearch::xCalcCrossComponentPredictionAlpha(       TComTU &rTu,
                                                const ComponentID compID,
                                                const Pel*        piResiL,
                                                const Pel*        piResiC,
                                                const Int         width,
                                                const Int         height,
                                                const Int         strideL,
                                                const Int         strideC )
{
  const Pel *pResiL = piResiL;
  const Pel *pResiC = piResiC;

        TComDataCU *pCU = rTu.getCU();
  const Int  absPartIdx = rTu.GetAbsPartIdxTU( compID );
  const Int diffBitDepth = pCU->getSlice()->getSPS()->getDifferentialLumaChromaBitDepth();

  SChar alpha = 0;
  Int SSxy  = 0;
  Int SSxx  = 0;

  for( UInt uiY = 0; uiY < height; uiY++ )
  {
    for( UInt uiX = 0; uiX < width; uiX++ )
    {
      const Pel scaledResiL = rightShift( pResiL[ uiX ], diffBitDepth );
      SSxy += ( scaledResiL * pResiC[ uiX ] );
      SSxx += ( scaledResiL * scaledResiL   );
    }

    pResiL += strideL;
    pResiC += strideC;
  }

  if( SSxx != 0 )
  {
    Double dAlpha = SSxy / Double( SSxx );
    alpha = SChar(Clip3<Int>(-16, 16, (Int)(dAlpha * 16)));

    static const SChar alphaQuant[17] = {0, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8};

    alpha = (alpha < 0) ? -alphaQuant[Int(-alpha)] : alphaQuant[Int(alpha)];
  }
  pCU->setCrossComponentPredictionAlphaPartRange( alpha, compID, absPartIdx, rTu.GetAbsPartIdxNumParts( compID ) );

  return alpha;
}

Void
TEncSearch::xRecurIntraChromaCodingQT(TComYuv*    pcOrgYuv,
                                      TComYuv*    pcPredYuv,
                                      TComYuv*    pcResiYuv,
                                      Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      Distortion& ruiDist,
                                      TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU         *pcCU                  = rTu.getCU();
  const UInt          uiTrDepth             = rTu.GetTransformDepthRel();
  const UInt          uiAbsPartIdx          = rTu.GetAbsPartIdxTU();
  const ChromaFormat  format                = rTu.GetChromaFormat();
  UInt                uiTrMode              = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt          numberValidComponents = getNumberValidComponents(format);

  if(  uiTrMode == uiTrDepth )
  {
    if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      return;
    }

    const UInt uiFullDepth = rTu.GetTransformDepthTotal();

    Bool checkTransformSkip = pcCU->getSlice()->getPPS()->getUseTransformSkip();
    checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Cb), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

    if ( m_pcEncCfg->getUseTransformSkipFast() )
    {
      checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

      if (checkTransformSkip)
      {
        Int nbLumaSkip = 0;
        const UInt maxAbsPartIdxSub=uiAbsPartIdx + (rTu.ProcessingAllQuadrants(COMPONENT_Cb)?1:4);
        for(UInt absPartIdxSub = uiAbsPartIdx; absPartIdxSub < maxAbsPartIdxSub; absPartIdxSub ++)
        {
          nbLumaSkip += pcCU->getTransformSkip(absPartIdxSub, COMPONENT_Y);
        }
        checkTransformSkip &= (nbLumaSkip > 0);
      }
    }


    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      DEBUG_STRING_NEW(sDebugBestMode)

      //use RDO to decide whether Cr/Cb takes TS
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[uiFullDepth][CI_QT_TRAFO_ROOT] );

      const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

      TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

      const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

      do
      {
        const UInt subTUAbsPartIdx   = TUIterator.GetAbsPartIdxTU(compID);

        Double     dSingleCost               = MAX_DOUBLE;
        Int        bestModeId                = 0;
        Distortion singleDistC               = 0;
        UInt       singleCbfC                = 0;
        Distortion singleDistCTmp            = 0;
        Double     singleCostTmp             = 0;
        UInt       singleCbfCTmp             = 0;
        SChar      bestCrossCPredictionAlpha = 0;
        Int        bestTransformSkipMode     = 0;

        const Bool checkCrossComponentPrediction =    (pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, subTUAbsPartIdx) == DM_CHROMA_IDX)
                                                   &&  pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                   && (pcCU->getCbf(subTUAbsPartIdx,  COMPONENT_Y, uiTrDepth) != 0);

        const Int  crossCPredictionModesToTest = checkCrossComponentPrediction ? 2 : 1;
        const Int  transformSkipModesToTest    = checkTransformSkip            ? 2 : 1;
        const Int  totalModesToTest            = crossCPredictionModesToTest * transformSkipModesToTest;
              Int  currModeId                  = 0;
              Int  default0Save1Load2          = 0;

        for(Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
        {
          for(Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
          {
            pcCU->setCrossComponentPredictionAlphaPartRange(0, compID, subTUAbsPartIdx, partIdxesPerSubTU);
            DEBUG_STRING_NEW(sDebugMode)
            pcCU->setTransformSkipPartRange( transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU );
            currModeId++;

            const Bool isOneMode  = (totalModesToTest == 1);
            const Bool isLastMode = (currModeId == totalModesToTest); // currModeId is indexed from 1

            if (isOneMode)
            {
              default0Save1Load2 = 0;
            }
            else if (!isOneMode && (transformSkipModeId == 0) && (crossCPredictionModeId == 0))
            {
              default0Save1Load2 = 1; //save prediction on first mode
            }
            else
            {
              default0Save1Load2 = 2; //load it on subsequent modes
            }

            singleDistCTmp = 0;

            xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, (crossCPredictionModeId != 0), singleDistCTmp, compID, TUIterator DEBUG_STRING_PASS_INTO(sDebugMode), default0Save1Load2);
            singleCbfCTmp = pcCU->getCbf( subTUAbsPartIdx, compID, uiTrDepth);

            if (  ((crossCPredictionModeId == 1) && (pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) == 0))
               || ((transformSkipModeId    == 1) && (singleCbfCTmp == 0))) //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
            {
              singleCostTmp = MAX_DOUBLE;
            }
            else if (!isOneMode)
            {
              UInt bitsTmp = xGetIntraBitsQTChroma( TUIterator, compID, false );
              singleCostTmp  = m_pcRdCost->calcRdCost( bitsTmp, singleDistCTmp);
            }

            if(singleCostTmp < dSingleCost)
            {
              DEBUG_STRING_SWAP(sDebugBestMode, sDebugMode)
              dSingleCost               = singleCostTmp;
              singleDistC               = singleDistCTmp;
              bestCrossCPredictionAlpha = (crossCPredictionModeId != 0) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;
              bestTransformSkipMode     = transformSkipModeId;
              bestModeId                = currModeId;
              singleCbfC                = singleCbfCTmp;

              if (!isOneMode && !isLastMode)
              {
                xStoreIntraResultQT(compID, TUIterator);
                m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
              }
            }

            if (!isOneMode && !isLastMode)
            {
              m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
            }
          }
        }

        if(bestModeId < totalModesToTest)
        {
          xLoadIntraResultQT(compID, TUIterator);
          pcCU->setCbfPartRange( singleCbfC << uiTrDepth, compID, subTUAbsPartIdx, partIdxesPerSubTU );

          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
        }

        DEBUG_STRING_APPEND(sDebug, sDebugBestMode)
        pcCU ->setTransformSkipPartRange                ( bestTransformSkipMode,     compID, subTUAbsPartIdx, partIdxesPerSubTU );
        pcCU ->setCrossComponentPredictionAlphaPartRange( bestCrossCPredictionAlpha, compID, subTUAbsPartIdx, partIdxesPerSubTU );
        ruiDist += singleDistC;
      } while (TUIterator.nextSection(rTu));

      if (splitIntoSubTUs)
      {
        offsetSubTUCBFs(rTu, compID);
      }
    }
  }
  else
  {
    UInt    uiSplitCbf[MAX_NUM_COMPONENT] = {0,0,0};

    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiTrDepthChild   = tuRecurseChild.GetTransformDepthRel();
    do
    {
      DEBUG_STRING_NEW(sChild)

      xRecurIntraChromaCodingQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, ruiDist, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );

      DEBUG_STRING_APPEND(sDebug, sChild)
      const UInt uiAbsPartIdxSub=tuRecurseChild.GetAbsPartIdxTU();

      for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
      {
        uiSplitCbf[ch] |= pcCU->getCbf( uiAbsPartIdxSub, ComponentID(ch), uiTrDepthChild );
      }
    } while ( tuRecurseChild.nextSection(rTu) );


    UInt uiPartsDiv = rTu.GetAbsPartIdxNumParts();
    for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      if (uiSplitCbf[ch])
      {
        const UInt flag=1<<uiTrDepth;
        ComponentID compID=ComponentID(ch);
        UChar *pBase=pcCU->getCbf( compID );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
  }
}




Void
TEncSearch::xSetIntraResultChromaQT(TComYuv*    pcRecoYuv, TComTU &rTu)
{
  if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
  {
    return;
  }
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth   = rTu.GetTransformDepthRel();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====
    const TComRectangle &tuRectCb=rTu.getRect(COMPONENT_Cb);
    UInt uiNumCoeffC    = tuRectCb.width*tuRectCb.height;//( pcCU->getSlice()->getSPS()->getMaxCUWidth() * pcCU->getSlice()->getSPS()->getMaxCUHeight() ) >> ( uiFullDepth << 1 );
    const UInt offset = rTu.getCoefficientOffset(COMPONENT_Cb);

    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID component = ComponentID(ch);
      const TCoeff* src           = m_ppcQTTempCoeff[component][uiQTLayer] + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      TCoeff* dest                = pcCU->getCoeff(component) + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      ::memcpy( dest, src, sizeof(TCoeff)*uiNumCoeffC );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[component][ uiQTLayer ] + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      TCoeff* pcArlCoeffDst = pcCU->getArlCoeff(component)                + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeffC );
#endif
    }

    //===== copy reconstruction =====

    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cb, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cr, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultChromaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}



Void
TEncSearch::estIntraPredLumaQT(TComDataCU* pcCU,
                               TComYuv*    pcOrgYuv,
                               TComYuv*    pcPredYuv,
                               TComYuv*    pcResiYuv,
                               TComYuv*    pcRecoYuv,
                               Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                               DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt         uiDepth               = pcCU->getDepth(0);
  const UInt         uiInitTrDepth         = pcCU->getPartitionSize(0) == SIZE_2Nx2N ? 0 : 1;
  const UInt         uiNumPU               = 1<<(2*uiInitTrDepth);
  const UInt         uiQNumParts           = pcCU->getTotalNumPart() >> 2;
  const UInt         uiWidthBit            = pcCU->getIntraSizeIdx(0);
  const ChromaFormat chFmt                 = pcCU->getPic()->getChromaFormat();
  const UInt         numberValidComponents = getNumberValidComponents(chFmt);
  const TComSPS     &sps                   = *(pcCU->getSlice()->getSPS());
  const TComPPS     &pps                   = *(pcCU->getSlice()->getPPS());
        Distortion   uiOverallDistY        = 0;
        UInt         CandNum;
        Double       CandCostList[ FAST_UDI_MAX_RDMODE_NUM ];
        Pel          resiLumaPU[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

  // Lambda calculation at equivalent Qp of 4 is recommended because at that Qp, the quantisation divisor is 1.
#if FULL_NBIT
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#else
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12 - 6 * (sps.getBitDepth(CHANNEL_TYPE_LUMA) - 8)) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#endif

  //===== set QP and clear Cbf =====
  if ( pps.getUseDQP() == true)
  {
    pcCU->setQPSubParts( pcCU->getQP(0), 0, uiDepth );
  }
  else
  {
    pcCU->setQPSubParts( pcCU->getSlice()->getSliceQp(), 0, uiDepth );
  }

  //===== loop over partitions =====
  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);

  do
  {
    const UInt uiPartOffset=tuRecurseWithPU.GetAbsPartIdxTU();
//  for( UInt uiPU = 0, uiPartOffset=0; uiPU < uiNumPU; uiPU++, uiPartOffset += uiQNumParts )
  //{
    //===== init pattern for luma prediction =====
    DEBUG_STRING_NEW(sTemp2)

    //===== determine set of modes to be tested (using prediction signal only) =====
    Int numModesAvailable     = 35; //total number of Intra modes
    UInt uiRdModeList[FAST_UDI_MAX_RDMODE_NUM];
    Int numModesForFullRD = m_pcEncCfg->getFastUDIUseMPMEnabled()?g_aucIntraModeNumFast_UseMPM[ uiWidthBit ] : g_aucIntraModeNumFast_NotUseMPM[ uiWidthBit ];

    // this should always be true
    assert (tuRecurseWithPU.ProcessComponentSection(COMPONENT_Y));
    initIntraPatternChType( tuRecurseWithPU, COMPONENT_Y, true DEBUG_STRING_PASS_INTO(sTemp2) );

    Bool doFastSearch = (numModesForFullRD != numModesAvailable);
    if (doFastSearch)
    {
      assert(numModesForFullRD < numModesAvailable);

      for( Int i=0; i < numModesForFullRD; i++ )
      {
        CandCostList[ i ] = MAX_DOUBLE;
      }
      CandNum = 0;

      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt uiAbsPartIdx=tuRecurseWithPU.GetAbsPartIdxTU();

      Pel* piOrg         = pcOrgYuv ->getAddr( COMPONENT_Y, uiAbsPartIdx );
      Pel* piPred        = pcPredYuv->getAddr( COMPONENT_Y, uiAbsPartIdx );
      UInt uiStride      = pcPredYuv->getStride( COMPONENT_Y );
      DistParam distParam;
      const Bool bUseHadamard=pcCU->getCUTransquantBypass(0) == 0;
      m_pcRdCost->setDistParam(distParam, sps.getBitDepth(CHANNEL_TYPE_LUMA), piOrg, uiStride, piPred, uiStride, puRect.width, puRect.height, bUseHadamard);
      distParam.bApplyWeight = false;
      for( Int modeIdx = 0; modeIdx < numModesAvailable; modeIdx++ )
      {
        UInt       uiMode = modeIdx;
        Distortion uiSad  = 0;

        const Bool bUseFilter=TComPrediction::filteringIntraReferenceSamples(COMPONENT_Y, uiMode, puRect.width, puRect.height, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

        predIntraAng( COMPONENT_Y, uiMode, piOrg, uiStride, piPred, uiStride, tuRecurseWithPU, bUseFilter, TComPrediction::UseDPCMForFirstPassIntraEstimation(tuRecurseWithPU, uiMode) );

        // use hadamard transform here
        uiSad+=distParam.DistFunc(&distParam);

        UInt   iModeBits = 0;

        // NB xModeBitsIntra will not affect the mode for chroma that may have already been pre-estimated.
        iModeBits+=xModeBitsIntra( pcCU, uiMode, uiPartOffset, uiDepth, CHANNEL_TYPE_LUMA );

        Double cost      = (Double)uiSad + (Double)iModeBits * sqrtLambdaForFirstPass;

#if DEBUG_INTRA_SEARCH_COSTS
        std::cout << "1st pass mode " << uiMode << " SAD = " << uiSad << ", mode bits = " << iModeBits << ", cost = " << cost << "\n";
#endif

        CandNum += xUpdateCandList( uiMode, cost, numModesForFullRD, uiRdModeList, CandCostList );
      }

      if (m_pcEncCfg->getFastUDIUseMPMEnabled())
      {
        Int uiPreds[NUM_MOST_PROBABLE_MODES] = {-1, -1, -1};

        Int iMode = -1;
        pcCU->getIntraDirPredictor( uiPartOffset, uiPreds, COMPONENT_Y, &iMode );

        const Int numCand = ( iMode >= 0 ) ? iMode : Int(NUM_MOST_PROBABLE_MODES);

        for( Int j=0; j < numCand; j++)
        {
          Bool mostProbableModeIncluded = false;
          Int mostProbableMode = uiPreds[j];

          for( Int i=0; i < numModesForFullRD; i++)
          {
            mostProbableModeIncluded |= (mostProbableMode == uiRdModeList[i]);
          }
          if (!mostProbableModeIncluded)
          {
            uiRdModeList[numModesForFullRD++] = mostProbableMode;
          }
        }
      }
    }
    else
    {
      for( Int i=0; i < numModesForFullRD; i++)
      {
        uiRdModeList[i] = i;
      }
    }

    //===== check modes (using r-d costs) =====
#if HHI_RQT_INTRA_SPEEDUP_MOD
    UInt   uiSecondBestMode  = MAX_UINT;
    Double dSecondBestPUCost = MAX_DOUBLE;
#endif
    DEBUG_STRING_NEW(sPU)
    UInt       uiBestPUMode  = 0;
    Distortion uiBestPUDistY = 0;
    Double     dBestPUCost   = MAX_DOUBLE;

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
    UInt max=numModesForFullRD;

    if (DebugOptionList::ForceLumaMode.isSet())
    {
      max=0;  // we are forcing a direction, so don't bother with mode check
    }
    for ( UInt uiMode = 0; uiMode < max; uiMode++)
#else
    for( UInt uiMode = 0; uiMode < numModesForFullRD; uiMode++ )
#endif
    {
      // set luma prediction mode
      UInt uiOrgMode = uiRdModeList[uiMode];

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );

      DEBUG_STRING_NEW(sMode)
      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, true, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#endif

#if DEBUG_INTRA_SEARCH_COSTS
      std::cout << "2nd pass [luma,chroma] mode [" << Int(pcCU->getIntraDir(CHANNEL_TYPE_LUMA, uiPartOffset)) << "," << Int(pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, uiPartOffset)) << "] cost = " << dPUCost << "\n";
#endif

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sMode)
#if HHI_RQT_INTRA_SPEEDUP_MOD
        uiSecondBestMode  = uiBestPUMode;
        dSecondBestPUCost = dBestPUCost;
#endif
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();

        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
#if HHI_RQT_INTRA_SPEEDUP_MOD
      else if( dPUCost < dSecondBestPUCost )
      {
        uiSecondBestMode  = uiOrgMode;
        dSecondBestPUCost = dPUCost;
      }
#endif
    } // Mode loop

#if HHI_RQT_INTRA_SPEEDUP
#if HHI_RQT_INTRA_SPEEDUP_MOD
    for( UInt ui =0; ui < 2; ++ui )
#endif
    {
#if HHI_RQT_INTRA_SPEEDUP_MOD
      UInt uiOrgMode   = ui ? uiSecondBestMode  : uiBestPUMode;
      if( uiOrgMode == MAX_UINT )
      {
        break;
      }
#else
      UInt uiOrgMode = uiBestPUMode;
#endif

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
      if (DebugOptionList::ForceLumaMode.isSet())
      {
        uiOrgMode = DebugOptionList::ForceLumaMode.getInt();
      }
#endif

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );
      DEBUG_STRING_NEW(sModeTree)

      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;

      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, false, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sModeTree));

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sModeTree)
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );

        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
    } // Mode loop
#endif

    DEBUG_STRING_APPEND(sDebug, sPU)

    //--- update overall distortion ---
    uiOverallDistY += uiBestPUDistY;

    //--- update transform index and cbf ---
    const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
    ::memcpy( pcCU->getTransformIdx()       + uiPartOffset, m_puhQTTempTrIdx,  uiQPartNum * sizeof( UChar ) );
    for (UInt component = 0; component < numberValidComponents; component++)
    {
      const ComponentID compID = ComponentID(component);
      ::memcpy( pcCU->getCbf( compID  ) + uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
      ::memcpy( pcCU->getTransformSkip( compID  ) + uiPartOffset, m_puhQTTempTransformSkipFlag[compID ], uiQPartNum * sizeof( UChar ) );
    }

    //--- set reconstruction for next intra prediction blocks ---
    if( !tuRecurseWithPU.IsLastSection() )
    {
      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt  uiCompWidth   = puRect.width;
      const UInt  uiCompHeight  = puRect.height;

      const UInt  uiZOrder      = pcCU->getZorderIdxInCtu() + uiPartOffset;
            Pel*  piDes         = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
      const UInt  uiDesStride   = pcCU->getPic()->getPicYuvRec()->getStride( COMPONENT_Y);
      const Pel*  piSrc         = pcRecoYuv->getAddr( COMPONENT_Y, uiPartOffset );
      const UInt  uiSrcStride   = pcRecoYuv->getStride( COMPONENT_Y);

      for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
      {
        for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
        {
          piDes[ uiX ] = piSrc[ uiX ];
        }
      }
    }

    //=== update PU data ====
    pcCU->setIntraDirSubParts     ( CHANNEL_TYPE_LUMA, uiBestPUMode, uiPartOffset, uiDepth + uiInitTrDepth );
	
  } while (tuRecurseWithPU.nextSection(tuRecurseCU));


  if( uiNumPU > 1 )
  { // set Cbf for all blocks
    UInt uiCombCbfY = 0;
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfY |= pcCU->getCbf( uiPartIdx, COMPONENT_Y,  1 );
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Y  )[ uiOffs ] |= uiCombCbfY;
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  //===== reset context models =====
  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  //===== set distortion (rate and r-d costs are determined later) =====
  pcCU->getTotalDistortion() = uiOverallDistY;
}




Void
TEncSearch::estIntraPredChromaQT(TComDataCU* pcCU,
                                 TComYuv*    pcOrgYuv,
                                 TComYuv*    pcPredYuv,
                                 TComYuv*    pcResiYuv,
                                 TComYuv*    pcRecoYuv,
                                 Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                                 DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt    uiInitTrDepth  = pcCU->getPartitionSize(0) != SIZE_2Nx2N && enable4ChromaPUsInIntraNxNCU(pcOrgYuv->getChromaFormat()) ? 1 : 0;

  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);
  const UInt    uiQNumParts    = tuRecurseWithPU.GetAbsPartIdxNumParts();
  const UInt    uiDepthCU=tuRecurseWithPU.getCUDepth();
  const UInt    numberValidComponents = pcCU->getPic()->getNumberValidComponents();

  do
  {
    UInt       uiBestMode  = 0;
    Distortion uiBestDist  = 0;
    Double     dBestCost   = MAX_DOUBLE;

    //----- init mode list -----
    if (tuRecurseWithPU.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      UInt uiModeList[FAST_UDI_MAX_RDMODE_NUM];
      const UInt  uiQPartNum     = uiQNumParts;
      const UInt  uiPartOffset   = tuRecurseWithPU.GetAbsPartIdxTU();
      {
        UInt  uiMinMode = 0;
        UInt  uiMaxMode = NUM_CHROMA_MODE;

        //----- check chroma modes -----
        pcCU->getAllowedChromaDir( uiPartOffset, uiModeList );

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
        if (DebugOptionList::ForceChromaMode.isSet())
        {
          uiMinMode=DebugOptionList::ForceChromaMode.getInt();
          if (uiModeList[uiMinMode]==34)
          {
            uiMinMode=4; // if the fixed mode has been renumbered because DM_CHROMA covers it, use DM_CHROMA.
          }
          uiMaxMode=uiMinMode+1;
        }
#endif

        DEBUG_STRING_NEW(sPU)

        for( UInt uiMode = uiMinMode; uiMode < uiMaxMode; uiMode++ )
        {
          //----- restore context models -----
          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          
          DEBUG_STRING_NEW(sMode)
          //----- chroma coding -----
          Distortion uiDist = 0;
          pcCU->setIntraDirSubParts  ( CHANNEL_TYPE_CHROMA, uiModeList[uiMode], uiPartOffset, uiDepthCU+uiInitTrDepth );
          xRecurIntraChromaCodingQT       ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );

          if( pcCU->getSlice()->getPPS()->getUseTransformSkip() )
          {
            m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          }

          UInt    uiBits = xGetIntraBitsQT( tuRecurseWithPU, false, true, false );
          Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );

          //----- compare -----
          if( dCost < dBestCost )
          {
            DEBUG_STRING_SWAP(sPU, sMode);
            dBestCost   = dCost;
            uiBestDist  = uiDist;
            uiBestMode  = uiModeList[uiMode];

            xSetIntraResultChromaQT( pcRecoYuv, tuRecurseWithPU );
            for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
            {
              const ComponentID compID = ComponentID(componentIndex);
              ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_puhQTTempTransformSkipFlag[compID], pcCU->getTransformSkip( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_phQTTempCrossComponentPredictionAlpha[compID], pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, uiQPartNum * sizeof( SChar ) );
            }
          }
        }

        DEBUG_STRING_APPEND(sDebug, sPU)

        //----- set data -----
        for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
        {
          const ComponentID compID = ComponentID(componentIndex);
          ::memcpy( pcCU->getCbf( compID )+uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getTransformSkip( compID )+uiPartOffset, m_puhQTTempTransformSkipFlag[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, m_phQTTempCrossComponentPredictionAlpha[compID], uiQPartNum * sizeof( SChar ) );
        }
      }

      if( ! tuRecurseWithPU.IsLastSection() )
      {
        for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
        {
          const ComponentID compID    = ComponentID(ch);
          const TComRectangle &tuRect = tuRecurseWithPU.getRect(compID);
          const UInt  uiCompWidth     = tuRect.width;
          const UInt  uiCompHeight    = tuRect.height;
          const UInt  uiZOrder        = pcCU->getZorderIdxInCtu() + tuRecurseWithPU.GetAbsPartIdxTU();
                Pel*  piDes           = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
          const UInt  uiDesStride     = pcCU->getPic()->getPicYuvRec()->getStride( compID);
          const Pel*  piSrc           = pcRecoYuv->getAddr( compID, uiPartOffset );
          const UInt  uiSrcStride     = pcRecoYuv->getStride( compID);

          for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
          {
            for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
            {
              piDes[ uiX ] = piSrc[ uiX ];
            }
          }
        }
      }

      pcCU->setIntraDirSubParts( CHANNEL_TYPE_CHROMA, uiBestMode, uiPartOffset, uiDepthCU+uiInitTrDepth );
      pcCU->getTotalDistortion      () += uiBestDist;
    }

  } while (tuRecurseWithPU.nextSection(tuRecurseCU));

  //----- restore context models -----

  if( uiInitTrDepth != 0 )
  { // set Cbf for all blocks
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
}




/** Function for encoding and reconstructing luma/chroma samples of a PCM mode CU.
 * \param pcCU pointer to current CU
 * \param uiAbsPartIdx part index
 * \param pOrg pointer to original sample arrays
 * \param pPCM pointer to PCM code arrays
 * \param pPred pointer to prediction signal arrays
 * \param pResi pointer to residual signal arrays
 * \param pReco pointer to reconstructed sample arrays
 * \param uiStride stride of the original/prediction/residual sample arrays
 * \param uiWidth block width
 * \param uiHeight block height
 * \param compID texture component type
 */
Void TEncSearch::xEncPCM (TComDataCU* pcCU, UInt uiAbsPartIdx, Pel* pOrg, Pel* pPCM, Pel* pPred, Pel* pResi, Pel* pReco, UInt uiStride, UInt uiWidth, UInt uiHeight, const ComponentID compID )
{
  const UInt uiReconStride   = pcCU->getPic()->getPicYuvRec()->getStride(compID);
  const UInt uiPCMBitDepth   = pcCU->getSlice()->getSPS()->getPCMBitDepth(toChannelType(compID));
  const Int  channelBitDepth = pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
  Pel* pRecoPic = pcCU->getPic()->getPicYuvRec()->getAddr(compID, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu()+uiAbsPartIdx);

  const Int pcmShiftRight=(channelBitDepth - Int(uiPCMBitDepth));

  assert(pcmShiftRight >= 0);

  for( UInt uiY = 0; uiY < uiHeight; uiY++ )
  {
    for( UInt uiX = 0; uiX < uiWidth; uiX++ )
    {
      // Reset pred and residual
      pPred[uiX] = 0;
      pResi[uiX] = 0;
      // Encode
      pPCM[uiX] = (pOrg[uiX]>>pcmShiftRight);
      // Reconstruction
      pReco   [uiX] = (pPCM[uiX]<<(pcmShiftRight));
      pRecoPic[uiX] = pReco[uiX];
    }
    pPred += uiStride;
    pResi += uiStride;
    pPCM += uiWidth;
    pOrg += uiStride;
    pReco += uiStride;
    pRecoPic += uiReconStride;
  }
}


//!  Function for PCM mode estimation.
Void TEncSearch::IPCMSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv )
{
  UInt              uiDepth      = pcCU->getDepth(0);
  const Distortion  uiDistortion = 0;
  UInt              uiBits;

  Double dCost;

  for (UInt ch=0; ch < pcCU->getPic()->getNumberValidComponents(); ch++)
  {
    const ComponentID compID  = ComponentID(ch);
    const UInt width  = pcCU->getWidth(0)  >> pcCU->getPic()->getComponentScaleX(compID);
    const UInt height = pcCU->getHeight(0) >> pcCU->getPic()->getComponentScaleY(compID);
    const UInt stride = pcPredYuv->getStride(compID);

    Pel * pOrig    = pcOrgYuv->getAddr  (compID, 0, width);
    Pel * pResi    = pcResiYuv->getAddr(compID, 0, width);
    Pel * pPred    = pcPredYuv->getAddr(compID, 0, width);
    Pel * pReco    = pcRecoYuv->getAddr(compID, 0, width);
    Pel * pPCM     = pcCU->getPCMSample (compID);

    xEncPCM ( pcCU, 0, pOrig, pPCM, pPred, pResi, pReco, stride, width, height, compID );

  }

  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiDepth, 0, true, false);
  uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  dCost = m_pcRdCost->calcRdCost( uiBits, uiDistortion );

  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  pcCU->getTotalBits()       = uiBits;
  pcCU->getTotalCost()       = dCost;
  pcCU->getTotalDistortion() = uiDistortion;

  pcCU->copyToPic(uiDepth);
}




Void TEncSearch::xGetInterPredictionError( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, Distortion& ruiErr, Bool /*bHadamard*/ )
{
  motionCompensation( pcCU, &m_tmpYuvPred, REF_PIC_LIST_X, iPartIdx );

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;
  pcCU->getPartIndexAndSize( iPartIdx, uiAbsPartIdx, iWidth, iHeight );

  DistParam cDistParam;

  cDistParam.bApplyWeight = false;


  m_pcRdCost->setDistParam( cDistParam, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA),
                            pcYuvOrg->getAddr( COMPONENT_Y, uiAbsPartIdx ), pcYuvOrg->getStride(COMPONENT_Y),
                            m_tmpYuvPred .getAddr( COMPONENT_Y, uiAbsPartIdx ), m_tmpYuvPred.getStride(COMPONENT_Y),
                            iWidth, iHeight, m_pcEncCfg->getUseHADME() && (pcCU->getCUTransquantBypass(iPartIdx) == 0) );

  ruiErr = cDistParam.DistFunc( &cDistParam );
}

//! estimation of best merge coding
Void TEncSearch::xMergeEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPUIdx, UInt& uiInterDir, TComMvField* pacMvField, UInt& uiMergeIndex, Distortion& ruiCost, TComMvField* cMvFieldNeighbours, UChar* uhInterDirNeighbours, Int& numValidMergeCand )
{

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;

 
  pcCU->getPartIndexAndSize( iPUIdx, uiAbsPartIdx, iWidth, iHeight );
  UInt uiDepth = pcCU->getDepth( uiAbsPartIdx );

  PartSize partSize = pcCU->getPartitionSize( 0 );
  if ( pcCU->getSlice()->getPPS()->getLog2ParallelMergeLevelMinus2() && partSize != SIZE_2Nx2N && pcCU->getWidth( 0 ) <= 8 )
  {
    if ( iPUIdx == 0 )
    {
      pcCU->setPartSizeSubParts( SIZE_2Nx2N, 0, uiDepth ); // temporarily set
      pcCU->getInterMergeCandidates( 0, 0, cMvFieldNeighbours,uhInterDirNeighbours, numValidMergeCand );
      pcCU->setPartSizeSubParts( partSize, 0, uiDepth ); // restore
    }
  }
  else
  {
    pcCU->getInterMergeCandidates( uiAbsPartIdx, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );
  }

  xRestrictBipredMergeCand( pcCU, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );

  ruiCost = std::numeric_limits<Distortion>::max();
  for( UInt uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )
  {
    Distortion uiCostCand = std::numeric_limits<Distortion>::max();
    UInt       uiBitsCand = 0;

    PartSize ePartSize = pcCU->getPartitionSize( 0 );

    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( cMvFieldNeighbours[0 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( cMvFieldNeighbours[1 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );

    xGetInterPredictionError( pcCU, pcYuvOrg, iPUIdx, uiCostCand, m_pcEncCfg->getUseHADME() );
    uiBitsCand = uiMergeCand + 1;
    if (uiMergeCand == m_pcEncCfg->getMaxNumMergeCand() -1)
    {
        uiBitsCand--;
    }
    uiCostCand = uiCostCand + m_pcRdCost->getCost( uiBitsCand );
    if ( uiCostCand < ruiCost )
    {
      ruiCost = uiCostCand;
      pacMvField[0] = cMvFieldNeighbours[0 + 2*uiMergeCand];
      pacMvField[1] = cMvFieldNeighbours[1 + 2*uiMergeCand];
      uiInterDir = uhInterDirNeighbours[uiMergeCand];
      uiMergeIndex = uiMergeCand;
    }
  }
 
}

/** convert bi-pred merge candidates to uni-pred
 * \param pcCU
 * \param puIdx
 * \param mvFieldNeighbours
 * \param interDirNeighbours
 * \param numValidMergeCand
 * \returns Void
 */
Void TEncSearch::xRestrictBipredMergeCand( TComDataCU* pcCU, UInt puIdx, TComMvField* mvFieldNeighbours, UChar* interDirNeighbours, Int numValidMergeCand )
{
	
  if ( pcCU->isBipredRestriction(puIdx) )
  {
    for( UInt mergeCand = 0; mergeCand < numValidMergeCand; ++mergeCand )
    {
      if ( interDirNeighbours[mergeCand] == 3 )
      {
        interDirNeighbours[mergeCand] = 1;
        mvFieldNeighbours[(mergeCand << 1) + 1].setMvField(TComMv(0,0), -1);
      }
    }
  }
}

//! search of the best candidate for inter prediction
#if AMP_MRG
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv DEBUG_STRING_FN_DECLARE(sDebug), Bool bUseRes, Bool bUseMRG )
#else
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv, Bool bUseRes )
#endif
{
  for(UInt i=0; i<NUM_REF_PIC_LIST_01; i++)
  {
    m_acYuvPred[i].clear();
  }
  m_cYuvPredTemp.clear();
  pcPredYuv->clear();

  if ( !bUseRes )
  {
    pcResiYuv->clear();
  }

  pcRecoYuv->clear();
  
  TComMv       cMvSrchRngLT;
  TComMv       cMvSrchRngRB;

  TComMv       cMvZero;
  TComMv       TempMv; //kolya

  TComMv       cMv[2];
  TComMv       cMvBi[2];
  TComMv       cMvTemp[2][33];

  Int          iNumPart    = pcCU->getNumPartitions();
  Int          iNumPredDir = pcCU->getSlice()->isInterP() ? 1 : 2;

  TComMv       cMvPred[2][33];

  TComMv       cMvPredBi[2][33];
  Int          aaiMvpIdxBi[2][33];

  Int          aaiMvpIdx[2][33];
  Int          aaiMvpNum[2][33];

  AMVPInfo     aacAMVPInfo[2][33];

  Int          iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
  Int          iRefIdxBi[2];

  UInt         uiPartAddr;
  Int          iRoiWidth, iRoiHeight;

  UInt         uiMbBits[3] = {1, 1, 0};

  UInt         uiLastMode = 0;
  Int          iRefStart, iRefEnd;

  PartSize     ePartSize = pcCU->getPartitionSize( 0 );

  Int          bestBiPRefIdxL1 = 0;
  Int          bestBiPMvpL1 = 0;
  Distortion   biPDistTemp = std::numeric_limits<Distortion>::max();

  TComMvField cMvFieldNeighbours[MRG_MAX_NUM_CANDS << 1]; // double length for mv of both lists
  UChar uhInterDirNeighbours[MRG_MAX_NUM_CANDS];
  Int numValidMergeCand = 0 ;

  for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
  {
    Distortion   uiCost[2] = { std::numeric_limits<Distortion>::max(), std::numeric_limits<Distortion>::max() };
    Distortion   uiCostBi  =   std::numeric_limits<Distortion>::max();
    Distortion   uiCostTemp;

    UInt         uiBits[3];
    UInt         uiBitsTemp;
    Distortion   bestBiPDist = std::numeric_limits<Distortion>::max();

    Distortion   uiCostTempL0[MAX_NUM_REF];
    for (Int iNumRef=0; iNumRef < MAX_NUM_REF; iNumRef++)
    {
      uiCostTempL0[iNumRef] = std::numeric_limits<Distortion>::max();
    }
    UInt         uiBitsTempL0[MAX_NUM_REF];

    TComMv       mvValidList1;
    Int          refIdxValidList1 = 0;
    UInt         bitsValidList1 = MAX_UINT;
    Distortion   costValidList1 = std::numeric_limits<Distortion>::max();

    xGetBlkBits( ePartSize, pcCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);

    pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
	
	
#if AMP_MRG
    Bool bTestNormalMC = true;

    if ( bUseMRG && pcCU->getWidth( 0 ) > 8 && iNumPart == 2 )
    {
      bTestNormalMC = false;
    }

    if (bTestNormalMC)
    {
#endif

    //  Uni-directional prediction
    for ( Int iRefList = 0; iRefList < iNumPredDir; iRefList++ )
    {
      RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

      for ( Int iRefIdxTemp = 0; iRefIdxTemp < pcCU->getSlice()->getNumRefIdx(eRefPicList); iRefIdxTemp++ )
      {
        uiBitsTemp = uiMbBits[iRefList];
        if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
        {
          uiBitsTemp += iRefIdxTemp+1;
          if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
          {
            uiBitsTemp--;
          }
        }
        xEstimateMvPredAMVP( pcCU, pcOrgYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
        aaiMvpIdx[iRefList][iRefIdxTemp] = pcCU->getMVPIdx(eRefPicList, uiPartAddr);
        aaiMvpNum[iRefList][iRefIdxTemp] = pcCU->getMVPNum(eRefPicList, uiPartAddr);

        if(pcCU->getSlice()->getMvdL1ZeroFlag() && iRefList==1 && biPDistTemp < bestBiPDist)
        {
          bestBiPDist = biPDistTemp;
          bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
          bestBiPRefIdxL1 = iRefIdxTemp;
        }

        uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];

        if ( m_pcEncCfg->getFastMEForGenBLowDelayEnabled() && iRefList == 1 )    // list 1
        {
          if ( pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) >= 0 )
          {
            cMvTemp[1][iRefIdxTemp] = cMvTemp[0][pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            uiCostTemp = uiCostTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            /*first subtract the bit-rate part of the cost of the other list*/
            uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )] );
            /*correct the bit-rate part of the current ref*/
            m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
            uiBitsTemp += m_pcRdCost->getBitsOfVectorWithPredictor( cMvTemp[1][iRefIdxTemp].getHor(), cMvTemp[1][iRefIdxTemp].getVer() );
            /*calculate the correct cost*/
            uiCostTemp += m_pcRdCost->getCost( uiBitsTemp );
          }
          else
          {
            xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
          }
        }
        else
        {
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
        }
        xCopyAMVPInfo(pcCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
        xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

        if ( iRefList == 0 )
        {
          uiCostTempL0[iRefIdxTemp] = uiCostTemp;
          uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
        }
        if ( uiCostTemp < uiCost[iRefList] )
        {
          uiCost[iRefList] = uiCostTemp;
          uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

          // set motion
          cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
          iRefIdx[iRefList] = iRefIdxTemp;
        }

        if ( iRefList == 1 && uiCostTemp < costValidList1 && pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
        {
          costValidList1 = uiCostTemp;
          bitsValidList1 = uiBitsTemp;

          // set motion
          mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
          refIdxValidList1 = iRefIdxTemp;
        }
      }
    }

    //  Bi-predictive Motion estimation
    if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )
    {

      cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
      iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];

      ::memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
      ::memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));

      UInt uiMotBits[2];

      if(pcCU->getSlice()->getMvdL1ZeroFlag())
      {
        xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
        pcCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
        cMvPredBi[1][bestBiPRefIdxL1]   = pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo()->m_acMvCand[bestBiPMvpL1];

        cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
        iRefIdxBi[1] = bestBiPRefIdxL1;
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        TComYuv* pcYuvPred = &m_acYuvPred[REF_PIC_LIST_1];
        motionCompensation( pcCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );

        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiMbBits[1];

        if ( pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1) > 1 )
        {
          uiMotBits[1] += bestBiPRefIdxL1+1;
          if ( bestBiPRefIdxL1 == pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1)-1 )
          {
            uiMotBits[1]--;
          }
        }

        uiMotBits[1] += m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][AMVP_MAX_NUM_CANDS];

        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

        cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
      }
      else
      {
        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiBits[1] - uiMbBits[1];
        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
      }

      // 4-times iteration (default)
      Int iNumIter = 4;

      // fast encoder setting: only one iteration
      if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 || pcCU->getSlice()->getMvdL1ZeroFlag() )
      {
        iNumIter = 1;
      }

      for ( Int iIter = 0; iIter < iNumIter; iIter++ )
      {
        Int         iRefList    = iIter % 2;

        if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 )
        {
          if( uiCost[0] <= uiCost[1] )
          {
            iRefList = 1;
          }
          else
          {
            iRefList = 0;
          }
        }
        else if ( iIter == 0 )
        {
          iRefList = 0;
        }
        if ( iIter == 0 && !pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllMv( cMv[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllRefIdx( iRefIdx[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          TComYuv*  pcYuvPred = &m_acYuvPred[1-iRefList];
          motionCompensation ( pcCU, pcYuvPred, RefPicList(1-iRefList), iPartIdx );
        }

        RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

        if(pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          iRefList = 0;
          eRefPicList = REF_PIC_LIST_0;
        }

        Bool bChanged = false;

        iRefStart = 0;
        iRefEnd   = pcCU->getSlice()->getNumRefIdx(eRefPicList)-1;

        for ( Int iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
        {
          uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
          if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
          {
            uiBitsTemp += iRefIdxTemp+1;
            if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
            {
              uiBitsTemp--;
            }
          }
          uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];
          // call ME
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );

          xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], pcCU->getCUMvField(eRefPicList)->getAMVPInfo());
          xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

          if ( uiCostTemp < uiCostBi )
          {
            bChanged = true;

            cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
            iRefIdxBi[iRefList] = iRefIdxTemp;

            uiCostBi            = uiCostTemp;
            uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
            uiBits[2]           = uiBitsTemp;

            if(iNumIter!=1)
            {
              //  Set motion
              pcCU->getCUMvField( eRefPicList )->setAllMv( cMvBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
              pcCU->getCUMvField( eRefPicList )->setAllRefIdx( iRefIdxBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );

              TComYuv* pcYuvPred = &m_acYuvPred[iRefList];
              motionCompensation( pcCU, pcYuvPred, eRefPicList, iPartIdx );
            }
          }
        } // for loop-iRefIdxTemp

        if ( !bChanged )
        {
          if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
          {
            xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
            xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
            if(!pcCU->getSlice()->getMvdL1ZeroFlag())
            {
              xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
              xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
            }
          }
          break;
        }
      } // for loop-iter
    } // if (B_SLICE)

#if AMP_MRG
    } //end if bTestNormalMC
#endif
    //  Clear Motion Field
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );

    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

    UInt uiMEBits = 0;
    // Set Motion Field_
    cMv[1] = mvValidList1;
	
    iRefIdx[1] = refIdxValidList1;
    uiBits[1] = bitsValidList1;
    uiCost[1] = costValidList1;

#if AMP_MRG
    if (bTestNormalMC)
    {
#endif
    if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
    {
      uiLastMode = 2;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMvBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdxBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 3, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[2];
    }
    else if ( uiCost[0] <= uiCost[1] )
    {
      uiLastMode = 0;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[0];
    }
    else
    {
      uiLastMode = 1;
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMv[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdx[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 2, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[1];
    }
#if AMP_MRG
    } // end if bTestNormalMC
#endif

    if ( pcCU->getPartitionSize( uiPartAddr ) != SIZE_2Nx2N )
    {
      UInt uiMRGInterDir = 0;
      TComMvField cMRGMvField[2];
      UInt uiMRGIndex = 0;

      UInt uiMEInterDir = 0;
      TComMvField cMEMvField[2];

      m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

#if AMP_MRG
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      Distortion uiMECost  = std::numeric_limits<Distortion>::max();

      if (bTestNormalMC)
      {
        xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
        uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
      }
#else
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
      Distortion uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
#endif
      // save ME result.
      uiMEInterDir = pcCU->getInterDir( uiPartAddr );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

      // find Merge result
      Distortion uiMRGCost = std::numeric_limits<Distortion>::max();

      xMergeEstimation( pcCU, pcOrgYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);

      if ( uiMRGCost < uiMECost )
      {
        // set Merge result
        pcCU->setMergeFlagSubParts ( true,          uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setMergeIndexSubParts( uiMRGIndex,    uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts  ( uiMRGInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMRGMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMRGMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      }
      else
      {
        // set ME result
        pcCU->setMergeFlagSubParts( false,        uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts ( uiMEInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMEMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMEMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );
      }
    }

    //  MC
    motionCompensation ( pcCU, pcPredYuv, REF_PIC_LIST_X, iPartIdx );

  } //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )

  setWpScalingDistParam( pcCU, -1, REF_PIC_LIST_X );
 // CTUW = iRoiWidth;
 // CTUH = iRoiHeight;
 // myfile << CTUH << ',' << CTUW << endl;
  return;
}


// AMVP
Void TEncSearch::xEstimateMvPredAMVP( TComDataCU* pcCU, TComYuv* pcOrgYuv, UInt uiPartIdx, RefPicList eRefPicList, Int iRefIdx, TComMv& rcMvPred, Bool bFilled, Distortion* puiDistBiP )
{

  AMVPInfo*  pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();

  TComMv     cBestMv;
  Int        iBestIdx   = 0;
  TComMv     cZeroMv;
  TComMv     cMvPred;
  Distortion uiBestCost = std::numeric_limits<Distortion>::max();
  UInt       uiPartAddr = 0;
  Int        iRoiWidth, iRoiHeight;
  Int        i;
 
  pcCU->getPartIndexAndSize( uiPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
 

  // Fill the MV Candidates
  if (!bFilled)
  {
    pcCU->fillMvpCand( uiPartIdx, uiPartAddr, eRefPicList, iRefIdx, pcAMVPInfo );
  }

  // initialize Mvp index & Mvp
  iBestIdx = 0;
  cBestMv  = pcAMVPInfo->m_acMvCand[0];
  if (pcAMVPInfo->iN <= 1)
  {
    rcMvPred = cBestMv;

    pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));

    if(pcCU->getSlice()->getMvdL1ZeroFlag() && eRefPicList==REF_PIC_LIST_1)
    {
      (*puiDistBiP) = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, rcMvPred, 0, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    }
    return;
  }

  if (bFilled)
  {
    assert(pcCU->getMVPIdx(eRefPicList,uiPartAddr) >= 0);
    rcMvPred = pcAMVPInfo->m_acMvCand[pcCU->getMVPIdx(eRefPicList,uiPartAddr)];
    return;
  }

  m_cYuvPredTemp.clear();
  //-- Check Minimum Cost.
  for ( i = 0 ; i < pcAMVPInfo->iN; i++)
  {
    Distortion uiTmpCost;
    uiTmpCost = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, pcAMVPInfo->m_acMvCand[i], i, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    if ( uiBestCost > uiTmpCost )
    {
      uiBestCost = uiTmpCost;
      cBestMv   = pcAMVPInfo->m_acMvCand[i];
      iBestIdx  = i;
      (*puiDistBiP) = uiTmpCost;
    }
  }

  m_cYuvPredTemp.clear();

  // Setting Best MVP
  rcMvPred = cBestMv;
  pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  return;
  
}

UInt TEncSearch::xGetMvpIdxBits(Int iIdx, Int iNum)
{
  assert(iIdx >= 0 && iNum >= 0 && iIdx < iNum);

  if (iNum == 1)
  {
    return 0;
  }

  UInt uiLength = 1;
  Int iTemp = iIdx;
  if ( iTemp == 0 )
  {
    return uiLength;
  }

  Bool bCodeLast = ( iNum-1 > iTemp );

  uiLength += (iTemp-1);

  if( bCodeLast )
  {
    uiLength++;
  }

  return uiLength;
}

Void TEncSearch::xGetBlkBits( PartSize eCUMode, Bool bPSlice, Int iPartIdx, UInt uiLastMode, UInt uiBlkBit[3])
{
  if ( eCUMode == SIZE_2Nx2N )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else if ( (eCUMode == SIZE_2NxN || eCUMode == SIZE_2NxnU) || eCUMode == SIZE_2NxnD )
  {
    UInt aauiMbBits[2][3][3] = { { {0,0,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7,5,7}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( (eCUMode == SIZE_Nx2N || eCUMode == SIZE_nLx2N) || eCUMode == SIZE_nRx2N )
  {
    UInt aauiMbBits[2][3][3] = { { {0,2,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7-2,7-2,9-2}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( eCUMode == SIZE_NxN )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else
  {
    printf("Wrong!\n");
    assert( 0 );
  }
}

Void TEncSearch::xCopyAMVPInfo (AMVPInfo* pSrc, AMVPInfo* pDst)
{
  pDst->iN = pSrc->iN;
  for (Int i = 0; i < pSrc->iN; i++)
  {
    pDst->m_acMvCand[i] = pSrc->m_acMvCand[i];
  }
}

Void TEncSearch::xCheckBestMVP ( TComDataCU* pcCU, RefPicList eRefPicList, TComMv cMv, TComMv& rcMvPred, Int& riMVPIdx, UInt& ruiBits, Distortion& ruiCost )
{
  AMVPInfo* pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();
  
  assert(pcAMVPInfo->m_acMvCand[riMVPIdx] == rcMvPred);

  if (pcAMVPInfo->iN < 2)
  {
    return;
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(0) );
  m_pcRdCost->setCostScale ( 0    );

  Int iBestMVPIdx = riMVPIdx;

  m_pcRdCost->setPredictor( rcMvPred );
  Int iOrgMvBits  = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
  iOrgMvBits += m_auiMVPIdxCost[riMVPIdx][AMVP_MAX_NUM_CANDS];
  Int iBestMvBits = iOrgMvBits;

  for (Int iMVPIdx = 0; iMVPIdx < pcAMVPInfo->iN; iMVPIdx++)
  {
    if (iMVPIdx == riMVPIdx)
    {
      continue;
    }

    m_pcRdCost->setPredictor( pcAMVPInfo->m_acMvCand[iMVPIdx] );

    Int iMvBits = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
    iMvBits += m_auiMVPIdxCost[iMVPIdx][AMVP_MAX_NUM_CANDS];

    if (iMvBits < iBestMvBits)
    {
      iBestMvBits = iMvBits;
      iBestMVPIdx = iMVPIdx;
    }
  }

  if (iBestMVPIdx != riMVPIdx)  //if changed
  {
    rcMvPred = pcAMVPInfo->m_acMvCand[iBestMVPIdx];

    riMVPIdx = iBestMVPIdx;
    UInt uiOrgBits = ruiBits;
    ruiBits = uiOrgBits - iOrgMvBits + iBestMvBits;
    ruiCost = (ruiCost - m_pcRdCost->getCost( uiOrgBits ))  + m_pcRdCost->getCost( ruiBits );
  }
  
}


Distortion TEncSearch::xGetTemplateCost( TComDataCU* pcCU,
                                         UInt        uiPartAddr,
                                         TComYuv*    pcOrgYuv,
                                         TComYuv*    pcTemplateCand,
                                         TComMv      cMvCand,
                                         Int         iMVPIdx,
                                         Int         iMVPNum,
                                         RefPicList  eRefPicList,
                                         Int         iRefIdx,
                                         Int         iSizeX,
                                         Int         iSizeY
                                         )
{
  Distortion uiCost = std::numeric_limits<Distortion>::max();

  TComPicYuv* pcPicYuvRef = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdx )->getPicYuvRec();

  pcCU->clipMv( cMvCand );

  // prediction pattern
  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, true, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }
  else
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, false, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }

  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xWeightedPredictionUni( pcCU, pcTemplateCand, uiPartAddr, iSizeX, iSizeY, eRefPicList, pcTemplateCand, iRefIdx );
  }

  // calc distortion

  uiCost = m_pcRdCost->getDistPart( pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA), pcTemplateCand->getAddr(COMPONENT_Y, uiPartAddr), pcTemplateCand->getStride(COMPONENT_Y), pcOrgYuv->getAddr(COMPONENT_Y, uiPartAddr), pcOrgYuv->getStride(COMPONENT_Y), iSizeX, iSizeY, COMPONENT_Y, DF_SAD );
  uiCost = (UInt) m_pcRdCost->calcRdCost( m_auiMVPIdxCost[iMVPIdx][iMVPNum], uiCost, DF_SAD );
  return uiCost;
}


Void TEncSearch::xMotionEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, RefPicList eRefPicList, TComMv* pcMvPred, Int iRefIdxPred, TComMv& rcMv, UInt& ruiBits, Distortion& ruiCost, Bool bBi  )
{
  UInt          uiPartAddr;
  Int           iRoiWidth;
  Int           iRoiHeight;

  TComMv        cMvHalf, cMvQter;
  TComMv        cMvSrchRngLT;
  TComMv        cMvSrchRngRB;
  // Distortion   INTCOST=0;
  TComYuv*      pcYuv = pcYuvOrg;
   
  assert(eRefPicList < MAX_NUM_REF_LIST_ADAPT_SR && iRefIdxPred<Int(MAX_IDX_ADAPT_SR));
  m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];

  Int           iSrchRng      = ( bBi ? m_bipredSearchRange : m_iSearchRange );
  TComPattern   tmpPattern;
  TComPattern*  pcPatternKey  = &tmpPattern;

  Double        fWeight       = 1.0;

  pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );

  if ( bBi ) // Bipredictive ME
  {
    TComYuv*  pcYuvOther = &m_acYuvPred[1-(Int)eRefPicList];
    pcYuv                = &m_cYuvPredTemp;

    pcYuvOrg->copyPartToPartYuv( pcYuv, uiPartAddr, iRoiWidth, iRoiHeight );

    pcYuv->removeHighFreq( pcYuvOther, uiPartAddr, iRoiWidth, iRoiHeight, pcCU->getSlice()->getSPS()->getBitDepths().recon, m_pcEncCfg->getClipForBiPredMeEnabled() );

    fWeight = 0.5;
  }
  m_cDistParam.bIsBiPred = bBi;

  //  Search key pattern initialization
  pcPatternKey->initPattern( pcYuv->getAddr  ( COMPONENT_Y, uiPartAddr ),
                             iRoiWidth,
                             iRoiHeight,
                             pcYuv->getStride(COMPONENT_Y),
                             pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );

  Pel*        piRefY      = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu() + uiPartAddr );
  Int         iRefStride  = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getStride(COMPONENT_Y);

  TComMv      cMvPred = *pcMvPred;

  if ( bBi )
  {
	  
    xSetSearchRange   ( pcCU, rcMv   , iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }
  else
  {
	  
    xSetSearchRange   ( pcCU, cMvPred, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }

  m_pcRdCost->selectMotionLambda(true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setPredictor  ( *pcMvPred );
  m_pcRdCost->setCostScale  ( 2 );

  setWpScalingDistParam( pcCU, iRefIdxPred, eRefPicList );
  //  Do integer search
  if ( (m_motionEstimationSearchMethod==MESEARCH_FULL) || bBi )
  {
    xPatternSearch      ( pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost );
  }
  else
  {
    rcMv = *pcMvPred;
    const TComMv *pIntegerMv2Nx2NPred=0;
    if (pcCU->getPartitionSize(0) != SIZE_2Nx2N || pcCU->getDepth(0) != 0)
    {
      pIntegerMv2Nx2NPred = &(m_integerMv2Nx2N[eRefPicList][iRefIdxPred]);
    }
    
    // EMI: Save Block width and height in global variables, to use in our NN
    PUHeight = iRoiHeight;
    PUWidth = iRoiWidth;
    PIdx = iPartIdx;
    PAddr = uiPartAddr;

    xPatternSearchFast  ( pcCU, pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost, pIntegerMv2Nx2NPred );
    if (pcCU->getPartitionSize(0) == SIZE_2Nx2N)
    {
      m_integerMv2Nx2N[eRefPicList][iRefIdxPred] = rcMv;
    }
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );
  m_pcRdCost->setCostScale ( 1 );
  
  const Bool bIsLosslessCoded = pcCU->getCUTransquantBypass(uiPartAddr) != 0;
  xPatternSearchFracDIF( bIsLosslessCoded, pcPatternKey, piRefY, iRefStride, &rcMv, cMvHalf, cMvQter, ruiCost );

  m_pcRdCost->setCostScale( 0 );

  
  
  // EMI: Modification
  
  /* 
  Fractional Motion Estimation values computed by standard are stored in TComMv variables cMvHalf & cMvQter
  We create other TComMv variables, and replace the standard values with our NN predicted values
  Our NN modifies global variables MVX_HALF & MVX_QRTER, which in return are set used to set our new Mv
  */
  TComMv MV_HALF, MV_QRTER;
  MV_HALF.setHor(MVX_HALF);
  MV_HALF.setVer(MVY_HALF);
  MV_QRTER.setHor(MVX_QRTER);
  MV_QRTER.setVer(MVY_QRTER);

  // For finding Integer Motion Estimation, Set Horizontal and Vertical values to zero:

  // MV_HALF.setHor(0);
  // MV_HALF.setVer(0);
  // MV_QRTER.setHor(0);
  // MV_QRTER.setVer(0);

  /* 
  EMI: To Write the errors and output MV in a CSV file:
  Real values for errors: U,V,H           - NN values for errors: IN[]
  Real values for MV: cMvHalf, cMvQter    - NN values for MV: MV_HALF, MV_QRTER
  Block Width and Hight: iRoiWidth, iRoiHeight
  */
  
  // ofstream mv_nn;
  // ofstream errors;
  // errors.open("/home/vague/git-repos/data/HM16.9/extract_data/SSE_errors.csv", ios::app);
  // mv_nn.open("/home/vague/git-repos/data/HM16.9/extract_data/mv_nn.csv", ios::app);
  // mv_nn << NN_out << endl;
  // mv_nn << MV_HALF.getHor() << ',' << MV_QRTER.getHor() << ',' << MV_HALF.getVer() << ',' << MV_QRTER.getVer() << endl;
  // mv_nn << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer()  << endl;
  // errors << IN[8] << ',' << IN[9] << ',' << IN[10] << ',' << IN[11] << ',' << IN[12] << ',' << IN[13] << ',' << IN[14] << ',' << IN[15] << ',' << IN[16] << endl;
  // errors << IN[0] << ',' << IN[1] << ',' << IN[2] << ',' << IN[3] << ',' << IN[4] << ',' << IN[5] << ',' << IN[6] << ',' << IN[7] << endl;

  // errors << U1 << ',' << V1 << ',' << U2 << ',' << H1 << ',' << C << ',' << H2 << ',' << U3 << ',' << V2 << ',' << U4 << ',' << iRoiHeight << ',' << iRoiWidth << endl;
  // errors << ',' << uiPartAddr << ',' << iPartIdx << endl;
  
  /*
  EXPERIMENTAL -> Write the values of the output class directly instead of coordinates "Works quite well":
  Half * 0.5 + Quarter * 0.25:  results in range from -0.75->0.75
  Add both X & Y + 0.75:        range is now 0->1.5
  Multiply X by 4:              X values are now [0, 1, 2, 3, 4, 5, 6]
  Multiply Y by 4*7=28:         Y values are now [0, 7, 14, 21, 28, 35, 42]
  Adding X+Y results in the desired output class, given that the mapping starts from 
  0 for top left corner, 24 center, and 48 for bottom right corner
  */
  
  // int MV_X = (((cMvHalf.getHor() * 0.5) + (cMvQter.getHor() * 0.25)) + 0.75) * 4;
  // int MV_Y = (((cMvHalf.getVer() * 0.5) + (cMvQter.getVer() * 0.25)) + 0.75) * 28;
  // int OUT_CLASS = MV_Y + MV_X;
  // mv_nn << OUT_CLASS << endl;
  // mv_nn << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer()  << endl;
  

  // Replace Motion Vector with values computed by our NN

  rcMv <<= 2;
  // rcMv += (cMvHalf <<= 1);
  // rcMv += cMvQter;
  rcMv += (MV_HALF <<= 1);
  rcMv += MV_QRTER;
  
  // End of modification

  UInt uiMvBits = m_pcRdCost->getBitsOfVectorWithPredictor( rcMv.getHor(), rcMv.getVer() );

  ruiBits      += uiMvBits;
  ruiCost       = (Distortion)( floor( fWeight * ( (Double)ruiCost - (Double)m_pcRdCost->getCost( uiMvBits ) ) ) + (Double)m_pcRdCost->getCost( ruiBits ) );
}


Void TEncSearch::xSetSearchRange ( const TComDataCU* const pcCU, const TComMv& cMvPred, const Int iSrchRng,
                                   TComMv& rcMvSrchRngLT, TComMv& rcMvSrchRngRB )
{
  Int  iMvShift = 2;
  TComMv cTmpMvPred = cMvPred;
  pcCU->clipMv( cTmpMvPred );

  rcMvSrchRngLT.setHor( cTmpMvPred.getHor() - (iSrchRng << iMvShift) );
  rcMvSrchRngLT.setVer( cTmpMvPred.getVer() - (iSrchRng << iMvShift) );

  rcMvSrchRngRB.setHor( cTmpMvPred.getHor() + (iSrchRng << iMvShift) );
  rcMvSrchRngRB.setVer( cTmpMvPred.getVer() + (iSrchRng << iMvShift) );
  pcCU->clipMv        ( rcMvSrchRngLT );
  pcCU->clipMv        ( rcMvSrchRngRB );

#if ME_ENABLE_ROUNDING_OF_MVS
  rcMvSrchRngLT.divideByPowerOf2(iMvShift);
  rcMvSrchRngRB.divideByPowerOf2(iMvShift);
#else
  rcMvSrchRngLT >>= iMvShift;
  rcMvSrchRngRB >>= iMvShift;
#endif
}


Void TEncSearch::xPatternSearch(const TComPattern* const pcPatternKey,
	const Pel*               piRefY,
	const Int                iRefStride,
	const TComMv* const      pcMvSrchRngLT,
	const TComMv* const      pcMvSrchRngRB,
	TComMv&      rcMv,
	Distortion&  ruiSAD)
{
	Int   iSrchRngHorLeft = pcMvSrchRngLT->getHor();
	Int   iSrchRngHorRight = pcMvSrchRngRB->getHor();
	Int   iSrchRngVerTop = pcMvSrchRngLT->getVer();
	Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

	Distortion  uiSad;
	Distortion  uiSadBest = std::numeric_limits<Distortion>::max();
	Int         iBestX = 0;
	Int         iBestY = 0;


	m_pcRdCost->setDistParam(pcPatternKey, piRefY, iRefStride, m_cDistParam);

	// fast encoder decision: use subsampled SAD for integer ME
	if (m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE3)
	{
		if (m_cDistParam.iRows > 8)
		{
			m_cDistParam.iSubShift = 1;
		}
	}

	piRefY += (iSrchRngVerTop * iRefStride);

	for (Int y = iSrchRngVerTop; y <= iSrchRngVerBottom; y++)
	{
		for (Int x = iSrchRngHorLeft; x <= iSrchRngHorRight; x++)
		{
			//  find min. distortion position
			m_cDistParam.pCur = piRefY + x;

			setDistParamComp(COMPONENT_Y);

			m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
			uiSad = m_cDistParam.DistFunc(&m_cDistParam);

			// motion cost
			uiSad += m_pcRdCost->getCostOfVectorWithPredictor(x, y);

			if (uiSad < uiSadBest)
			{
				uiSadBest = uiSad;
				iBestX = x;
				iBestY = y;
				m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
			}
		}
		piRefY += iRefStride;
	}




		rcMv.set(iBestX, iBestY);


		ruiSAD = uiSadBest - m_pcRdCost->getCostOfVectorWithPredictor(iBestX, iBestY);

		//getchar();
		return;
	}


Void TEncSearch::xPatternSearchFast( const TComDataCU* const  pcCU,
                                     const TComPattern* const pcPatternKey,
                                     const Pel* const         piRefY,
                                     const Int                iRefStride,
                                     const TComMv* const      pcMvSrchRngLT,
                                     const TComMv* const      pcMvSrchRngRB,
                                     TComMv&                  rcMv,
                                     Distortion&              ruiSAD,
                                     const TComMv* const      pIntegerMv2Nx2NPred )
{
  assert (MD_LEFT < NUM_MV_PREDICTORS);
  pcCU->getMvPredLeft       ( m_acMvPredictors[MD_LEFT] );
  assert (MD_ABOVE < NUM_MV_PREDICTORS);
  pcCU->getMvPredAbove      ( m_acMvPredictors[MD_ABOVE] );
  assert (MD_ABOVE_RIGHT < NUM_MV_PREDICTORS);
  pcCU->getMvPredAboveRight ( m_acMvPredictors[MD_ABOVE_RIGHT] );

  switch ( m_motionEstimationSearchMethod )
  {
    case MESEARCH_DIAMOND:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, false );
	  
      C = array_e[0];
      for (int i = 1; i <=index_ref - 1; i++)
      {
        if (array_e[i] < C)
          C = array_e[i];

      }
	 
      // index_ref = index_ref + 1;
      U1 = array_e[index_ref];
      V1 = array_e[index_ref + 1];
      U2 = array_e[index_ref + 2];
      H1 = array_e[index_ref + 3];	  
      H2 = array_e[index_ref + 4];
      U3 = array_e[index_ref + 5];
      V2 = array_e[index_ref + 6];
      U4 = array_e[index_ref + 7];
      	  
      // EMI: neural network implementation
      
      // Reset all values of arrays

      memset(IN, 0, sizeof(IN));
      memset(X1, 0, sizeof(X1));
      memset(X2, 0, sizeof(X2));
      memset(OUT, 0, sizeof(OUT));
      memset(array_e, 0, sizeof(array_e));
      N = 0; NN_out = 0; counter_i = 0; index_ref = 0;


      // Normalize input values using the computed mean and standard deviations

      IN[8] = (U1 - mean[0]) / stdev[0];
      IN[9] = (V1 - mean[1]) / stdev[1];
      IN[10] = (U2 - mean[2]) / stdev[2];
      IN[11] = (H1 - mean[3]) / stdev[3];
      IN[12] = (C - mean[4]) / stdev[4];
      IN[13] = (H2 - mean[5]) / stdev[5];
      IN[14] = (U3 - mean[6]) / stdev[6];
      IN[15] = (V2 - mean[7]) / stdev[7];
      IN[16] = (U4 - mean[8]) / stdev[8];

      // Input layer also consists of categorical variables, in which we will use embedding matrices depending on block Height and Width

      switch (PUHeight) {
        case 4:   IN[0] = embs0[1][0];  IN[1] = embs0[1][1];   IN[2] = embs0[1][2];   IN[3] = embs0[1][3];		break;
        case 8:   IN[0] = embs0[2][0];  IN[1] = embs0[2][1];   IN[2] = embs0[2][2];   IN[3] = embs0[2][3];		break;
        case 12:  IN[0] = embs0[3][0];  IN[1] = embs0[3][1];   IN[2] = embs0[3][2];   IN[3] = embs0[3][3];	  break;
        case 16:  IN[0] = embs0[4][0];  IN[1] = embs0[4][1];   IN[2] = embs0[4][2];   IN[3] = embs0[4][3];		break;
        case 24:  IN[0] = embs0[5][0];  IN[1] = embs0[5][1];   IN[2] = embs0[5][2];   IN[3] = embs0[5][3];	  break;
        case 32:  IN[0] = embs0[6][0];  IN[1] = embs0[6][1];   IN[2] = embs0[6][2];   IN[3] = embs0[6][3];		break;
        case 64:  IN[0] = embs0[7][0];  IN[1] = embs0[7][1];   IN[2] = embs0[7][2];   IN[3] = embs0[7][3];		break;
        default:  IN[0] = embs0[0][0];  IN[1] = embs0[0][1];   IN[2] = embs0[0][2];   IN[3] = embs0[0][3];		break;
      }

      switch (PUWidth) {
        case 4:   IN[4] = embs1[1][0];  IN[5] = embs1[1][1];   IN[6] = embs1[1][2];   IN[7] = embs1[1][3];		break;
        case 8:   IN[4] = embs1[2][0];  IN[5] = embs1[2][1];   IN[6] = embs1[2][2];   IN[7] = embs1[2][3];		break;
        case 12:  IN[4] = embs1[3][0];  IN[5] = embs1[3][1];   IN[6] = embs1[3][2];   IN[7] = embs1[3][3];	  break;
        case 16:  IN[4] = embs1[4][0];  IN[5] = embs1[4][1];   IN[6] = embs1[4][2];   IN[7] = embs1[4][3];		break;
        case 24:  IN[4] = embs1[5][0];  IN[5] = embs1[5][1];   IN[6] = embs1[5][2];   IN[7] = embs1[5][3];	  break;
        case 32:  IN[4] = embs1[6][0];  IN[5] = embs1[6][1];   IN[6] = embs1[6][2];   IN[7] = embs1[6][3];		break;
        case 64:  IN[4] = embs1[7][0];  IN[5] = embs1[7][1];   IN[6] = embs1[7][2];   IN[7] = embs1[7][3];		break;
        default:  IN[4] = embs1[0][0];  IN[5] = embs1[0][1];   IN[6] = embs1[0][2];   IN[7] = embs1[0][3];		break;
      }

      // Input Layer
      for(int i=0;i<9;i++){
        IN[i+8] = (IN[i+8] * BN_gamma_in[i]);	  
      }

      
      // First Hidden Layer
      for (int i = 0; i < 22; i++) {
        for (int j = 0; j < 17; j++) {
          X1[i] += (in_h1[i][j] * IN[j]);
        }
        X1[i] += b1[i];
        X1[i] = (relu(X1[i]) * BN_gamma_1[i]) + BN_beta_1[i];
      }

      // Second Hidden Layer
      for (int i = 0; i < 20; i++) {
        for (int j = 0; j < 22; j++) {
          X2[i] += (h1_h2[i][j] * X1[j]);
        }
        X2[i] += b2[i];
        X2[i] = (relu(X2[i]) * BN_gamma_2[i]) + BN_beta_2[i];
      }

      // OUTPUT LAYER
      for (int i = 0; i < 49; i++) {
        for (int j = 0; j < 20; j++) {
          OUT[i] += (h2_out[i][j] * X2[j]);
        }
        OUT[i] += bout[i];
      }
      
      // Decision: NN_out holds the index of the maximum element

      N = sizeof(OUT) / sizeof(float); // Size of OUT[] array, used in next step
      NN_out = std::distance(OUT, std::max_element(OUT, OUT + N));
      
      switch (NN_out) {
        case 0: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 1: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 2: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 3: MVX_HALF = 0;   MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 4: MVX_HALF = 0;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 5: MVX_HALF = 1;   MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 6: MVX_HALF = 1;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;

        case 7: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 8: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 9: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 10: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 11: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 12: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 13: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;

        case 14: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 15: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 16: MVX_HALF = 0;  MVX_QRTER = -1;   MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 17: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 18: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 19: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 20: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;

        case 21: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 22: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 23: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 24: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 25: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 26: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 27: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;

        case 28: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 29: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 30: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 31: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 32: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 33: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 34: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;

        case 35: MVX_HALF = -1; MVX_QRTER = -1;   MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 36: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 37: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 38: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 0;		break;
        case 39: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 40: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 41: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;

        case 42: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 43: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 44: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 45: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 1;	  break;
        case 46: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 47: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 48: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        default: MVX_HALF = 0;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
      }


      //end of neural network code

      break;



    case MESEARCH_SELECTIVE:
      xTZSearchSelective( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred );
      break;

    case MESEARCH_DIAMOND_ENHANCED:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, true );
      break;

    case MESEARCH_FULL: // shouldn't get here.
    default:
      break;
  }
}


Void TEncSearch::xTZSearch( const TComDataCU* const pcCU,
                            const TComPattern* const pcPatternKey,
                            const Pel* const         piRefY,
                            const Int                iRefStride,
                            const TComMv* const      pcMvSrchRngLT,
                            const TComMv* const      pcMvSrchRngRB,
                            TComMv&                  rcMv,
                            Distortion&              ruiSAD,
                            const TComMv* const      pIntegerMv2Nx2NPred,
                            const Bool               bExtendedSettings)
{
  const Bool bUseAdaptiveRaster                      = bExtendedSettings;
  const Int  iRaster                                 = 5;
  const Bool bTestOtherPredictedMV                   = bExtendedSettings;
  const Bool bTestZeroVector                         = true;
  const Bool bTestZeroVectorStart                    = bExtendedSettings;
  const Bool bTestZeroVectorStop                     = false;
  const Bool bFirstSearchDiamond                     = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bFirstCornersForDiamondDist1            = bExtendedSettings;
  const Bool bFirstSearchStop                        = m_pcEncCfg->getFastMEAssumingSmootherMVEnabled();
  const UInt uiFirstSearchRounds                     = 3;     // first search stop X rounds after best match (must be >=1)
  const Bool bEnableRasterSearch                     = true;
  const Bool bAlwaysRasterSearch                     = bExtendedSettings;  // true: BETTER but factor 2 slower
  const Bool bRasterRefinementEnable                 = false; // enable either raster refinement or star refinement
  const Bool bRasterRefinementDiamond                = false; // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bRasterRefinementCornersForDiamondDist1 = bExtendedSettings;
  const Bool bStarRefinementEnable                   = true;  // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond                  = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementCornersForDiamondDist1   = bExtendedSettings;
  const Bool bStarRefinementStop                     = false;
  const UInt uiStarRefinementRounds                  = 2;  // star refinement stop X rounds after best match (must be >=1)
  const Bool bNewZeroNeighbourhoodTest               = bExtendedSettings;

  UInt uiSearchRange = m_iSearchRange;
  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;

  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      if (cMv != rcMv && (cMv.getHor() != cStruct.iBestX && cMv.getVer() != cStruct.iBestY))
      {
        // only test cMV if not obviously previously tested.
        xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
      }
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    if ((rcMv.getHor() != 0 || rcMv.getVer() != 0) &&
        (0 != cStruct.iBestX || 0 != cStruct.iBestY))
    {
      // only test 0-vector if not obviously previously tested.
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
    }
  }

  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  if (pIntegerMv2Nx2NPred != 0)
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    if ((rcMv != integerMv2Nx2NPred) &&
        (integerMv2Nx2NPred.getHor() != cStruct.iBestX || integerMv2Nx2NPred.getVer() != cStruct.iBestY))
    {
      // only test integerMv2Nx2NPred if not obviously previously tested.
      xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);
    }

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // start search
  Int  iDist = 0;
  Int  iStartX = cStruct.iBestX;
  Int  iStartY = cStruct.iBestY;

  const Bool bBestCandidateZero = (cStruct.iBestX == 0) && (cStruct.iBestY == 0);

  // first search around best position up to now.
  // The following works as a "subsampled/log" window search around the best candidate
  for (iDist = 1; iDist <= (Int)uiSearchRange; iDist *= 2)
	  
  {
    if ( bFirstSearchDiamond == 1 )
    {
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bFirstCornersForDiamondDist1 );
    }
    else
    {
      xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
    }

    if ( bFirstSearchStop && ( cStruct.uiBestRound >= uiFirstSearchRounds ) ) // stop criterion
    {
      break;
    }
  }

  if (!bNewZeroNeighbourhoodTest)
  {
    // test whether zero Mv is a better start point than Median predictor
    if ( bTestZeroVectorStart && ((cStruct.iBestX != 0) || (cStruct.iBestY != 0)) )
    {
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
      if ( (cStruct.iBestX == 0) && (cStruct.iBestY == 0) )
      {
        // test its neighborhood
        for ( iDist = 1; iDist <= (Int)uiSearchRange; iDist*=2 )
        {
          xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
          if ( bTestZeroVectorStop && (cStruct.uiBestRound > 0) ) // stop criterion
          {
            break;
          }
        }
      }
    }
  }
  else
  {
    // Test also zero neighbourhood but with half the range
    // It was reported that the original (above) search scheme using bTestZeroVectorStart did not
    // make sense since one would have already checked the zero candidate earlier
    // and thus the conditions for that test would have not been satisfied
    if (bTestZeroVectorStart == true && bBestCandidateZero != true)
    {
      for ( iDist = 1; iDist <= ((Int)uiSearchRange >> 1); iDist*=2 )
      {
        xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
        if ( bTestZeroVectorStop && (cStruct.uiBestRound > 2) ) // stop criterion
        {
          break;
        }
      }
    }
  }

  // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
  if ( cStruct.uiBestDistance == 1 )
  {
    cStruct.uiBestDistance = 0;
    xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
  }

  // raster search if distance is too big
  if (bUseAdaptiveRaster)
  {
    int iWindowSize = iRaster;
    Int   iSrchRngRasterLeft   = iSrchRngHorLeft;
    Int   iSrchRngRasterRight  = iSrchRngHorRight;
    Int   iSrchRngRasterTop    = iSrchRngVerTop;
    Int   iSrchRngRasterBottom = iSrchRngVerBottom;

    if (!(bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster))))
    {
      iWindowSize ++;
      iSrchRngRasterLeft /= 2;
      iSrchRngRasterRight /= 2;
      iSrchRngRasterTop /= 2;
      iSrchRngRasterBottom /= 2;
    }
    cStruct.uiBestDistance = iWindowSize;
    for ( iStartY = iSrchRngRasterTop; iStartY <= iSrchRngRasterBottom; iStartY += iWindowSize )
    {
      for ( iStartX = iSrchRngRasterLeft; iStartX <= iSrchRngRasterRight; iStartX += iWindowSize )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iWindowSize );
      }
    }
  }
  else
  {
    if ( bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster) || bAlwaysRasterSearch ) )
    {
      cStruct.uiBestDistance = iRaster;
      for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += iRaster )
      {
        for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += iRaster )
        {
          xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iRaster );
        }
      }
    }
  }

  // raster refinement

  if ( bRasterRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      if ( cStruct.uiBestDistance > 1 )
      {
        iDist = cStruct.uiBestDistance >>= 1;
        if ( bRasterRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bRasterRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
      }

      // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // star refinement
  if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bStarRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }


  // EMI: BIG DIFFERENCE!
  // getting the 8 SAD points
  iDist = 1;
  iStartX = cStruct.iBestX;
  iStartY = cStruct.iBestY;
  index_ref = counter_i;
  
  xTZ8PointSquareSearch(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  iDist = 2;
  xTZ8PointSquareSearch2(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );
}


Void TEncSearch::xTZSearchSelective( const TComDataCU* const   pcCU,
                                     const TComPattern* const  pcPatternKey,
                                     const Pel* const          piRefY,
                                     const Int                 iRefStride,
                                     const TComMv* const       pcMvSrchRngLT,
                                     const TComMv* const       pcMvSrchRngRB,
                                     TComMv                   &rcMv,
                                     Distortion               &ruiSAD,
                                     const TComMv* const       pIntegerMv2Nx2NPred )
{
  const Bool bTestOtherPredictedMV    = true;
  const Bool bTestZeroVector          = true;
  const Bool bEnableRasterSearch      = true;
  const Bool bAlwaysRasterSearch      = false;  // 1: BETTER but factor 15x slower
  const Bool bStarRefinementEnable    = true;   // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond   = true;   // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementStop      = false;
  const UInt uiStarRefinementRounds   = 2;  // star refinement stop X rounds after best match (must be >=1)
  const UInt uiSearchRange            = m_iSearchRange;
  const Int  uiSearchRangeInitial     = m_iSearchRange >> 2;
  const Int  uiSearchStep             = 4;
  const Int  iMVDistThresh            = 8;

  Int   iSrchRngHorLeft         = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight        = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop          = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom       = pcMvSrchRngRB->getVer();
  Int   iFirstSrchRngHorLeft    = 0;
  Int   iFirstSrchRngHorRight   = 0;
  Int   iFirstSrchRngVerTop     = 0;
  Int   iFirstSrchRngVerBottom  = 0;
  Int   iStartX                 = 0;
  Int   iStartY                 = 0;
  Int   iBestX                  = 0;
  Int   iBestY                  = 0;
  Int   iDist                   = 0;

  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;
  cStruct.iBestX = 0;
  cStruct.iBestY = 0;


  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
  }

  if ( pIntegerMv2Nx2NPred != 0 )
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // Initial search
  iBestX = cStruct.iBestX;
  iBestY = cStruct.iBestY; 
  iFirstSrchRngHorLeft    = ((iBestX - uiSearchRangeInitial) > iSrchRngHorLeft)   ? (iBestX - uiSearchRangeInitial) : iSrchRngHorLeft;
  iFirstSrchRngVerTop     = ((iBestY - uiSearchRangeInitial) > iSrchRngVerTop)    ? (iBestY - uiSearchRangeInitial) : iSrchRngVerTop;
  iFirstSrchRngHorRight   = ((iBestX + uiSearchRangeInitial) < iSrchRngHorRight)  ? (iBestX + uiSearchRangeInitial) : iSrchRngHorRight;  
  iFirstSrchRngVerBottom  = ((iBestY + uiSearchRangeInitial) < iSrchRngVerBottom) ? (iBestY + uiSearchRangeInitial) : iSrchRngVerBottom;    

  for ( iStartY = iFirstSrchRngVerTop; iStartY <= iFirstSrchRngVerBottom; iStartY += uiSearchStep )
  {
    for ( iStartX = iFirstSrchRngHorLeft; iStartX <= iFirstSrchRngHorRight; iStartX += uiSearchStep )
    {
      xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 0 );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 1, false );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 2, false );
    }
  }

  Int iMaxMVDistToPred = (abs(cStruct.iBestX - iBestX) > iMVDistThresh || abs(cStruct.iBestY - iBestY) > iMVDistThresh);

  //full search with early exit if MV is distant from predictors
  if ( bEnableRasterSearch && (iMaxMVDistToPred || bAlwaysRasterSearch) )
  {
    for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += 1 )
    {
      for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += 1 )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 1 );
      }
    }
  }
  //Smaller MV, refine around predictor
  else if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    // start refinement
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, false );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );

}


Void TEncSearch::xPatternSearchFracDIF(
                                       Bool         bIsLosslessCoded,
                                       TComPattern* pcPatternKey,
                                       Pel*         piRefY,
                                       Int          iRefStride,
                                       TComMv*      pcMvInt,
                                       TComMv&      rcMvHalf,
                                       TComMv&      rcMvQter,
                                       Distortion&  ruiCost
                                      )
{
  //  Reference pattern initialization (integer scale)
	
  TComPattern cPatternRoi;
  Int         iOffset    = pcMvInt->getHor() + pcMvInt->getVer() * iRefStride;
  cPatternRoi.initPattern(piRefY + iOffset,
                          pcPatternKey->getROIYWidth(),
                          pcPatternKey->getROIYHeight(),
                          iRefStride,
                          pcPatternKey->getBitDepthY());

  //  Half-pel refinement
  xExtDIFUpSamplingH ( &cPatternRoi );

  rcMvHalf = *pcMvInt;   rcMvHalf <<= 1;    // for mv-cost
  TComMv baseRefMv(0, 0);
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 2, rcMvHalf, !bIsLosslessCoded );

  m_pcRdCost->setCostScale( 0 );

  xExtDIFUpSamplingQ ( &cPatternRoi, rcMvHalf );
  baseRefMv = rcMvHalf;
  baseRefMv <<= 1;

  rcMvQter = *pcMvInt;   rcMvQter <<= 1;    // for mv-cost
  rcMvQter += rcMvHalf;  rcMvQter <<= 1;
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 1, rcMvQter, !bIsLosslessCoded );
}


//! encode residual and calculate rate-distortion for a CU block
Void TEncSearch::encodeResAndCalcRdInterCU( TComDataCU* pcCU, TComYuv* pcYuvOrg, TComYuv* pcYuvPred,
                                            TComYuv* pcYuvResi, TComYuv* pcYuvResiBest, TComYuv* pcYuvRec,
                                            Bool bSkipResidual DEBUG_STRING_FN_DECLARE(sDebug) )
{
  assert ( !pcCU->isIntra(0) );

  const UInt cuWidthPixels      = pcCU->getWidth ( 0 );
  const UInt cuHeightPixels     = pcCU->getHeight( 0 );
  const Int  numValidComponents = pcCU->getPic()->getNumberValidComponents();
  const TComSPS &sps=*(pcCU->getSlice()->getSPS());

  // The pcCU is not marked as skip-mode at this point, and its m_pcTrCoeff, m_pcArlCoeff, m_puhCbf, m_puhTrIdx will all be 0.
  // due to prior calls to TComDataCU::initEstData(  );

  if ( bSkipResidual ) //  No residual coding : SKIP mode
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    pcYuvResi->clear();

    pcYuvPred->copyToPartYuv( pcYuvRec, 0 );
    Distortion distortion = 0;

    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID compID=ComponentID(comp);
      const UInt csx=pcYuvOrg->getComponentScaleX(compID);
      const UInt csy=pcYuvOrg->getComponentScaleY(compID);
      distortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID), pcYuvRec->getStride(compID), pcYuvOrg->getAddr(compID),
                                               pcYuvOrg->getStride(compID), cuWidthPixels >> csx, cuHeightPixels >> csy, compID);
    }

    m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST]);
    m_pcEntropyCoder->resetBits();

    if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex( pcCU, 0, true );

    UInt uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    pcCU->getTotalBits()       = uiBits;
    pcCU->getTotalDistortion() = distortion;
    pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( uiBits, distortion );

    m_pcRDGoOnSbacCoder->store(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_TEMP_BEST]);

#if DEBUG_STRING
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif

    return;
  }

  //  Residual coding.

   pcYuvResi->subtract( pcYuvOrg, pcYuvPred, 0, cuWidthPixels );

  TComTURecurse tuLevel0(pcCU, 0);

  Double     nonZeroCost       = 0;
  UInt       nonZeroBits       = 0;
  Distortion nonZeroDistortion = 0;
  Distortion zeroDistortion    = 0;

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_CURR_BEST ] );

  xEstimateInterResidualQT( pcYuvResi,  nonZeroCost, nonZeroBits, nonZeroDistortion, &zeroDistortion, tuLevel0 DEBUG_STRING_PASS_INTO(sDebug) );

  // -------------------------------------------------------
  // set the coefficients in the pcCU, and also calculates the residual data.
  // If a block full of 0's is efficient, then just use 0's.
  // The costs at this point do not include header bits.

  m_pcEntropyCoder->resetBits();
  m_pcEntropyCoder->encodeQtRootCbfZero( );
  const UInt   zeroResiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  const Double zeroCost     = (pcCU->isLosslessCoded( 0 )) ? (nonZeroCost+1) : (m_pcRdCost->calcRdCost( zeroResiBits, zeroDistortion ));

  if ( zeroCost < nonZeroCost || !pcCU->getQtRootCbf(0) )
  {
    const UInt uiQPartNum = tuLevel0.GetAbsPartIdxNumParts();
    ::memset( pcCU->getTransformIdx()     , 0, uiQPartNum * sizeof(UChar) );
    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID component = ComponentID(comp);
      ::memset( pcCU->getCbf( component ) , 0, uiQPartNum * sizeof(UChar) );
      ::memset( pcCU->getCrossComponentPredictionAlpha(component), 0, ( uiQPartNum * sizeof(SChar) ) );
    }
    static const UInt useTS[MAX_NUM_COMPONENT]={0,0,0};
    pcCU->setTransformSkipSubParts ( useTS, 0, pcCU->getDepth(0) );
#if DEBUG_STRING
    sDebug.clear();
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif
  }
  else
  {
    xSetInterResidualQTData( NULL, false, tuLevel0); // Call first time to set coefficients.
  }

  // all decisions now made. Fully encode the CU, including the headers:
  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST] );

  UInt finalBits = 0;
  xAddSymbolBitsInter( pcCU, finalBits );
  // we've now encoded the pcCU, and so have a valid bit cost

  if ( !pcCU->getQtRootCbf( 0 ) )
  {
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
  }
  else
  {
    xSetInterResidualQTData( pcYuvResiBest, true, tuLevel0 ); // else set the residual image data pcYUVResiBest from the various temp images.
  }
  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_TEMP_BEST ] );

  pcYuvRec->addClip ( pcYuvPred, pcYuvResiBest, 0, cuWidthPixels, sps.getBitDepths() );

  // update with clipped distortion and cost (previously unclipped reconstruction values were used)

  Distortion finalDistortion = 0;
  for(Int comp=0; comp<numValidComponents; comp++)
  {
    const ComponentID compID=ComponentID(comp);
    finalDistortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID ), pcYuvRec->getStride(compID ), pcYuvOrg->getAddr(compID ), pcYuvOrg->getStride(compID), cuWidthPixels >> pcYuvOrg->getComponentScaleX(compID), cuHeightPixels >> pcYuvOrg->getComponentScaleY(compID), compID);
  }

  pcCU->getTotalBits()       = finalBits;
  pcCU->getTotalDistortion() = finalDistortion;
  pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( finalBits, finalDistortion );
}



Void TEncSearch::xEstimateInterResidualQT( TComYuv    *pcResi,
                                           Double     &rdCost,
                                           UInt       &ruiBits,
                                           Distortion &ruiDist,
                                           Distortion *puiZeroDist,
                                           TComTU     &rTu
                                           DEBUG_STRING_FN_DECLARE(sDebug) )
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiDepth      = rTu.GetTransformDepthTotal();
  const UInt uiTrMode     = rTu.GetTransformDepthRel();
  const UInt subTUDepth   = uiTrMode + 1;
  const UInt numValidComp = pcCU->getPic()->getNumberValidComponents();
  DEBUG_STRING_NEW(sSingleStringComp[MAX_NUM_COMPONENT])

  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  UInt SplitFlag = ((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && pcCU->isInter(uiAbsPartIdx) && ( pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N ));
#if DEBUG_STRING
  const Int debugPredModeMask = DebugStringGetPredModeMask(pcCU->getPredictionMode(uiAbsPartIdx));
#endif

  Bool bCheckFull;

  if ( SplitFlag && uiDepth == pcCU->getDepth(uiAbsPartIdx) && ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) ) )
  {
    bCheckFull = false;
  }
  else
  {
    bCheckFull =  ( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
  }

  const Bool bCheckSplit  = ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

  assert( bCheckFull || bCheckSplit );

  // code full block
  Double     dSingleCost = MAX_DOUBLE;
  UInt       uiSingleBits                                                                                                        = 0;
  Distortion uiSingleDistComp            [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  Distortion uiSingleDist                                                                                                        = 0;
  TCoeff     uiAbsSum                    [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  UInt       uiBestTransformMode         [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  //  Stores the best explicit RDPCM mode for a TU encoded without split
  UInt       bestExplicitRdpcmModeUnSplit[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{3,3}, {3,3}, {3,3}};
  SChar      bestCrossCPredictionAlpha   [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};

  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );

  if( bCheckFull )
  {
    Double minCost[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/];
    Bool checkTransformSkip[MAX_NUM_COMPONENT];
    pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

    m_pcEntropyCoder->resetBits();

    memset( m_pTempPel, 0, sizeof( Pel ) * rTu.getRect(COMPONENT_Y).width * rTu.getRect(COMPONENT_Y).height ); // not necessary needed for inside of recursion (only at the beginning)

    const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    TCoeff *pcCoeffCurr[MAX_NUM_COMPONENT];
#if ADAPTIVE_QP_SELECTION
    TCoeff *pcArlCoeffCurr[MAX_NUM_COMPONENT];
#endif

    for(UInt i=0; i<numValidComp; i++)
    {
      minCost[i][0] = MAX_DOUBLE;
      minCost[i][1] = MAX_DOUBLE;
    }

    Pel crossCPredictedResidualBuffer[ MAX_TU_SIZE * MAX_TU_SIZE ];

    for(UInt i=0; i<numValidComp; i++)
    {
      checkTransformSkip[i]=false;
      const ComponentID compID=ComponentID(i);
      const Int channelBitDepth=pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
      pcCoeffCurr[compID]    = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
#if ADAPTIVE_QP_SELECTION
      pcArlCoeffCurr[compID] = m_ppcQTTempArlCoeff[compID ][uiQTTempAccessLayer] +  rTu.getCoefficientOffset(compID);
#endif

      if(rTu.ProcessComponentSection(compID))
      {
        const QpParam cQP(*pcCU, compID);

        checkTransformSkip[compID] = pcCU->getSlice()->getPPS()->getUseTransformSkip() &&
                                     TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(compID), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize()) &&
                                     (!pcCU->isLosslessCoded(0));

        const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

        TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

        const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

        do
        {
          const UInt           subTUIndex             = TUIterator.GetSectionNumber();
          const UInt           subTUAbsPartIdx        = TUIterator.GetAbsPartIdxTU(compID);
          const TComRectangle &tuCompRect             = TUIterator.getRect(compID);
          const UInt           subTUBufferOffset      = tuCompRect.width * tuCompRect.height * subTUIndex;

                TCoeff        *currentCoefficients    = pcCoeffCurr[compID] + subTUBufferOffset;
#if ADAPTIVE_QP_SELECTION
                TCoeff        *currentARLCoefficients = pcArlCoeffCurr[compID] + subTUBufferOffset;
#endif
          const Bool isCrossCPredictionAvailable      =    isChroma(compID)
                                                         && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                         && (pcCU->getCbf(subTUAbsPartIdx, COMPONENT_Y, uiTrMode) != 0);

          SChar preCalcAlpha = 0;
          const Pel *pLumaResi = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( COMPONENT_Y, rTu.getRect( COMPONENT_Y ).x0, rTu.getRect( COMPONENT_Y ).y0 );

          if (isCrossCPredictionAvailable)
          {
            const Bool bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
            const Pel  *const lumaResidualForEstimate       = bUseReconstructedResidualForEstimate ? pLumaResi                                                     : pcResi->getAddrPix(COMPONENT_Y, tuCompRect.x0, tuCompRect.y0);
            const UInt        lumaResidualStrideForEstimate = bUseReconstructedResidualForEstimate ? m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y) : pcResi->getStride(COMPONENT_Y);

            preCalcAlpha = xCalcCrossComponentPredictionAlpha(TUIterator,
                                                              compID,
                                                              lumaResidualForEstimate,
                                                              pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                              tuCompRect.width,
                                                              tuCompRect.height,
                                                              lumaResidualStrideForEstimate,
                                                              pcResi->getStride(compID));
          }

          const Int transformSkipModesToTest    = checkTransformSkip[compID] ? 2 : 1;
          const Int crossCPredictionModesToTest = (preCalcAlpha != 0)        ? 2 : 1; // preCalcAlpha cannot be anything other than 0 if isCrossCPredictionAvailable is false

          const Bool isOneMode                  = (crossCPredictionModesToTest == 1) && (transformSkipModesToTest == 1);

          for (Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
          {
            pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);

            for (Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
            {
              const Bool isFirstMode          = (transformSkipModeId == 0) && (crossCPredictionModeId == 0);
              const Bool bUseCrossCPrediction = crossCPredictionModeId != 0;

              m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
              m_pcEntropyCoder->resetBits();

              pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);
              pcCU->setCrossComponentPredictionAlphaPartRange((bUseCrossCPrediction ? preCalcAlpha : 0), compID, subTUAbsPartIdx, partIdxesPerSubTU );

              if ((compID != COMPONENT_Cr) && ((transformSkipModeId == 1) ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ()))
              {
                m_pcEntropyCoder->estimateBit(m_pcTrQuant->m_pcEstBitsSbac, tuCompRect.width, tuCompRect.height, toChannelType(compID));
              }

#if RDOQ_CHROMA_LAMBDA
              m_pcTrQuant->selectLambda(compID);
#endif

              Pel *pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
              UInt resiStride     = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);

              TCoeff bestCoeffComp   [MAX_TU_SIZE*MAX_TU_SIZE];
              Pel    bestResiComp    [MAX_TU_SIZE*MAX_TU_SIZE];

#if ADAPTIVE_QP_SELECTION
              TCoeff bestArlCoeffComp[MAX_TU_SIZE*MAX_TU_SIZE];
#endif
              TCoeff     currAbsSum   = 0;
              UInt       currCompBits = 0;
              Distortion currCompDist = 0;
              Double     currCompCost = 0;
              UInt       nonCoeffBits = 0;
              Distortion nonCoeffDist = 0;
              Double     nonCoeffCost = 0;

              if(!isOneMode && !isFirstMode)
              {
                memcpy(bestCoeffComp,    currentCoefficients,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(bestArlCoeffComp, currentARLCoefficients, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for(Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy(&bestResiComp[y * tuCompRect.width], (pcResiCurrComp + (y * resiStride)), (sizeof(Pel) * tuCompRect.width));
                }
              }

              if (bUseCrossCPrediction)
              {
                TComTrQuant::crossComponentPrediction(TUIterator,
                                                      compID,
                                                      pLumaResi,
                                                      pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                      crossCPredictedResidualBuffer,
                                                      tuCompRect.width,
                                                      tuCompRect.height,
                                                      m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                      pcResi->getStride(compID),
                                                      tuCompRect.width,
                                                      false);

                m_pcTrQuant->transformNxN(TUIterator, compID, crossCPredictedResidualBuffer, tuCompRect.width, currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }
              else
              {
                m_pcTrQuant->transformNxN(TUIterator, compID, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ), pcResi->getStride(compID), currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }

              if(isFirstMode || (currAbsSum == 0))
              {
                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pTempPel,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        tuCompRect.width,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        true);

                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride( compID ), pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }
                else
                {
                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pTempPel, tuCompRect.width, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }

                m_pcEntropyCoder->encodeQtCbfZero( TUIterator, toChannelType(compID) );

                if ( isCrossCPredictionAvailable )
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                nonCoeffBits = m_pcEntropyCoder->getNumberOfWrittenBits();
                nonCoeffCost = m_pcRdCost->calcRdCost( nonCoeffBits, nonCoeffDist );
              }

              if((puiZeroDist != NULL) && isFirstMode)
              {
                *puiZeroDist += nonCoeffDist; // initialized with zero residual distortion
              }

              DEBUG_STRING_NEW(sSingleStringTest)

              if( currAbsSum > 0 ) //if non-zero coefficients are present, a residual needs to be derived for further prediction
              {
                if (isFirstMode)
                {
                  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
                  m_pcEntropyCoder->resetBits();
                }

                m_pcEntropyCoder->encodeQtCbf( TUIterator, compID, true );

                if (isCrossCPredictionAvailable)
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                m_pcEntropyCoder->encodeCoeffNxN( TUIterator, currentCoefficients, compID );
                currCompBits = m_pcEntropyCoder->getNumberOfWrittenBits();

                pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 );

                m_pcTrQuant->invTransformNxN( TUIterator, compID, pcResiCurrComp, m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID), currentCoefficients, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sSingleStringTest, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );

                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        true);
                }

                currCompDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        pcResi->getStride(compID),
                                                        tuCompRect.width, tuCompRect.height, compID);

                currCompCost = m_pcRdCost->calcRdCost(currCompBits, currCompDist);
                  
                if (pcCU->isLosslessCoded(0))
                {
                  nonCoeffCost = MAX_DOUBLE;
                }
              }
              else if ((transformSkipModeId == 1) && !bUseCrossCPrediction)
              {
                currCompCost = MAX_DOUBLE;
              }
              else
              {
                currCompBits = nonCoeffBits;
                currCompDist = nonCoeffDist;
                currCompCost = nonCoeffCost;
              }

              // evaluate
              if ((currCompCost < minCost[compID][subTUIndex]) || ((transformSkipModeId == 1) && (currCompCost == minCost[compID][subTUIndex])))
              {
                bestExplicitRdpcmModeUnSplit[compID][subTUIndex] = pcCU->getExplicitRdpcmMode(compID, subTUAbsPartIdx);

                if(isFirstMode) //check for forced null
                {
                  if((nonCoeffCost < currCompCost) || (currAbsSum == 0))
                  {
                    memset(currentCoefficients, 0, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));

                    currAbsSum   = 0;
                    currCompBits = nonCoeffBits;
                    currCompDist = nonCoeffDist;
                    currCompCost = nonCoeffCost;
                  }
                }

#if DEBUG_STRING
                if (currAbsSum > 0)
                {
                  DEBUG_STRING_SWAP(sSingleStringComp[compID], sSingleStringTest)
                }
                else
                {
                  sSingleStringComp[compID].clear();
                }
#endif

                uiAbsSum                 [compID][subTUIndex] = currAbsSum;
                uiSingleDistComp         [compID][subTUIndex] = currCompDist;
                minCost                  [compID][subTUIndex] = currCompCost;
                uiBestTransformMode      [compID][subTUIndex] = transformSkipModeId;
                bestCrossCPredictionAlpha[compID][subTUIndex] = (crossCPredictionModeId == 1) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;

                if (uiAbsSum[compID][subTUIndex] == 0)
                {
                  if (bUseCrossCPrediction)
                  {
                    TComTrQuant::crossComponentPrediction(TUIterator,
                                                          compID,
                                                          pLumaResi,
                                                          m_pTempPel,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                          tuCompRect.width,
                                                          tuCompRect.height,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                          tuCompRect.width,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                          true);
                  }
                  else
                  {
                    pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
                    const UInt uiStride = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);
                    for(UInt uiY = 0; uiY < tuCompRect.height; uiY++)
                    {
                      memset(pcResiCurrComp, 0, (sizeof(Pel) * tuCompRect.width));
                      pcResiCurrComp += uiStride;
                    }
                  }
                }
              }
              else
              {
                // reset
                memcpy(currentCoefficients,    bestCoeffComp,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(currentARLCoefficients, bestArlCoeffComp, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for (Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy((pcResiCurrComp + (y * resiStride)), &bestResiComp[y * tuCompRect.width], (sizeof(Pel) * tuCompRect.width));
                }
              }
            }
          }

          pcCU->setExplicitRdpcmModePartRange            (   bestExplicitRdpcmModeUnSplit[compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU);
          pcCU->setTransformSkipPartRange                (   uiBestTransformMode         [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCbfPartRange                          ((((uiAbsSum                    [compID][subTUIndex] > 0) ? 1 : 0) << uiTrMode), compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCrossComponentPredictionAlphaPartRange(   bestCrossCPredictionAlpha   [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
        } while (TUIterator.nextSection(rTu)); //end of sub-TU loop
      } // processing section
    } // component loop

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      if (rTu.ProcessComponentSection(compID) && (rTu.getRect(compID).width != rTu.getRect(compID).height))
      {
        offsetSubTUCBFs(rTu, compID); //the CBFs up to now have been defined for two sub-TUs - shift them down a level and replace with the parent level CBF
      }
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    if( uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( 0, 5 - uiLog2TrSize );
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const UInt chOrderChange = ((ch + 1) == numValidComp) ? 0 : (ch + 1);
      const ComponentID compID=ComponentID(chOrderChange);
      if( rTu.ProcessComponentSection(compID) )
      {
        m_pcEntropyCoder->encodeQtCbf( rTu, compID, true );
      }
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if (rTu.ProcessComponentSection(compID))
      {
        if(isChroma(compID) && (uiAbsSum[COMPONENT_Y][0] != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, compID );
        }

        m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr[compID], compID );
        for (UInt subTUIndex = 0; subTUIndex < 2; subTUIndex++)
        {
          uiSingleDist += uiSingleDistComp[compID][subTUIndex];
        }
      }
    }

    uiSingleBits = m_pcEntropyCoder->getNumberOfWrittenBits();

    dSingleCost = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDist );
  } // check full

  // code sub-blocks
  if( bCheckSplit )
  {
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    Distortion uiSubdivDist = 0;
    UInt       uiSubdivBits = 0;
    Double     dSubdivCost = 0.0;

    //save the non-split CBFs in case we need to restore them later

    UInt bestCBF     [MAX_NUM_COMPONENT];
    UInt bestsubTUCBF[MAX_NUM_COMPONENT][2];
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);

      if (rTu.ProcessComponentSection(compID))
      {
        bestCBF[compID] = pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode);

        const TComRectangle &tuCompRect = rTu.getRect(compID);
        if (tuCompRect.width != tuCompRect.height)
        {
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

          for (UInt subTU = 0; subTU < 2; subTU++)
          {
            bestsubTUCBF[compID][subTU] = pcCU->getCbf ((uiAbsPartIdx + (subTU * partIdxesPerSubTU)), compID, subTUDepth);
          }
        }
      }
    }


    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiQPartNumSubdiv = tuRecurseChild.GetAbsPartIdxNumParts();

    DEBUG_STRING_NEW(sSplitString[MAX_NUM_COMPONENT])

    do
    {
      DEBUG_STRING_NEW(childString)
      xEstimateInterResidualQT( pcResi, dSubdivCost, uiSubdivBits, uiSubdivDist, bCheckFull ? NULL : puiZeroDist,  tuRecurseChild DEBUG_STRING_PASS_INTO(childString));
#if DEBUG_STRING
      // split the string by component and append to the relevant output (because decoder decodes in channel order, whereas this search searches by TU-order)
      std::size_t lastPos=0;
      const std::size_t endStrng=childString.find(debug_reorder_data_inter_token[MAX_NUM_COMPONENT], lastPos);
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        if (lastPos!=std::string::npos && childString.find(debug_reorder_data_inter_token[ch], lastPos)==lastPos)
        {
          lastPos+=strlen(debug_reorder_data_inter_token[ch]); // skip leading string
        }
        std::size_t pos=childString.find(debug_reorder_data_inter_token[ch+1], lastPos);
        if (pos!=std::string::npos && pos>endStrng)
        {
          lastPos=endStrng;
        }
        sSplitString[ch]+=childString.substr(lastPos, (pos==std::string::npos)? std::string::npos : (pos-lastPos) );
        lastPos=pos;
      }
#endif
    } while ( tuRecurseChild.nextSection(rTu) ) ;

    UInt uiCbfAny=0;
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      UInt uiYUVCbf = 0;
      for( UInt ui = 0; ui < 4; ++ui )
      {
        uiYUVCbf |= pcCU->getCbf( uiAbsPartIdx + ui * uiQPartNumSubdiv, ComponentID(ch),  uiTrMode + 1 );
      }
      UChar *pBase=pcCU->getCbf( ComponentID(ch) );
      const UInt flags=uiYUVCbf << uiTrMode;
      for( UInt ui = 0; ui < 4 * uiQPartNumSubdiv; ++ui )
      {
        pBase[uiAbsPartIdx + ui] |= flags;
      }
      uiCbfAny|=uiYUVCbf;
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    // when compID isn't a channel, code Cbfs:
    xEncodeInterResidualQT( MAX_NUM_COMPONENT, rTu );
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      xEncodeInterResidualQT( ComponentID(ch), rTu );
    }

    uiSubdivBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    dSubdivCost  = m_pcRdCost->calcRdCost( uiSubdivBits, uiSubdivDist );

    if (!bCheckFull || (uiCbfAny && (dSubdivCost < dSingleCost)))
    {
      rdCost += dSubdivCost;
      ruiBits += uiSubdivBits;
      ruiDist += uiSubdivDist;
#if DEBUG_STRING
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        DEBUG_STRING_APPEND(sDebug, sSplitString[ch])
      }
#endif
    }
    else
    {
      rdCost  += dSingleCost;
      ruiBits += uiSingleBits;
      ruiDist += uiSingleDist;

      //restore state to unsplit

      pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        const ComponentID compID=ComponentID(ch);

        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        if (rTu.ProcessComponentSection(compID))
        {
          DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])

          const Bool splitIntoSubTUs   = rTu.getRect(compID).width != rTu.getRect(compID).height;
          const UInt numberOfSections  = splitIntoSubTUs ? 2 : 1;
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> (splitIntoSubTUs ? 1 : 0);

          for (UInt subTUIndex = 0; subTUIndex < numberOfSections; subTUIndex++)
          {
            const UInt  uisubTUPartIdx = uiAbsPartIdx + (subTUIndex * partIdxesPerSubTU);

            if (splitIntoSubTUs)
            {
              const UChar combinedCBF = (bestsubTUCBF[compID][subTUIndex] << subTUDepth) | (bestCBF[compID] << uiTrMode);
              pcCU->setCbfPartRange(combinedCBF, compID, uisubTUPartIdx, partIdxesPerSubTU);
            }
            else
            {
              pcCU->setCbfPartRange((bestCBF[compID] << uiTrMode), compID, uisubTUPartIdx, partIdxesPerSubTU);
            }

            pcCU->setCrossComponentPredictionAlphaPartRange(bestCrossCPredictionAlpha[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setTransformSkipPartRange(uiBestTransformMode[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setExplicitRdpcmModePartRange(bestExplicitRdpcmModeUnSplit[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
          }
        }
      }

      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
    }
  }
  else
  {
    rdCost  += dSingleCost;
    ruiBits += uiSingleBits;
    ruiDist += uiSingleDist;
#if DEBUG_STRING
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[compID])

      if (rTu.ProcessComponentSection(compID))
      {
        DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])
      }
    }
#endif
  }
  DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[MAX_NUM_COMPONENT])
}



Void TEncSearch::xEncodeInterResidualQT( const ComponentID compID, TComTU &rTu )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  const UInt uiCurrTrMode = rTu.GetTransformDepthRel();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );

  const Bool bSubdiv = uiCurrTrMode != uiTrMode;

  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  if (compID==MAX_NUM_COMPONENT)  // we are not processing a channel, instead we always recurse and code the CBFs
  {
    if( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() && uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      if((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && (pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N))
      {
        assert(bSubdiv); // Inferred splitting rule - see derivation and use of interSplitFlag in the specification.
      }
      else
      {
        m_pcEntropyCoder->encodeTransformSubdivFlag( bSubdiv, 5 - uiLog2TrSize );
      }
    }

    assert( !pcCU->isIntra(uiAbsPartIdx) );

    const Bool bFirstCbfOfCU = uiCurrTrMode == 0;

    for (UInt ch=COMPONENT_Cb; ch<pcCU->getPic()->getNumberValidComponents(); ch++)
    {
      const ComponentID compIdInner=ComponentID(ch);
      if( bFirstCbfOfCU || rTu.ProcessingAllQuadrants(compIdInner) )
      {
        if( bFirstCbfOfCU || pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) )
        {
          m_pcEntropyCoder->encodeQtCbf( rTu, compIdInner, !bSubdiv );
        }
      }
      else
      {
        assert( pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode ) == pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) );
      }
    }

    if (!bSubdiv)
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }

  if( !bSubdiv )
  {
    if (compID != MAX_NUM_COMPONENT) // we have already coded the CBFs, so now we code coefficients
    {
      if (rTu.ProcessComponentSection(compID))
      {
        if (isChroma(compID) && (pcCU->getCbf(uiAbsPartIdx, COMPONENT_Y, uiTrMode) != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction(rTu, compID);
        }

        if (pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode) != 0)
        {
          const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
          TCoeff *pcCoeffCurr = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
          m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr, compID );
        }
      }
    }
  }
  else
  {
    if( compID==MAX_NUM_COMPONENT || pcCU->getCbf( uiAbsPartIdx, compID, uiCurrTrMode ) )
    {
      TComTURecurse tuRecurseChild(rTu, false);
      do
      {
        xEncodeInterResidualQT( compID, tuRecurseChild );
      } while (tuRecurseChild.nextSection(rTu));
    }
  }
}




Void TEncSearch::xSetInterResidualQTData( TComYuv* pcResi, Bool bSpatial, TComTU &rTu ) // TODO: turn this into two functions for bSpatial=true and false.
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiCurrTrMode=rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );
  const TComSPS *sps=pcCU->getSlice()->getSPS();

  if( uiCurrTrMode == uiTrMode )
  {
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTTempAccessLayer = sps->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if( bSpatial )
    {
      // Data to be copied is in the spatial domain, i.e., inverse-transformed.

      for(UInt i=0; i<pcResi->getNumberValidComponents(); i++)
      {
        const ComponentID compID=ComponentID(i);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          m_pcQTTempTComYuv[uiQTTempAccessLayer].copyPartToPartComponentMxN    ( compID, pcResi, rectCompTU );
        }
      }
    }
    else
    {
      for (UInt ch=0; ch < getNumberValidComponents(sps->getChromaFormatIdc()); ch++)
      {
        const ComponentID compID   = ComponentID(ch);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          const UInt numCoeffInBlock    = rectCompTU.width * rectCompTU.height;
          const UInt offset             = rTu.getCoefficientOffset(compID);
          TCoeff* dest                  = pcCU->getCoeff(compID)                        + offset;
          const TCoeff* src             = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + offset;
          ::memcpy( dest, src, sizeof(TCoeff)*numCoeffInBlock );

#if ADAPTIVE_QP_SELECTION
          TCoeff* pcArlCoeffSrc            = m_ppcQTTempArlCoeff[compID][uiQTTempAccessLayer] + offset;
          TCoeff* pcArlCoeffDst            = pcCU->getArlCoeff(compID)                        + offset;
          ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * numCoeffInBlock );
#endif
        }
      }
    }
  }
  else
  {

    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetInterResidualQTData( pcResi, bSpatial, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}




UInt TEncSearch::xModeBitsIntra( TComDataCU* pcCU, UInt uiMode, UInt uiPartOffset, UInt uiDepth, const ChannelType chType )
{
  // Reload only contexts required for coding intra mode information
  m_pcRDGoOnSbacCoder->loadIntraDirMode( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST], chType );

  // Temporarily set the intra dir being tested, and only
  // for absPartIdx, since encodeIntraDirModeLuma/Chroma only use
  // the entry at absPartIdx.

  UChar &rIntraDirVal=pcCU->getIntraDir( chType )[uiPartOffset];
  UChar origVal=rIntraDirVal;
  rIntraDirVal = uiMode;
  //pcCU->setIntraDirSubParts ( chType, uiMode, uiPartOffset, uiDepth + uiInitTrDepth );

  m_pcEntropyCoder->resetBits();
  if (isLuma(chType))
  {
    m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiPartOffset);
  }
  else
  {
    m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiPartOffset);
  }

  rIntraDirVal = origVal; // restore

  return m_pcEntropyCoder->getNumberOfWrittenBits();
}




UInt TEncSearch::xUpdateCandList( UInt uiMode, Double uiCost, UInt uiFastCandNum, UInt * CandModeList, Double * CandCostList )
{
  UInt i;
  UInt shift=0;

  while ( shift<uiFastCandNum && uiCost<CandCostList[ uiFastCandNum-1-shift ] )
  {
    shift++;
  }

  if( shift!=0 )
  {
    for(i=1; i<shift; i++)
    {
      CandModeList[ uiFastCandNum-i ] = CandModeList[ uiFastCandNum-1-i ];
      CandCostList[ uiFastCandNum-i ] = CandCostList[ uiFastCandNum-1-i ];
    }
    CandModeList[ uiFastCandNum-shift ] = uiMode;
    CandCostList[ uiFastCandNum-shift ] = uiCost;
    return 1;
  }

  return 0;
}





/** add inter-prediction syntax elements for a CU block
 * \param pcCU
 * \param uiQp
 * \param uiTrMode
 * \param ruiBits
 * \returns Void
 */
Void  TEncSearch::xAddSymbolBitsInter( TComDataCU* pcCU, UInt& ruiBits )
{
  if(pcCU->getMergeFlag( 0 ) && pcCU->getPartitionSize( 0 ) == SIZE_2Nx2N && !pcCU->getQtRootCbf( 0 ))
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    m_pcEntropyCoder->resetBits();
    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }
    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex(pcCU, 0, true);

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
  else
  {
    m_pcEntropyCoder->resetBits();

    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag ( pcCU, 0, true );
    m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
    m_pcEntropyCoder->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );
    m_pcEntropyCoder->encodePredInfo( pcCU, 0 );

    Bool codeDeltaQp = false;
    Bool codeChromaQpAdj = false;
    m_pcEntropyCoder->encodeCoeff   ( pcCU, 0, pcCU->getDepth(0), codeDeltaQp, codeChromaQpAdj );

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
}





/**
 * \brief Generate half-sample interpolated block
 *
 * \param pattern Reference picture ROI
 * \param biPred    Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingH( TComPattern* pattern )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;
  Int halfFilterSize = (filterSize>>1);
  Pel *srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[0].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 0, false, chFmt, pattern->getBitDepthY());
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[2].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 2, false, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + halfFilterSize * intStride + 1;
  dstPtr = m_filteredBlock[0][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
  dstPtr = m_filteredBlock[2][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+1, 2, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
  dstPtr = m_filteredBlock[0][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[2][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+1, 2, false, true, chFmt, pattern->getBitDepthY());
}





/**
 * \brief Generate quarter-sample interpolated blocks
 *
 * \param pattern    Reference picture ROI
 * \param halfPelRef Half-pel mv
 * \param biPred     Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingQ( TComPattern* pattern, TComMv halfPelRef )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Pel *srcPtr;
  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;

  Int halfFilterSize = (filterSize>>1);

  Int extHeight = (halfPelRef.getVer() == 0) ? height + filterSize : height + filterSize-1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  // Horizontal filter 1/4
  srcPtr = pattern->getROIY() - halfFilterSize * srcStride - 1;
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() >= 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 1, false, chFmt, pattern->getBitDepthY());

  // Horizontal filter 3/4
  srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() > 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 3, false, chFmt, pattern->getBitDepthY());

  // Generate @ 1,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][1].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());

  if (halfPelRef.getVer() != 0)
  {
    // Generate @ 2,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][1].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 2,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][3].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 0,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][1].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 0,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][3].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());
  }

  if (halfPelRef.getHor() != 0)
  {
    // Generate @ 1,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[1][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[3][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 1,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[1][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[3][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }

  // Generate @ 1,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][3].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
}





//! set wp tables
Void  TEncSearch::setWpScalingDistParam( TComDataCU* pcCU, Int iRefIdx, RefPicList eRefPicListCur )
{
  if ( iRefIdx<0 )
  {
    m_cDistParam.bApplyWeight = false;
    return;
  }

  TComSlice       *pcSlice  = pcCU->getSlice();
  WPScalingParam  *wp0 , *wp1;

  m_cDistParam.bApplyWeight = ( pcSlice->getSliceType()==P_SLICE && pcSlice->testWeightPred() ) || ( pcSlice->getSliceType()==B_SLICE && pcSlice->testWeightBiPred() ) ;

  if ( !m_cDistParam.bApplyWeight )
  {
    return;
  }

  Int iRefIdx0 = ( eRefPicListCur == REF_PIC_LIST_0 ) ? iRefIdx : (-1);
  Int iRefIdx1 = ( eRefPicListCur == REF_PIC_LIST_1 ) ? iRefIdx : (-1);

  getWpScaling( pcCU, iRefIdx0, iRefIdx1, wp0 , wp1 );

  if ( iRefIdx0 < 0 )
  {
    wp0 = NULL;
  }
  if ( iRefIdx1 < 0 )
  {
    wp1 = NULL;
  }

  m_cDistParam.wpCur  = NULL;

  if ( eRefPicListCur == REF_PIC_LIST_0 )
  {
    m_cDistParam.wpCur = wp0;
  }
  else
  {
    m_cDistParam.wpCur = wp1;
  }
}



//! \}
