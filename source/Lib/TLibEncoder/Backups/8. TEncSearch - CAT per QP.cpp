/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2016, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     TEncSearch.cpp
 \brief    encoder search class
 */

#include "TLibCommon/CommonDef.h"
#include "TLibCommon/TComRom.h"
#include "TLibCommon/TComMotionInfo.h"
#include "TEncSearch.h"
#include "TLibCommon/TComTU.h"
#include "TLibCommon/Debug.h"
#include <math.h>
#include <limits>
#include <fstream>
#include <iostream>
#include <algorithm>


// EMI: Parameters declaration

signed short MVX_HALF, MVX_QRTER, MVY_HALF, MVY_QRTER = 0;
float  C, H1, H2, V1, V2, U1, U2, U3, U4;
long int array_e[100000];

float IN[17] = {};
float X1[22] = {};
float X2[20] = {};
float OUT[49] = {};
int N, NN_out, index_ref, counter_i, PUHeight, PUWidth;

/*
The next group of variables are all 1D and 2D arrays. The reason why I declared them as std::array is because that
way they can be assigned in a cleaner manner. These arrays are assigned values in TEncSearch::init() function depending
on the chosen Quantization Parameter
https://stackoverflow.com/questions/16059781/2d-array-value-assign-after-declaration-in-c for more info on 2D array assignment
*/
std::array<std::array<float,4>,8> embs0, embs1;
std::array<std::array<float,17>,22> in_h1;
std::array<std::array<float,22>,20> h1_h2;
std::array<std::array<float,20>,49> h2_out;
std::array<float ,22> b1, BN_gamma_1, BN_beta_1;
std::array<float ,20> b2, BN_gamma_2, BN_beta_2;
std::array<float ,49> bout;
std::array<float ,9> BN_gamma_in, mean, stdev;

// Helper Functions

float relu(float x){
	if (x>0)	{	return x; }
	else { return 0; }
}

float sigmoid(float x){
  return (1 / (1 + std::exp(-x)));
}

//end of modification


//! \ingroup TLibEncoder
//! \{

static const TComMv s_acMvRefineH[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static const TComMv s_acMvRefineQ[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static Void offsetSubTUCBFs(TComTU &rTu, const ComponentID compID)
{
        TComDataCU *pcCU              = rTu.getCU();
  const UInt        uiTrDepth         = rTu.GetTransformDepthRel();
  const UInt        uiAbsPartIdx      = rTu.GetAbsPartIdxTU(compID);
  const UInt        partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

  //move the CBFs down a level and set the parent CBF

  UChar subTUCBF[2];
  UChar combinedSubTUCBF = 0;

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);

    subTUCBF[subTU]   = pcCU->getCbf(subTUAbsPartIdx, compID, uiTrDepth);
    combinedSubTUCBF |= subTUCBF[subTU];
  }

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);
    const UChar compositeCBF = (subTUCBF[subTU] << 1) | combinedSubTUCBF;

    pcCU->setCbfPartRange((compositeCBF << uiTrDepth), compID, subTUAbsPartIdx, partIdxesPerSubTU);
  }
}


TEncSearch::TEncSearch()
: m_puhQTTempTrIdx(NULL)
, m_pcQTTempTComYuv(NULL)
, m_pcEncCfg (NULL)
, m_pcTrQuant (NULL)
, m_pcRdCost (NULL)
, m_pcEntropyCoder (NULL)
, m_iSearchRange (0)
, m_bipredSearchRange (0)
, m_motionEstimationSearchMethod (MESEARCH_FULL)
, m_pppcRDSbacCoder (NULL)
, m_pcRDGoOnSbacCoder (NULL)
, m_pTempPel (NULL)
, m_isInitialized (false)
{
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    m_ppcQTTempCoeff[ch]                           = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]                        = NULL;
#endif
    m_puhQTTempCbf[ch]                             = NULL;
    m_phQTTempCrossComponentPredictionAlpha[ch]    = NULL;
    m_pSharedPredTransformSkip[ch]                 = NULL;
    m_pcQTTempTUCoeff[ch]                          = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = NULL;
#endif
    m_puhQTTempTransformSkipFlag[ch]               = NULL;
  }

  for (Int i=0; i<MAX_NUM_REF_LIST_ADAPT_SR; i++)
  {
    memset (m_aaiAdaptSR[i], 0, MAX_IDX_ADAPT_SR * sizeof (Int));
  }
  for (Int i=0; i<AMVP_MAX_NUM_CANDS+1; i++)
  {
    memset (m_auiMVPIdxCost[i], 0, (AMVP_MAX_NUM_CANDS+1) * sizeof (UInt) );
  }

  setWpScalingDistParam( NULL, -1, REF_PIC_LIST_X );
}


Void TEncSearch::destroy()
{
  assert (m_isInitialized);
  if ( m_pTempPel )
  {
    delete [] m_pTempPel;
    m_pTempPel = NULL;
  }

  if ( m_pcEncCfg )
  {
    const UInt uiNumLayersAllocated = m_pcEncCfg->getQuadtreeTULog2MaxSize()-m_pcEncCfg->getQuadtreeTULog2MinSize()+1;

    for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
    {
      for (UInt layer = 0; layer < uiNumLayersAllocated; layer++)
      {
        delete[] m_ppcQTTempCoeff[ch][layer];
#if ADAPTIVE_QP_SELECTION
        delete[] m_ppcQTTempArlCoeff[ch][layer];
#endif
      }
      delete[] m_ppcQTTempCoeff[ch];
      delete[] m_puhQTTempCbf[ch];
#if ADAPTIVE_QP_SELECTION
      delete[] m_ppcQTTempArlCoeff[ch];
#endif
    }

    for( UInt layer = 0; layer < uiNumLayersAllocated; layer++ )
    {
      m_pcQTTempTComYuv[layer].destroy();
    }
  }

  delete[] m_puhQTTempTrIdx;
  delete[] m_pcQTTempTComYuv;

  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    delete[] m_pSharedPredTransformSkip[ch];
    delete[] m_pcQTTempTUCoeff[ch];
#if ADAPTIVE_QP_SELECTION
    delete[] m_ppcQTTempTUArlCoeff[ch];
#endif
    delete[] m_phQTTempCrossComponentPredictionAlpha[ch];
    delete[] m_puhQTTempTransformSkipFlag[ch];
  }
  m_pcQTTempTransformSkipTComYuv.destroy();

  m_tmpYuvPred.destroy();
  m_isInitialized = false;
}

TEncSearch::~TEncSearch()
{
  if (m_isInitialized)
  {
    destroy();
  }
}




Void TEncSearch::init(TEncCfg*       pcEncCfg,
                      TComTrQuant*   pcTrQuant,
                      Int            iSearchRange,
                      Int            bipredSearchRange,
                      MESearchMethod motionEstimationSearchMethod,
                      const UInt     maxCUWidth,
                      const UInt     maxCUHeight,
                      const UInt     maxTotalCUDepth,
                      TEncEntropy*   pcEntropyCoder,
                      TComRdCost*    pcRdCost,
                      TEncSbac***    pppcRDSbacCoder,
                      TEncSbac*      pcRDGoOnSbacCoder
                      )
{
  assert (!m_isInitialized);
  m_pcEncCfg                     = pcEncCfg;
  m_pcTrQuant                    = pcTrQuant;
  m_iSearchRange                 = iSearchRange;
  m_bipredSearchRange            = bipredSearchRange;
  m_motionEstimationSearchMethod = motionEstimationSearchMethod;
  m_pcEntropyCoder               = pcEntropyCoder;
  m_pcRdCost                     = pcRdCost;

  m_pppcRDSbacCoder              = pppcRDSbacCoder;
  m_pcRDGoOnSbacCoder            = pcRDGoOnSbacCoder;
  
  for (UInt iDir = 0; iDir < MAX_NUM_REF_LIST_ADAPT_SR; iDir++)
  {
    for (UInt iRefIdx = 0; iRefIdx < MAX_IDX_ADAPT_SR; iRefIdx++)
    {
      m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange;
    }
  }

  // initialize motion cost
  for( Int iNum = 0; iNum < AMVP_MAX_NUM_CANDS+1; iNum++)
  {
    for( Int iIdx = 0; iIdx < AMVP_MAX_NUM_CANDS; iIdx++)
    {
      if (iIdx < iNum)
      {
        m_auiMVPIdxCost[iIdx][iNum] = xGetMvpIdxBits(iIdx, iNum);
      }
      else
      {
        m_auiMVPIdxCost[iIdx][iNum] = MAX_INT;
      }
    }
  }

  const ChromaFormat cform=pcEncCfg->getChromaFormatIdc();
  initTempBuff(cform);

  m_pTempPel = new Pel[maxCUWidth*maxCUHeight];

  const UInt uiNumLayersToAllocate = pcEncCfg->getQuadtreeTULog2MaxSize()-pcEncCfg->getQuadtreeTULog2MinSize()+1;
  const UInt uiNumPartitions = 1<<(maxTotalCUDepth<<1);
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    const UInt csx=::getComponentScaleX(ComponentID(ch), cform);
    const UInt csy=::getComponentScaleY(ComponentID(ch), cform);
    m_ppcQTTempCoeff[ch] = new TCoeff* [uiNumLayersToAllocate];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]  = new TCoeff*[uiNumLayersToAllocate];
#endif
    m_puhQTTempCbf[ch] = new UChar  [uiNumPartitions];

    for (UInt layer = 0; layer < uiNumLayersToAllocate; layer++)
    {
      m_ppcQTTempCoeff[ch][layer] = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy)];
#if ADAPTIVE_QP_SELECTION
      m_ppcQTTempArlCoeff[ch][layer]  = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy) ];
#endif
    }

    m_phQTTempCrossComponentPredictionAlpha[ch]    = new SChar  [uiNumPartitions];
    m_pSharedPredTransformSkip[ch]                 = new Pel   [MAX_CU_SIZE*MAX_CU_SIZE];
    m_pcQTTempTUCoeff[ch]                          = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#endif
    m_puhQTTempTransformSkipFlag[ch]               = new UChar [uiNumPartitions];
  }
  m_puhQTTempTrIdx   = new UChar  [uiNumPartitions];
  m_pcQTTempTComYuv  = new TComYuv[uiNumLayersToAllocate];
  for( UInt ui = 0; ui < uiNumLayersToAllocate; ++ui )
  {
    m_pcQTTempTComYuv[ui].create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  }
  m_pcQTTempTransformSkipTComYuv.create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  m_tmpYuvPred.create(MAX_CU_SIZE, MAX_CU_SIZE, pcEncCfg->getChromaFormatIdc());
  m_isInitialized = true;

  // EMI: Weights and Bias Initialization based on QP
  
  if(m_pcEncCfg->getQP() == 27){
    
    embs0 = {{
      {{-0.22579685,0.37087914,-0.36475608,-0.3759366}},
      {{0.005899623,0.0007738069,0.004559606,-0.019524919}},
      {{-0.003034366,-0.0007522093,-0.0037438963,0.001327705}},
      {{0.030020643,0.10396184,-0.08480464,-0.01764657}},
      {{-0.0056542847,0.0007028617,0.0048953514,0.022720478}},
      {{0.051458202,0.11751456,-0.08933365,-0.010590083}},
      {{0.02591021,0.005934756,0.006191248,0.044846732}},
      {{0.11294124,-0.014423225,-0.046134386,0.06067603}}
    }};

    embs1 = {{
      {{-0.31501395,0.34884545,0.33946195,-0.33367366}},
      {{-0.0021896516,-0.0013515691,0.01637554,-0.009368172}},
      {{0.0032338316,0.001166443,-0.0031741005,0.0027044665}},
      {{0.10256603,0.07192254,0.017187014,-0.14188431}},
      {{-0.010095494,0.001252212,-0.025346601,0.007659931}},
      {{0.011414239,0.066679515,-0.00038335662,-0.09267971}},
      {{-0.009668102,-0.025371956,-0.05147087,0.003167758}},
      {{0.024297599,-0.08455402,-0.08230939,-0.015351957}}
    }};

    in_h1 = {{
      {{-0.059698477,0.03163257,0.033778887,-0.0033815622,-0.03761247,0.04613399,-0.03383695,-0.03895188,-1.5904548,-0.8734548,-1.5289663,-1.7442336,-1.1158818,-2.4458823,-1.4295113,-0.50605005,-1.1028112}},
      {{0.031277966,-0.0053364323,0.00092750334,0.027071068,-0.009192003,-0.03111067,-0.03436998,-0.021719463,-1.0574352,1.3975251,-0.4594568,-4.777477,0.23498885,-1.0993859,-1.4922426,3.765909,0.1152864}},
      {{-0.35083014,-0.08268345,-0.21465118,0.16813092,0.04263848,0.22265299,-0.09137811,0.54050946,-0.32648355,-3.2700205,-0.10405341,2.7971532,0.87610537,0.96086746,0.015391618,-2.3169641,-0.16053136}},
      {{0.3914886,-0.06477659,-0.44944093,2.0935411,0.22093819,-0.40479413,-1.9135822,0.42373437,-0.047230337,0.09386772,0.4114793,-1.2348603,-1.6313934,-0.37851566,-0.16955711,7.7614555,0.3025144}},
      {{-0.0017960753,-0.009806501,-0.020154048,0.022726376,0.014152175,-0.00069762947,-0.01793345,0.023109214,0.12081964,-0.046933513,0.28661728,-6.1479197,0.03577732,3.1457136,-1.4360603,1.0083025,-0.056594845}},
      {{-0.0013728766,0.0037810332,0.00032788282,0.020784738,-0.0033429377,0.00036126634,-0.019158106,-0.001089381,0.012926649,0.92186373,-0.02189548,0.12290564,0.10508544,0.21134269,-0.10029336,-11.625169,-0.06527906}},
      {{0.109765545,-0.23007372,0.050720833,-0.644058,-0.041248355,-0.13380669,0.60291725,0.059974194,-0.13098828,0.14503786,-0.11506916,1.2856112,-5.673846,0.27256832,-0.33251604,1.2510425,0.0026004736}},
      {{-0.015277584,-0.004579446,0.023216974,-0.029556094,-0.024136795,0.029655643,0.028208131,-0.020557031,0.83712107,-1.7419015,-1.9275868,0.17889534,0.5303531,1.29918,-2.623799,-2.8685648,0.88725626}},
      {{-0.0033119654,0.006613438,-0.014180166,0.032237254,-0.036404833,0.024280068,-0.01340903,0.0036882455,-2.3493962,-0.9645668,1.025943,0.22304437,0.9287792,1.2226028,0.51367354,-1.5173951,-1.7425812}},
      {{-0.0021627229,-0.005470903,-0.008363347,0.007155103,0.0043993285,0.005171382,-0.009922784,-0.0029977877,0.27074876,-0.62570626,0.64006,4.7526636,0.10739735,-3.82877,-0.29325297,2.4983356,-0.16517545}},
      {{0.04332853,-0.03458633,-0.040624615,0.11730919,0.029995495,-0.050869167,-0.11071494,0.05104216,-0.5047801,1.5637335,0.18412974,2.8668919,-0.11835165,-1.9815228,-0.019863177,-12.102377,0.7186876}},
      {{-0.023845702,0.012646092,-0.015842583,0.059353407,0.0011792317,0.02091875,-0.044768672,0.027500989,-0.20885761,-0.7388391,1.7348778,0.39319718,-0.5866081,3.2736735,0.35034078,-0.8807731,1.1926564}},
      {{0.051039338,0.028991936,0.0865326,0.035914686,-0.006569314,-0.0372637,-0.04976376,-0.07558003,-1.7745452,1.228842,1.2112066,-2.2545047,-0.02569196,0.95034987,4.1915994,0.18880475,-1.0657877}},
      {{-0.2703106,0.06337222,0.09472765,-0.018769378,-0.15446493,0.18123819,-7.2029376e-05,0.15046364,0.118280716,1.1628456,0.17847064,0.6117479,-5.3524365,0.28655976,-0.8936226,-1.5325726,-0.21685207}},
      {{0.14770612,-0.015293621,0.15173703,0.25781482,-0.16139254,-0.29107034,-0.14026202,0.08105963,0.52995735,-1.2477587,-0.6169318,0.84888643,-2.5206788,-3.3231933,3.1574912,3.4636302,-0.040064942}},
      {{-2.1407106,-1.1544136,-0.39612368,-3.0282257,0.685005,1.2565261,3.2749057,1.0277393,1.0024991,-1.9054142,2.5752175,1.4686384,0.56010675,0.62669104,-0.049317457,-5.5274725,-0.09372077}},
      {{-1.0742384,-0.025283981,0.0817697,0.77279806,-0.11757536,0.82861686,-0.6905585,0.49534068,0.09224458,0.21953213,0.2954113,1.1718657,-5.800162,0.7080461,0.7820422,-1.8169082,0.14965734}},
      {{-0.21310897,-0.04101268,0.007850147,-0.42226663,0.03242774,0.18455069,0.40638041,0.07738289,-0.30709133,0.47020867,-0.49102697,-4.1438203,-0.10460214,-0.6884959,1.8044028,10.054509,1.411217}},
      {{0.0714968,-0.037916984,-0.01762149,0.06290628,0.011778244,-0.0859331,-0.064396255,-0.03962659,-0.16577817,-4.5988092,-0.12999833,1.114651,0.9814081,0.33838257,-0.18719974,2.5674207,-0.011799746}},
      {{-0.62963355,-0.044709362,-0.012939443,0.39524665,-0.115791306,0.46533167,-0.30835113,0.36418703,-0.5304803,1.097681,-0.2904667,-4.1222644,-1.7314935,-3.2396019,-1.0881026,3.7340987,-0.39193743}},
      {{-0.06441704,0.0043620425,-0.03929836,0.12713727,0.026085107,0.0054917084,-0.07678954,0.14124073,-0.13856319,1.1491005,-2.547486,1.3055223,0.45043048,-2.7193203,-1.3433676,-0.8392059,0.29254007}},
      {{-0.088836886,-0.042519882,-0.058564506,0.057657346,0.0733196,0.022019325,0.03046784,0.15743968,0.99209595,3.2925382,0.8374605,-0.91714007,-0.9415035,1.0459685,1.0667751,-2.3261242,-0.98359686}}
    }};

    h1_h2 = {{
      {{1.3366798,2.1473067,-1.1481482,-0.30269927,0.3420392,0.80527866,0.2112666,1.8949242,-2.2844713,-2.8122184,0.8661985,-0.31255254,-1.0619642,-0.090461716,-1.05661,-2.0720685,0.5246863,-3.0847893,-1.1544098,-0.1474719,0.15236789,-1.8697616}},
      {{-2.1901896,-2.302431,0.1504839,0.32583287,-2.0748978,-0.0015830481,0.188493,0.50171536,-0.35719928,0.65105104,0.07094403,0.97620314,-1.0490416,0.082095526,-0.25676703,-1.7772769,0.97369146,-0.6957963,1.1061985,-1.7912332,-0.6789646,0.052829426}},
      {{1.4292475,-4.04947,-0.54216367,0.60321015,-6.5800114,0.03307015,0.15888333,0.036740188,-1.0772588,0.82810694,0.85664904,-0.0885597,-1.0427722,-0.38632476,-3.1966262,-0.89435005,-0.16388509,0.05833078,-0.23316735,0.6308868,-0.32763696,-0.6546428}},
      {{-3.7409503,-2.023291,-0.7320157,1.5379808,-0.3050289,9.865936,0.19772063,-0.4992605,0.09300648,0.24949713,-1.3343432,0.22081698,0.05452996,0.3829643,-0.023354664,-0.19834031,0.080223635,-0.009985908,-1.1948742,0.21862575,-0.78492004,-0.35486785}},
      {{-4.941852,-0.032371283,-2.4123857,1.1229806,0.3409133,0.9438828,0.28545186,0.3352069,-1.2101693,-1.1221887,0.5436041,0.070201844,-4.8727636,0.52772087,0.8764483,-0.27922162,-0.2231253,-0.67704266,-2.5907764,0.7617089,-0.102621995,0.4333553}},
      {{1.0196422,-2.2234485,-1.2993236,1.2905678,0.16600458,6.579101,0.1499306,0.37718353,-0.61989886,-0.019184675,-4.183652,0.0765318,-1.5761912,-0.367667,-3.8944275,-0.20317666,-0.18617164,-0.43617085,-1.729553,1.3274533,-0.44235983,-0.21068577}},
      {{0.12249864,2.4859521,0.0043996,0.62282735,0.726192,0.8853546,2.2463632,0.11719111,-0.21742572,0.13253544,-0.47266862,0.018729934,-0.1298904,-0.33828568,0.14397837,-0.41424635,2.6429076,-0.99562067,-0.9512448,-2.7863052,0.7191035,0.07875241}},
      {{-1.6973517,-0.22245465,-0.034469496,0.40814024,-1.331163,-0.32290387,0.6421964,-0.032473046,0.4192619,-3.1738126,-1.5718875,1.5535986,0.11266616,-0.10745822,-0.08535494,-1.9790707,0.7199211,-1.2512087,-1.6678172,-1.2133677,0.3451544,0.64690804}},
      {{-7.4187913,-1.504429,0.24051164,1.4555514,-0.3219973,-0.11462258,1.4229542,-4.543266,0.028504934,-0.31256184,0.8677965,0.13550144,-0.10931782,-2.9148858,0.4031034,-0.61146116,1.0109465,-0.62000763,-0.5260379,-1.0529075,0.91828114,-0.33121377}},
      {{-0.2733114,-2.8915908,-1.2962065,-0.11256313,0.2387418,0.84019727,-0.05956053,0.09213473,-0.5026005,-0.48687991,2.174954,0.0019837436,-0.33705616,-3.3686607,0.15527247,-0.009809421,0.13191754,-1.3558306,-4.641077,0.66032314,-0.28392187,0.25353995}},
      {{-1.0597627,-5.297261,0.08871106,0.32049093,-3.4310224,0.12168595,0.005662153,-0.18561909,-0.392125,-1.9211403,-0.010761871,0.49755418,-1.2983141,-0.27819017,0.24327114,-1.3504597,0.33023408,-0.8784922,0.4480792,-0.80214053,-1.3524421,0.3239973}},
      {{0.8729989,-4.8211436,0.045451093,0.91140586,-1.9140657,-0.7268389,1.0842664,-0.6222629,-0.77018857,-0.29576942,-0.74468106,1.2986944,-0.7639014,-0.5427835,0.069635846,-0.79551625,1.9136698,-1.1062489,2.3857512,-2.5860746,-4.128765,0.11861352}},
      {{-4.250963,-0.38413683,-2.130754,0.75339085,-0.279094,1.1595733,0.23884611,-1.3589935,0.5314767,0.3807853,1.7264738,0.18956248,0.5979105,-0.1777919,-0.39825487,-0.5298624,0.67070943,-0.54985327,-3.9595833,-0.49177057,-0.2666661,-0.072639}},
      {{-1.078424,-8.84403,1.272497,-0.21376424,0.22763331,1.9224707,0.5792531,0.66965836,-0.18807235,0.15200174,-1.6454985,0.18452293,0.11634239,-2.8464239,-0.36180958,-0.44207907,0.35060242,-1.5280471,2.9758356,-0.2119336,-1.0976888,-0.46587676}},
      {{2.7126942,-0.26725814,-2.4321344,1.1222789,0.13618116,4.735732,0.5662359,-0.101486094,-0.66473687,-0.39278105,0.40423593,-0.013160507,-0.4316558,2.9514842,0.2854143,-0.24984045,0.3467927,-0.22046189,-3.687394,0.8282856,-0.3105543,1.1299065}},
      {{0.36283442,-0.48418066,-1.9370633,0.77974224,0.06220006,-0.5528945,1.2471946,-2.6805449,-2.1472816,-0.067481585,-0.3195946,0.00015366274,-0.25921282,1.9210199,0.1545362,-0.41796386,2.4977179,-0.18017869,0.66481197,-1.4899087,-1.9745895,-1.0513135}},
      {{0.9019863,-0.7083395,-0.5192162,2.4854283,0.033069883,1.783605,2.9949758,-0.005928655,-0.28991202,-0.1083596,-0.0048342277,-0.047012974,-0.3320257,-0.43701407,0.1356422,-0.26023102,0.9419895,-0.58234495,1.1826185,0.7554848,-0.23243071,0.0799166}},
      {{1.5012083,0.0945359,0.06753334,0.25609422,-2.4533508,0.2687232,0.30240068,-6.6145744,0.08103446,-0.15886372,-1.9544557,-0.057866372,0.06345046,-0.029731035,-0.09530341,-0.58359814,-0.049281918,-2.2188454,0.6306324,0.6917044,-2.8882575,1.3319223}},
      {{-1.676263,4.9864607,-0.09103233,-0.46256325,-0.07545503,2.3225074,0.08489619,-0.146074,4.364359,-4.033682,-0.38147447,-8.734857,-0.0604296,-1.4321567,-0.47753024,0.018162291,-0.01490355,-0.4472279,-2.056865,0.14509927,7.608703,-4.071613}},
      {{1.5354769,-3.8804698,-0.19447368,0.7877629,0.08742532,-0.09305229,-0.18438384,-0.6631061,-0.6160534,-7.7722507,-0.054210275,0.1954818,0.059482742,-0.42145258,-0.8270901,-0.3883751,-0.05927111,-0.14591458,0.86895454,0.4548475,-4.047224,-0.1881122}}
    }};

    h2_out = {{
      {{-4.3754787,-3.0871735,-1.0946872,-0.1349006,-5.822015,0.19726855,-0.58629215,0.038514066,1.7372693,-1.9417794,-0.95431465,-1.8684267,1.1115499,-3.3342261,-1.823946,-2.3305461,0.5587855,0.8035892,-8.352532,0.4934803}},
      {{-2.7777855,-0.790035,-0.52454454,0.24311325,-5.996696,-1.2697759,-1.1681135,0.6059274,1.352198,-2.6934688,-0.69266313,-0.94081503,1.0810248,-0.8525316,-4.286354,-2.8638277,-0.30072322,0.30209786,-4.8622093,1.4596145}},
      {{-1.5746207,-0.14803872,-1.4148245,0.61251485,-4.0801277,-0.81153286,-0.75746197,0.40478718,0.2769711,-4.3369546,0.87823945,0.021494374,0.43397528,0.64588344,-6.516792,-0.15447105,-0.8405064,-0.13723604,-4.8114243,0.7706249}},
      {{0.5789083,0.18157682,-0.6806873,-0.17476967,-0.20065878,0.28901148,0.78298724,0.092273235,-0.1345295,-6.748685,1.3698786,0.20596687,-2.4446278,0.3716843,-3.4180446,0.3257385,-0.49593493,-0.12999368,-4.2367334,-0.3599573}},
      {{1.3802799,0.90078944,0.5897143,-0.24130316,0.71011573,0.74319047,-0.59395695,-1.1779813,-0.17041326,-3.9010127,0.97766656,-0.23980564,-5.409696,1.0008984,-4.571392,-0.0640221,-1.1993456,-2.0468657,-4.677451,-1.3753972}},
      {{1.3683753,0.979889,1.6161462,-0.45893902,0.88756126,0.22127962,-0.3313138,-0.9875719,0.21143034,-1.6059042,-0.05301965,-3.4844882,-6.8892035,0.3623637,-2.0736163,-2.766263,-1.3201928,-2.9630904,-5.2333717,-1.0724683}},
      {{1.7494218,-0.19613442,0.7139465,-0.34390983,0.61611295,0.052066196,0.13931458,-0.68263197,-2.1009402,-0.54641503,-1.1956061,-9.484663,-4.525829,-0.006966217,-0.18749925,-1.5340109,-1.296483,-3.652229,-9.214475,-2.5191615}},
      {{-3.2952895,-4.785441,-0.9738761,0.5830421,-3.3587363,1.1580349,-1.9246461,0.3112702,0.2934775,-0.65697575,-3.2103193,-4.3336205,0.90599245,-3.5186386,-0.94017327,-1.7953256,0.51388997,0.50824136,-5.431935,0.40588415}},
      {{-3.2079263,-1.5887198,-1.1804119,0.5129129,-3.001205,0.77641094,-0.8116018,0.70192814,2.3895845,-2.0452218,-1.4340755,-1.8980246,1.1176455,-1.6505884,-2.075514,-2.4788618,0.23153485,-0.20302612,1.9244491,1.3369644}},
      {{-1.4864404,-0.41357356,-1.3607211,0.7676584,-2.1843536,1.266187,-1.3068833,0.44733763,1.0336195,-2.7586472,0.51274437,-0.16395916,0.6349129,-0.6683021,-3.98747,-0.7776352,-0.447453,-0.535677,-1.3350422,0.89494926}},
      {{0.6097202,0.19543007,-0.8977484,0.8264196,-0.22235224,1.0955954,0.7801765,0.067310326,0.03855273,-3.668241,1.1398635,0.20342806,-1.0771589,0.71726763,-5.21083,-0.091808386,-0.46122843,-0.25675347,1.7434754,-0.55834377}},
      {{0.4329028,0.92837656,1.0273724,0.71760726,0.24652138,0.89476186,-0.83385825,-1.5820729,1.2265805,-1.8319677,0.6664292,-0.41924393,-4.355511,-0.9368194,-2.5270321,-0.5603621,-0.63483745,-1.2436532,-1.3608822,-1.0911508}},
      {{0.31466016,0.7343589,1.8354177,0.33640233,0.4971883,0.19101022,0.2834938,-0.7076975,0.04599393,-0.7541127,-0.73854595,-6.3825846,-4.08938,-0.6743548,-0.6183369,-2.5444593,-0.5152035,-1.9426109,-1.2198713,-1.5652558}},
      {{0.83554804,-1.5794712,1.6778857,0.30218092,1.0747986,0.30020866,-1.5952612,-2.38812,-2.228855,-0.27683014,-3.1707602,-9.7727785,-2.6773055,-1.3353438,-0.06602113,-1.7994102,-0.49927047,-2.9693232,-6.5886784,-2.947288}},
      {{-1.7653029,-5.655635,-1.6666646,0.31764153,-1.6609266,1.0679144,-0.80043525,0.012014736,0.4258566,-0.2662676,-5.4608774,-9.672119,0.94837093,-0.31534526,-0.37126377,-0.15327296,0.3501039,0.3078396,-4.936254,0.68516773}},
      {{-1.6540637,-2.6786644,-1.3080626,0.23290235,-1.5242032,1.2897582,-1.6239362,0.49659267,1.3673203,-1.0598428,-2.50865,-4.01169,1.1078445,-0.52054936,-0.7834136,-1.217105,0.2742405,-0.68419504,0.34776694,1.7097098}},
      {{-0.8601527,-0.44185248,-1.910738,0.24423459,-0.9173711,1.2873636,-0.48184103,0.394247,0.6749954,-1.3346585,0.48495334,0.0065978942,0.8101004,-0.8074535,-0.6070541,-0.7121354,-0.21077341,-0.4554537,-0.04531413,0.8462389}},
      {{0.5503358,0.2543725,-0.7481519,0.64526004,0.04064148,0.6874624,0.7437614,0.06470732,-0.7844802,-2.0219648,1.1889173,0.20888695,0.2348492,-0.23915148,-0.744651,0.16023453,-0.1934266,-0.1910142,-0.055178907,-0.39025003}},
      {{0.35702747,0.8732783,0.7824879,0.643041,0.6880586,-0.21447824,-0.33716345,-1.2292587,-0.58249295,-1.2004855,0.58816814,-0.28165865,-0.549239,-0.54450744,-0.42469454,-0.6771878,-0.6233077,-0.8011053,0.16966775,-1.4635074}},
      {{0.18339868,0.5214707,1.8981457,0.22429438,0.35055506,-0.08179922,-0.6412924,-4.629044,-1.4474701,-0.6929996,-1.7885616,-6.9268336,-0.4221022,0.07401,0.051081683,-1.0139319,-0.4589152,-1.0700299,-1.7617419,-1.9555273}},
      {{0.40107113,-3.017404,1.8783699,0.15352938,1.0446858,-0.10122782,-0.9885381,-7.670027,-1.2543633,-0.39441177,-3.3089995,-7.8450975,-0.3848026,0.6279737,0.024411147,-0.3933328,0.2344901,-1.9544609,-6.451568,-3.8309498}},
      {{0.32488394,-4.1099567,-1.5241109,-0.0776115,0.47377694,0.29114342,-1.6542357,-2.7949066,-0.6615756,-0.28731838,-8.557645,-6.8666124,0.5081915,2.2399557,0.18527746,0.36349204,1.239638,-0.59367526,-5.398738,0.69899315}},
      {{0.089495555,-3.1443222,-2.6334589,-0.16314623,0.17975743,0.6859986,-2.0977273,0.07826167,1.1940749,-0.4519781,-3.8044457,-6.296631,0.30629382,1.2541894,0.18670237,0.36328343,0.6811413,-0.84752035,2.1455314,1.5571784}},
      {{0.03684653,-0.72713614,-2.3951762,-0.053210642,0.31094992,0.4317873,-1.5519708,0.36278263,-0.34900123,-0.3238462,0.003247752,-0.28979486,0.6250983,-0.41942206,0.18559366,0.3562907,0.84137076,-0.7698706,-1.349329,0.7887361}},
      {{0.11110455,0.22443031,-0.76607037,-0.008768224,0.34840268,-0.33961043,0.7302612,0.08849884,-1.232423,-0.3123606,1.201674,0.22422543,0.66826576,-1.668372,0.18205592,0.6281926,2.1352468,-0.36213592,4.0096097,-0.37367877}},
      {{0.024779506,0.4677021,0.83706903,0.29723245,0.51981294,-1.4088076,-0.878485,-2.6082318,-1.3146158,-0.41168126,0.4283516,-0.06421758,0.9328578,-0.4341426,0.17116338,0.2016405,0.6406017,-0.30206499,-0.50859296,-1.4304607}},
      {{0.14720233,0.056687348,1.5762129,0.16268681,0.127878,-1.4737095,-1.4101387,-9.485525,-1.8074111,-0.3751395,-2.5987146,-6.5767508,0.98027426,0.7011502,0.15103391,0.2873778,0.88969177,0.081172034,0.06882161,-2.9046452}},
      {{-0.23891447,-2.5989838,0.727657,-0.00014859693,0.1896083,-0.8113678,-1.9385895,-8.422196,-0.7620743,-0.0368185,-3.1382926,-5.4103236,0.9082458,1.5330377,0.16640861,0.33187422,1.3123014,-0.42285806,-6.487903,-4.5522027}},
      {{1.0271639,-4.845513,-1.8814031,-0.43573865,1.4575213,0.5094975,-1.125345,-4.798034,-1.8863853,0.41083482,-6.7466297,-8.044467,-0.25102484,1.518702,-0.18874508,-0.23708312,0.30578756,-2.37487,-5.457276,0.82139224}},
      {{0.36282232,-2.426831,-1.3454291,-0.9450539,1.1674583,0.48784336,-1.1899605,-0.6995004,1.811048,0.45773774,-3.142511,-6.161018,-0.497692,1.4996947,-0.2540961,-0.5684855,-0.2649799,-2.2739315,0.6773892,1.7188487}},
      {{0.4373303,-0.3184302,-1.4959695,-1.1683226,1.0531392,0.10561705,-0.6795914,0.26569018,-0.27556822,0.2514499,0.24173029,-0.28635392,0.34265926,0.8196665,-0.21823329,-0.6595397,-0.37163663,-1.4721845,0.8676526,0.57463384}},
      {{0.37837103,0.25922972,-0.12222703,-1.0093615,0.33954388,-1.5299301,0.6827003,0.051953234,-0.6160864,0.3034747,1.1698848,0.2117921,0.7658733,-1.2305791,-0.24715957,0.18369797,0.23083964,-0.29525352,0.39797705,0.07032271}},
      {{-0.63116795,0.14806876,0.8637881,-0.26955003,-0.14994766,-2.604273,-0.37846527,-0.7664623,-0.1340042,0.28085232,0.24849746,0.19617175,1.1259757,0.24963778,-0.1790811,-0.42931476,-0.62070984,0.2645184,0.9654837,-1.0698277}},
      {{-0.94616544,-0.39796466,1.345015,-0.1417562,-0.6878889,-2.0048268,-0.68147784,-5.108819,-1.5423696,0.30660072,-2.1354022,-5.2603354,1.6871704,0.48820028,-0.5407998,-0.7993608,-0.46021706,0.91880435,-1.4567819,-1.8372781}},
      {{-1.8458744,-3.5156631,1.2067583,0.017368361,-1.046842,-1.2934445,-1.268782,-7.9438047,-1.9713948,0.48793468,-3.6345763,-7.2237124,1.5433202,0.23395135,-0.21642672,-0.28606522,0.3788235,1.1421237,-5.4189634,-2.4519765}},
      {{1.2865765,-2.1591039,-0.96915597,-1.181629,1.8158746,0.1305694,-1.791506,-3.0630474,-1.6939908,0.46719256,-4.825982,-7.7316866,-0.45364654,0.31580785,-0.5985358,-0.9285385,-0.51468533,-3.0823884,-5.8861933,0.31829122}},
      {{0.6605483,-0.5046314,-1.556311,-1.7132679,1.6576909,0.07745785,-0.3124206,-0.3293121,0.41124016,0.4902506,-1.9044467,-5.33445,-1.0492806,1.5261428,-1.2691355,-2.274871,-0.43429893,-2.4892323,-0.9837063,1.1690522}},
      {{0.5253149,-0.5534735,-1.1151137,-2.0488775,1.6473168,-0.675851,-1.5323702,-0.16983354,0.3376483,0.5464755,0.16242515,-0.14511797,-0.5070888,1.0306613,-2.9794545,-0.8645699,-0.62845653,-1.7195079,-2.282905,0.69286174}},
      {{0.5312602,0.2047493,-0.09876918,-2.566573,0.40743455,-2.3795433,0.7023673,0.006872385,-0.18120933,0.38917702,1.179176,0.22454481,0.57804096,-0.9904704,-7.4739685,0.14259349,0.25818938,-0.25093013,-0.29356655,0.14235024}},
      {{-1.0818316,-0.21873379,0.6169928,-1.7492563,-0.48044854,-3.2886112,-0.66886103,-0.6921084,-0.1349892,0.4174177,0.4031118,0.16060482,1.2705708,0.46663156,-3.7200065,-1.0197401,-0.8187394,0.83125937,-2.3845623,-0.7847859}},
      {{-1.9473785,-1.0366132,1.1522604,-0.57540447,-1.0418986,-3.2065594,0.6196387,-0.93234146,-0.1806071,0.21778314,-1.7641262,-2.5212111,1.5488348,0.89377403,-1.87739,-2.8018126,-0.74073726,1.4349816,-0.79879165,-1.4335002}},
      {{-2.8510785,-3.735619,0.99052894,-0.32280526,-1.3963677,-1.6032387,-1.9725044,-1.512405,-0.376211,0.418998,-2.895266,-5.2568264,1.4530804,-1.030533,-0.79715526,-1.1204774,-0.36253172,1.6266146,-5.636225,-1.7021633}},
      {{2.0799024,-0.68707573,-1.3378009,-1.4420806,1.1354638,-0.11250993,0.06347486,-1.2180578,-1.0817075,0.20744392,-2.359603,-6.0055532,-1.9840908,1.9353008,-0.48659077,-0.8764283,-1.656648,-4.115076,-8.5846615,-0.35391295}},
      {{1.5826861,-0.26606327,-0.67884856,-2.2624786,1.7480823,-0.20603903,-0.8725569,0.13645552,-0.3643509,0.09524712,-0.95279264,-3.3099892,-3.6097791,1.9949579,-1.8274957,-2.2291434,-1.242309,-3.420556,-5.1572237,1.1604772}},
      {{1.3376217,-0.107751325,-0.8779232,-3.3502617,1.6441836,-1.1437259,-1.2029091,0.04891629,-0.059691314,0.12382601,0.5158118,-0.15872754,-2.5700583,1.3465583,-5.144521,-0.117266975,-0.7934806,-2.4086292,-4.6392565,0.6365037}},
      {{0.6494704,0.1389994,-0.35719192,-2.7693806,0.075989775,-3.0689025,0.72430104,0.031572204,0.2350551,-0.3663019,1.2989384,0.25664905,-0.68700606,-0.2693294,-5.950737,0.42968222,-0.22374292,-0.16175042,-3.8113575,-0.02121402}},
      {{-1.8655165,-8.222134e-05,0.45667422,-2.7801764,-2.375025,-3.846032,0.08412461,0.025925398,-0.39236492,-0.1179872,0.866943,0.23734365,0.74934214,0.36029726,-7.6014194,-0.18364842,-0.76764446,1.0295315,-4.4882946,-0.4783297}},
      {{-3.0659237,-1.0478464,1.1082239,-1.1547533,-3.230023,-4.1426134,-0.3351034,-0.1766851,0.5829029,-0.4717376,-0.6782563,-0.8232878,0.93485856,0.4160418,-3.144381,-2.2145698,-1.069367,1.7342479,-5.2277713,-0.7451861}},
      {{-3.9708443,-3.4406247,0.5941005,-0.5225445,-2.9259667,-2.2338877,0.34550098,-0.4331516,1.0476178,-0.34840772,-1.1462964,-2.2123926,0.96223706,-0.12323363,-1.4982947,-2.1174521,-0.7926986,1.6230855,-8.715379,-1.5033095}}
    }};

    b1 = {
	    -0.63413405, -0.17731118, 0.025438694, 0.29573512, -0.010788428, -0.021896422, -0.07537085, -0.11001833, -0.33067816, -0.00029446644, 0.07732811, 0.28313714, 0.064134434, -0.08234277, -0.0751523, -0.095550984, 0.12904549, 0.26539752, -0.21452652, -0.15988149, -0.18337585, 0.2690503
    };

    b2 = {
	    -0.038151696, 0.20478237, -0.115766145, 0.19101532, 0.18376683, -0.13896869, -0.0016504632, 0.2441459, -0.07775698, -0.09787881, -0.05843331, -0.0811103, 0.13462877, 0.0043533593, -0.07126894, -0.14502244, 0.7673002, -0.03411942, -0.5045972, -0.041862395
    };

    bout = {
    	-3.093108, -2.584057, -2.1450324, -1.0913042, -2.1973906, -2.7982814, -3.6204262, -2.8959327, -0.6381555, -1.2296265, 0.19600865, -1.2585409, -1.045657, -3.3299713, -2.1744044, -0.85574234, 0.23640694, 0.8329267, 0.19200066, -1.2172902, -2.499868, -1.1730568, 0.30147097, 0.7852892, 3.8625524, 0.9800942, 0.012016173, -1.42775, -2.5095253, -1.0883512, 0.052974634, 0.9461875, 0.2842241, -1.216847, -2.3682027, -3.2555585, -1.1949967, -1.5585074, -0.09594824, -1.5256705, -0.9961622, -2.933468, -3.601505, -2.839812, -2.3212447, -1.1569328, -2.1994855, -2.5503948, -3.174397
    };

    BN_gamma_in = {
	    0.98440933, 0.64243037, 0.66649544, 0.1259445, 0.5134397, 0.24218386, 0.2894593, 0.07677251, 0.9291135
    };

    BN_gamma_1 = {
	    -8.822952, 6.139186, 2.0733836, 1.5007641, 6.5188336, -7.7943463, 2.736275, 4.178584, 3.8761666, 7.905259, 3.5031354, 4.2722526, 1.9270445, 5.1721272, 5.4048934, 2.245453, 2.1021104, 2.7449918, 3.833869, 1.6778785, 3.5360177, 2.2140915
    };

    BN_gamma_2 = {
    	3.7039633, 1.4577787, 2.4865587, 2.2312248, 1.4769112, 2.136651, 1.8724821, 0.6483817, 3.1480954, 2.2247677, 3.4059236, 0.8040822, 1.3161602, 1.7794256, 0.88763535, 3.0028057, 1.2502271, 2.9445739, 6.9290676, 2.3545578
    };

    BN_beta_1 = {
      0.015698837, -0.015822815, -0.41040236, -0.36074567, -0.030406293, 0.029526776, -0.1397727, -0.023755137, -0.10272656, -0.013812793, -0.19346444, -0.06193311, -0.1578722, -0.012416575, -0.0076187165, -0.002861566, -0.28929535, -0.33957785, -0.06788221, -0.14537738, -0.08880826, -7.3078318e-06
    };

    BN_beta_2 = {
	    -0.12642598, -0.26399237, -0.12535955, -0.44561127, -0.27127737, -0.055896644, -0.13388884, -0.1285429, -0.03801396, -0.08170246, -0.058202002, -0.034074474, -0.12193836, -0.13203906, -0.061714124, -0.07448967, -0.9401322, -0.2385494, -0.10266154, -0.13578667
    };
    
    mean = {
      29413.86215673105,14444.318278456156,29459.63732133561,20027.833619340214,1627.4898399674162,19968.25107178404,29337.181316854447,14227.719285639147,29199.16346520579
    };

    stdev = {
      256530.43446733567,159913.93525268522,254235.72859848003,172449.89124960327,31779.256630701733,171936.16973749298,254689.66251499098,159851.3677639325,256163.06806407517
    };
  }

  else if(m_pcEncCfg->getQP() == 32){
    
    embs0 = {{
      {{0.39371553,0.30992392,-0.12682,-0.06690508}},
      {{0.0049153366,-0.0022002147,-0.0018410255,-0.02503133}},
      {{-0.002731018,0.0017022903,9.39613e-06,0.0018852518}},
      {{0.18860547,0.37618592,-0.15264468,-0.11002508}},
      {{-0.011217669,-0.0036274258,0.007853744,0.03371015}},
      {{0.19485062,0.27180293,-0.053971045,-0.06597314}},
      {{0.05005251,0.0008866917,-0.021797808,0.06467195}},
      {{0.13324834,0.031375065,0.21450981,0.13844115}}
    }};

    embs1 = {{
      {{0.33710966,0.25165662,-0.24877429,0.32685015}},
      {{0.0019764344,0.023588404,0.0027816817,0.00075746654}},
      {{-0.0004889872,-0.0025502974,-0.002014502,-5.694545e-05}},
      {{-0.0044377656,0.044454124,4.5385335e-05,0.47767398}},
      {{-0.008570834,-0.038477883,-0.0062741456,-0.0034641696}},
      {{-0.021635747,0.038518954,-0.025281219,0.39785665}},
      {{0.027964458,-0.063295186,0.05192977,-0.0031375561}},
      {{-0.19433993,-0.1378725,0.15940286,-0.019092659}}
    }};

    in_h1 = {{
      {{0.027590476,0.0132346405,-0.07736504,0.16172357,0.062917694,-0.13327757,0.06430237,-0.008281257,-0.15347981,0.4287921,0.20602478,1.1245939,0.31353018,0.56987315,-2.1061518,-5.3482704,0.77467424}},
      {{0.079532236,-0.041292954,-0.07999515,0.06464332,0.028672675,0.016128482,0.031446997,0.059263308,0.8380832,-0.8829329,0.44793037,2.4062812,-0.5782996,1.0709116,0.69346434,-1.9386554,1.1450615}},
      {{-0.11838462,0.062406033,-0.0701064,0.03420964,0.054369185,-0.0850073,-0.044227287,-0.019834999,0.26779875,0.16509338,-0.63017225,-2.2428567,-3.5136702,-3.0610547,-1.1765715,0.33388838,-1.3488481}},
      {{-0.05920804,-0.074327424,0.04349369,-0.24225996,-0.04811471,0.24755523,-0.08536578,-0.1428517,0.96950775,0.2779643,-0.56126297,-1.8287024,1.0063863,0.8156167,-1.9364742,2.6172056,1.0931575}},
      {{-0.0006733242,0.003849412,-0.06601437,0.12630449,0.047276556,-0.09606393,0.005690302,-0.026778566,-0.15130952,0.27266395,-0.022880854,0.581795,0.9986647,-3.8138976,-0.045876298,0.9842593,-2.2158937}},
      {{-0.0010616088,0.00037156482,0.0013085315,0.004918647,-0.0005369437,-0.0037710639,-0.00079220085,-0.00222834,-0.8816876,0.49343115,-1.0382524,-1.9432554,1.701009,-0.35011208,-1.5472625,0.88747025,-0.9943933}},
      {{-0.039674375,0.03031085,-0.006586265,-0.07883261,-0.014628594,0.09364573,-0.04274815,0.22407608,-0.39548573,-1.3265442,2.3393059,0.65925,0.67107874,-1.5282484,-0.5449766,3.1515944,-2.9815507}},
      {{0.026074318,0.029092506,-0.01945236,0.11554605,0.015647667,-0.10211745,0.04596544,0.005718236,0.79680496,-1.6957138,-0.30024314,-0.831079,-0.090895675,1.4241904,-0.11725617,5.6913004,-3.0127413}},
      {{-0.014483753,-0.0055549834,-0.0019218081,-0.083357975,-0.0003975183,0.041304357,-0.039174505,0.041420937,0.5098039,-2.2683327,-0.8655112,0.7906491,0.2937863,-0.52962726,0.43328282,6.1073804,0.5422783}},
      {{-0.0111104725,0.0075571993,0.011824241,-0.011565122,-0.009722306,0.007762806,-0.015518417,0.0015916975,0.13812421,1.640831,-0.07054081,-0.21909519,0.3892315,0.10985175,0.2091212,-7.938674,-0.46175432}},
      {{0.0049360963,-0.009195759,-0.009743255,0.027683275,0.010079999,-0.022874838,0.007265889,-0.034008086,-0.25748712,-4.3962507,-0.19788104,0.39340517,1.7286772,0.33911708,-0.20549467,0.20235313,-1.129155}},
      {{0.22542275,-0.03157022,0.048280846,0.27371007,-0.02832136,-0.2355231,0.23136432,-0.014958532,1.2151697,3.0746834,-0.41120723,-1.2118294,-1.4439766,0.51389986,0.5452293,0.4723688,0.85023654}},
      {{-2.282946,-0.29797506,-0.17484367,-4.581853,0.21683827,4.3640122,-2.6270323,-0.49536687,0.7854396,0.42226362,0.49648842,-0.74630105,4.173735,0.8879905,-0.12801038,2.1422927,0.73450136}},
      {{0.05368281,-0.030386895,-0.00093018677,0.0053648097,-0.014822948,0.008407528,0.06359777,-0.0050887815,-2.6379747,-1.0453436,-1.1075901,0.36111584,0.4920966,2.1531465,0.70228076,-1.4485129,-0.4797132}},
      {{-0.013026872,0.012410348,0.006141189,-0.0068910937,-0.011254753,-0.009467919,-0.0030911663,-0.008932446,-0.63626844,0.8111363,-0.47167954,2.8016002,-0.31939057,-1.9671768,0.18971977,-0.7963832,0.7323565}},
      {{-0.3601372,-0.16796862,0.13044724,0.08494624,-0.18679933,-0.15915701,-0.2855487,0.03829398,0.7862195,0.7859955,0.18754606,-0.2078767,-5.1427774,-0.5358521,0.26881433,2.4305952,3.2954805}},
      {{0.036637664,0.02271182,0.076422825,0.001941879,-0.05651234,0.00396911,0.039913412,0.0062012435,-3.345816,1.3588396,-0.36980587,-0.5921612,0.22524814,0.98623127,-0.044372335,1.5299966,-0.7820253}},
      {{-0.0025128126,-1.1264643e-05,-0.0008281107,-0.003133358,0.0009369066,0.00255265,-0.002515967,0.0007454661,1.0795605,0.3801206,-2.1711392,0.35931095,-0.13111801,1.4821911,-1.3513339,0.006215032,5.038265}},
      {{-0.13090399,0.11071604,-0.058897395,-0.10652947,-0.014600118,0.056124058,-0.12863438,0.4317426,0.047150273,0.6320397,1.0930033,-1.4234188,0.37048456,2.8660324,-0.56099594,-2.5438435,-0.94896704}},
      {{-0.3724585,-0.009346912,-0.4430932,0.9375519,0.5081802,-0.8641001,-0.33669728,-0.2685146,-0.2544275,0.24682069,0.80558336,0.10866434,-5.4752293,-0.5055169,0.15623963,0.8944716,-1.5643713}},
      {{-0.38251248,-0.11927843,-0.14948326,-0.9732829,0.038263865,0.79827887,-0.25193608,-0.16040292,-0.026402118,0.21869817,-0.17252304,0.105718866,-6.9959974,0.70425147,-0.18500309,0.8774508,-0.78063923}},
      {{-0.11287931,-0.04158819,0.00674634,-0.27850047,0.011064987,0.17775284,-0.1826226,-0.028967768,-1.6262553,1.1199157,0.11739173,-2.0926762,1.2144841,0.77458304,1.3120619,0.40025234,-2.9010777}}
    }};

    h1_h2 = {{
      {{-0.33025387,0.20552967,-3.421573,-1.6355089,-0.5265192,-4.7509937,0.9456904,-2.347744,0.7239074,0.561968,0.68900913,0.44128838,-0.23175742,-3.6161697,-0.37916484,-0.13654278,-4.5766406,0.12836304,-1.0741451,-0.3504656,-0.16415572,-0.86828053}},
      {{-0.061643455,0.6664652,-1.7208964,-0.025029996,-1.3570687,-7.0931296,-1.4079479,1.7267708,-0.7702937,0.08854216,0.62003785,0.1312058,-0.21238288,-1.2178907,-1.4267911,-0.36415896,-0.28302336,-0.075437486,0.44100878,-0.20345497,-0.372091,0.3013957}},
      {{1.2583071,-0.10413156,1.6366613,-0.18151157,0.4558647,9.766517,-0.49472156,-1.4493788,-0.3340917,1.0148251,0.59049624,-0.85248226,-0.51754445,0.4322035,-0.12665868,1.5047429,0.958763,-0.21543807,-0.20036156,-0.14564024,-0.00423347,-0.22196296}},
      {{0.22785166,0.108786665,0.16186094,-0.015029995,-0.92699647,-1.2408389,-0.6385838,0.2603124,-2.4234326,-0.555762,1.2228656,0.08771358,-0.24290806,0.13654885,-4.1702814,-0.23566742,-0.54733866,-0.2316665,0.19364887,-0.30161923,-0.24122542,0.69616127}},
      {{0.6117924,-0.0030547963,0.7463459,0.26383814,-0.3256632,-6.212795,-0.7824335,-1.42897,-1.8593112,-0.030228212,-4.5283694,0.8180258,-0.3448833,-0.63310665,1.1022315,-0.38583624,-0.34590867,0.011394481,0.5562507,0.07368148,0.0015258432,-0.18408802}},
      {{-0.7589685,-0.3547194,-0.10835199,-0.2876175,0.071539015,6.061057,-0.72561187,0.83590704,-0.27832368,-0.122494176,-1.1842873,-0.15005413,0.051853314,-0.4006582,0.35505602,-0.24636506,-0.49604794,0.13584448,0.30172113,2.009029,2.12205,-0.19866593}},
      {{2.4519572,0.45333847,2.451773,-0.025379784,-1.2446853,15.765891,0.4623597,-0.5872551,0.47083393,-0.47356054,-0.51291126,0.36930504,-0.2056867,-0.42729864,-0.35593683,-0.19895098,-0.18013956,0.06980486,-0.2369066,0.18741944,0.3693921,-0.3139021}},
      {{1.0860313,0.27283245,-0.467366,0.29325676,-0.1884111,-5.4203897,-1.3060007,-1.4964274,1.1264595,-1.6555109,-0.2984495,1.0535549,-2.2937398,-1.1293323,-0.6158897,1.0464779,0.55762845,-0.063844725,0.54282594,0.0651159,0.17481416,-1.7164347}},
      {{-1.7178164,-0.46530482,-0.27128777,-0.14154159,0.27759892,-7.1508713,-0.6567227,-0.39322028,0.2483083,-2.8853047,-1.8807532,2.5364506,-0.23834832,-0.3443406,0.07269343,0.35751927,-0.60439533,0.03460739,0.80392015,0.44910794,0.34703034,-0.86404175}},
      {{0.64653784,-1.3650596,0.186417,0.26567426,-0.21872157,-9.101551,-0.29466057,0.56253874,-0.3026101,-0.24986856,-0.8005738,0.29401127,-0.26216894,-2.4225264,-5.16671,-0.26093954,-0.15606989,-0.005740639,0.13104066,-0.024678577,0.12746096,0.5182544}},
      {{-0.5483858,0.2627379,-0.2964825,-1.4000711,-0.38779745,-1.7915606,0.1684299,0.03614654,-1.8353529,2.0690114,5.508461,-1.1505494,-1.7186267,-0.9799774,-1.9062638,-0.51706624,-3.8109484,0.57863605,-2.6913204,-0.5089438,0.079654604,-0.34303245}},
      {{-0.58039784,2.7058578,0.08246934,-1.1741819,-2.9725335,-5.640031,0.05126281,0.03055201,-0.39001238,0.35035843,0.073404655,0.39642245,-0.28033182,0.040597577,-1.3498945,-0.060127817,-0.9188748,-0.058441587,-0.5841264,0.16860968,-0.112975575,-0.74133044}},
      {{1.3657212,0.2375315,-2.510199,-0.6247684,0.5979028,-0.40804008,0.03164306,0.68927443,-0.5368664,0.58742094,1.8801111,-0.7084529,-0.30858096,0.13958906,-0.1793759,1.0176299,1.8225808,-3.0435317,-0.88767385,-0.07457644,0.51060754,-0.9223488}},
      {{-0.9557425,0.50460905,0.70691985,-1.8198538,-1.103444,-8.493174,-1.4004333,1.1208173,-0.9902634,-0.6488099,0.9777566,-0.29161465,-1.7782038,-0.17295028,0.6547156,0.9416317,0.8115638,-0.0033732776,1.229819,0.9867463,1.933477,-2.2215521}},
      {{0.13324386,0.0879572,-0.08369631,-0.54000455,0.13928753,3.341026,0.18573394,0.48239022,-0.30763906,0.25762326,0.026515998,-0.6571992,-0.035042245,-0.04143813,0.10128834,-0.18600199,0.34419924,-15.099125,-0.17684008,0.07080337,0.17309858,0.107756704}},
      {{-0.04527184,-0.30833414,-0.81813526,-1.0907258,-0.9129162,-7.7556963,1.4218085,1.3718557,-1.4545985,-0.5162667,-0.8928237,0.31512702,-0.27976698,0.54114133,0.9474232,-0.0836892,0.253165,-3.8035944,-0.4317794,0.5535779,0.6674524,-0.057231158}},
      {{-1.740317,-0.5882293,-3.401083,-0.10607002,-1.4514952,2.3793786,0.23587146,1.4450994,0.35939047,0.5623428,-0.39023772,-0.51850045,-0.2886709,0.83652496,0.1841097,-1.0180383,-8.079909,0.4265998,0.3246348,-0.15697095,0.40167865,-1.2367896}},
      {{-1.0339758,1.0830736,-0.47309434,-2.3002994,-1.9380342,-3.1179926,-1.394368,-0.20553976,-2.683722,0.14998536,-1.9972652,0.7826623,-0.5352005,0.80324644,-1.657345,-0.43787995,-0.65385336,-0.57012594,0.42137888,-0.20796123,-0.080211416,1.1813099}},
      {{-0.84239376,0.3107443,-0.28265697,-0.32583013,-0.012328537,-4.215473,0.482133,1.4439347,-0.38871545,-7.1384654,-3.3500242,0.5490217,-0.25168365,-0.13415915,0.08715309,-0.33538806,-0.44030637,-0.16074531,-0.43801397,0.07510669,-0.0023575018,-0.029932283}},
      {{-0.08308267,-0.057954475,-0.19780524,0.05172868,0.10931126,2.7262676,-0.6577385,0.2774598,0.18885392,-0.7260866,11.065731,-1.3926381,-0.5799344,-0.03201101,-0.37352958,-0.08536503,0.8825062,-0.14811227,-0.10287839,-0.10413111,0.23933108,-0.11924575}}
    }};

    h2_out = {{
      {{-1.4272655,-0.6940853,-4.8021765,0.2625723,-0.89226115,0.58309036,-1.602951,-5.7985516,-2.582605,-0.2624874,1.3817238,0.9689448,-0.16524911,-4.887285,2.4481583,0.5349153,-2.7862217,0.1337298,0.028389143,-3.6891403}},
      {{-0.6577078,-0.71787024,-2.7206528,0.98551947,-1.5022647,0.3417132,-1.5473343,-6.2971573,-5.598903,-1.0681102,1.5759214,0.26631176,-0.15645632,-3.404717,2.3763773,0.542587,-0.6114225,0.61910164,0.08489757,-2.9481096}},
      {{-1.2599453,-0.021126365,-1.8537465,0.13951795,-3.277974,-0.19865358,-0.83120954,-3.7359598,-6.6766095,-1.0405548,1.1279918,-0.35431716,0.17470205,-0.28873798,2.1353922,0.051133335,1.2672006,0.18097658,0.325113,-3.4329221}},
      {{-0.5227549,-0.02864772,-1.1005406,-0.6115463,-6.876724,0.9030452,0.3047044,0.21916671,-6.376264,-0.23370501,-0.74845934,-0.45715052,-0.07201998,0.72262245,0.8503344,-0.6793985,0.32695043,-0.24133164,-0.030634135,-5.670604}},
      {{0.38754466,-0.2270504,-1.8465053,-0.15272602,-3.0756257,-0.4383824,0.4194224,0.21076524,-3.0267627,-0.40962055,1.4478221,-0.26770708,-0.48780847,-0.29407227,0.05990814,-3.9276228,1.6246752,-2.7522154,-0.27006862,-3.5516868}},
      {{0.9014624,-1.0986334,-2.8516955,1.2199688,-1.3495129,-0.71022934,0.5638304,0.31494004,-1.4982798,-0.5447144,1.4977545,1.1560246,-0.65365523,-3.4505029,-0.57512754,-5.590089,1.7299104,-4.5543447,-0.3244584,-3.2561033}},
      {{-0.39906964,-1.3626359,-5.714026,0.38376406,-0.49046716,-0.45162672,0.7738746,0.27121124,-0.8406792,0.3952042,0.108097896,2.761558,-0.5278505,-4.5887146,-0.94122857,-6.730519,1.048903,-4.585824,-0.1349552,-3.2023077}},
      {{-2.36131,-0.80192584,-2.9803069,-0.0756539,-0.8444377,-0.11160214,-2.6169643,-4.319335,-1.1386687,1.2977617,2.0721684,2.9593558,-0.6635144,-5.0595446,1.8809985,0.60453814,-3.5929472,0.25685233,0.7367167,-1.3297827}},
      {{-1.8480306,0.6379412,1.0831146,0.020332688,-1.8711987,0.14353317,-0.58320665,-3.473419,-2.50238,-0.104534954,1.25897,1.0863217,-0.9826745,-5.5508356,1.7246991,0.40366843,-1.4906927,0.82290626,0.7112594,-0.42842335}},
      {{-1.29615,0.63602096,0.92387855,-0.10337911,-2.4430017,-0.38203785,-0.8639729,-2.6296117,-2.9702039,-0.38739672,0.793786,-0.097347595,-0.12558284,-1.1643143,1.2625414,-0.09277076,0.58588254,0.48229325,1.1330276,-1.3789585}},
      {{-0.62617445,0.16332707,0.71066815,-0.61499083,-4.2931395,-0.11959843,0.35459054,-0.015806666,-2.8283615,-0.30552232,-0.3090774,-0.4259258,0.07533038,0.7519026,0.36166894,-0.25795835,1.0605828,-0.662277,0.7664583,-0.061592862}},
      {{0.69187313,-0.68133795,0.031791966,-0.21627031,-1.971324,-0.7933627,0.47683096,-0.29133663,-0.9417083,-0.2013486,1.1795653,0.22110917,-0.333469,-1.196119,0.1719698,-2.6309018,1.3323941,-1.9016272,0.9097291,-1.394055}},
      {{0.9802289,-1.826851,0.029557351,0.7721126,-0.66160196,-0.9776839,0.3327975,0.04628493,-0.160087,0.16922686,0.7413884,2.2164574,-0.0207781,-4.6914964,-0.019017933,-3.8910851,1.4409336,-3.6756084,0.60712427,-0.8280501}},
      {{-0.1565256,-2.2119856,-3.7236993,-0.3470856,0.20845754,-1.001413,0.13563307,-0.04872033,0.2375751,1.189455,0.056732375,4.278734,-0.23525903,-4.602652,-0.46745542,-5.5468245,1.0607957,-3.8026123,0.7300192,-0.85653865}},
      {{-1.3304092,-1.3660164,0.017813886,0.08474336,-1.2439998,-0.69238436,-3.9815793,-2.12778,-0.06880237,2.5086074,2.3593125,3.160566,-0.85730153,-4.4844246,0.3081071,0.35494864,-3.2392378,0.5268147,0.4116896,-0.76385957}},
      {{-2.1471443,0.8953242,1.0098727,0.17784317,-1.2227165,-0.34693828,-1.3439531,-2.3272955,-0.30259636,0.7387501,0.13889953,2.4027815,-0.9250418,-5.7139606,0.73015946,0.22174552,-0.7613201,0.8750231,0.5734332,0.98907775}},
      {{-1.8542395,0.6069686,0.80328435,-0.3129642,-1.4090916,-0.24130836,-0.54523987,-1.460107,0.051230047,-0.112518236,0.17389975,-0.21456964,-0.15723918,-0.70543146,-0.28068313,0.3678112,0.16400157,0.48682666,0.4944364,-0.14680547}},
      {{-0.5885368,0.08008948,0.5854609,-0.64059293,-1.9088295,0.20943208,0.42867,0.019949106,0.00077154045,-0.39501286,-0.11782551,-0.43388247,-7.494798e-05,0.7179028,-0.1932157,0.053932656,0.16926652,-0.38404354,0.6693203,-1.737253}},
      {{0.5814523,-1.0454018,0.68184066,-0.22488278,-0.8562897,-0.71949434,0.58532554,-0.027573204,0.43097866,-0.22089636,0.7604876,0.1532096,-0.3353563,-1.0044956,-0.54108447,-0.74035263,0.4154379,-1.9187924,0.60313004,-0.7248256}},
      {{1.3895423,-2.260748,-0.23201133,0.917637,0.004826212,-0.9198344,-0.5363679,-0.1620558,0.48467264,-0.0023599698,-0.064406216,3.2175875,-0.13853323,-5.5634866,-0.75136936,-1.9339198,0.78173846,-2.6779609,0.82563287,0.43772298}},
      {{0.37298197,-2.4263508,-1.6381584,1.5227318,0.4737674,-0.8986814,-1.3693892,0.0152154295,0.5143173,0.33259073,1.2381583,8.715972,-0.36535943,-4.6251035,-0.8667291,-2.5584311,0.7431268,-2.7801788,0.79066956,-0.54658234}},
      {{-1.076241,-0.2706199,0.7205818,0.35394633,-0.28222224,-0.24905641,-3.8395162,0.27752963,0.5973267,2.522921,2.4925358,4.5056195,0.14030714,-2.2213435,-0.68213415,0.10498123,-0.5218692,-0.15273912,-0.12947097,-0.31591588}},
      {{-2.1208375,0.80743355,0.91286355,0.37923586,-0.7108965,-0.24338254,-0.91175044,0.07586481,0.6343751,1.2536603,-0.54378384,3.3806798,0.0866816,-6.0164247,-0.51024157,-0.037819114,-0.30750388,0.71465963,-0.16377456,1.4743421}},
      {{-1.508831,0.6652055,0.5272825,-0.22674462,-0.5269772,0.03743934,-0.6049109,0.18896167,0.6479758,0.57787144,0.19238257,0.0053269244,0.45213956,-0.40066668,-1.3012607,0.19263335,-0.2349337,0.54711187,-0.12878703,0.15429388}},
      {{-0.5706192,-0.23106427,0.58533263,-0.46042964,-0.058518913,1.6519283,0.42705894,0.20764017,0.5524103,-0.57523674,-3.414934,-0.47647887,1.2016678,0.650426,-2.1152792,0.2699465,-0.7461304,-0.10185044,0.112722084,0.7880476}},
      {{0.7963515,-1.700983,0.24002457,0.91942084,0.30799815,0.021472527,-0.5361618,0.2141092,0.5614658,-1.2768712,0.3251676,0.32950962,0.6443308,-1.0719036,-1.1273531,0.2659485,-0.76633537,-1.134329,0.30158302,-0.20157543}},
      {{1.3487992,-3.8644621,0.3470017,1.1537635,0.3142574,-0.46729672,-1.7336549,0.057714,0.6046436,-0.4071731,-0.0038012417,3.8465128,0.85149306,-5.3910694,-0.87673724,0.17358197,-0.285715,-1.6759472,0.28504854,0.65645176}},
      {{0.87386066,-2.1112597,0.41462216,1.9687681,0.1379354,-0.016329622,-4.2911916,0.22209425,0.5771851,0.116642796,1.400927,12.916083,0.49483493,-3.020944,-0.53898877,0.18614188,0.23694494,-0.53843826,0.30600515,-0.066848665}},
      {{-2.6435947,-0.31841078,-1.6020344,-0.09528576,0.30929497,-0.8624252,-2.396795,0.2134687,0.57499605,2.5071483,1.3848301,4.5005736,-0.8077781,-2.3422525,-0.5345096,-2.8152568,0.25455946,-0.49170998,-0.70695835,0.3610746}},
      {{-1.671258,0.8897908,0.045202088,0.2513221,0.40125906,-0.6401707,-0.0034772672,-0.2009482,0.35645276,0.9022966,0.092611685,2.9012082,-0.8944915,-6.6485,0.3264092,-2.9600255,0.07221225,0.2240186,-0.4364357,1.6651574}},
      {{-1.5166967,0.61876136,-0.073625796,-0.2894467,0.16626512,-0.41691548,0.5927762,0.1577241,0.44162786,-0.32959777,0.5246383,0.14939247,-0.59663063,-0.80091935,-0.52857876,-1.4778882,-0.13643725,0.38513276,-0.9035614,0.31198624}},
      {{-0.51615393,-0.39966765,-0.6602353,-0.6403333,0.4809632,0.28289846,0.5523253,0.07392692,0.08044878,-0.82810086,-0.55216676,-0.43279424,-0.06626557,0.6294202,-0.68458855,0.1255131,-0.73121595,0.20072511,-1.2252889,-0.25678438}},
      {{0.31351438,-2.3737917,-0.10732298,-0.07546387,0.43827182,-0.5318478,-0.027738625,-1.3151709,0.15065148,-0.6704137,0.35281655,-0.14077334,0.07313828,-0.7891497,-0.15540123,0.55257183,-0.6681945,-0.48966685,-0.54566914,0.22796123}},
      {{1.3403753,-3.7370615,-0.31703252,1.0993949,0.501216,-0.69648635,-1.7473065,-2.1107001,-0.17274912,-0.42630583,0.27362356,2.3386555,-0.023228811,-6.2395225,0.026368545,0.6105575,-1.1848133,-0.7047918,-0.11142007,0.81627345}},
      {{0.65776217,-2.5504863,-1.6051323,1.1280861,0.31381872,-0.046132382,-4.298041,-2.0612655,0.23224173,-0.45857748,0.88278264,8.029195,-0.6893928,-6.3326845,0.7777575,0.54848725,-2.1959054,-0.024207179,-0.04436481,0.36867017}},
      {{-2.1267424,-0.10276413,-3.7199826,-0.15208486,0.7984794,-0.9526172,-0.22278845,0.24088791,0.120282985,1.4212615,0.7060752,4.4230523,-0.90737265,-7.419943,-0.6630723,-4.800324,0.49610996,-0.8177165,-0.87227285,0.04934169}},
      {{-1.9800348,0.712702,-1.1224039,0.16192305,0.65888107,-0.7426572,0.8507786,0.055193845,-0.21731246,0.70290375,0.8469362,2.4832475,-0.63282603,-3.9487846,-0.48130897,-3.1428807,0.325607,-0.675251,-1.4538016,0.74024326}},
      {{-1.1458026,0.5015655,-1.9470961,-0.15389033,0.8017414,-0.62053967,0.68889934,-0.24146894,-1.0016865,-0.24258053,1.0674157,0.10500919,-0.26830366,-1.0369964,-0.21831714,-3.1802227,0.06476939,0.12721528,-1.8589989,-0.22524802}},
      {{-0.6275394,-0.5596751,-0.93726194,-0.63935596,0.6784275,-0.13462076,0.48055354,-0.02448281,-5.192111,-0.70291984,-0.41244355,-0.39331397,0.39157057,0.71474713,-0.27249736,-0.45282528,0.03853646,0.30738258,-3.0041106,-0.00011387257}},
      {{0.7289089,-1.2036585,-1.4542595,-0.4622979,0.61486125,-0.7755493,-1.0072633,-1.9885724,-4.589737,-0.2315311,0.8885696,-0.18161225,0.0324992,-0.9031385,0.74531955,0.3868601,-1.1230178,0.08765237,-1.1364825,0.0015959262}},
      {{0.87494457,-3.406733,-0.606817,0.27506357,0.36998534,-0.6445861,-1.4155612,-3.2285144,-2.530486,-0.046369243,0.3044461,1.0622725,0.000631638,-4.354814,0.8575429,0.8586392,-1.2859272,-0.14898935,-0.4572965,0.8604926}},
      {{0.54781026,-4.1967587,-4.3465395,0.020854872,0.44927156,-0.3665563,-2.7703547,-4.695755,-1.2489858,0.7270078,0.32321176,3.6856284,0.022086304,-6.0090904,1.1866409,0.62701356,-3.2265573,0.2696897,-0.15866975,0.6128013}},
      {{-1.87523,-0.36828107,-7.4569063,0.39500716,0.20876136,-0.35172263,1.0556389,0.20582928,-0.7581834,0.6199362,-0.018991278,3.1169028,-1.2032534,-5.6221323,-1.2846448,-5.7821016,0.4650171,-2.2502108,-1.0326433,-0.8146536}},
      {{-1.2452973,0.5330747,-4.95701,0.5341015,0.20583148,-0.7470466,1.3825293,0.16224782,-1.5650312,0.114863425,2.0356076,1.2716545,-1.2847929,-2.6936154,-0.49520302,-5.4360113,0.42733464,-1.5109533,-1.835508,-0.68138635}},
      {{-0.9638092,0.47621706,-4.979689,-0.016416555,0.42750296,-0.061752554,0.93344015,0.348978,-5.707282,-0.7208938,0.6964287,0.089513816,-1.0277231,-0.70384544,-0.07088257,-3.938814,0.47548547,-0.38088423,-3.2795522,-0.66449326}},
      {{-0.5961306,-0.18853483,-3.7382314,-0.6028914,-0.07746723,0.58638376,0.25924274,0.12494213,-7.3446064,-0.6111682,-2.1023214,-0.48660254,-0.09074918,0.7081376,0.82562166,-0.4838075,-0.1577472,-0.107257344,-4.7956777,-0.6373796}},
      {{0.39720082,-1.1394918,-3.9079309,-0.4194092,0.14239937,-0.27651408,-0.52992165,-3.5322216,-8.105418,-0.6140551,0.5653687,-0.46165472,-0.24342138,-0.11291559,2.8284729,0.04935434,-0.44812334,0.14042187,-2.1157398,-0.7162597}},
      {{0.7676087,-2.5656188,-4.55848,0.6858961,-0.053099714,-0.3921422,-1.5830283,-4.909201,-5.1602535,-0.8805106,0.6944843,0.3887328,0.0146171395,-2.6638188,2.4529767,0.75152224,-0.80845463,0.013281839,-0.8605837,-0.30096567}},
      {{-0.002264823,-3.062854,-7.580196,-0.13061172,-0.18470602,-0.005956374,-1.8373847,-5.338462,-2.833375,0.13863516,-0.8143517,1.2377462,-0.2548096,-4.1981897,2.2053473,0.6609067,-2.1476543,-0.12782297,-0.45504907,0.25790888}}
    }};

    b1 = {
      -0.080619484, 0.37310305, -0.64498436, -0.08008613, -0.17701633, -0.45951617, 0.06336899, 0.016775854, 0.013983283, -0.024859095, -0.2072501, 0.23639959, -0.035222735, -0.1575506, 0.07577149, 0.10658548, -0.18094136, -0.042898793, 0.13137217, 0.22228464, -0.026535574, -0.0360464
    };

    b2 = {
      -0.071673326, 0.04200613, 0.11519674, 0.025664432, -0.005014618, 0.6100854, 0.2150823, 0.058222394, -0.09722264, 0.10425386, -0.05860091, 0.035667907, 0.61803025, -0.103281535, 0.08480645, 0.057735942, 0.1148159, 0.032741982, -0.058279853, 0.028167589
    };

    bout = {
      -2.4027185, -2.1722178, -1.7022872, -0.48782632, -1.4828808, -2.3221836, -2.7176056, -2.700923, -0.6962983, -1.1049794, 0.24801883, -1.1247063, -0.93812203, -2.4241085, -2.1965497, -1.0322502, 0.15621702, 0.78812146, -0.014568883, -1.166483, -2.0138283, -0.6584837, 0.13742836, 0.7114569, 3.7974756, 0.7810993, -0.067965545, -0.9993488, -1.8978443, -0.95820546, -0.03606764, 0.8051081, 0.2566167, -1.188643, -2.3204613, -2.6000078, -0.91319466, -1.2131271, 0.030988522, -1.3157029, -0.92526096, -2.639844, -2.6723323, -2.168419, -1.6252275, -0.53096104, -1.6506462, -2.1177075, -2.4634678
    };

    BN_gamma_in = {
      0.70267504, 0.70357084, 0.94557714, 0.75978374, 0.34237754, 0.63005507, 0.85478354, 0.21745646, 0.13549209
    };

    BN_gamma_1 = {
      2.9573154, 1.1359866, 7.6989727, 2.5133028, 3.7220056, 22.226463, 2.3536532, 3.427774, 3.1237254, 4.880636, 3.5443888, 2.0054395, 2.395812, 4.0944133, 3.665944, 2.987139, 6.190279, 9.063478, 2.4290683, 1.9331659, 1.8610959, 2.2616534
    };

    BN_gamma_2 = {
      1.8158312, 1.5146632, 2.3070698, 3.008763, 1.1381414, 1.2389618, 1.5030686, 2.2242405, 0.6317776, 1.9484404, 4.446682, -1.0661546, 1.3281077, 1.0522325, 2.6229444, 1.651497, 1.0616264, 1.0742683, 1.2442908, 3.8835213
    };

    BN_beta_1 = {
      -0.09601808, -0.0215671, -0.014702585, -0.22012916, -0.14184996, -0.0054267496, -0.027514404, -0.0463327, -0.02729181, -0.055683285, -0.18807039, -0.02866544, 0.0022125216, -0.030673439, -0.06489544, -0.016133865, -0.005487822, -0.0029678198, -0.028944008, -0.48648304, -0.10851393, -0.06099488
    };

    BN_beta_2 = {
      -0.14212401, -0.11062334, -0.17567025, -0.068763636, -0.12339554, -0.7684899, -0.25354493, -0.14604366, -0.050663352, -0.31183884, -0.06768016, 0.06527718, -0.6593886, -0.027411247, -0.15764748, -0.09718259, -0.20855342, -0.1217547, -0.12227243, -0.20353982
    };
    
    mean = {
      29192.797943175487,14592.526713728088,29262.738563904524,19940.08074678151,1944.0432456829724,19894.383956247995,29069.324172281114,14309.17194875009,28948.555352745476
    };

    stdev = {
      256869.05289660723,160129.43884245644,254307.62196992838,173226.57274217487,31935.87374724543,172479.47161329084,254629.885567268,159614.81314715123,255957.14041221823
    };
  }
  
  else if(m_pcEncCfg->getQP() == 37){
    
    embs0 = {{
      {{-0.37106234,0.39180014,-0.39043066,-0.017929256}},
      {{-0.0016742039,0.006316201,-0.016599173,0.002573843}},
      {{0.0012775547,-0.0032349115,0.0006122366,-0.0037655528}},
      {{0.92741734,0.041697964,-0.13284609,-0.02665431}},
      {{-0.0009829359,-0.009492256,0.025873588,0.013001581}},
      {{0.78872544,0.06202706,-0.05565414,-0.041349944}},
      {{0.007619581,0.034511182,0.079581894,0.0063700983}},
      {{-0.007568301,0.08086361,0.24534892,-0.034980066}}
    }};

    embs1 = {{
      {{-0.38317236,-0.25579894,-0.17721067,-0.33353758}},
      {{-0.0014700565,0.00035045386,0.009794617,-0.011399414}},
      {{0.00444577,0.0002599881,-0.002839705,0.0049549486}},
      {{0.031726692,0.44247752,0.012670473,-0.047681365}},
      {{-0.013958859,-0.0011895119,-0.019062975,0.026341889}},
      {{0.00096200337,0.42890504,0.005357605,-0.09823296}},
      {{-0.027725648,-0.0014061326,0.059115663,0.064862385}},
      {{0.05539066,-0.010152473,0.11263285,0.26693246}}
    }};

    in_h1 = {{
      {{0.003785039,-0.013453558,0.014876918,0.014980261,-0.047933597,-0.039582316,-0.014416897,-0.016472973,0.8686903,-0.38626885,0.8349304,2.602776,0.09965005,-2.4377482,0.4831106,-0.77535397,1.0010717}},
      {{-0.011023161,0.052329715,-0.016338598,0.005427554,0.016358474,-0.03377595,0.01581661,0.00905764,1.4080608,-3.2757504,0.3701545,-0.80621827,0.00101586,-0.12582606,0.42894056,3.820252,0.14113425}},
      {{-0.025754487,0.15411,-0.045640893,0.25525787,-0.26578018,0.03098633,0.3942243,0.16613482,0.27998272,2.3680632,0.10001128,-0.7584301,-0.97516876,0.29215828,-1.1651064,-1.6348857,-2.152709}},
      {{-0.1089501,-0.023625609,0.060501702,0.04118683,-0.04547423,-0.03267198,-0.09603646,0.021236423,1.0407674,-0.36511424,-1.6995724,-0.6560518,0.58603835,-2.480414,0.4726404,-0.5117385,-1.0030189}},
      {{0.08605082,0.4044592,-0.30869505,-0.28764844,0.44993782,0.9043219,1.4565922,-0.89157844,-0.6092716,2.603229,0.666124,-0.55878145,-0.5259074,-1.0854172,0.9210312,0.033110734,3.0304823}},
      {{0.010302201,-0.26948667,0.17269959,0.079360776,-0.033943653,-0.012816659,-0.25547433,0.1381704,-0.85653543,-1.0624744,-1.0274223,-1.0464936,-2.9638543,-1.4816256,-0.70305717,-1.2582731,-1.3323019}},
      {{0.27616143,-0.19823734,-0.12202656,0.007848741,-0.057510056,0.5495193,0.010564917,-0.035571,0.23791215,-0.74840426,0.34090543,0.65471745,1.030805,-0.034045663,-0.5384408,-0.6676222,-0.1869355}},
      {{0.006864081,-0.059141602,-0.024240552,-0.008557875,0.044401705,-0.013036836,-0.019076368,-0.02487997,1.0824894,2.4786801,0.43804488,-0.7126657,0.2667505,-0.23484957,0.4183719,-4.4596257,0.35887787}},
      {{0.008785854,-0.03188494,0.01431164,-0.026140332,0.030382773,-0.013429164,-0.006673331,0.009955699,-0.5391811,-4.598464,-0.6109619,0.34633994,0.8539241,0.31741816,-0.18273473,-0.3422418,-0.45821333}},
      {{-1.2895849,-3.6876235,-8.944421,1.1509391,-1.2296032,0.071126714,-3.2529516,-9.125631,-0.8837813,-0.28689262,-1.3730755,0.97140026,1.3583696,0.97685635,-0.618433,2.9489393,-1.764792}},
      {{0.0059788865,-0.0013101345,0.002022277,0.006672745,-0.003804719,-0.017516663,0.0046195583,-0.012550249,0.7766896,-0.13806729,-0.038080957,-3.364448,0.0841575,2.032947,0.12765859,-0.13815214,0.2282766}},
      {{-0.015188259,-0.012256623,0.0073639336,-0.021784855,0.012526868,-0.005128573,-0.009883962,0.004104585,-1.129877,0.69831717,-0.3806895,-2.448364,0.61011714,-1.6325761,-1.147039,1.2442151,-0.9396864}},
      {{0.06531556,-0.42425725,0.118099935,-0.38105145,0.56231964,-0.006267218,-0.33762002,0.023214916,-0.06101188,0.62414455,-0.3385853,-0.0656724,-3.7135913,-0.021401096,0.012078139,1.8332891,0.5556162}},
      {{-0.0050653126,0.00058344373,-0.004348284,-0.01840112,0.013357961,-0.004850481,0.0032565582,-0.008629271,-1.4855441,-1.4874023,-1.7983831,-0.34988597,0.99122804,-0.44386005,-1.5240469,-0.88736445,-1.7984928}},
      {{-0.0019027768,0.00078677497,0.001489395,-0.0013317928,0.00033574164,0.004357815,0.00075227977,0.001832635,3.655935,0.13312352,-3.4321277,0.059825808,0.0020182177,-0.074670866,-1.3400286,-0.19454266,3.3833132}},
      {{-0.012224268,0.038972236,0.061671928,0.031815916,0.13456018,0.11835698,0.00052055664,0.0026537438,1.9302344,0.916249,1.1528176,-1.278802,-0.8316651,-0.6836187,0.74059063,4.383474,1.1981761}},
      {{-0.00987082,0.065587156,0.09543849,0.011289881,-0.10071988,-0.0041798437,0.040946115,0.060613863,2.2131057,-0.7814703,1.5043974,0.42843875,-0.44392034,0.3953395,1.1341802,-0.68841815,1.5920008}},
      {{-0.0025234222,-0.0011504287,0.0032720082,-0.00095917523,0.0010110686,0.009771736,-0.0005306372,0.0037713766,-3.0423818,-0.2683782,3.3695579,-0.6853413,0.13136351,-0.20838474,1.8103907,-0.5878571,-2.3950777}},
      {{-0.4094181,2.2756305,-1.7375882,-2.175708,1.1164751,-1.5475413,0.79230106,-1.2137794,3.9453945,-1.0494102,2.4941099,1.0830152,-0.46182725,1.4231977,-0.06550385,-0.87214905,0.3460513}},
      {{0.012232964,-0.0046169115,0.010123774,0.009171051,-0.01840204,-0.015746422,-0.013407091,-0.0078062317,-1.7133051,0.9906461,-1.8133057,-0.43247446,0.47109717,-1.9728316,-0.5976648,1.2906313,-2.1196208}},
      {{-0.23685579,-0.3099889,0.8936611,0.42531475,-0.5407457,0.07714001,-1.2094535,0.26132643,-1.1584142,-0.3538987,-1.5335274,0.094881035,-1.7515144,-1.1409179,-1.2792777,0.53328395,-1.61499}},
      {{0.64379317,-0.29699296,-0.50610864,-0.08805868,-0.02219474,1.0916737,-0.1152267,-0.56534594,-1.8643812,-0.76767796,1.0029138,-0.29710844,2.2522902,0.070306085,1.2856859,-1.6768335,-0.482455}}
    }};

    h1_h2 = {{
      {{0.3007872,-0.5282157,-0.7533598,0.44944325,-0.26679358,0.50895077,-0.2841703,0.072615124,-1.5969619,-0.056219786,-1.9439707,-0.1499281,-0.6335996,-0.6241784,0.71533567,0.045664106,0.91787463,-3.1779504,-2.0652037,-0.9142199,-0.47653615,0.21327896}},
      {{0.22256704,-1.1332182,1.6588426,1.8266234,0.1555852,-0.3473562,-0.15406919,-1.4484285,1.1779066,0.010446315,-1.1664835,2.0541592,0.33316946,11.383975,-1.4021173,-3.5830715,-4.161866,0.20686378,-0.44587293,7.671288,0.20946403,-0.13892847}},
      {{-2.423074,-0.075878,0.012060929,-1.3207284,-0.036336783,-0.1293286,0.18790746,-0.023013784,0.15455152,-0.06644251,0.35269108,-0.09372044,-0.10790959,-1.4725043,-0.1319226,-0.080118395,1.2352333,0.027428638,-1.1739683,-4.157764,0.40653288,-0.0022351658}},
      {{0.92681634,-0.03993356,0.19995447,-0.83332646,0.079488784,0.14392692,0.1464895,-0.096776545,-0.109326966,-0.15172325,-5.3242493,-0.5005558,-0.07642723,-2.1702135,-0.24670234,0.011025963,0.66664743,-0.15274638,-1.0583631,-3.9436905,0.76081103,0.16525239}},
      {{-0.9454026,-0.09391882,0.11746358,-0.055317387,-0.037402723,0.10253839,0.32388183,-0.08395281,0.22076422,-0.05112524,-0.9031215,-3.4353483,-0.07421713,-1.0123897,0.04755307,-0.19231553,1.9612156,-0.060714774,-1.3755417,0.17706768,0.012854833,-0.13767773}},
      {{-0.7087773,-0.75753814,0.7825236,-3.0638912,-0.8269579,-1.0604604,1.2482686,-0.99294764,0.16522409,-0.06968021,0.117604025,-1.2897218,0.5610219,2.123782,0.42288378,0.27419168,0.27980363,-7.5526896,-0.45772916,-0.9365572,0.24716842,-0.7820474}},
      {{0.4991068,-0.06115324,0.2151406,3.2313478,0.014388213,0.86043423,-1.585123,-0.11910261,0.18867266,-0.058817793,0.5661369,-3.3967276,0.9086952,-5.381287,-0.18827148,-0.3956382,0.47308585,0.11394733,-0.2549873,-0.87650275,-1.1125776,-1.8379856}},
      {{-0.05613913,-0.8069124,0.06498883,-1.5561124,-0.44352138,0.16720656,0.98031574,-0.7391707,-0.13871755,-0.04174419,-0.0011764854,-1.0048689,0.20738517,1.2601275,-10.590995,0.4268626,0.12982184,0.5540116,-0.18990175,-0.47428188,-0.27921325,-0.6364276}},
      {{-0.042191382,-2.7850788,-3.5635312,1.5294751,-0.5907288,1.7963552,0.21429342,0.8185722,-5.1719146,-0.10208078,-0.035656482,-2.4947212,-0.37088105,-3.6157973,-0.16371295,1.2056286,0.07939196,-0.10691409,0.022703966,-0.41206563,-0.579107,-0.10290423}},
      {{-0.0055129207,-4.2087674,-0.11891731,-3.2797232,0.17389026,5.2836647,0.26900154,0.0879012,3.720883,-0.043221943,-0.074548684,0.23986168,-4.0493402,-4.184896,0.029586991,-0.17779326,0.03246311,0.13064493,-0.024095863,-1.3443437,0.008130068,-0.11755074}},
      {{-0.83078915,-0.08151411,0.027590007,1.9640115,-0.09983613,1.9537034,0.20298626,0.10882443,0.12451047,-0.025376951,-0.68197674,-0.26089972,-0.01189236,5.687665,0.10447362,-0.072483,1.5393885,-0.44938037,-0.11878373,-0.038941834,-0.22275555,-0.021542715}},
      {{-0.019557225,0.10301447,1.2391307,0.29490316,-0.68912464,-2.4875658,0.2958147,-0.81324863,-0.32765153,-0.19443785,-0.015715888,1.6278017,2.7127304,0.501622,-0.8471083,-0.65067446,0.2076609,-0.43798828,-0.22186504,-0.24643575,0.48273087,-0.21133056}},
      {{-0.0073148888,0.48104224,-0.19659735,0.8031968,-0.9510552,4.308305,0.14065091,-6.383704,-3.9070008,-0.20878306,-0.00018898705,-0.4698674,-0.9047132,-1.7122506,-0.2399177,0.8630219,0.030039055,-0.20800136,-0.0014391073,-0.5257501,-1.0660056,0.08124528}},
      {{-3.3552175,0.039798956,-0.75267243,3.0816882,-0.07866177,2.360647,-0.5293006,0.079596184,-1.3725333,-0.03188496,0.3418649,-0.016154442,-0.27007252,-4.510822,0.03371553,0.007785519,0.09491269,-0.2852092,-0.26714385,2.626794,-0.28143957,0.32635006}},
      {{-0.042828802,-2.6707368,2.42207,0.28634885,-1.2221354,-0.36065757,0.7779145,-1.6277997,0.027818775,-0.08400684,0.08088977,-2.6216187,1.9913403,3.011286,-0.19015479,2.2431643,0.21899718,-0.056541856,-0.17914169,0.1319782,0.4047614,-0.5960172}},
      {{-0.0024460966,-0.46532375,0.24162807,0.5671798,-0.5496432,0.5378465,-0.07685859,-1.1241752,3.8836882,0.019685837,-0.009691908,-5.867121,-0.043682687,5.0394597,-0.46812144,0.18364112,0.046857808,-0.57164633,-0.0631779,-0.07309394,0.19110937,-0.05038768}},
      {{1.0122087,-0.14983073,0.26371697,-1.607593,-1.7886863,-0.18330699,0.6536257,-0.16856557,0.20121478,-3.054399,-4.072943,-0.5755707,0.12133423,0.04470853,-0.43848476,0.29539984,-1.6673224,-1.529743,0.09319513,7.9211335,0.16916361,-0.77251244}},
      {{-0.019087149,-0.023933152,0.17022,-1.2308137,0.019699143,6.6356635,-0.6366461,0.0011511947,-2.2180645,0.0076240436,-0.029133802,-0.33836928,0.4667316,-10.311294,-0.09804277,-0.13322806,0.072560385,-0.063544534,0.04372299,-1.0211091,1.4512781,-0.88339067}},
      {{-1.2070727,-0.73390687,0.64081943,-0.17491141,-0.8246243,-0.1717393,0.79307854,-0.45059335,0.07868033,-0.21220651,-1.226881,0.32176048,-0.002381234,-2.083159,-0.56555194,0.58911675,1.8124387,-0.798068,-1.4267161,0.19598591,0.2348267,-0.41036052}},
      {{-3.499495,-5.3884377,0.27021876,-0.28740528,0.20360607,-0.006229385,0.09146772,-5.135032,-0.51047486,-1.7277482,1.2418526,-0.20771047,0.03071591,0.45138502,-0.39001158,-4.8796787,-2.659972,-0.3090429,0.21968421,2.046576,0.07895806,-0.21426156}}
    }};

    h2_out = {{
      {{-3.55295,-5.659002,0.3105471,-1.0328752,-0.5851352,-2.522014,-5.3850875,0.7750809,-0.9835279,-0.58738756,-4.1053057,-0.6716972,-0.15305832,-1.4251007,-1.1891552,-1.4755136,-0.7695092,0.47500792,-3.7780402,-8.223577}},
      {{-3.3825245,-4.8625984,1.2350849,-0.012968331,-0.06838247,-2.7678592,-5.6162987,0.65273976,-2.3944917,0.3215407,-1.1209211,-0.68487275,-0.73213166,-0.23936911,-2.2614608,-1.2216398,-1.868197,-0.37962434,-1.4336107,-5.63884}},
      {{-2.8685887,-5.2780933,0.92688495,0.005751882,0.43471158,-2.2350645,-1.9969803,0.41435027,-3.669462,0.28458378,-0.1550187,-0.6338938,-0.08469721,-0.50205874,-6.792473,-1.3864596,-1.6279567,-0.29348198,-0.11009607,-3.9850307}},
      {{-0.11507723,-4.344658,0.00561877,-0.23501097,0.3721847,-0.6957584,0.45985752,-0.11514642,-6.076105,-0.83238554,0.27945518,0.45950806,-0.28008068,-0.29756036,-8.419951,-3.9208956,1.1044428,0.91694814,0.41792595,-0.17648989}},
      {{0.45291853,-5.060452,-0.2748176,0.40550178,0.32531714,0.13927448,-1.5945811,-2.7926562,-4.529365,0.25845888,0.11055241,-1.1634611,-0.28272173,0.06533372,-6.6215,-1.4203781,-2.0405803,-0.37977424,-0.38558447,-1.2939373}},
      {{0.8845079,-4.6312003,-0.43842524,0.44972137,-0.6532531,0.3025442,-4.6504827,-3.865216,-3.0537996,-0.037948053,-0.24740718,-0.78111094,-0.47976428,-0.32460988,-2.951053,-1.1855881,-3.2213721,-0.48903358,-2.2449393,-2.7211359}},
      {{0.63493663,-5.3894315,-1.369058,-0.52036524,-1.6092414,0.87768555,-4.7057767,-3.517476,-1.8125908,-0.21167299,-1.6399226,-1.3763254,-0.2311889,-0.6039808,-1.3065128,-1.7089477,-5.1026864,0.4766205,-3.9643776,-2.5175986}},
      {{-4.072647,-3.4958246,-0.3738064,-1.7893703,-2.1489606,-1.6643893,-2.0451748,0.84831715,-0.17272237,-0.010172399,-5.7844515,-1.0375404,0.7240191,-0.2636226,-0.4428295,0.38992804,-0.60492283,-0.36214864,-1.848809,-5.987675}},
      {{-3.1726978,1.5795226,0.61932987,-1.1169318,-0.9373801,-1.6937923,-6.464582,0.6997193,-1.5949991,0.74954057,-0.9140222,-0.5347449,0.5508684,0.12421766,-0.8626821,0.48030832,0.43474534,-0.33342358,-2.5472822,-1.9030414}},
      {{-2.139202,1.2188671,0.7877444,-0.3558659,-0.003989319,-1.6804382,-3.395544,0.14115761,-2.246586,0.06823199,0.045530304,-1.21186,0.7024337,-0.35476694,-2.4524364,0.21396561,-1.7177476,-0.39429742,-0.32703963,-0.89751107}},
      {{-0.39227194,0.89063424,-0.25803927,-0.41664153,0.32408747,-0.17983668,0.64530617,0.16967285,-4.19629,1.0311711,0.2852325,-0.24403217,0.8083447,-0.5409251,-4.165652,-0.31409723,0.9368535,-0.8106689,0.38879734,1.644572}},
      {{0.4168413,1.0615118,-0.46355468,0.2838975,-0.10859194,-0.27696675,-3.3342655,-1.7322965,-2.9425516,0.15418614,0.25386882,-1.1426084,0.7642989,-0.21506812,-1.9376465,0.19252579,-1.0739691,-0.70425326,-0.6309935,-1.4045149}},
      {{0.76211077,-1.0999869,-1.1086882,0.33553794,-1.5227748,-0.04637689,-5.285986,-2.1317177,-1.7558947,-0.7600217,-0.044057887,0.3676667,0.6663316,-0.205614,-0.8584855,0.3957048,-2.7012477,-0.6043117,-3.2798443,0.30072892}},
      {{0.88851666,-4.3298893,-1.9241071,-1.0741026,-4.4561477,0.68957,-4.832905,-2.4996684,-1.0859737,-0.74448925,-1.797304,-1.4268339,0.8145592,-0.5064678,-0.4587616,-0.0407253,-4.4269657,-0.4480625,-1.9794763,-2.4719498}},
      {{-3.0666165,-4.3582387,-0.05257251,-2.7994556,-8.072535,-1.08176,-3.150581,0.6568734,-0.18155909,0.113427065,-3.6761749,-1.6435788,0.5342892,-0.37305254,0.019419441,0.41585463,-0.08187249,-0.32384187,-0.41788796,-6.063616}},
      {{-2.4149268,1.7823881,0.7952726,-1.3137118,-3.1660562,-0.82232136,-5.981502,0.41010115,-0.2941035,-0.25675952,-1.613129,-0.11405601,0.4454426,0.12592216,-0.07720399,0.502464,0.4286796,-0.9605691,-0.81353277,-2.4288194}},
      {{-1.6752898,-0.1939502,0.5046681,-0.600671,-0.14064723,-0.6229932,-2.6347291,0.3594249,-1.0547061,0.054830562,0.21573406,-0.7667163,0.41235146,-0.07948313,-0.074110955,0.17872025,-0.2567318,-0.5796573,-0.20059538,0.09240963}},
      {{-0.28409466,-0.2842907,-0.19451252,-0.3104387,0.3349567,-0.20454748,0.5637734,0.22165401,-2.4054904,0.67699164,0.29727483,-0.3514469,0.6002683,-0.57804066,-0.17509988,-1.3667059,0.955882,-0.1323334,0.38970858,0.66732186}},
      {{0.2451648,0.36782753,-0.6605086,0.42989627,-0.24885868,-0.22369312,-2.4089563,-0.7075876,-1.2533994,-0.17071232,0.24473862,-0.61289877,0.49554917,-0.38091934,0.087700285,0.1399553,-0.18449101,-0.6630645,-0.34085968,0.6027307}},
      {{0.644867,-0.48317304,-1.4697016,0.5483779,-3.336033,-0.2953871,-5.1884265,-1.5138633,-0.71068466,-1.0743095,-0.7545137,-0.13741228,0.44930148,-0.42883328,0.08344662,0.4463025,-2.4033241,-0.9394942,-0.87377703,0.4566015}},
      {{0.65591556,-5.598041,-3.1236916,-0.45839238,-8.234779,0.34024227,-4.390254,-1.6823064,-0.58030355,-0.18775646,-2.2074254,-0.83587307,0.5254729,-1.0833634,0.343577,0.41070148,-5.9752774,-0.49318144,-0.5546556,-0.8402229}},
      {{-0.40993786,-5.282645,0.32867074,-5.937723,-15.121317,-0.19917253,-0.07324918,-0.15659812,0.22345628,-1.261947,-3.188245,-0.26866162,0.08699997,-1.641696,0.37104905,1.2915515,-0.67115545,1.1901411,0.40769187,-7.6269755}},
      {{-1.620299,0.86465293,0.51289314,-2.5477326,-5.2168074,0.103031054,-5.912945,0.022129405,-0.014369321,-0.31357694,-0.9849865,0.6218316,-0.1628626,0.20247816,0.43280032,0.6335822,-0.3091476,-0.6206515,0.34699687,-1.4907706}},
      {{-0.7525392,-0.3261736,0.42785543,-1.5032097,-0.7228878,-0.070960425,-2.1531863,0.12234696,0.09182827,-0.5527367,0.09870554,0.54755414,-0.08453516,-0.12520617,0.46055442,0.46476856,-1.0899084,-0.30204952,0.27676117,-1.8400319}},
      {{-0.2538896,1.4662235,-0.22482939,-0.43966314,0.3494493,-0.28349322,0.79647934,0.19851604,0.21623723,-0.96468705,0.29549262,0.9413105,-0.00080130156,-0.98685455,0.4067462,0.07502962,2.5307722,1.2311434,0.34437263,3.8556364}},
      {{0.054900214,-0.29503804,-1.1854112,0.4314905,-0.67073774,-0.37447426,-1.5056899,0.17090204,0.08441788,-0.63195264,0.020410854,0.53710324,-0.051700473,-0.69357854,0.46896952,0.4663253,-1.8237215,-0.3221487,0.25648984,0.09039861}},
      {{0.2811235,-1.1884255,-2.5244439,0.59563714,-5.1303663,-0.7516084,-3.7639785,-0.0069369413,-0.08463045,-0.86131746,-1.0603387,0.7888023,-0.19466215,-0.7324042,0.4479395,0.6541371,-1.5228299,-0.61019605,0.31920633,-0.3558011}},
      {{-0.012650794,-4.115445,-4.6499577,-0.36399123,-8.403234,-0.020744747,-2.435382,0.0419372,0.17340179,-0.9537097,-4.987884,0.1857751,0.06922924,-2.384827,0.42606774,1.4299619,-4.7460713,1.1224513,0.31801394,-0.9673115}},
      {{0.19300982,-5.4793344,0.13812643,-4.0223827,-12.258115,0.54291093,-3.0094454,-1.4693595,0.2802701,0.22709207,-2.0906148,-1.440988,-0.15067545,-0.28184038,0.28100622,0.75810736,-0.47031203,-0.60705817,-0.031189626,-7.2665668}},
      {{-0.09513186,1.3595806,0.4926538,-1.9645275,-4.0366964,0.47658035,-6.714307,-1.066881,0.3814223,0.057802282,-0.7547527,-0.9160051,-0.746764,0.3737708,0.12757081,0.52628756,-0.24086797,-0.82277375,-0.65204144,-2.5049593}},
      {{-0.1982239,0.5818302,0.5226087,-0.92597586,-0.24467307,0.011724609,-2.605554,-0.8187138,0.34667245,-0.005374942,0.20890674,-0.697693,-0.9754276,-0.2058157,0.15859689,0.3879302,-0.15046877,-0.65424377,-0.24997732,0.07461457}},
      {{-0.21243735,0.2907261,-0.1437635,-0.33520362,0.36988008,-0.45859802,0.47273916,-0.00865859,0.3500255,0.7156191,0.30923143,-0.1625783,-0.88754886,-0.80397916,0.11736758,-0.8047367,0.9277771,-0.2766973,0.32187918,0.7079024}},
      {{-0.12826732,-0.3164108,-0.5485259,0.4574219,-0.21425863,-1.5313387,-2.435519,0.43100476,0.37425557,0.060608473,0.042413402,-0.6617219,-0.77950007,-0.35766917,0.017456781,0.5065229,-1.0856441,-0.72825783,-0.21088983,0.8408524}},
      {{-0.013107667,-1.4272004,-1.3434726,0.70407164,-3.0477946,-2.1008613,-5.117788,0.43579173,0.4607894,-0.315523,-2.0586486,-0.26782015,-0.5283285,-0.35615808,-0.08187268,0.8396111,-3.068286,-0.89508265,-0.4543056,-0.5170467}},
      {{-0.6970699,-4.9584546,-2.6173103,-0.010744034,-8.060467,-2.339789,-4.3458986,0.5359988,0.43713334,0.36182052,-4.982746,-0.80680686,-0.20741224,-1.040444,0.077970535,0.87535757,-5.413979,-0.316212,-0.12693295,-0.5285551}},
      {{0.37964278,-4.522652,-0.702511,-2.7130575,-4.223425,1.0407917,-2.772348,-2.4541345,0.46045133,0.18507077,-2.3447325,-2.1223292,-1.0091778,0.12919359,-0.20140731,0.4263705,-1.0418941,-0.82062966,-1.6418836,-5.705392}},
      {{0.035226583,-0.96381694,0.30593365,-1.5941029,-1.6017638,0.40873498,-5.7452383,-1.8836269,0.41552043,0.039345045,-0.1952475,-0.12293238,-1.6464294,0.35615087,-0.45121765,0.7197587,-0.023010353,-0.6444285,-2.9063709,-2.5557117}},
      {{-0.07617141,-1.4308597,0.421088,-0.8940926,-0.16617858,-0.08161519,-3.1411524,-2.0887961,0.43630213,0.6228827,0.18684572,-0.92116934,-2.263433,0.0045221727,-1.9564912,0.39384508,-2.3944542,-0.93449706,-0.35389715,-1.6604114}},
      {{-0.19998515,-1.5558568,-0.15413038,-0.48180288,0.33527035,-0.67503905,0.5980447,-0.16439399,0.19667517,1.1450523,0.28823072,-0.2076498,-2.9312873,-0.5955293,-4.3993573,-0.13683145,0.7425921,-0.640524,0.3274943,1.2258646}},
      {{-0.47831374,-1.7592491,-0.32800862,0.46300477,0.06303815,-2.5764306,-3.195479,0.15784922,0.43219507,0.82032925,-0.15489385,-0.45969433,-1.7843502,-0.9043174,-2.182535,0.29751328,-1.7406051,-0.96711004,-0.42989704,-2.4622643}},
      {{-0.42796645,-1.2912468,-0.9228254,0.67094743,-0.76042205,-2.8702354,-5.6931553,0.58528733,0.47014385,0.11253488,-1.6693008,0.54182225,-1.1547068,-0.02161924,-0.6764946,0.89984477,-2.9781744,-0.759902,-2.4915984,0.037488014}},
      {{-0.62846094,-3.8163702,-1.4937439,-0.30982417,-2.3048873,-3.4522204,-4.6080766,0.70830554,0.48982057,0.42994806,-7.44895,-0.9122343,-0.52914345,-0.541868,-0.24502723,1.2476113,-3.6498206,-0.10949796,-1.5880795,-1.1793302}},
      {{0.23718885,-6.212149,-0.415432,-1.7763754,-1.6734239,1.1097699,-4.68703,-4.102831,-0.05811395,-0.5594947,-1.5151305,-2.1519098,-1.4594121,-0.8864056,-1.3072726,-0.63327056,-1.1544151,0.08686006,-3.6371012,-7.1364408}},
      {{0.30109325,-5.029677,0.8071814,-0.8023641,-0.7623157,0.71398556,-4.23911,-3.936258,-0.5725496,0.28467056,-0.43096247,-1.095542,-2.7908943,-0.06674747,-2.4022567,-0.1643201,-1.9386908,-0.715624,-1.8188089,-4.990135}},
      {{0.09570122,-6.0882015,0.60895604,-0.505054,0.0048278915,0.21906476,-1.8069031,-2.9485996,-0.3733264,0.836686,0.12757653,-1.7064258,-3.6971998,-0.19110498,-6.018557,-0.4966469,-0.9610393,-0.5585036,-0.15623543,-2.6626167}},
      {{-0.2597562,-5.4368033,-0.012995988,-0.251017,0.4109406,-0.72267574,0.48063543,-0.29228947,-0.21081665,0.36675718,0.27183443,0.53607744,-5.478186,-0.12232786,-10.326494,-2.0225928,0.8990801,0.5742402,0.37023377,-0.030089136}},
      {{-0.8280561,-5.9869924,0.034215145,0.615456,0.65003926,-3.623601,-1.8585167,0.28011203,-0.21366748,0.7240893,-0.27728653,-1.168661,-3.5259113,-0.8701466,-6.010406,-0.7038182,-2.544172,-0.32990238,-0.26992196,-1.9547623}},
      {{-0.5704428,-5.2501597,-0.05518698,0.77590185,0.14914918,-4.660978,-4.750221,0.6003483,-0.38558775,0.32890886,-1.2291088,-0.3521019,-1.9663038,-1.0472287,-2.1946983,-0.3634483,-3.8411064,-0.56734276,-2.0145347,-3.530522}},
      {{-0.30832186,-4.5260906,-0.04105039,0.02253893,0.4537315,-4.6575,-6.4273667,0.49328977,-0.19919102,-0.8828457,-8.83846,-0.11531856,-1.4043094,-1.3715577,-1.0192107,0.4904019,-4.9156284,0.2485973,-2.8212667,-2.137299}}
    }};

    b1 = {
	    0.07376809, 0.15050517, -0.23658463, -0.36192277, -0.19558038, -0.8344826, -0.085948795, -0.010754284, -0.26889148, -0.02343543, 0.019347208, -0.4171939, -0.09434327, -0.54343975, -0.0017795088, 0.33165008, 0.31908405, -0.011559977, -0.3264415, -0.31027687, -0.54481083, 0.08021595
    };

    b2 = {
	    -0.037917964, -0.08278857, -0.17848562, -0.19772966, -0.0965522, 0.14252307, -0.14090908, 0.076883435, -0.17579938, -0.42235097, 0.39952838, 0.33052886, -0.27397856, 0.0106219025, 0.25481084, 0.20290358, 0.04261958, 0.110291734, -0.00042762217, 0.021046443
    };

    bout = {
	    -2.3600461, -2.2562196, -1.8025904, -0.13215388, -1.7312118, -2.3280172, -2.3839288, -2.579279, -0.9938266, -1.3079562, 0.24653773, -1.4169043, -1.2233919, -2.6162226, -1.987781, -1.0036097, -0.060092885, 0.617066, -0.19821562, -1.1847852, -2.0332146, -0.44402015, 0.3153041, 0.7016462, 3.7472055, 0.7242891, 0.123548195, -0.4745357, -2.1037128, -1.2243667, -0.14355275, 0.65257114, -0.14465633, -1.3422159, -2.1278608, -2.6165984, -1.1279745, -1.445583, 0.26131463, -1.4963038, -1.204661, -2.5564053, -2.5253403, -2.3015406, -1.7220392, -0.11853414, -1.7522002, -2.3035877, -2.5725474
    };

    BN_gamma_in = {
    	0.32467806, 0.8029626, 0.39012754, 0.6904612, 0.9439163, 0.9540966, 0.923294, 0.6920582, 0.42988652
    };

    BN_gamma_1 = {
	    3.010324, 2.7744305, 3.0477295, 4.8258004, 2.6075711, 11.10822, 2.0760446, 3.303424, 3.1275551, 5.8096066, 3.1534305, 8.698063, 2.6482508, 5.8576565, 5.2141237, 2.8110828, 2.4419446, 4.361841, 1.5560924, 3.1751235, 3.13858, 1.3732953
    };

    BN_gamma_2 = {
	    1.1154319, 7.110937, 0.9656589, 0.7594045, 0.9213586, 1.486982, 0.9870783, 1.8883826, 0.5790137, 1.136113, 0.8366121, 1.7569128, 0.57776207, 1.9862721, 0.40576103, 4.162282, 5.6844125, 0.8785663, 1.8632501, 7.142186
    };

    BN_beta_1 = {
      -0.11389731, -0.30853564, -0.007965379, -0.05768705, -0.00011580075, 0.0044624656, -0.0028615799, -0.09643813, -0.16532153, 0.00028300786, -0.076211564, -0.011822377, -0.026292048, -0.035369027, -0.006635007, 1.3740765e-05, -0.080018245, -0.0054840525, -0.0026760576, -0.18497786, -0.03727885, -0.022659235
    };

    BN_beta_2 = {
      -0.07494251, -0.028752947, -0.12833498, -0.07693969, -0.021133386, -0.1671839, -0.020974083, -0.16952342, -0.106714316, -0.08200206, -0.19855925, -0.35176742, -0.05813751, -0.15319298, -0.056510206, -0.23383737, -0.107055195, -0.42523587, -0.1042804, -0.09310237
    };
    
    mean = {
      28934.678928730336,14898.819258388328,28928.550954853097,19992.62621922142,2668.0555968414565,19848.724334111426,28842.245188912773,14626.770800248936,28639.980444933626
    };

    stdev = {
      255999.8559999595,160010.5468523872,252341.39262514978,173461.22379367673,32798.269222628194,171455.79096665123,253796.88811331,159361.63854579307,254188.62363213662
    };
  }

  else {
    
    embs0 = {{
      {{0.30408958,-0.27300584,-0.02798444,-0.24088626}},
      {{0.0014876119,7.1521805e-05,-0.009433132,-0.018565701}},
      {{-0.0038655591,-0.0008201832,0.007035888,-0.0003191089}},
      {{0.014335697,-0.07501568,-0.029700983,-0.0033344193}},
      {{0.008656698,0.0027359466,0.0033393991,0.020257713}},
      {{-0.0020324795,-0.14046577,-0.06760916,-0.0047845324}},
      {{0.008027862,0.003720626,-0.022962233,0.05693227}},
      {{-0.12708512,0.021037325,-0.088703044,0.11770256}}
    }};

    embs1 = {{
      {{-0.09062728,-0.29279956,-0.25568354,-0.071374}},
      {{8.4338644e-05,-0.009071482,-0.017999459,0.00032973874}},
      {{0.002691059,0.008548092,0.0004798977,-0.00029527507}},
      {{-0.0102196075,-0.028763628,-0.023206908,0.06744544}},
      {{-0.009069848,0.002486622,0.021980857,-0.0005051298}},
      {{0.009678684,-0.0022701703,-0.010259032,0.07060614}},
      {{-0.003106608,-0.028920548,0.061304998,-0.00414634}},
      {{0.16275163,-0.099335104,0.11306711,0.020576002}}
    }};

    in_h1 = {{
      {{0.0015036725,-0.018245433,0.0005937874,0.15101802,0.0036903732,-0.0011454772,0.15501137,-0.022265729,-0.30479553,-0.9984189,-0.06134527,0.3899408,0.98343325,0.15539306,-0.31487173,-4.023224,-4.412744}},
      {{0.0007922572,-0.017262997,-0.04768743,0.080254465,0.0054692207,-0.04000345,0.07149233,0.031837218,-0.45814225,-2.6414254,-0.10384478,-0.836043,-0.23026402,1.0073298,0.85691965,2.1338854,-3.4414492}},
      {{0.09690361,0.100003354,-0.28718188,0.28016794,-0.1537598,-0.33036733,0.15947995,-0.17358492,2.0431037,0.1614384,0.19566305,-1.0128194,-0.76165634,-1.4281971,2.8273692,-2.4886189,-4.8431673}},
      {{0.045766458,-0.022868311,-0.10023753,0.1693696,0.002302204,-0.17481883,0.042837236,-0.2512296,1.0751739,-0.30083045,-0.47069383,-0.37473416,-0.45006442,3.3557975,0.8416216,-0.4930743,4.963142}},
      {{0.0042875917,-0.007840432,-0.0034138223,0.0027276822,0.0075216787,-0.0052398057,0.008079452,0.033813585,0.17282572,-0.10252493,0.006820656,-2.4122736,0.023019593,2.6443655,0.12789635,-0.0627301,-0.19148876}},
      {{-0.17909744,-0.0063041584,0.17412245,-0.35517308,0.11251472,0.20344019,-0.3124144,-0.14634946,-0.024940269,0.13698371,0.13695846,0.075320385,-5.1681633,-0.03178088,-0.090227865,0.124625355,1.1215543}},
      {{-0.1677581,0.07866856,-0.29295406,0.3359118,0.2714034,-0.28150937,0.34837824,-0.01726055,0.79032695,0.62497616,2.073347,-1.6299257,-2.7667534,1.6243126,-1.5593982,-1.255876,8.86397}},
      {{0.008404646,-0.12891051,-0.039019197,0.4705202,0.014428221,-0.044922527,0.38701817,-0.31744266,-1.5883063,1.3897756,-0.33185956,-2.404055,0.4014381,-2.1921055,-0.44804654,0.061890654,-5.0466995}},
      {{-0.0012702475,-0.00012471227,0.0034828486,-0.0017353313,0.0012076882,0.004041549,-0.00031422687,-7.075708e-05,-1.197864,-0.008809175,-1.2809706,-1.4079401,0.8528252,-1.5416986,-1.7214504,-0.29019675,-1.4821465}},
      {{0.21360981,0.19688852,0.44703025,0.91764873,-0.24650191,0.3312773,0.9434278,-0.09601884,-0.17870381,0.2969674,0.6111938,-0.44995406,-4.9791656,0.5889029,0.63172376,0.23147242,5.1778045}},
      {{-0.084370114,0.08595786,0.41874027,-0.7433425,0.03963304,0.36191726,-0.6493457,-0.093163975,-1.2381401,-0.61682206,3.2559793,0.41638732,0.4035901,-1.1549485,1.1734958,1.444498,-9.396358}},
      {{0.0035294548,-0.0095640775,0.0034329696,0.025528468,-5.4600816e-05,0.0020967545,0.023280056,0.004224577,-0.040440682,3.6406715,-0.052805003,0.02807056,-0.21980433,0.021761235,-0.0029119982,-1.5802387,1.3487773}},
      {{-0.0035786366,0.0036305299,-0.0007678467,-0.0029785251,0.0018945263,0.0019019947,-0.002281209,0.015965005,0.047356587,0.22228014,-0.36618182,2.2420404,0.09525667,-3.8500605,0.37368557,-0.1886249,-1.4900954}},
      {{-0.0092434315,0.009780344,-0.030005405,0.08553846,0.008770543,-0.03221885,0.09347034,-0.00775387,-1.2565731,1.1940143,-0.79840505,-2.6680236,0.5118595,-1.5777992,-0.63633543,0.40414533,-2.410566}},
      {{-0.05931547,-0.06434815,0.017162137,0.51511544,0.031176329,0.061567996,0.5564637,-0.017960224,1.4602277,2.8693888,0.09056663,-1.1918086,-0.76812285,-0.120920606,0.510157,1.1732347,8.193792}},
      {{0.06930043,-0.035308316,-0.03629557,0.3024219,-0.044987667,-0.06431238,0.272238,-0.058459666,-0.14546607,-2.5622485,-1.9588418,0.7568255,-0.030512284,0.7631312,-0.22620027,1.6155533,4.3732634}},
      {{0.10068967,-0.032212406,-0.013426095,-0.3668379,-0.020733764,-0.14947954,-0.45452496,-0.03034347,1.8397264,0.13211565,-2.0994225,0.034570664,-0.77942646,0.42368624,-0.8278755,1.9011651,12.159769}},
      {{0.32025212,-0.22829354,-0.54374474,1.4064083,-0.18584324,-0.6566218,1.1939607,0.16164048,-0.28875062,0.35895985,1.621514,2.2666566,-1.5435816,-2.794548,-0.17472023,-0.04289484,-2.8771074}},
      {{-0.0040138867,0.0032674256,0.001329425,-0.0019783783,0.001641315,0.0041972855,-0.0006726654,0.013798191,2.3779883,0.3074334,-1.8242748,-0.2136918,-0.1958769,1.3494966,-2.1268404,0.5726274,5.8637214}},
      {{0.24539588,0.010368425,-0.19259955,0.12971708,-0.16289236,-0.29782206,-0.01090509,0.03757297,-1.4100424,2.2726183,-1.4341072,-2.3923032,0.40252376,-1.0482728,0.3149498,-0.021224154,-1.8693409}},
      {{-0.017982366,-0.02956959,0.04937496,0.025272338,0.025021356,0.047810376,0.024622727,-0.10473701,-0.076471314,0.20581442,-0.22651699,-1.8011554,-4.5716,-1.2459857,-0.1686769,0.08636565,-0.9360141}},
      {{0.19960855,0.059539206,0.14097963,0.066011444,-0.21054573,0.1009663,0.049542442,-0.0034582338,-0.07332075,0.0008924958,-0.03696889,2.0958745,-2.1408525,-3.3592536,0.2758657,-0.09337859,2.266475}}
    }};

    h1_h2 = {{
      {{-4.265617,0.24798045,-0.50341547,-0.31926513,-0.07342759,5.0450783,-0.030697629,-0.20700672,-12.073285,3.0752728,-0.63459986,0.1907879,-0.09655047,-0.5262697,-0.13294284,-0.1633057,-0.8429443,1.4031397,-0.088877775,-0.16360453,0.70319355,0.123940796}},
      {{-0.36963665,0.25334343,-0.46280488,-0.41889626,0.19875103,0.2324809,-0.6881051,-0.67164683,-4.7286644,0.9836841,-0.33007404,-0.038086757,0.31559727,-0.67503077,-0.43589687,-1.0383323,1.1837955,0.9521481,-10.117554,0.11597285,-2.556,-0.36800715}},
      {{-0.1809887,-0.055391986,-0.58536655,0.14825599,-9.077236,-0.2524324,0.1416249,-1.9068301,6.5443687,-0.08926083,-0.09756802,-0.038713306,0.23974456,-1.7281436,0.08590566,0.12403688,-0.00062715675,1.6275297,-0.04947127,-0.7360949,0.8120835,-0.2683769}},
      {{0.11655636,0.06843575,-0.4932932,-0.006080044,-0.050519463,-0.42892262,0.020239795,-0.1725422,0.9801051,0.15028965,0.00027104028,-14.239421,-0.054584507,-0.4209949,-0.43480492,0.1919918,0.0760325,1.1398059,0.048387844,-0.45378342,1.7384953,0.047726505}},
      {{0.09878524,0.064528,-0.36552,3.2384946,-0.9183956,0.5949416,0.11850218,-1.0124962,6.7672954,0.43227848,-0.7244845,0.0026891232,-0.54175377,-2.4866004,0.5462985,0.22633028,-0.57082266,0.26118636,-0.6197709,-1.5884782,-0.48226154,0.31032923}},
      {{-1.4200524,0.4157732,0.12259993,-0.007986256,0.097592786,-2.9753609,-0.07821006,-0.1653261,-13.506453,-3.7045174,-0.1193348,0.32124367,0.164562,-2.9504476,-0.8967655,-0.31631193,-1.6903342,-0.8884762,-0.16868156,0.14338447,-3.753348,-0.2676231}},
      {{-2.2516656,-1.8158742,-0.36337352,0.88352364,0.32778883,-0.18776007,-0.3067254,-0.13630791,-2.2459576,0.47879136,-1.0329776,-0.2907577,0.36642295,-0.020196252,2.127359,-2.7398548,-0.83372366,0.62835646,-0.99533194,-0.18753336,-0.3283361,-0.12078951}},
      {{-0.14529055,0.6278528,-0.32390738,0.8886115,-1.4030404,0.13609882,-0.20102826,-1.7287903,-3.6438138,0.55498594,-0.71678275,0.40273213,-2.5075796,-2.703902,-0.04034642,-0.87042284,-0.72242427,1.8010403,-1.4348211,-3.2383,-0.39380345,0.21439897}},
      {{-0.037637692,-5.369246,-1.1100491,0.5047704,0.024773518,0.23842673,-5.771534,0.29385826,-3.2816565,0.05742349,-1.1272424,0.69816464,-0.1748027,-2.0350552,-0.43550187,-2.4776654,0.93838644,1.3376044,-0.19530918,-0.3744342,1.1029145,-1.834356}},
      {{-1.4445395,0.60900253,-0.27735674,0.20126285,-0.06648749,-0.41862163,-0.045865238,-0.3142043,11.660124,0.08622034,-0.19685738,0.13203673,0.10626309,-0.6024614,0.014741635,-0.7112421,0.9962208,0.8339482,-2.1655865,-0.4921871,7.790991,-0.09939433}},
      {{-0.62441856,-0.6660139,-0.85410106,-0.67517227,-1.0631124,-0.030735832,-0.11354815,-0.8397165,-1.3317312,0.5991855,-2.243069,0.0034823106,0.5600892,-1.3355744,1.1081069,1.4955914,-2.2962446,-1.5105172,-0.9108367,-0.2858115,-1.1169621,-1.2531825}},
      {{1.7529962,0.122745745,-1.3598723,-3.9499183,-6.7197948,-0.50360966,0.22881082,2.6235998,10.198843,0.21661586,-0.78124183,-0.54587674,0.7450198,4.7773533,-3.7711828,-0.2599673,-0.477241,-1.2119023,1.0563862,3.0914297,-2.2172768,-0.74768144}},
      {{-1.0442553,-0.73276174,0.3167902,0.088923186,-0.5127382,2.2841282,0.4789474,-0.65145946,3.8056436,1.8665556,-1.4807585,-0.43445298,-0.61795527,0.63925415,0.53964746,1.4437469,-1.1119539,-1.0281796,-0.9939354,-0.620679,4.8831544,0.557091}},
      {{0.12765615,0.22309732,-1.4671376,0.1486819,0.36160085,0.021718718,-2.0637994,-1.0208915,-8.095934,0.4221694,-0.71732354,-0.0057376525,-6.825433,-2.3815289,0.60003597,-0.28731105,0.4070029,0.45173845,-0.19542594,-0.51222265,0.3651403,-0.68101907}},
      {{-0.066369906,-0.24450532,-1.4653983,-2.0056357,-5.263404,0.14611483,-0.27199078,-0.38222,-7.6667705,0.311654,-0.38430366,-0.12764281,0.43543324,-1.3323034,0.05789574,-0.51821846,-1.2737731,1.57912,-0.96527433,-1.8094223,1.4693503,-1.3270977}},
      {{0.30496734,-0.019444171,-0.38229498,0.8660317,-0.20159657,0.6355992,0.06921294,-3.1421409,-5.606283,2.5951357,-0.96543664,0.029560825,-1.6946635,-3.8560176,-0.26153037,-0.22350056,-1.4982623,1.315151,-0.36685386,-1.0895768,-1.5931349,1.8852314}},
      {{-1.8709626,-3.7594268,-1.0161687,0.29098952,0.7870975,-0.168655,-0.23202915,-0.9141201,1.0630281,0.33806565,-1.7527275,-0.38445154,-1.9058404,-0.028824026,0.95813924,0.67607003,-1.0545658,0.118769035,0.21535246,-1.3452618,3.1653476,1.4948823}},
      {{1.1776047,-2.0482864,-0.32693642,0.29708117,-0.011059524,-1.781698,0.11358092,-2.475162,-2.5707486,-0.99538463,-0.118849695,0.37446344,0.19732516,-2.173338,-1.0597148,-1.1253419,0.27260408,0.93345594,0.08982035,-1.0581906,0.25283104,-0.17236827}},
      {{6.1419487,-0.14387767,-0.024651233,0.10537182,-0.08150009,0.16779737,-0.15378265,-0.17457269,-6.939655,0.6260578,-0.85097104,0.37818864,0.005643344,-0.67245483,-1.5184827,-1.7029158,0.0676868,0.5598221,0.059500962,-0.21227734,-2.2696407,0.086881936}},
      {{-2.1183264,-0.19364575,-0.6083517,0.34304616,0.12346917,0.5810285,-0.1469552,-0.1629677,-4.3059616,0.86025465,-0.4557506,-2.020571,0.007831413,-1.9356154,2.3168094,-1.3491908,-1.1210121,1.5081089,-0.40575293,-0.18536071,-0.96927816,0.04714295}}
    }};

    h2_out = {{
      {{-0.11302813,3.1013553,-1.0753176,-0.27839482,-3.7686145,-0.15781054,-2.5692856,-0.39712134,-1.5078151,0.7696371,-5.0657887,-2.4836607,-2.8747454,0.38376394,-1.1433069,-2.31463,-7.464399,-1.2356255,-0.25704372,-1.082457}},
      {{-2.9808433,3.404618,-1.3659927,0.22257258,-0.71989286,0.44628155,-4.5824184,-0.23525749,-1.608447,1.7714282,-3.4475489,-1.528064,-1.8795768,1.3847284,-0.53324693,-3.9607172,-6.979113,-0.38382852,0.6838115,-1.7737893}},
      {{-4.800733,2.5253592,-1.0996608,1.7034364,0.06718629,0.6581236,-8.576919,0.49983633,-1.6905285,0.9231333,-2.651007,-2.6562176,-0.92214143,1.2157456,-0.26528886,-0.4721492,-4.160807,-0.52827805,1.0483861,-2.6652563}},
      {{-2.9370883,0.1891951,-0.4836841,2.132101,0.22966,0.29780138,-6.928151,0.5587685,-1.6999376,-0.8455983,-0.28009892,-1.7755541,0.30547556,0.1906632,0.14005262,0.81310695,-0.46830457,-0.34741735,1.4704947,-3.104054}},
      {{-5.007013,-2.3269753,0.27086353,1.9061526,0.12956892,0.69364804,-10.237303,0.06704852,-1.9990404,-3.5411432,1.677441,-2.6203053,0.63686764,-0.559966,0.7696551,-0.8761773,0.41178495,-0.16507815,1.0068259,-1.7088934}},
      {{-4.376595,-2.7513397,0.36433354,0.6598737,-0.49058962,0.6273959,-7.267412,-2.9225104,-0.90002406,-3.4731157,3.0029936,-2.4372723,0.31084478,-0.3784673,0.8019991,-2.1112125,0.6076483,0.21284199,0.17598157,-1.5302515}},
      {{-0.9164378,-3.094283,0.06825681,0.15114294,-3.0765893,0.3865406,-2.766121,-6.5083075,-1.1571214,-3.2954292,2.654162,-3.1775827,-0.817561,-1.1457312,0.34744594,0.4814382,0.4801759,-0.85023564,-0.28460574,-0.9833158}},
      {{-1.494488,3.0127263,-1.7289864,-0.28989553,-8.972203,0.37882972,-1.1662775,-0.51783454,-1.0875176,1.5400443,-4.697568,-0.6187973,-1.1992983,0.010231776,-1.9201252,-3.737287,-5.5443935,-1.9812115,-1.0318743,0.469751}},
      {{-0.94435513,2.0718338,-1.6237359,-0.104248405,-1.707079,0.4820406,-2.4841466,-0.43703446,-1.3685482,2.017604,-4.7036276,1.5747875,-0.34537318,1.3030951,-0.998771,-4.8549666,-3.4870014,-0.64794517,-0.622365,-0.18949439}},
      {{-4.1234975,1.5563742,-1.3297307,1.0064185,-0.15173608,0.9503225,-3.4682658,0.20529763,-1.7927687,1.2432464,-1.7389731,-1.159585,-0.23355275,1.1253315,-0.85896987,-1.5262291,-1.8570014,-0.94568866,0.13291483,-0.4342968}},
      {{-3.5905254,0.13304378,-0.33855477,2.0843973,0.24935862,0.7219115,-6.0199947,0.45144203,-1.6625401,-0.19406658,-0.5374367,1.4254178,0.9660861,0.15280078,0.19596952,0.8702314,0.12341681,-1.0316608,0.52547485,-1.1649137}},
      {{-4.7512956,-1.7992562,0.537542,0.8982979,0.13263364,1.0316682,-4.4165845,0.0024966777,-2.5097325,-1.6171806,1.8586543,-1.7585174,0.79008865,-1.0142896,0.6748312,-2.0986881,0.25188032,-0.90910006,0.21575879,-0.052197196}},
      {{-1.3676249,-1.72092,0.51642096,0.17467679,-1.0803189,1.0088973,-2.8172626,-4.9085574,-1.1852441,-2.059114,2.6919806,-0.22985955,0.43282825,-1.2519132,0.8748157,-1.7127163,0.4258542,-0.5405563,-0.18854234,-0.21368772}},
      {{-2.0323844,-2.5148485,0.2694878,0.053394925,-4.7801843,0.7547379,-1.3942997,-10.423931,-0.8458333,-2.6556132,2.6897047,-2.3079293,0.103228815,-2.3091776,0.113182686,-0.897559,0.5463738,-1.4006472,-1.1720119,0.602564}},
      {{-0.62009853,2.6242867,-2.5888634,-0.31763205,-8.960055,0.14554839,0.30908003,-6.9856954,-0.96743894,1.0293233,-4.551239,-0.36853957,-0.70085806,0.10463352,-3.4003577,-4.1964107,-3.1940055,-1.1374362,-1.0538179,0.75124717}},
      {{-1.973024,1.4010211,-2.6551745,-0.067469776,-2.261388,0.3295778,-0.11674209,-2.8343444,-1.5133187,1.3354973,-3.544713,0.315369,-0.35839748,1.4913617,-1.61091,-7.013367,-1.9904461,-0.33359498,-0.7122886,0.6711977}},
      {{-0.4099141,0.7151922,-1.1466472,-0.1944941,0.15296449,0.2803091,-0.8166342,0.32860625,-1.8206716,0.5376873,-1.5232245,-0.74629664,-0.8244287,1.0351629,-1.1107135,-1.0625445,-0.6627602,-0.66706795,-0.59750026,0.73997754}},
      {{-1.2174032,-0.034219667,-0.11438208,0.8405198,0.27012768,-0.25556993,-0.5366693,0.41570807,-1.3557055,-0.16867062,-0.50899893,-1.189708,0.19017409,0.20343938,-0.12640378,0.8359806,0.31595355,-0.7747517,-0.6474773,0.7991212}},
      {{-0.6494714,-1.1428351,0.7721277,-0.04454878,0.03911997,0.23249377,-0.82489425,-0.1804981,-1.7695645,-0.974414,0.83981776,-0.30206215,-0.24470717,-0.9966169,0.7450369,-0.7879337,0.3471997,-0.6947218,-0.58187,0.78305286}},
      {{-1.3162193,-1.0440007,0.7458484,-0.09473911,-2.7961018,0.49806225,-0.27152255,-4.908027,-1.0531937,-1.6347433,2.3153267,-0.78756505,-0.14454329,-2.957495,1.1097945,-4.1108727,-0.10330945,-0.51679516,-0.42097965,0.81601596}},
      {{-1.2519666,-1.8423321,0.31546098,-0.13974148,-7.478501,0.3004394,0.095639616,-9.522021,-0.76075673,-2.4446578,2.2968512,-2.0894268,0.057463076,-5.121408,0.6559758,-3.7936816,-0.022382796,-0.994886,-0.8176789,0.8701796}},
      {{0.8694902,0.6744171,-2.5081835,-0.69051725,-6.7207346,0.025369765,0.58094436,-7.330454,-0.6701836,-0.59410244,-0.9901,0.24561504,-0.19066186,-0.6217328,-4.396617,-0.24711618,-0.17955849,-1.0413642,-0.010526946,0.755032}},
      {{0.84627515,0.45023054,-2.5118053,-0.3752236,-3.1060135,0.09679725,0.60657626,-5.286415,-1.1073924,0.26662827,-1.7532427,2.427106,-0.04635438,1.4919909,-3.3155699,-5.3088093,0.20913284,-0.32170555,0.19199146,0.71530306}},
      {{0.83356416,0.060803045,-1.9350902,-0.5964506,0.1345652,-0.30240583,0.59393364,0.12404559,-1.0121974,-0.12345394,-0.28347355,-0.59680146,-0.4326742,0.8235135,-1.5969145,-1.1329682,0.17748529,-0.7083395,-0.02299394,0.7673458}},
      {{0.89970654,-0.1629608,0.04205346,-0.7846839,0.24970944,-1.3980564,0.57323515,0.4200288,-1.0461344,-0.164008,-0.6692219,2.7679586,1.1438873,0.2398781,-0.28577378,0.8861656,0.31271553,-0.71739864,-0.72158134,0.76430887}},
      {{0.8884262,-0.035943378,0.68725777,-0.53435487,-0.13421817,-0.64136475,0.56082165,-0.25214645,-0.66927975,-0.5073642,0.27157235,-0.2372839,-0.5781322,-1.787045,0.6490409,-1.1577576,0.070655726,-0.6642889,-0.24966423,0.77609104}},
      {{0.9156029,0.20870641,0.6149127,-0.48691288,-4.0529313,-0.23555548,0.5519121,-4.7672024,-0.4341507,-0.59194416,0.87652117,1.1310089,-0.55576164,-4.3446236,1.3131607,-4.5438657,-0.55907124,-0.3724567,0.060288318,0.7541777}},
      {{0.8761585,0.1949724,-0.054912567,-0.82147807,-7.1863265,-0.23758857,0.58979267,-7.1169157,-0.64233,-0.7014453,-0.034128763,-0.32006958,-0.6348796,-5.755368,1.133224,-0.4714468,-0.77596384,-0.9392874,0.019344615,0.75225216}},
      {{-0.8668286,-1.8419628,-2.5231214,-0.6197707,-9.366288,0.41913754,0.54229635,-10.960323,0.07662602,-2.5780432,0.22219719,0.14585398,0.6916552,0.7108534,-4.1855206,-3.7745447,0.6159958,-0.8275918,-0.83343136,0.54095596}},
      {{-1.7113209,-1.6097319,-2.3985944,-0.48709056,-2.7053146,0.29344407,0.36082187,-4.965337,0.18248427,-0.5761483,-1.0080047,1.0952984,0.41502497,1.6839106,-2.3534167,-3.7837234,0.76646584,0.011151525,-0.51252556,0.12592103}},
      {{0.15740907,-0.92005724,-1.2981673,-0.35522366,0.17034246,-0.2551143,0.5698437,-0.21148318,0.3426285,-0.61314285,0.46071795,0.55183893,-0.6863347,1.0289378,-2.1899314,-0.557328,0.53553414,0.17943989,-0.1719259,-0.26498985}},
      {{-0.440511,0.13824093,-0.11244122,-1.3742715,0.21990126,-0.70254254,0.6004561,0.43345186,0.27538183,0.11737389,-0.18606171,-0.94419706,0.410316,-0.03343436,-0.8683151,0.95547956,0.31305256,0.057981644,-0.15404662,-1.0565668}},
      {{0.24467544,0.5279804,0.50104076,-0.45807374,-0.11237076,-0.6041689,0.5933665,0.115861595,0.73778206,0.48589158,-0.6686835,-0.7737601,-1.0519431,-1.2870551,0.28888837,-1.029045,-1.0391903,0.036276318,-0.4989122,-0.19783235}},
      {{-1.85295,1.1073431,0.6273372,-0.6931552,-3.57965,-0.31796193,0.59246004,-2.013674,0.7970615,0.40789974,-0.2254504,-0.03435181,-1.177221,-2.9139743,1.219476,-6.38413,-2.7774513,-0.2745224,-0.60163575,-0.04945367}},
      {{-0.40856934,1.793198,0.21343367,-0.876706,-7.7870684,-0.24163997,0.62773776,-4.639148,0.6442336,0.37294218,-1.642914,-1.284674,-1.3869933,-4.8794575,0.8254633,-3.4335983,-2.5983493,-1.1305146,-1.0656145,0.26094884}},
      {{-1.5943118,-2.9993625,-1.429982,-0.9935314,-5.6642933,0.5301051,-0.3289419,-11.582482,1.1057198,-2.9514751,1.2120496,-0.23568256,-0.20105904,0.9020697,-3.5782351,-0.86594397,0.93594664,-1.0873847,-0.32160217,-0.36594453}},
      {{-1.1094959,-2.311067,-1.6918317,-0.28527316,-1.8203118,0.104413114,-0.78708357,-5.3174787,1.2520328,-1.7648649,0.94362646,1.1313117,-0.032096412,1.7439438,-2.3890545,-1.0488213,0.94097555,0.44670078,0.2971006,-1.091758}},
      {{-0.7010182,-1.8691782,-1.3942387,-0.694436,0.1268093,0.035078656,-0.2833708,-0.36309427,1.3580078,-1.5376247,0.06723503,0.12831518,-0.3641818,1.1644698,-1.9278591,-1.3726063,0.5175776,0.6576815,1.4020889,-2.128613}},
      {{-1.8697511,0.27548262,-0.37368304,-1.2513887,0.21663506,-0.12955266,-0.50680333,0.45469666,1.3593924,-0.19642913,-0.38354832,1.6510788,0.5377468,-0.19051494,-0.8492657,0.9553039,-0.02980964,0.47046295,2.2677963,-5.2665176}},
      {{-5.0652547,1.1365253,0.1816972,-0.74396026,-0.31092507,-0.24351814,0.15865542,0.13117371,1.3711649,0.7912165,-2.2961092,-1.0713974,-0.79285294,-1.2394229,0.53398764,-2.164641,-2.1190088,0.4853579,1.2705479,-2.3844426}},
      {{-0.74758154,1.5810094,0.31425375,-0.5444322,-2.2941163,-0.53161776,0.11373614,-0.24704,1.219692,1.261429,-1.4707344,0.36209735,-1.3876033,-1.777231,0.87759334,-4.4115443,-5.1381035,0.023384308,0.12655573,-1.3839018}},
      {{-2.3478143,2.336497,0.057932563,-1.0501305,-7.2227297,-0.0885818,0.30756518,-0.1986253,1.1108487,1.0997059,-2.0714235,-1.5051955,-1.6069002,-3.3152843,-0.07631964,-5.692199,-4.2831483,-1.1609458,-0.6601059,-0.6551451}},
      {{-0.6828672,-3.6943924,-1.0109963,-0.5675709,-2.7799315,0.13621975,-2.2874942,-5.966041,0.24331005,-3.188541,1.9992528,-2.8101926,-1.0807192,0.6681028,-2.7283733,0.46888068,0.62187034,-0.52274615,-0.057808433,-1.5281148}},
      {{-2.345792,-3.359005,-1.4361659,-0.057814326,-1.1251912,0.060760316,-2.6158497,-3.2848542,0.777303,-3.811068,1.6957968,-0.20291427,-0.5430897,1.8672738,-1.5676363,-1.2345897,0.90690553,1.2248281,1.2165014,-2.0003457}},
      {{-2.3129618,-2.3848693,-1.1118659,-0.61022925,0.10724824,-0.07624641,-2.8583932,-0.16470583,1.171676,-3.4555192,0.9676993,-0.86112773,-0.6121912,1.3026167,-1.8757887,-0.17617099,0.46387652,1.0585791,2.5743992,-4.6709166}},
      {{-3.2172067,-0.033372648,-0.4185175,-0.5933314,0.21591215,0.00048612984,-2.5691862,0.5122878,0.87190306,-0.61972207,-1.3287953,-0.9004783,0.26881,0.014885339,-0.2618467,0.92507833,-0.50481486,0.5480487,3.0048516,-6.279689}},
      {{-5.6558805,1.9626898,0.042700306,-0.52332795,-0.05855856,-0.37910888,-1.7007251,0.4102458,1.3163912,0.56263703,-3.0100663,-1.9191312,-1.1893446,-0.6643594,0.55183417,-1.0029821,-3.5956256,0.96710515,2.039576,-4.486082}},
      {{-2.4933233,2.4111745,0.26635852,-0.45154768,-1.0376494,-0.4364323,-1.247194,-0.061501574,0.50781035,1.2186687,-1.7826884,-1.5999938,-2.1836047,-0.46088737,0.67823434,-3.8478591,-7.954169,0.45879564,0.8592002,-2.3055942}},
      {{-0.36501542,2.7201357,-0.027633503,-0.70432484,-3.0426884,-0.29447764,-1.1843257,-0.037301544,0.23185831,0.19497268,-1.7775892,-2.5391438,-3.5133677,-1.8233314,-0.32716715,-1.8274794,-7.339109,-1.0563016,-0.23508342,-1.5474701}}
    }};

    b1 = {
      -0.213346, 0.028760426, -0.014551441, 0.19894181, -0.022308297, -0.1164823, -0.10068269, -0.27621564, -0.40333724, 0.020169264, 0.32942092, 0.053830616, -0.028252268, -0.30931965, 0.23553668, -0.019832443, 0.2599094, 0.21252474, 0.025738265, 0.008634177, -0.33617315, -0.08116614
    };

    b2 = {
      -0.41990316, 0.003051797, 0.2967776, 0.28330138, 0.1398859, 0.14001136, -0.0330835, -0.05267117, -0.07704713, 0.20691288, -0.032469373, -0.11905696, 0.4676714, -0.052492928, -0.06500218, -0.15530805, 0.007389827, 0.06515267, 0.017715806, 0.23577581
    };

    bout = {
      -3.6814597, -2.6710703, -2.148799, -1.051703, -1.8366822, -2.093628, -3.1320689, -3.5612848, -0.98160565, -1.2413034, 0.4675489, -1.126994, -0.8508381, -2.9411595, -3.000064, -1.289711, 0.17994691, 1.0642827, 0.38848725, -1.1161627, -2.6535866, -1.700216, 0.058825, 0.80536807, 3.7559142, 1.106547, 0.06865467, -1.6879978, -3.0259187, -1.0173445, 0.39390498, 1.0848408, 0.41924372, -1.2039295, -2.6750083, -3.4938836, -0.84398335, -1.1504238, 0.16916405, -1.1938165, -0.9909545, -3.2553968, -3.4495747, -2.0991328, -2.1259074, -1.4073397, -1.9715292, -2.342783, -3.58193
    };

    BN_gamma_in = {
      0.5250117, 0.49629182, 0.43587452, 0.58271205, 0.67215633, 0.4201203, 0.5164243, 0.7354392, 0.0055419207
    };

    BN_gamma_1 = {
      3.1082547, 4.1881394, 3.5150673, 1.7783523, 7.339819, 4.321002, 8.322755, 2.6939805, 23.612686, 1.8386278, 2.5973883, 6.9100804, 5.786443, 5.342283, 2.0216637, 3.717042, -1.4394021, 1.4551395, 7.0769815, 1.744616, 20.886349, 6.356341
    };

    BN_gamma_2 = {
      1.4668213, 4.489821, 1.9612845, 2.304053, 1.260486, 1.504819, 2.09106, 2.2705712, 3.058992, 2.1272624, 3.5009131, 2.4203718, 1.4101518, 3.132666, 4.907079, 1.5661591, 2.3501859, 1.8748721, 3.7388186, 1.5214491
    };

    BN_beta_1 = {
      -0.2092613, -0.024161045, -0.0052127684, -0.054882538, -0.0106112715, -0.05805744, -0.0025749907, -0.13063458, -0.0070461337, -0.110239804, -0.3808496, -0.022893522, -0.016584462, -0.032185704, -0.032526754, -0.07607417, 0.2425467, -0.23849145, -0.009978011, -0.42775485, -0.0020245172, -0.0051668365
    };

    BN_beta_2 = {
      -0.030887755, -0.25623792, -0.56962025, -0.7683961, -0.1471507, -0.2866278, -0.043858577, -0.04609389, -0.16695924, -0.33157605, -0.12269447, -0.1584389, -0.69046485, -0.15786712, -0.1212441, -0.04696738, -0.11082168, -0.43992463, -0.41754964, -0.428991
    };
    
    mean = {
      29399.300583080498,14318.203565548843,29480.87822874806,20000.565122546792,1491.075400210116,19996.878566931184,29362.43210456565,14171.993571666819,29280.433639232095
    };

    stdev = {
      255805.55015089098,159473.2063764945,253776.56036758004,171764.17246911535,31669.903441595776,171635.74602046044,254184.71595278895,159578.54893437275,255845.69749753462
    };
  }
  
}


__inline Void TEncSearch::xTZSearchHelp( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const Int iSearchX, const Int iSearchY, const UChar ucPointNr, const UInt uiDistance )
{
  Distortion  uiSad = 0;

  const Pel* const  piRefSrch = rcStruct.piRefY + iSearchY * rcStruct.iYStride + iSearchX;

  //-- jclee for using the SAD function pointer
  m_pcRdCost->setDistParam( pcPatternKey, piRefSrch, rcStruct.iYStride,  m_cDistParam );

  setDistParamComp(COMPONENT_Y);

  // distortion
  m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
  m_cDistParam.m_maximumDistortionForEarlyExit = rcStruct.uiBestSad;

  if((m_pcEncCfg->getRestrictMESampling() == false) && m_pcEncCfg->getMotionEstimationSearchMethod() == MESEARCH_SELECTIVE)
  {
    Int isubShift = 0;
    // motion cost
    Distortion uiBitCost = m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

    // Skip search if bit cost is already larger than best SAD
    if (uiBitCost < rcStruct.uiBestSad)
    {
      if ( m_cDistParam.iRows > 32 )
      {
        m_cDistParam.iSubShift = 4;
      }
      else if ( m_cDistParam.iRows > 16 )
      {
        m_cDistParam.iSubShift = 3;
      }
      else if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 2;
      }
      else
      {
        m_cDistParam.iSubShift = 1;
      }

      Distortion uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
      if((uiTempSad + uiBitCost) < rcStruct.uiBestSad)
      {
        uiSad += uiTempSad >>  m_cDistParam.iSubShift;
        while(m_cDistParam.iSubShift > 0)
        {
          isubShift         = m_cDistParam.iSubShift -1;
          m_cDistParam.pOrg = pcPatternKey->getROIY() + (pcPatternKey->getPatternLStride() << isubShift);
          m_cDistParam.pCur = piRefSrch + (rcStruct.iYStride << isubShift);
          uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
          uiSad += uiTempSad >>  m_cDistParam.iSubShift;
          if(((uiSad << isubShift) + uiBitCost) > rcStruct.uiBestSad)
          {
            break;
          }

          m_cDistParam.iSubShift--;
        }

        if(m_cDistParam.iSubShift == 0)
        {
          uiSad += uiBitCost;
          if( uiSad < rcStruct.uiBestSad )
          {
            rcStruct.uiBestSad      = uiSad;
            rcStruct.iBestX         = iSearchX;
            rcStruct.iBestY         = iSearchY;
            rcStruct.uiBestDistance = uiDistance;
            rcStruct.uiBestRound    = 0;
            rcStruct.ucPointNr      = ucPointNr;
            m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
          }
        }
      }
    }
  }
  else
  {
    // fast encoder decision: use subsampled SAD when rows > 8 for integer ME
    if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE3 )
    {
      if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 1;
      }
    }

    uiSad = m_cDistParam.DistFunc( &m_cDistParam );

    // EMI: Modification "array_e & counter_i"
    array_e[counter_i] = uiSad;
    
    // only add motion cost if uiSad is smaller than best. Otherwise pointless
    // to add motion cost.
    if( uiSad < rcStruct.uiBestSad )
    {
      // motion cost
      uiSad += m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

      if( uiSad < rcStruct.uiBestSad )
      {
        rcStruct.uiBestSad      = uiSad;
        rcStruct.iBestX         = iSearchX;
        rcStruct.iBestY         = iSearchY;
        rcStruct.uiBestDistance = uiDistance;
        rcStruct.uiBestRound    = 0;
        rcStruct.ucPointNr      = ucPointNr;
        m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
      }
    }
  }
  counter_i = counter_i + 1;
}

__inline Void TEncSearch::xTZ2PointSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB )
{
  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 2 point search,                   //   1 2 3
  // check only the 2 untested points  //   4 0 5
  // around the start point            //   6 7 8
  Int iStartX = rcStruct.iBestX;
  Int iStartY = rcStruct.iBestY;
  switch( rcStruct.ucPointNr )
  {
    case 1:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY, 0, 2 );
      }
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
    }
      break;
    case 2:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 3:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
    }
      break;
    case 4:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 5:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 6:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY , 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    case 7:
    {
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 8:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    default:
    {
      assert( false );
    }
      break;
  } // switch( rcStruct.ucPointNr )
}




__inline Void TEncSearch::xTZ8PointSquareSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iTop >= iSrchRngVerTop ) // check top
  {
    if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
    }
    // top middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );

    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
    }
  } // check top
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
  }
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
  }
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
    if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
    }
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );

    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
    }
  } // check bottom
}


//additing other square search

__inline Void TEncSearch::xTZ8PointSquareSearch2( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;
// check top
  if ( iTop >= iSrchRngVerTop ) // check top
  {
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iLeft, iTop, 9, iDist);
    }
	  
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iStartX - 1, iTop, 10, iDist);
    }
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 11, iDist );
	
	if (iRight <= iSrchRngHorRight) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX +1, iTop, 12, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 13, iDist );
    }
  }

  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY-1, 14, iDist );
  }

  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY-1, 15, iDist );
  }
  
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 16, iDist );
  }
  
  
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 17, iDist );
  }
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY+1, 18, iDist );
  }
  
  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY+1, 19, iDist );
  }
  
  
  
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 20, iDist );
    }  
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iBottom, 21, iDist );
    }   
	  
	  
    
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 22, iDist );

	if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iBottom, 23, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 24, iDist );
    }
  } 
  
  // check bottom
}











__inline Void TEncSearch::xTZ8PointDiamondSearch( const TComPattern*const  pcPatternKey,
                                                  IntTZSearchStruct& rcStruct,
                                                  const TComMv*const  pcMvSrchRngLT,
                                                  const TComMv*const  pcMvSrchRngRB,
                                                  const Int iStartX,
                                                  const Int iStartY,
                                                  const Int iDist,
                                                  const Bool bCheckCornersAtDist1 )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert ( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iDist == 1 )
  {
    if ( iTop >= iSrchRngVerTop ) // check top
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
      }
    }
    if ( iLeft >= iSrchRngHorLeft ) // check middle left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
    }
    if ( iRight <= iSrchRngHorRight ) // check middle right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
    }
    if ( iBottom <= iSrchRngVerBottom ) // check bottom
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
      }
    }
  }
  else
  {
    if ( iDist <= 8 )
    {
      const Int iTop_2      = iStartY - (iDist>>1);
      const Int iBottom_2   = iStartY + (iDist>>1);
      const Int iLeft_2     = iStartX - (iDist>>1);
      const Int iRight_2    = iStartX + (iDist>>1);

      if (  iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iTop,      2, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iTop_2,    1, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2,    3, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,    iStartY,   4, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,   iStartY,   5, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iBottom_2, 6, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iBottom,   7, iDist    );
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        }
        if ( iTop_2 >= iSrchRngVerTop ) // check half top
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iTop_2, 1, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2, 3, (iDist>>1) );
          }
        } // check half top
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
        }
        if ( iBottom_2 <= iSrchRngVerBottom ) // check half bottom
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iBottom_2, 6, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, (iDist>>1) );
          }
        } // check half bottom
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        }
      } // check border
    }
    else // iDist > 8
    {
      if ( iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop,    0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,   iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,  iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
        }
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 0, iDist );
        }
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 0, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 0, iDist );
        }
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        }
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);

          if ( iPosYT >= iSrchRngVerTop ) // check top
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
            }
          } // check top
          if ( iPosYB <= iSrchRngVerBottom ) // check bottom
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
            }
          } // check bottom
        } // for ...
      } // check border
    } // iDist <= 8
  } // iDist == 1
}

Distortion TEncSearch::xPatternRefinement( TComPattern* pcPatternKey,
                                           TComMv baseRefMv,
                                           Int iFrac, TComMv& rcMvFrac,
                                           Bool bAllowUseOfHadamard
                                         )
{
  Distortion  uiDist;
  Distortion  uiDistBest  = std::numeric_limits<Distortion>::max();
  UInt        uiDirecBest = 0;

  Pel*  piRefPos;
  Int iRefStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);

  m_pcRdCost->setDistParam( pcPatternKey, m_filteredBlock[0][0].getAddr(COMPONENT_Y), iRefStride, 1, m_cDistParam, m_pcEncCfg->getUseHADME() && bAllowUseOfHadamard );

  const TComMv* pcMvRefine = (iFrac == 2 ? s_acMvRefineH : s_acMvRefineQ);

  for (UInt i = 0; i < 9; i++)
  {
    TComMv cMvTest = pcMvRefine[i];
    cMvTest += baseRefMv;

    Int horVal = cMvTest.getHor() * iFrac;
    Int verVal = cMvTest.getVer() * iFrac;
    piRefPos = m_filteredBlock[ verVal & 3 ][ horVal & 3 ].getAddr(COMPONENT_Y);
    if ( horVal == 2 && ( verVal & 1 ) == 0 )
    {
      piRefPos += 1;
    }
    if ( ( horVal & 1 ) == 0 && verVal == 2 )
    {
      piRefPos += iRefStride;
    }
    cMvTest = pcMvRefine[i];
    cMvTest += rcMvFrac;

    setDistParamComp(COMPONENT_Y);

    m_cDistParam.pCur = piRefPos;
    m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
    uiDist = m_cDistParam.DistFunc( &m_cDistParam );
    uiDist += m_pcRdCost->getCostOfVectorWithPredictor( cMvTest.getHor(), cMvTest.getVer() );

    if ( uiDist < uiDistBest )
    {
      uiDistBest  = uiDist;
      uiDirecBest = i;
      m_cDistParam.m_maximumDistortionForEarlyExit = uiDist;
    }
  }

  rcMvFrac = pcMvRefine[uiDirecBest];

  return uiDistBest;
}



Void
TEncSearch::xEncSubdivCbfQT(TComTU      &rTu,
                            Bool         bLuma,
                            Bool         bChroma )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx         = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth            = rTu.GetTransformDepthRel();
  const UInt uiTrMode             = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt uiSubdiv             = ( uiTrMode > uiTrDepth ? 1 : 0 );
  const UInt uiLog2LumaTrafoSize  = rTu.GetLog2LumaTrSize();

  if( pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_NxN && uiTrDepth == 0 )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize > pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getSlice()->getSPS()->getQuadtreeTULog2MinSize() )
  {
    assert( !uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
  {
    assert( !uiSubdiv );
  }
  else
  {
    assert( uiLog2LumaTrafoSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );
    if( bLuma )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( uiSubdiv, 5 - uiLog2LumaTrafoSize );
    }
  }

  if ( bChroma )
  {
    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if( rTu.ProcessingAllQuadrants(compID) && (uiTrDepth==0 || pcCU->getCbf( uiAbsPartIdx, compID, uiTrDepth-1 ) ))
      {
        m_pcEntropyCoder->encodeQtCbf(rTu, compID, (uiSubdiv == 0));
      }
    }
  }

  if( uiSubdiv )
  {
    TComTURecurse tuRecurse(rTu, false);
    do
    {
      xEncSubdivCbfQT( tuRecurse, bLuma, bChroma );
    } while (tuRecurse.nextSection(rTu));
  }
  else
  {
    //===== Cbfs =====
    if( bLuma )
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }
}




Void
TEncSearch::xEncCoeffQT(TComTU &rTu,
                        const ComponentID  component,
                        Bool         bRealCoeff )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();

  const UInt  uiTrMode        = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt  uiSubdiv        = ( uiTrMode > uiTrDepth ? 1 : 0 );

  if( uiSubdiv )
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xEncCoeffQT( tuRecurseChild, component, bRealCoeff );
    } while (tuRecurseChild.nextSection(rTu) );
  }
  else if (rTu.ProcessComponentSection(component))
  {
    //===== coefficients =====
    const UInt  uiLog2TrafoSize = rTu.GetLog2LumaTrSize();
    UInt    uiCoeffOffset   = rTu.getCoefficientOffset(component);
    UInt    uiQTLayer       = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrafoSize;
    TCoeff* pcCoeff         = bRealCoeff ? pcCU->getCoeff(component) : m_ppcQTTempCoeff[component][uiQTLayer];

    if (isChroma(component) && (pcCU->getCbf( rTu.GetAbsPartIdxTU(), COMPONENT_Y, uiTrMode ) != 0) && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag() )
    {
      m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, component );
    }

    m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeff+uiCoeffOffset, component );
  }
}




Void
TEncSearch::xEncIntraHeader( TComDataCU*  pcCU,
                            UInt         uiTrDepth,
                            UInt         uiAbsPartIdx,
                            Bool         bLuma,
                            Bool         bChroma )
{
  if( bLuma )
  {
    // CU header
    if( uiAbsPartIdx == 0 )
    {
      if( !pcCU->getSlice()->isIntra() )
      {
        if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
        {
          m_pcEntropyCoder->encodeCUTransquantBypassFlag( pcCU, 0, true );
        }
        m_pcEntropyCoder->encodeSkipFlag( pcCU, 0, true );
        m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
      }
      m_pcEntropyCoder  ->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );

      if (pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_2Nx2N )
      {
        m_pcEntropyCoder->encodeIPCMInfo( pcCU, 0, true );

        if ( pcCU->getIPCMFlag (0))
        {
          return;
        }
      }
    }
    // luma prediction mode
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N )
    {
      if (uiAbsPartIdx==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, 0 );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      if (uiTrDepth>0 && (uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiAbsPartIdx );
      }
    }
  }

  if( bChroma )
  {
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N || !enable4ChromaPUsInIntraNxNCU(pcCU->getPic()->getChromaFormat()))
    {
      if(uiAbsPartIdx==0)
      {
         m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      assert(uiTrDepth>0);
      if ((uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
  }
}




UInt
TEncSearch::xGetIntraBitsQT(TComTU &rTu,
                            Bool         bLuma,
                            Bool         bChroma,
                            Bool         bRealCoeff /* just for test */ )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();
  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiTrDepth, uiAbsPartIdx, bLuma, bChroma );
  xEncSubdivCbfQT ( rTu, bLuma, bChroma );

  if( bLuma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Y,      bRealCoeff );
  }
  if( bChroma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Cb,  bRealCoeff );
    xEncCoeffQT   ( rTu, COMPONENT_Cr,  bRealCoeff );
  }
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  return uiBits;
}

UInt TEncSearch::xGetIntraBitsQTChroma(TComTU &rTu,
                                       ComponentID compID,
                                       Bool         bRealCoeff /* just for test */ )
{
  m_pcEntropyCoder->resetBits();
  xEncCoeffQT   ( rTu, compID,  bRealCoeff );
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  return uiBits;
}

Void TEncSearch::xIntraCodingTUBlock(       TComYuv*    pcOrgYuv,
                                            TComYuv*    pcPredYuv,
                                            TComYuv*    pcResiYuv,
                                            Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      const Bool        checkCrossCPrediction,
                                            Distortion& ruiDist,
                                      const ComponentID compID,
                                            TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug)
                                           ,Int         default0Save1Load2
                                     )
{
  if (!rTu.ProcessComponentSection(compID))
  {
    return;
  }
  const Bool           bIsLuma          = isLuma(compID);
  const TComRectangle &rect             = rTu.getRect(compID);
        TComDataCU    *pcCU             = rTu.getCU();
  const UInt           uiAbsPartIdx     = rTu.GetAbsPartIdxTU();
  const TComSPS       &sps              = *(pcCU->getSlice()->getSPS());

  const UInt           uiTrDepth        = rTu.GetTransformDepthRelAdj(compID);
  const UInt           uiFullDepth      = rTu.GetTransformDepthTotal();
  const UInt           uiLog2TrSize     = rTu.GetLog2LumaTrSize();
  const ChromaFormat   chFmt            = pcOrgYuv->getChromaFormat();
  const ChannelType    chType           = toChannelType(compID);
  const Int            bitDepth         = sps.getBitDepth(chType);

  const UInt           uiWidth          = rect.width;
  const UInt           uiHeight         = rect.height;
  const UInt           uiStride         = pcOrgYuv ->getStride (compID);
        Pel           *piOrg            = pcOrgYuv ->getAddr( compID, uiAbsPartIdx );
        Pel           *piPred           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piResi           = pcResiYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piReco           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
  const UInt           uiQTLayer        = sps.getQuadtreeTULog2MaxSize() - uiLog2TrSize;
        Pel           *piRecQt          = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
  const UInt           uiRecQtStride    = m_pcQTTempTComYuv[ uiQTLayer ].getStride(compID);
  const UInt           uiZOrder         = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
        Pel           *piRecIPred       = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
        UInt           uiRecIPredStride = pcCU->getPic()->getPicYuvRec()->getStride  ( compID );
        TCoeff        *pcCoeff          = m_ppcQTTempCoeff[compID][uiQTLayer] + rTu.getCoefficientOffset(compID);
        Bool           useTransformSkip = pcCU->getTransformSkip(uiAbsPartIdx, compID);

#if ADAPTIVE_QP_SELECTION
        TCoeff        *pcArlCoeff       = m_ppcQTTempArlCoeff[compID][ uiQTLayer ] + rTu.getCoefficientOffset(compID);
#endif

  const UInt           uiChPredMode     = pcCU->getIntraDir( chType, uiAbsPartIdx );
  const UInt           partsPerMinCU    = 1<<(2*(sps.getMaxTotalCUDepth() - sps.getLog2DiffMaxMinCodingBlockSize()));
  const UInt           uiChCodedMode    = (uiChPredMode==DM_CHROMA_IDX && !bIsLuma) ? pcCU->getIntraDir(CHANNEL_TYPE_LUMA, getChromasCorrespondingPULumaIdx(uiAbsPartIdx, chFmt, partsPerMinCU)) : uiChPredMode;
  const UInt           uiChFinalMode    = ((chFmt == CHROMA_422)       && !bIsLuma) ? g_chroma422IntraAngleMappingTable[uiChCodedMode] : uiChCodedMode;

  const Int            blkX                                 = g_auiRasterToPelX[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            blkY                                 = g_auiRasterToPelY[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            bufferOffset                         = blkX + (blkY * MAX_CU_SIZE);
        Pel  *const    encoderLumaResidual                  = resiLuma[RESIDUAL_ENCODER_SIDE ] + bufferOffset;
        Pel  *const    reconstructedLumaResidual            = resiLuma[RESIDUAL_RECONSTRUCTED] + bufferOffset;
  const Bool           bUseCrossCPrediction                 = isChroma(compID) && (uiChPredMode == DM_CHROMA_IDX) && checkCrossCPrediction;
  const Bool           bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
        Pel *const     lumaResidualForEstimate              = bUseReconstructedResidualForEstimate ? reconstructedLumaResidual : encoderLumaResidual;

#if DEBUG_STRING
  const Int debugPredModeMask=DebugStringGetPredModeMask(MODE_INTRA);
#endif

  //===== init availability pattern =====
  DEBUG_STRING_NEW(sTemp)

#if !DEBUG_STRING
  if( default0Save1Load2 != 2 )
#endif
  {
    const Bool bUseFilteredPredictions=TComPrediction::filteringIntraReferenceSamples(compID, uiChFinalMode, uiWidth, uiHeight, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

    initIntraPatternChType( rTu, compID, bUseFilteredPredictions DEBUG_STRING_PASS_INTO(sDebug) );

    //===== get prediction signal =====
    predIntraAng( compID, uiChFinalMode, piOrg, uiStride, piPred, uiStride, rTu, bUseFilteredPredictions );

    // save prediction
    if( default0Save1Load2 == 1 )
    {
      Pel*  pPred   = piPred;
      Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
      Int k = 0;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pPredBuf[ k ++ ] = pPred[ uiX ];
        }
        pPred += uiStride;
      }
    }
  }
#if !DEBUG_STRING
  else
  {
    // load prediction
    Pel*  pPred   = piPred;
    Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
    Int k = 0;
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pPred[ uiX ] = pPredBuf[ k ++ ];
      }
      pPred += uiStride;
    }
  }
#endif

  //===== get residual signal =====
  {
    // get residual
    Pel*  pOrg    = piOrg;
    Pel*  pPred   = piPred;
    Pel*  pResi   = piResi;

    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pResi[ uiX ] = pOrg[ uiX ] - pPred[ uiX ];
      }

      pOrg  += uiStride;
      pResi += uiStride;
      pPred += uiStride;
    }
  }

  if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
  {
    if (bUseCrossCPrediction)
    {
      if (xCalcCrossComponentPredictionAlpha( rTu, compID, lumaResidualForEstimate, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride ) == 0)
      {
        return;
      }
      TComTrQuant::crossComponentPrediction ( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, false );
    }
    else if (isLuma(compID) && !bUseReconstructedResidualForEstimate)
    {
      xStoreCrossComponentPredictionResult( encoderLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
    }
  }

  //===== transform and quantization =====
  //--- init rate estimation arrays for RDOQ ---
  if( useTransformSkip ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ() )
  {
    m_pcEntropyCoder->estimateBit( m_pcTrQuant->m_pcEstBitsSbac, uiWidth, uiHeight, chType );
  }

  //--- transform and quantization ---
  TCoeff uiAbsSum = 0;
  if (bIsLuma)
  {
    pcCU       ->setTrIdxSubParts ( uiTrDepth, uiAbsPartIdx, uiFullDepth );
  }

  const QpParam cQP(*pcCU, compID);

#if RDOQ_CHROMA_LAMBDA
  m_pcTrQuant->selectLambda     (compID);
#endif

  m_pcTrQuant->transformNxN     ( rTu, compID, piResi, uiStride, pcCoeff,
#if ADAPTIVE_QP_SELECTION
    pcArlCoeff,
#endif
    uiAbsSum, cQP
    );

  //--- inverse transform ---

#if DEBUG_STRING
  if ( (uiAbsSum > 0) || (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask) )
#else
  if ( uiAbsSum > 0 )
#endif
  {
    m_pcTrQuant->invTransformNxN ( rTu, compID, piResi, uiStride, pcCoeff, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sDebug, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );
  }
  else
  {
    Pel* pResi = piResi;
    memset( pcCoeff, 0, sizeof( TCoeff ) * uiWidth * uiHeight );
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      memset( pResi, 0, sizeof( Pel ) * uiWidth );
      pResi += uiStride;
    }
  }


  //===== reconstruction =====
  {
    Pel* pPred      = piPred;
    Pel* pResi      = piResi;
    Pel* pReco      = piReco;
    Pel* pRecQt     = piRecQt;
    Pel* pRecIPred  = piRecIPred;

    if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
    {
      if (bUseCrossCPrediction)
      {
        TComTrQuant::crossComponentPrediction( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, true );
      }
      else if (isLuma(compID))
      {
        xStoreCrossComponentPredictionResult( reconstructedLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
      }
    }

 #if DEBUG_STRING
    std::stringstream ss(stringstream::out);
    const Bool bDebugPred=((DebugOptionList::DebugString_Pred.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugResi=((DebugOptionList::DebugString_Resi.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugReco=((DebugOptionList::DebugString_Reco.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));

    if (bDebugPred || bDebugResi || bDebugReco)
    {
      ss << "###: " << "CompID: " << compID << " pred mode (ch/fin): " << uiChPredMode << "/" << uiChFinalMode << " absPartIdx: " << rTu.GetAbsPartIdxTU() << "\n";
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        ss << "###: ";
        if (bDebugPred)
        {
          ss << " - pred: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pPred[ uiX ] << ", ";
          }
        }
        if (bDebugResi)
        {
          ss << " - resi: ";
        }
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          if (bDebugResi)
          {
            ss << pResi[ uiX ] << ", ";
          }
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        if (bDebugReco)
        {
          ss << " - reco: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pReco[ uiX ] << ", ";
          }
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
        ss << "\n";
      }
      DEBUG_STRING_APPEND(sDebug, ss.str())
    }
    else
#endif
    {

      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }

  //===== update distortion =====
  ruiDist += m_pcRdCost->getDistPart( bitDepth, piReco, uiStride, piOrg, uiStride, uiWidth, uiHeight, compID );
}




Void
TEncSearch::xRecurIntraCodingLumaQT(TComYuv*    pcOrgYuv,
                                    TComYuv*    pcPredYuv,
                                    TComYuv*    pcResiYuv,
                                    Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                    Distortion& ruiDistY,
#if HHI_RQT_INTRA_SPEEDUP
                                    Bool        bCheckFirst,
#endif
                                    Double&     dRDCost,
                                    TComTU&     rTu
                                    DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU   *pcCU          = rTu.getCU();
  const UInt    uiAbsPartIdx  = rTu.GetAbsPartIdxTU();
  const UInt    uiFullDepth   = rTu.GetTransformDepthTotal();
  const UInt    uiTrDepth     = rTu.GetTransformDepthRel();
  const UInt    uiLog2TrSize  = rTu.GetLog2LumaTrSize();
        Bool    bCheckFull    = ( uiLog2TrSize  <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
        Bool    bCheckSplit   = ( uiLog2TrSize  >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

        Pel     resiLumaSplit [NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];
        Pel     resiLumaSingle[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

#if HHI_RQT_INTRA_SPEEDUP
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // don't check split if TU size is less or equal to max TU size
  Bool noSplitIntraMaxTuSize = bCheckFull;
  if(m_pcEncCfg->getRDpenalty() && ! isIntraSlice)
  {
    // in addition don't check split if TU size is less or equal to 16x16 TU size for non-intra slice
    noSplitIntraMaxTuSize = ( uiLog2TrSize  <= min(maxTuSize,4) );

    // if maximum RD-penalty don't check TU size 32x32
    if(m_pcEncCfg->getRDpenalty()==2)
    {
      bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
    }
  }
  if( bCheckFirst && noSplitIntraMaxTuSize )

  {
    bCheckSplit = false;
  }
#else
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // if maximum RD-penalty don't check TU size 32x32
  if((m_pcEncCfg->getRDpenalty()==2)  && !isIntraSlice)
  {
    bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
  }
#endif
  Double     dSingleCost                        = MAX_DOUBLE;
  Distortion uiSingleDistLuma                   = 0;
  UInt       uiSingleCbfLuma                    = 0;
  Bool       checkTransformSkip  = pcCU->getSlice()->getPPS()->getUseTransformSkip();
  Int        bestModeId[MAX_NUM_COMPONENT] = { 0, 0, 0};
  checkTransformSkip           &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());
  checkTransformSkip           &= (!pcCU->getCUTransquantBypass(0));

  assert (rTu.ProcessComponentSection(COMPONENT_Y));
  const UInt totalAdjustedDepthChan   = rTu.GetTransformDepthTotalAdj(COMPONENT_Y);

  if ( m_pcEncCfg->getUseTransformSkipFast() )
  {
    checkTransformSkip       &= (pcCU->getPartitionSize(uiAbsPartIdx)==SIZE_NxN);
  }

  if( bCheckFull )
  {
    if(checkTransformSkip == true)
    {
      //----- store original entropy coding status -----
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );

      Distortion singleDistTmpLuma                    = 0;
      UInt       singleCbfTmpLuma                     = 0;
      Double     singleCostTmp                        = 0;
      Int        firstCheckId                         = 0;

      for(Int modeId = firstCheckId; modeId < 2; modeId ++)
      {
        DEBUG_STRING_NEW(sModeString)
        Int  default0Save1Load2 = 0;
        singleDistTmpLuma=0;
        if(modeId == firstCheckId)
        {
          default0Save1Load2 = 1;
        }
        else
        {
          default0Save1Load2 = 2;
        }


        pcCU->setTransformSkipSubParts ( modeId, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
        xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, singleDistTmpLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sModeString), default0Save1Load2 );

        singleCbfTmpLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );

        //----- determine rate and r-d cost -----
        if(modeId == 1 && singleCbfTmpLuma == 0)
        {
          //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
          singleCostTmp = MAX_DOUBLE;
        }
        else
        {
          UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );
          singleCostTmp     = m_pcRdCost->calcRdCost( uiSingleBits, singleDistTmpLuma );
        }
        if(singleCostTmp < dSingleCost)
        {
          DEBUG_STRING_SWAP(sDebug, sModeString)
          dSingleCost   = singleCostTmp;
          uiSingleDistLuma = singleDistTmpLuma;
          uiSingleCbfLuma = singleCbfTmpLuma;

          bestModeId[COMPONENT_Y] = modeId;
          if(bestModeId[COMPONENT_Y] == firstCheckId)
          {
            xStoreIntraResultQT(COMPONENT_Y, rTu );
            m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
          }

          if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
          {
            const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
            const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
            for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
            {
              if (bMaintainResidual[storedResidualIndex])
              {
                xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
              }
            }
          }
        }
        if (modeId == firstCheckId)
        {
          m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
        }
      }

      pcCU ->setTransformSkipSubParts ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

      if(bestModeId[COMPONENT_Y] == firstCheckId)
      {
        xLoadIntraResultQT(COMPONENT_Y, rTu );
        pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, rTu.GetTransformDepthTotalAdj(COMPONENT_Y) );

        m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
      }
    }
    else
    {
      //----- store original entropy coding status -----
      if( bCheckSplit )
      {
        m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
      }
      //----- code luma/chroma block with given intra prediction mode and store Cbf-----
      dSingleCost   = 0.0;

      pcCU ->setTransformSkipSubParts ( 0, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
      xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, uiSingleDistLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sDebug));

      if( bCheckSplit )
      {
        uiSingleCbfLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );
      }
      //----- determine rate and r-d cost -----
      UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );

      if(m_pcEncCfg->getRDpenalty() && (uiLog2TrSize==5) && !isIntraSlice)
      {
        uiSingleBits=uiSingleBits*4;
      }

      dSingleCost       = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDistLuma );

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }
    }
  }

  if( bCheckSplit )
  {
    //----- store full entropy coding status, load original entropy coding status -----
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    else
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    //----- code splitted block -----
    Double     dSplitCost      = 0.0;
    Distortion uiSplitDistLuma = 0;
    UInt       uiSplitCbfLuma  = 0;

    TComTURecurse tuRecurseChild(rTu, false);
    DEBUG_STRING_NEW(sSplit)
    do
    {
      DEBUG_STRING_NEW(sChild)
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, bCheckFirst, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#endif
      DEBUG_STRING_APPEND(sSplit, sChild)
      uiSplitCbfLuma |= pcCU->getCbf( tuRecurseChild.GetAbsPartIdxTU(), COMPONENT_Y, tuRecurseChild.GetTransformDepthRel() );
    } while (tuRecurseChild.nextSection(rTu) );

    UInt    uiPartsDiv     = rTu.GetAbsPartIdxNumParts();
    {
      if (uiSplitCbfLuma)
      {
        const UInt flag=1<<uiTrDepth;
        UChar *pBase=pcCU->getCbf( COMPONENT_Y );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
    //----- restore context states -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    
    //----- determine rate and r-d cost -----
    UInt uiSplitBits = xGetIntraBitsQT( rTu, true, false, false );
    dSplitCost       = m_pcRdCost->calcRdCost( uiSplitBits, uiSplitDistLuma );

    //===== compare and set best =====
    if( dSplitCost < dSingleCost )
    {
      //--- update cost ---
      DEBUG_STRING_SWAP(sSplit, sDebug)
      ruiDistY += uiSplitDistLuma;
      dRDCost  += dSplitCost;

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSplit[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }

      return;
    }

    //----- set entropy coding status -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );

    //--- set transform index and Cbf values ---
    pcCU->setTrIdxSubParts( uiTrDepth, uiAbsPartIdx, uiFullDepth );
    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
    pcCU ->setTransformSkipSubParts  ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

    //--- set reconstruction for next intra prediction blocks ---
    const UInt  uiQTLayer   = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt  uiZOrder    = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
    const UInt  uiWidth     = tuRect.width;
    const UInt  uiHeight    = tuRect.height;
    Pel*  piSrc       = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( COMPONENT_Y, uiAbsPartIdx );
    UInt  uiSrcStride = m_pcQTTempTComYuv[ uiQTLayer ].getStride  ( COMPONENT_Y );
    Pel*  piDes       = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
    UInt  uiDesStride = pcCU->getPic()->getPicYuvRec()->getStride  ( COMPONENT_Y );

    for( UInt uiY = 0; uiY < uiHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        piDes[ uiX ] = piSrc[ uiX ];
      }
    }
  }
  ruiDistY += uiSingleDistLuma;
  dRDCost  += dSingleCost;
}


Void
TEncSearch::xSetIntraResultLumaQT(TComYuv* pcRecoYuv, TComTU &rTu)
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiTrDepth    = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====

    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    const UInt coeffOffset = rTu.getCoefficientOffset(COMPONENT_Y);
    const UInt numCoeffInBlock = tuRect.width * tuRect.height;

    if (numCoeffInBlock!=0)
    {
      const TCoeff* srcCoeff = m_ppcQTTempCoeff[COMPONENT_Y][uiQTLayer] + coeffOffset;
      TCoeff* destCoeff      = pcCU->getCoeff(COMPONENT_Y) + coeffOffset;
      ::memcpy( destCoeff, srcCoeff, sizeof(TCoeff)*numCoeffInBlock );
#if ADAPTIVE_QP_SELECTION
      const TCoeff* srcArlCoeff = m_ppcQTTempArlCoeff[COMPONENT_Y][ uiQTLayer ] + coeffOffset;
      TCoeff* destArlCoeff      = pcCU->getArlCoeff (COMPONENT_Y)               + coeffOffset;
      ::memcpy( destArlCoeff, srcArlCoeff, sizeof( TCoeff ) * numCoeffInBlock );
#endif
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Y, pcRecoYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }

  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultLumaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}


Void
TEncSearch::xStoreIntraResultQT(const ComponentID compID, TComTU &rTu )
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff    = tuRect.width * tuRect.height;
      TCoeff* pcCoeffSrc = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffDst = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffDst = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( compID, &m_pcQTTempTransformSkipTComYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }
  }
}


Void
TEncSearch::xLoadIntraResultQT(const ComponentID compID, TComTU &rTu)
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt uiZOrder     = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff = tuRect.width * tuRect.height;
      TCoeff* pcCoeffDst = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffSrc = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffDst = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffSrc = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTransformSkipTComYuv.copyPartToPartComponent( compID, &m_pcQTTempTComYuv[ uiQTLayer ], uiAbsPartIdx, tuRect.width, tuRect.height );

      Pel*    piRecIPred        = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
      UInt    uiRecIPredStride  = pcCU->getPic()->getPicYuvRec()->getStride (compID);
      Pel*    piRecQt           = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
      UInt    uiRecQtStride     = m_pcQTTempTComYuv[ uiQTLayer ].getStride  (compID);
      UInt    uiWidth           = tuRect.width;
      UInt    uiHeight          = tuRect.height;
      Pel* pRecQt               = piRecQt;
      Pel* pRecIPred            = piRecIPred;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pRecIPred[ uiX ] = pRecQt   [ uiX ];
        }
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }
}

Void
TEncSearch::xStoreCrossComponentPredictionResult(       Pel    *pResiDst,
                                                  const Pel    *pResiSrc,
                                                        TComTU &rTu,
                                                  const Int     xOffset,
                                                  const Int     yOffset,
                                                  const Int     strideDst,
                                                  const Int     strideSrc )
{
  const Pel *pSrc = pResiSrc + yOffset * strideSrc + xOffset;
        Pel *pDst = pResiDst + yOffset * strideDst + xOffset;

  for( Int y = 0; y < rTu.getRect( COMPONENT_Y ).height; y++ )
  {
    ::memcpy( pDst, pSrc, sizeof(Pel) * rTu.getRect( COMPONENT_Y ).width );
    pDst += strideDst;
    pSrc += strideSrc;
  }
}

SChar
TEncSearch::xCalcCrossComponentPredictionAlpha(       TComTU &rTu,
                                                const ComponentID compID,
                                                const Pel*        piResiL,
                                                const Pel*        piResiC,
                                                const Int         width,
                                                const Int         height,
                                                const Int         strideL,
                                                const Int         strideC )
{
  const Pel *pResiL = piResiL;
  const Pel *pResiC = piResiC;

        TComDataCU *pCU = rTu.getCU();
  const Int  absPartIdx = rTu.GetAbsPartIdxTU( compID );
  const Int diffBitDepth = pCU->getSlice()->getSPS()->getDifferentialLumaChromaBitDepth();

  SChar alpha = 0;
  Int SSxy  = 0;
  Int SSxx  = 0;

  for( UInt uiY = 0; uiY < height; uiY++ )
  {
    for( UInt uiX = 0; uiX < width; uiX++ )
    {
      const Pel scaledResiL = rightShift( pResiL[ uiX ], diffBitDepth );
      SSxy += ( scaledResiL * pResiC[ uiX ] );
      SSxx += ( scaledResiL * scaledResiL   );
    }

    pResiL += strideL;
    pResiC += strideC;
  }

  if( SSxx != 0 )
  {
    Double dAlpha = SSxy / Double( SSxx );
    alpha = SChar(Clip3<Int>(-16, 16, (Int)(dAlpha * 16)));

    static const SChar alphaQuant[17] = {0, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8};

    alpha = (alpha < 0) ? -alphaQuant[Int(-alpha)] : alphaQuant[Int(alpha)];
  }
  pCU->setCrossComponentPredictionAlphaPartRange( alpha, compID, absPartIdx, rTu.GetAbsPartIdxNumParts( compID ) );

  return alpha;
}

Void
TEncSearch::xRecurIntraChromaCodingQT(TComYuv*    pcOrgYuv,
                                      TComYuv*    pcPredYuv,
                                      TComYuv*    pcResiYuv,
                                      Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      Distortion& ruiDist,
                                      TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU         *pcCU                  = rTu.getCU();
  const UInt          uiTrDepth             = rTu.GetTransformDepthRel();
  const UInt          uiAbsPartIdx          = rTu.GetAbsPartIdxTU();
  const ChromaFormat  format                = rTu.GetChromaFormat();
  UInt                uiTrMode              = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt          numberValidComponents = getNumberValidComponents(format);

  if(  uiTrMode == uiTrDepth )
  {
    if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      return;
    }

    const UInt uiFullDepth = rTu.GetTransformDepthTotal();

    Bool checkTransformSkip = pcCU->getSlice()->getPPS()->getUseTransformSkip();
    checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Cb), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

    if ( m_pcEncCfg->getUseTransformSkipFast() )
    {
      checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

      if (checkTransformSkip)
      {
        Int nbLumaSkip = 0;
        const UInt maxAbsPartIdxSub=uiAbsPartIdx + (rTu.ProcessingAllQuadrants(COMPONENT_Cb)?1:4);
        for(UInt absPartIdxSub = uiAbsPartIdx; absPartIdxSub < maxAbsPartIdxSub; absPartIdxSub ++)
        {
          nbLumaSkip += pcCU->getTransformSkip(absPartIdxSub, COMPONENT_Y);
        }
        checkTransformSkip &= (nbLumaSkip > 0);
      }
    }


    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      DEBUG_STRING_NEW(sDebugBestMode)

      //use RDO to decide whether Cr/Cb takes TS
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[uiFullDepth][CI_QT_TRAFO_ROOT] );

      const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

      TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

      const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

      do
      {
        const UInt subTUAbsPartIdx   = TUIterator.GetAbsPartIdxTU(compID);

        Double     dSingleCost               = MAX_DOUBLE;
        Int        bestModeId                = 0;
        Distortion singleDistC               = 0;
        UInt       singleCbfC                = 0;
        Distortion singleDistCTmp            = 0;
        Double     singleCostTmp             = 0;
        UInt       singleCbfCTmp             = 0;
        SChar      bestCrossCPredictionAlpha = 0;
        Int        bestTransformSkipMode     = 0;

        const Bool checkCrossComponentPrediction =    (pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, subTUAbsPartIdx) == DM_CHROMA_IDX)
                                                   &&  pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                   && (pcCU->getCbf(subTUAbsPartIdx,  COMPONENT_Y, uiTrDepth) != 0);

        const Int  crossCPredictionModesToTest = checkCrossComponentPrediction ? 2 : 1;
        const Int  transformSkipModesToTest    = checkTransformSkip            ? 2 : 1;
        const Int  totalModesToTest            = crossCPredictionModesToTest * transformSkipModesToTest;
              Int  currModeId                  = 0;
              Int  default0Save1Load2          = 0;

        for(Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
        {
          for(Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
          {
            pcCU->setCrossComponentPredictionAlphaPartRange(0, compID, subTUAbsPartIdx, partIdxesPerSubTU);
            DEBUG_STRING_NEW(sDebugMode)
            pcCU->setTransformSkipPartRange( transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU );
            currModeId++;

            const Bool isOneMode  = (totalModesToTest == 1);
            const Bool isLastMode = (currModeId == totalModesToTest); // currModeId is indexed from 1

            if (isOneMode)
            {
              default0Save1Load2 = 0;
            }
            else if (!isOneMode && (transformSkipModeId == 0) && (crossCPredictionModeId == 0))
            {
              default0Save1Load2 = 1; //save prediction on first mode
            }
            else
            {
              default0Save1Load2 = 2; //load it on subsequent modes
            }

            singleDistCTmp = 0;

            xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, (crossCPredictionModeId != 0), singleDistCTmp, compID, TUIterator DEBUG_STRING_PASS_INTO(sDebugMode), default0Save1Load2);
            singleCbfCTmp = pcCU->getCbf( subTUAbsPartIdx, compID, uiTrDepth);

            if (  ((crossCPredictionModeId == 1) && (pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) == 0))
               || ((transformSkipModeId    == 1) && (singleCbfCTmp == 0))) //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
            {
              singleCostTmp = MAX_DOUBLE;
            }
            else if (!isOneMode)
            {
              UInt bitsTmp = xGetIntraBitsQTChroma( TUIterator, compID, false );
              singleCostTmp  = m_pcRdCost->calcRdCost( bitsTmp, singleDistCTmp);
            }

            if(singleCostTmp < dSingleCost)
            {
              DEBUG_STRING_SWAP(sDebugBestMode, sDebugMode)
              dSingleCost               = singleCostTmp;
              singleDistC               = singleDistCTmp;
              bestCrossCPredictionAlpha = (crossCPredictionModeId != 0) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;
              bestTransformSkipMode     = transformSkipModeId;
              bestModeId                = currModeId;
              singleCbfC                = singleCbfCTmp;

              if (!isOneMode && !isLastMode)
              {
                xStoreIntraResultQT(compID, TUIterator);
                m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
              }
            }

            if (!isOneMode && !isLastMode)
            {
              m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
            }
          }
        }

        if(bestModeId < totalModesToTest)
        {
          xLoadIntraResultQT(compID, TUIterator);
          pcCU->setCbfPartRange( singleCbfC << uiTrDepth, compID, subTUAbsPartIdx, partIdxesPerSubTU );

          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
        }

        DEBUG_STRING_APPEND(sDebug, sDebugBestMode)
        pcCU ->setTransformSkipPartRange                ( bestTransformSkipMode,     compID, subTUAbsPartIdx, partIdxesPerSubTU );
        pcCU ->setCrossComponentPredictionAlphaPartRange( bestCrossCPredictionAlpha, compID, subTUAbsPartIdx, partIdxesPerSubTU );
        ruiDist += singleDistC;
      } while (TUIterator.nextSection(rTu));

      if (splitIntoSubTUs)
      {
        offsetSubTUCBFs(rTu, compID);
      }
    }
  }
  else
  {
    UInt    uiSplitCbf[MAX_NUM_COMPONENT] = {0,0,0};

    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiTrDepthChild   = tuRecurseChild.GetTransformDepthRel();
    do
    {
      DEBUG_STRING_NEW(sChild)

      xRecurIntraChromaCodingQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, ruiDist, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );

      DEBUG_STRING_APPEND(sDebug, sChild)
      const UInt uiAbsPartIdxSub=tuRecurseChild.GetAbsPartIdxTU();

      for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
      {
        uiSplitCbf[ch] |= pcCU->getCbf( uiAbsPartIdxSub, ComponentID(ch), uiTrDepthChild );
      }
    } while ( tuRecurseChild.nextSection(rTu) );


    UInt uiPartsDiv = rTu.GetAbsPartIdxNumParts();
    for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      if (uiSplitCbf[ch])
      {
        const UInt flag=1<<uiTrDepth;
        ComponentID compID=ComponentID(ch);
        UChar *pBase=pcCU->getCbf( compID );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
  }
}




Void
TEncSearch::xSetIntraResultChromaQT(TComYuv*    pcRecoYuv, TComTU &rTu)
{
  if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
  {
    return;
  }
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth   = rTu.GetTransformDepthRel();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====
    const TComRectangle &tuRectCb=rTu.getRect(COMPONENT_Cb);
    UInt uiNumCoeffC    = tuRectCb.width*tuRectCb.height;//( pcCU->getSlice()->getSPS()->getMaxCUWidth() * pcCU->getSlice()->getSPS()->getMaxCUHeight() ) >> ( uiFullDepth << 1 );
    const UInt offset = rTu.getCoefficientOffset(COMPONENT_Cb);

    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID component = ComponentID(ch);
      const TCoeff* src           = m_ppcQTTempCoeff[component][uiQTLayer] + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      TCoeff* dest                = pcCU->getCoeff(component) + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      ::memcpy( dest, src, sizeof(TCoeff)*uiNumCoeffC );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[component][ uiQTLayer ] + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      TCoeff* pcArlCoeffDst = pcCU->getArlCoeff(component)                + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeffC );
#endif
    }

    //===== copy reconstruction =====

    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cb, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cr, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultChromaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}



Void
TEncSearch::estIntraPredLumaQT(TComDataCU* pcCU,
                               TComYuv*    pcOrgYuv,
                               TComYuv*    pcPredYuv,
                               TComYuv*    pcResiYuv,
                               TComYuv*    pcRecoYuv,
                               Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                               DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt         uiDepth               = pcCU->getDepth(0);
  const UInt         uiInitTrDepth         = pcCU->getPartitionSize(0) == SIZE_2Nx2N ? 0 : 1;
  const UInt         uiNumPU               = 1<<(2*uiInitTrDepth);
  const UInt         uiQNumParts           = pcCU->getTotalNumPart() >> 2;
  const UInt         uiWidthBit            = pcCU->getIntraSizeIdx(0);
  const ChromaFormat chFmt                 = pcCU->getPic()->getChromaFormat();
  const UInt         numberValidComponents = getNumberValidComponents(chFmt);
  const TComSPS     &sps                   = *(pcCU->getSlice()->getSPS());
  const TComPPS     &pps                   = *(pcCU->getSlice()->getPPS());
        Distortion   uiOverallDistY        = 0;
        UInt         CandNum;
        Double       CandCostList[ FAST_UDI_MAX_RDMODE_NUM ];
        Pel          resiLumaPU[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

  // Lambda calculation at equivalent Qp of 4 is recommended because at that Qp, the quantisation divisor is 1.
#if FULL_NBIT
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#else
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12 - 6 * (sps.getBitDepth(CHANNEL_TYPE_LUMA) - 8)) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#endif

  //===== set QP and clear Cbf =====
  if ( pps.getUseDQP() == true)
  {
    pcCU->setQPSubParts( pcCU->getQP(0), 0, uiDepth );
  }
  else
  {
    pcCU->setQPSubParts( pcCU->getSlice()->getSliceQp(), 0, uiDepth );
  }

  //===== loop over partitions =====
  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);

  do
  {
    const UInt uiPartOffset=tuRecurseWithPU.GetAbsPartIdxTU();
//  for( UInt uiPU = 0, uiPartOffset=0; uiPU < uiNumPU; uiPU++, uiPartOffset += uiQNumParts )
  //{
    //===== init pattern for luma prediction =====
    DEBUG_STRING_NEW(sTemp2)

    //===== determine set of modes to be tested (using prediction signal only) =====
    Int numModesAvailable     = 35; //total number of Intra modes
    UInt uiRdModeList[FAST_UDI_MAX_RDMODE_NUM];
    Int numModesForFullRD = m_pcEncCfg->getFastUDIUseMPMEnabled()?g_aucIntraModeNumFast_UseMPM[ uiWidthBit ] : g_aucIntraModeNumFast_NotUseMPM[ uiWidthBit ];

    // this should always be true
    assert (tuRecurseWithPU.ProcessComponentSection(COMPONENT_Y));
    initIntraPatternChType( tuRecurseWithPU, COMPONENT_Y, true DEBUG_STRING_PASS_INTO(sTemp2) );

    Bool doFastSearch = (numModesForFullRD != numModesAvailable);
    if (doFastSearch)
    {
      assert(numModesForFullRD < numModesAvailable);

      for( Int i=0; i < numModesForFullRD; i++ )
      {
        CandCostList[ i ] = MAX_DOUBLE;
      }
      CandNum = 0;

      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt uiAbsPartIdx=tuRecurseWithPU.GetAbsPartIdxTU();

      Pel* piOrg         = pcOrgYuv ->getAddr( COMPONENT_Y, uiAbsPartIdx );
      Pel* piPred        = pcPredYuv->getAddr( COMPONENT_Y, uiAbsPartIdx );
      UInt uiStride      = pcPredYuv->getStride( COMPONENT_Y );
      DistParam distParam;
      const Bool bUseHadamard=pcCU->getCUTransquantBypass(0) == 0;
      m_pcRdCost->setDistParam(distParam, sps.getBitDepth(CHANNEL_TYPE_LUMA), piOrg, uiStride, piPred, uiStride, puRect.width, puRect.height, bUseHadamard);
      distParam.bApplyWeight = false;
      for( Int modeIdx = 0; modeIdx < numModesAvailable; modeIdx++ )
      {
        UInt       uiMode = modeIdx;
        Distortion uiSad  = 0;

        const Bool bUseFilter=TComPrediction::filteringIntraReferenceSamples(COMPONENT_Y, uiMode, puRect.width, puRect.height, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

        predIntraAng( COMPONENT_Y, uiMode, piOrg, uiStride, piPred, uiStride, tuRecurseWithPU, bUseFilter, TComPrediction::UseDPCMForFirstPassIntraEstimation(tuRecurseWithPU, uiMode) );

        // use hadamard transform here
        uiSad+=distParam.DistFunc(&distParam);

        UInt   iModeBits = 0;

        // NB xModeBitsIntra will not affect the mode for chroma that may have already been pre-estimated.
        iModeBits+=xModeBitsIntra( pcCU, uiMode, uiPartOffset, uiDepth, CHANNEL_TYPE_LUMA );

        Double cost      = (Double)uiSad + (Double)iModeBits * sqrtLambdaForFirstPass;

#if DEBUG_INTRA_SEARCH_COSTS
        std::cout << "1st pass mode " << uiMode << " SAD = " << uiSad << ", mode bits = " << iModeBits << ", cost = " << cost << "\n";
#endif

        CandNum += xUpdateCandList( uiMode, cost, numModesForFullRD, uiRdModeList, CandCostList );
      }

      if (m_pcEncCfg->getFastUDIUseMPMEnabled())
      {
        Int uiPreds[NUM_MOST_PROBABLE_MODES] = {-1, -1, -1};

        Int iMode = -1;
        pcCU->getIntraDirPredictor( uiPartOffset, uiPreds, COMPONENT_Y, &iMode );

        const Int numCand = ( iMode >= 0 ) ? iMode : Int(NUM_MOST_PROBABLE_MODES);

        for( Int j=0; j < numCand; j++)
        {
          Bool mostProbableModeIncluded = false;
          Int mostProbableMode = uiPreds[j];

          for( Int i=0; i < numModesForFullRD; i++)
          {
            mostProbableModeIncluded |= (mostProbableMode == uiRdModeList[i]);
          }
          if (!mostProbableModeIncluded)
          {
            uiRdModeList[numModesForFullRD++] = mostProbableMode;
          }
        }
      }
    }
    else
    {
      for( Int i=0; i < numModesForFullRD; i++)
      {
        uiRdModeList[i] = i;
      }
    }

    //===== check modes (using r-d costs) =====
#if HHI_RQT_INTRA_SPEEDUP_MOD
    UInt   uiSecondBestMode  = MAX_UINT;
    Double dSecondBestPUCost = MAX_DOUBLE;
#endif
    DEBUG_STRING_NEW(sPU)
    UInt       uiBestPUMode  = 0;
    Distortion uiBestPUDistY = 0;
    Double     dBestPUCost   = MAX_DOUBLE;

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
    UInt max=numModesForFullRD;

    if (DebugOptionList::ForceLumaMode.isSet())
    {
      max=0;  // we are forcing a direction, so don't bother with mode check
    }
    for ( UInt uiMode = 0; uiMode < max; uiMode++)
#else
    for( UInt uiMode = 0; uiMode < numModesForFullRD; uiMode++ )
#endif
    {
      // set luma prediction mode
      UInt uiOrgMode = uiRdModeList[uiMode];

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );

      DEBUG_STRING_NEW(sMode)
      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, true, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#endif

#if DEBUG_INTRA_SEARCH_COSTS
      std::cout << "2nd pass [luma,chroma] mode [" << Int(pcCU->getIntraDir(CHANNEL_TYPE_LUMA, uiPartOffset)) << "," << Int(pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, uiPartOffset)) << "] cost = " << dPUCost << "\n";
#endif

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sMode)
#if HHI_RQT_INTRA_SPEEDUP_MOD
        uiSecondBestMode  = uiBestPUMode;
        dSecondBestPUCost = dBestPUCost;
#endif
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();

        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
#if HHI_RQT_INTRA_SPEEDUP_MOD
      else if( dPUCost < dSecondBestPUCost )
      {
        uiSecondBestMode  = uiOrgMode;
        dSecondBestPUCost = dPUCost;
      }
#endif
    } // Mode loop

#if HHI_RQT_INTRA_SPEEDUP
#if HHI_RQT_INTRA_SPEEDUP_MOD
    for( UInt ui =0; ui < 2; ++ui )
#endif
    {
#if HHI_RQT_INTRA_SPEEDUP_MOD
      UInt uiOrgMode   = ui ? uiSecondBestMode  : uiBestPUMode;
      if( uiOrgMode == MAX_UINT )
      {
        break;
      }
#else
      UInt uiOrgMode = uiBestPUMode;
#endif

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
      if (DebugOptionList::ForceLumaMode.isSet())
      {
        uiOrgMode = DebugOptionList::ForceLumaMode.getInt();
      }
#endif

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );
      DEBUG_STRING_NEW(sModeTree)

      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;

      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, false, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sModeTree));

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sModeTree)
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );

        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
    } // Mode loop
#endif

    DEBUG_STRING_APPEND(sDebug, sPU)

    //--- update overall distortion ---
    uiOverallDistY += uiBestPUDistY;

    //--- update transform index and cbf ---
    const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
    ::memcpy( pcCU->getTransformIdx()       + uiPartOffset, m_puhQTTempTrIdx,  uiQPartNum * sizeof( UChar ) );
    for (UInt component = 0; component < numberValidComponents; component++)
    {
      const ComponentID compID = ComponentID(component);
      ::memcpy( pcCU->getCbf( compID  ) + uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
      ::memcpy( pcCU->getTransformSkip( compID  ) + uiPartOffset, m_puhQTTempTransformSkipFlag[compID ], uiQPartNum * sizeof( UChar ) );
    }

    //--- set reconstruction for next intra prediction blocks ---
    if( !tuRecurseWithPU.IsLastSection() )
    {
      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt  uiCompWidth   = puRect.width;
      const UInt  uiCompHeight  = puRect.height;

      const UInt  uiZOrder      = pcCU->getZorderIdxInCtu() + uiPartOffset;
            Pel*  piDes         = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
      const UInt  uiDesStride   = pcCU->getPic()->getPicYuvRec()->getStride( COMPONENT_Y);
      const Pel*  piSrc         = pcRecoYuv->getAddr( COMPONENT_Y, uiPartOffset );
      const UInt  uiSrcStride   = pcRecoYuv->getStride( COMPONENT_Y);

      for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
      {
        for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
        {
          piDes[ uiX ] = piSrc[ uiX ];
        }
      }
    }

    //=== update PU data ====
    pcCU->setIntraDirSubParts     ( CHANNEL_TYPE_LUMA, uiBestPUMode, uiPartOffset, uiDepth + uiInitTrDepth );
	
  } while (tuRecurseWithPU.nextSection(tuRecurseCU));


  if( uiNumPU > 1 )
  { // set Cbf for all blocks
    UInt uiCombCbfY = 0;
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfY |= pcCU->getCbf( uiPartIdx, COMPONENT_Y,  1 );
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Y  )[ uiOffs ] |= uiCombCbfY;
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  //===== reset context models =====
  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  //===== set distortion (rate and r-d costs are determined later) =====
  pcCU->getTotalDistortion() = uiOverallDistY;
}




Void
TEncSearch::estIntraPredChromaQT(TComDataCU* pcCU,
                                 TComYuv*    pcOrgYuv,
                                 TComYuv*    pcPredYuv,
                                 TComYuv*    pcResiYuv,
                                 TComYuv*    pcRecoYuv,
                                 Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                                 DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt    uiInitTrDepth  = pcCU->getPartitionSize(0) != SIZE_2Nx2N && enable4ChromaPUsInIntraNxNCU(pcOrgYuv->getChromaFormat()) ? 1 : 0;

  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);
  const UInt    uiQNumParts    = tuRecurseWithPU.GetAbsPartIdxNumParts();
  const UInt    uiDepthCU=tuRecurseWithPU.getCUDepth();
  const UInt    numberValidComponents = pcCU->getPic()->getNumberValidComponents();

  do
  {
    UInt       uiBestMode  = 0;
    Distortion uiBestDist  = 0;
    Double     dBestCost   = MAX_DOUBLE;

    //----- init mode list -----
    if (tuRecurseWithPU.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      UInt uiModeList[FAST_UDI_MAX_RDMODE_NUM];
      const UInt  uiQPartNum     = uiQNumParts;
      const UInt  uiPartOffset   = tuRecurseWithPU.GetAbsPartIdxTU();
      {
        UInt  uiMinMode = 0;
        UInt  uiMaxMode = NUM_CHROMA_MODE;

        //----- check chroma modes -----
        pcCU->getAllowedChromaDir( uiPartOffset, uiModeList );

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
        if (DebugOptionList::ForceChromaMode.isSet())
        {
          uiMinMode=DebugOptionList::ForceChromaMode.getInt();
          if (uiModeList[uiMinMode]==34)
          {
            uiMinMode=4; // if the fixed mode has been renumbered because DM_CHROMA covers it, use DM_CHROMA.
          }
          uiMaxMode=uiMinMode+1;
        }
#endif

        DEBUG_STRING_NEW(sPU)

        for( UInt uiMode = uiMinMode; uiMode < uiMaxMode; uiMode++ )
        {
          //----- restore context models -----
          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          
          DEBUG_STRING_NEW(sMode)
          //----- chroma coding -----
          Distortion uiDist = 0;
          pcCU->setIntraDirSubParts  ( CHANNEL_TYPE_CHROMA, uiModeList[uiMode], uiPartOffset, uiDepthCU+uiInitTrDepth );
          xRecurIntraChromaCodingQT       ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );

          if( pcCU->getSlice()->getPPS()->getUseTransformSkip() )
          {
            m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          }

          UInt    uiBits = xGetIntraBitsQT( tuRecurseWithPU, false, true, false );
          Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );

          //----- compare -----
          if( dCost < dBestCost )
          {
            DEBUG_STRING_SWAP(sPU, sMode);
            dBestCost   = dCost;
            uiBestDist  = uiDist;
            uiBestMode  = uiModeList[uiMode];

            xSetIntraResultChromaQT( pcRecoYuv, tuRecurseWithPU );
            for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
            {
              const ComponentID compID = ComponentID(componentIndex);
              ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_puhQTTempTransformSkipFlag[compID], pcCU->getTransformSkip( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_phQTTempCrossComponentPredictionAlpha[compID], pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, uiQPartNum * sizeof( SChar ) );
            }
          }
        }

        DEBUG_STRING_APPEND(sDebug, sPU)

        //----- set data -----
        for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
        {
          const ComponentID compID = ComponentID(componentIndex);
          ::memcpy( pcCU->getCbf( compID )+uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getTransformSkip( compID )+uiPartOffset, m_puhQTTempTransformSkipFlag[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, m_phQTTempCrossComponentPredictionAlpha[compID], uiQPartNum * sizeof( SChar ) );
        }
      }

      if( ! tuRecurseWithPU.IsLastSection() )
      {
        for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
        {
          const ComponentID compID    = ComponentID(ch);
          const TComRectangle &tuRect = tuRecurseWithPU.getRect(compID);
          const UInt  uiCompWidth     = tuRect.width;
          const UInt  uiCompHeight    = tuRect.height;
          const UInt  uiZOrder        = pcCU->getZorderIdxInCtu() + tuRecurseWithPU.GetAbsPartIdxTU();
                Pel*  piDes           = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
          const UInt  uiDesStride     = pcCU->getPic()->getPicYuvRec()->getStride( compID);
          const Pel*  piSrc           = pcRecoYuv->getAddr( compID, uiPartOffset );
          const UInt  uiSrcStride     = pcRecoYuv->getStride( compID);

          for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
          {
            for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
            {
              piDes[ uiX ] = piSrc[ uiX ];
            }
          }
        }
      }

      pcCU->setIntraDirSubParts( CHANNEL_TYPE_CHROMA, uiBestMode, uiPartOffset, uiDepthCU+uiInitTrDepth );
      pcCU->getTotalDistortion      () += uiBestDist;
    }

  } while (tuRecurseWithPU.nextSection(tuRecurseCU));

  //----- restore context models -----

  if( uiInitTrDepth != 0 )
  { // set Cbf for all blocks
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
}




/** Function for encoding and reconstructing luma/chroma samples of a PCM mode CU.
 * \param pcCU pointer to current CU
 * \param uiAbsPartIdx part index
 * \param pOrg pointer to original sample arrays
 * \param pPCM pointer to PCM code arrays
 * \param pPred pointer to prediction signal arrays
 * \param pResi pointer to residual signal arrays
 * \param pReco pointer to reconstructed sample arrays
 * \param uiStride stride of the original/prediction/residual sample arrays
 * \param uiWidth block width
 * \param uiHeight block height
 * \param compID texture component type
 */
Void TEncSearch::xEncPCM (TComDataCU* pcCU, UInt uiAbsPartIdx, Pel* pOrg, Pel* pPCM, Pel* pPred, Pel* pResi, Pel* pReco, UInt uiStride, UInt uiWidth, UInt uiHeight, const ComponentID compID )
{
  const UInt uiReconStride   = pcCU->getPic()->getPicYuvRec()->getStride(compID);
  const UInt uiPCMBitDepth   = pcCU->getSlice()->getSPS()->getPCMBitDepth(toChannelType(compID));
  const Int  channelBitDepth = pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
  Pel* pRecoPic = pcCU->getPic()->getPicYuvRec()->getAddr(compID, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu()+uiAbsPartIdx);

  const Int pcmShiftRight=(channelBitDepth - Int(uiPCMBitDepth));

  assert(pcmShiftRight >= 0);

  for( UInt uiY = 0; uiY < uiHeight; uiY++ )
  {
    for( UInt uiX = 0; uiX < uiWidth; uiX++ )
    {
      // Reset pred and residual
      pPred[uiX] = 0;
      pResi[uiX] = 0;
      // Encode
      pPCM[uiX] = (pOrg[uiX]>>pcmShiftRight);
      // Reconstruction
      pReco   [uiX] = (pPCM[uiX]<<(pcmShiftRight));
      pRecoPic[uiX] = pReco[uiX];
    }
    pPred += uiStride;
    pResi += uiStride;
    pPCM += uiWidth;
    pOrg += uiStride;
    pReco += uiStride;
    pRecoPic += uiReconStride;
  }
}


//!  Function for PCM mode estimation.
Void TEncSearch::IPCMSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv )
{
  UInt              uiDepth      = pcCU->getDepth(0);
  const Distortion  uiDistortion = 0;
  UInt              uiBits;

  Double dCost;

  for (UInt ch=0; ch < pcCU->getPic()->getNumberValidComponents(); ch++)
  {
    const ComponentID compID  = ComponentID(ch);
    const UInt width  = pcCU->getWidth(0)  >> pcCU->getPic()->getComponentScaleX(compID);
    const UInt height = pcCU->getHeight(0) >> pcCU->getPic()->getComponentScaleY(compID);
    const UInt stride = pcPredYuv->getStride(compID);

    Pel * pOrig    = pcOrgYuv->getAddr  (compID, 0, width);
    Pel * pResi    = pcResiYuv->getAddr(compID, 0, width);
    Pel * pPred    = pcPredYuv->getAddr(compID, 0, width);
    Pel * pReco    = pcRecoYuv->getAddr(compID, 0, width);
    Pel * pPCM     = pcCU->getPCMSample (compID);

    xEncPCM ( pcCU, 0, pOrig, pPCM, pPred, pResi, pReco, stride, width, height, compID );

  }

  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiDepth, 0, true, false);
  uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  dCost = m_pcRdCost->calcRdCost( uiBits, uiDistortion );

  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  pcCU->getTotalBits()       = uiBits;
  pcCU->getTotalCost()       = dCost;
  pcCU->getTotalDistortion() = uiDistortion;

  pcCU->copyToPic(uiDepth);
}




Void TEncSearch::xGetInterPredictionError( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, Distortion& ruiErr, Bool /*bHadamard*/ )
{
  motionCompensation( pcCU, &m_tmpYuvPred, REF_PIC_LIST_X, iPartIdx );

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;
  pcCU->getPartIndexAndSize( iPartIdx, uiAbsPartIdx, iWidth, iHeight );

  DistParam cDistParam;

  cDistParam.bApplyWeight = false;


  m_pcRdCost->setDistParam( cDistParam, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA),
                            pcYuvOrg->getAddr( COMPONENT_Y, uiAbsPartIdx ), pcYuvOrg->getStride(COMPONENT_Y),
                            m_tmpYuvPred .getAddr( COMPONENT_Y, uiAbsPartIdx ), m_tmpYuvPred.getStride(COMPONENT_Y),
                            iWidth, iHeight, m_pcEncCfg->getUseHADME() && (pcCU->getCUTransquantBypass(iPartIdx) == 0) );

  ruiErr = cDistParam.DistFunc( &cDistParam );
}

//! estimation of best merge coding
Void TEncSearch::xMergeEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPUIdx, UInt& uiInterDir, TComMvField* pacMvField, UInt& uiMergeIndex, Distortion& ruiCost, TComMvField* cMvFieldNeighbours, UChar* uhInterDirNeighbours, Int& numValidMergeCand )
{

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;

 
  pcCU->getPartIndexAndSize( iPUIdx, uiAbsPartIdx, iWidth, iHeight );
  UInt uiDepth = pcCU->getDepth( uiAbsPartIdx );

  PartSize partSize = pcCU->getPartitionSize( 0 );
  if ( pcCU->getSlice()->getPPS()->getLog2ParallelMergeLevelMinus2() && partSize != SIZE_2Nx2N && pcCU->getWidth( 0 ) <= 8 )
  {
    if ( iPUIdx == 0 )
    {
      pcCU->setPartSizeSubParts( SIZE_2Nx2N, 0, uiDepth ); // temporarily set
      pcCU->getInterMergeCandidates( 0, 0, cMvFieldNeighbours,uhInterDirNeighbours, numValidMergeCand );
      pcCU->setPartSizeSubParts( partSize, 0, uiDepth ); // restore
    }
  }
  else
  {
    pcCU->getInterMergeCandidates( uiAbsPartIdx, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );
  }

  xRestrictBipredMergeCand( pcCU, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );

  ruiCost = std::numeric_limits<Distortion>::max();
  for( UInt uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )
  {
    Distortion uiCostCand = std::numeric_limits<Distortion>::max();
    UInt       uiBitsCand = 0;

    PartSize ePartSize = pcCU->getPartitionSize( 0 );

    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( cMvFieldNeighbours[0 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( cMvFieldNeighbours[1 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );

    xGetInterPredictionError( pcCU, pcYuvOrg, iPUIdx, uiCostCand, m_pcEncCfg->getUseHADME() );
    uiBitsCand = uiMergeCand + 1;
    if (uiMergeCand == m_pcEncCfg->getMaxNumMergeCand() -1)
    {
        uiBitsCand--;
    }
    uiCostCand = uiCostCand + m_pcRdCost->getCost( uiBitsCand );
    if ( uiCostCand < ruiCost )
    {
      ruiCost = uiCostCand;
      pacMvField[0] = cMvFieldNeighbours[0 + 2*uiMergeCand];
      pacMvField[1] = cMvFieldNeighbours[1 + 2*uiMergeCand];
      uiInterDir = uhInterDirNeighbours[uiMergeCand];
      uiMergeIndex = uiMergeCand;
    }
  }
 
}

/** convert bi-pred merge candidates to uni-pred
 * \param pcCU
 * \param puIdx
 * \param mvFieldNeighbours
 * \param interDirNeighbours
 * \param numValidMergeCand
 * \returns Void
 */
Void TEncSearch::xRestrictBipredMergeCand( TComDataCU* pcCU, UInt puIdx, TComMvField* mvFieldNeighbours, UChar* interDirNeighbours, Int numValidMergeCand )
{
	
  if ( pcCU->isBipredRestriction(puIdx) )
  {
    for( UInt mergeCand = 0; mergeCand < numValidMergeCand; ++mergeCand )
    {
      if ( interDirNeighbours[mergeCand] == 3 )
      {
        interDirNeighbours[mergeCand] = 1;
        mvFieldNeighbours[(mergeCand << 1) + 1].setMvField(TComMv(0,0), -1);
      }
    }
  }
}

//! search of the best candidate for inter prediction
#if AMP_MRG
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv DEBUG_STRING_FN_DECLARE(sDebug), Bool bUseRes, Bool bUseMRG )
#else
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv, Bool bUseRes )
#endif
{
  for(UInt i=0; i<NUM_REF_PIC_LIST_01; i++)
  {
    m_acYuvPred[i].clear();
  }
  m_cYuvPredTemp.clear();
  pcPredYuv->clear();

  if ( !bUseRes )
  {
    pcResiYuv->clear();
  }

  pcRecoYuv->clear();
  
  TComMv       cMvSrchRngLT;
  TComMv       cMvSrchRngRB;

  TComMv       cMvZero;
  TComMv       TempMv; //kolya

  TComMv       cMv[2];
  TComMv       cMvBi[2];
  TComMv       cMvTemp[2][33];

  Int          iNumPart    = pcCU->getNumPartitions();
  Int          iNumPredDir = pcCU->getSlice()->isInterP() ? 1 : 2;

  TComMv       cMvPred[2][33];

  TComMv       cMvPredBi[2][33];
  Int          aaiMvpIdxBi[2][33];

  Int          aaiMvpIdx[2][33];
  Int          aaiMvpNum[2][33];

  AMVPInfo     aacAMVPInfo[2][33];

  Int          iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
  Int          iRefIdxBi[2];

  UInt         uiPartAddr;
  Int          iRoiWidth, iRoiHeight;

  UInt         uiMbBits[3] = {1, 1, 0};

  UInt         uiLastMode = 0;
  Int          iRefStart, iRefEnd;

  PartSize     ePartSize = pcCU->getPartitionSize( 0 );

  Int          bestBiPRefIdxL1 = 0;
  Int          bestBiPMvpL1 = 0;
  Distortion   biPDistTemp = std::numeric_limits<Distortion>::max();

  TComMvField cMvFieldNeighbours[MRG_MAX_NUM_CANDS << 1]; // double length for mv of both lists
  UChar uhInterDirNeighbours[MRG_MAX_NUM_CANDS];
  Int numValidMergeCand = 0 ;

  for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
  {
    Distortion   uiCost[2] = { std::numeric_limits<Distortion>::max(), std::numeric_limits<Distortion>::max() };
    Distortion   uiCostBi  =   std::numeric_limits<Distortion>::max();
    Distortion   uiCostTemp;

    UInt         uiBits[3];
    UInt         uiBitsTemp;
    Distortion   bestBiPDist = std::numeric_limits<Distortion>::max();

    Distortion   uiCostTempL0[MAX_NUM_REF];
    for (Int iNumRef=0; iNumRef < MAX_NUM_REF; iNumRef++)
    {
      uiCostTempL0[iNumRef] = std::numeric_limits<Distortion>::max();
    }
    UInt         uiBitsTempL0[MAX_NUM_REF];

    TComMv       mvValidList1;
    Int          refIdxValidList1 = 0;
    UInt         bitsValidList1 = MAX_UINT;
    Distortion   costValidList1 = std::numeric_limits<Distortion>::max();

    xGetBlkBits( ePartSize, pcCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);

    pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
	
	
#if AMP_MRG
    Bool bTestNormalMC = true;

    if ( bUseMRG && pcCU->getWidth( 0 ) > 8 && iNumPart == 2 )
    {
      bTestNormalMC = false;
    }

    if (bTestNormalMC)
    {
#endif

    //  Uni-directional prediction
    for ( Int iRefList = 0; iRefList < iNumPredDir; iRefList++ )
    {
      RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

      for ( Int iRefIdxTemp = 0; iRefIdxTemp < pcCU->getSlice()->getNumRefIdx(eRefPicList); iRefIdxTemp++ )
      {
        uiBitsTemp = uiMbBits[iRefList];
        if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
        {
          uiBitsTemp += iRefIdxTemp+1;
          if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
          {
            uiBitsTemp--;
          }
        }
        xEstimateMvPredAMVP( pcCU, pcOrgYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
        aaiMvpIdx[iRefList][iRefIdxTemp] = pcCU->getMVPIdx(eRefPicList, uiPartAddr);
        aaiMvpNum[iRefList][iRefIdxTemp] = pcCU->getMVPNum(eRefPicList, uiPartAddr);

        if(pcCU->getSlice()->getMvdL1ZeroFlag() && iRefList==1 && biPDistTemp < bestBiPDist)
        {
          bestBiPDist = biPDistTemp;
          bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
          bestBiPRefIdxL1 = iRefIdxTemp;
        }

        uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];

        if ( m_pcEncCfg->getFastMEForGenBLowDelayEnabled() && iRefList == 1 )    // list 1
        {
          if ( pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) >= 0 )
          {
            cMvTemp[1][iRefIdxTemp] = cMvTemp[0][pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            uiCostTemp = uiCostTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            /*first subtract the bit-rate part of the cost of the other list*/
            uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )] );
            /*correct the bit-rate part of the current ref*/
            m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
            uiBitsTemp += m_pcRdCost->getBitsOfVectorWithPredictor( cMvTemp[1][iRefIdxTemp].getHor(), cMvTemp[1][iRefIdxTemp].getVer() );
            /*calculate the correct cost*/
            uiCostTemp += m_pcRdCost->getCost( uiBitsTemp );
          }
          else
          {
            xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
          }
        }
        else
        {
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
        }
        xCopyAMVPInfo(pcCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
        xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

        if ( iRefList == 0 )
        {
          uiCostTempL0[iRefIdxTemp] = uiCostTemp;
          uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
        }
        if ( uiCostTemp < uiCost[iRefList] )
        {
          uiCost[iRefList] = uiCostTemp;
          uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

          // set motion
          cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
          iRefIdx[iRefList] = iRefIdxTemp;
        }

        if ( iRefList == 1 && uiCostTemp < costValidList1 && pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
        {
          costValidList1 = uiCostTemp;
          bitsValidList1 = uiBitsTemp;

          // set motion
          mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
          refIdxValidList1 = iRefIdxTemp;
        }
      }
    }

    //  Bi-predictive Motion estimation
    if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )
    {

      cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
      iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];

      ::memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
      ::memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));

      UInt uiMotBits[2];

      if(pcCU->getSlice()->getMvdL1ZeroFlag())
      {
        xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
        pcCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
        cMvPredBi[1][bestBiPRefIdxL1]   = pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo()->m_acMvCand[bestBiPMvpL1];

        cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
        iRefIdxBi[1] = bestBiPRefIdxL1;
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        TComYuv* pcYuvPred = &m_acYuvPred[REF_PIC_LIST_1];
        motionCompensation( pcCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );

        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiMbBits[1];

        if ( pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1) > 1 )
        {
          uiMotBits[1] += bestBiPRefIdxL1+1;
          if ( bestBiPRefIdxL1 == pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1)-1 )
          {
            uiMotBits[1]--;
          }
        }

        uiMotBits[1] += m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][AMVP_MAX_NUM_CANDS];

        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

        cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
      }
      else
      {
        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiBits[1] - uiMbBits[1];
        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
      }

      // 4-times iteration (default)
      Int iNumIter = 4;

      // fast encoder setting: only one iteration
      if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 || pcCU->getSlice()->getMvdL1ZeroFlag() )
      {
        iNumIter = 1;
      }

      for ( Int iIter = 0; iIter < iNumIter; iIter++ )
      {
        Int         iRefList    = iIter % 2;

        if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 )
        {
          if( uiCost[0] <= uiCost[1] )
          {
            iRefList = 1;
          }
          else
          {
            iRefList = 0;
          }
        }
        else if ( iIter == 0 )
        {
          iRefList = 0;
        }
        if ( iIter == 0 && !pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllMv( cMv[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllRefIdx( iRefIdx[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          TComYuv*  pcYuvPred = &m_acYuvPred[1-iRefList];
          motionCompensation ( pcCU, pcYuvPred, RefPicList(1-iRefList), iPartIdx );
        }

        RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

        if(pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          iRefList = 0;
          eRefPicList = REF_PIC_LIST_0;
        }

        Bool bChanged = false;

        iRefStart = 0;
        iRefEnd   = pcCU->getSlice()->getNumRefIdx(eRefPicList)-1;

        for ( Int iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
        {
          uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
          if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
          {
            uiBitsTemp += iRefIdxTemp+1;
            if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
            {
              uiBitsTemp--;
            }
          }
          uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];
          // call ME
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );

          xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], pcCU->getCUMvField(eRefPicList)->getAMVPInfo());
          xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

          if ( uiCostTemp < uiCostBi )
          {
            bChanged = true;

            cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
            iRefIdxBi[iRefList] = iRefIdxTemp;

            uiCostBi            = uiCostTemp;
            uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
            uiBits[2]           = uiBitsTemp;

            if(iNumIter!=1)
            {
              //  Set motion
              pcCU->getCUMvField( eRefPicList )->setAllMv( cMvBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
              pcCU->getCUMvField( eRefPicList )->setAllRefIdx( iRefIdxBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );

              TComYuv* pcYuvPred = &m_acYuvPred[iRefList];
              motionCompensation( pcCU, pcYuvPred, eRefPicList, iPartIdx );
            }
          }
        } // for loop-iRefIdxTemp

        if ( !bChanged )
        {
          if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
          {
            xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
            xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
            if(!pcCU->getSlice()->getMvdL1ZeroFlag())
            {
              xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
              xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
            }
          }
          break;
        }
      } // for loop-iter
    } // if (B_SLICE)

#if AMP_MRG
    } //end if bTestNormalMC
#endif
    //  Clear Motion Field
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );

    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

    UInt uiMEBits = 0;
    // Set Motion Field_
    cMv[1] = mvValidList1;
	
    iRefIdx[1] = refIdxValidList1;
    uiBits[1] = bitsValidList1;
    uiCost[1] = costValidList1;

#if AMP_MRG
    if (bTestNormalMC)
    {
#endif
    if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
    {
      uiLastMode = 2;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMvBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdxBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 3, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[2];
    }
    else if ( uiCost[0] <= uiCost[1] )
    {
      uiLastMode = 0;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[0];
    }
    else
    {
      uiLastMode = 1;
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMv[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdx[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 2, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[1];
    }
#if AMP_MRG
    } // end if bTestNormalMC
#endif

    if ( pcCU->getPartitionSize( uiPartAddr ) != SIZE_2Nx2N )
    {
      UInt uiMRGInterDir = 0;
      TComMvField cMRGMvField[2];
      UInt uiMRGIndex = 0;

      UInt uiMEInterDir = 0;
      TComMvField cMEMvField[2];

      m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

#if AMP_MRG
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      Distortion uiMECost  = std::numeric_limits<Distortion>::max();

      if (bTestNormalMC)
      {
        xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
        uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
      }
#else
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
      Distortion uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
#endif
      // save ME result.
      uiMEInterDir = pcCU->getInterDir( uiPartAddr );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

      // find Merge result
      Distortion uiMRGCost = std::numeric_limits<Distortion>::max();

      xMergeEstimation( pcCU, pcOrgYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);

      if ( uiMRGCost < uiMECost )
      {
        // set Merge result
        pcCU->setMergeFlagSubParts ( true,          uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setMergeIndexSubParts( uiMRGIndex,    uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts  ( uiMRGInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMRGMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMRGMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      }
      else
      {
        // set ME result
        pcCU->setMergeFlagSubParts( false,        uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts ( uiMEInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMEMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMEMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );
      }
    }

    //  MC
    motionCompensation ( pcCU, pcPredYuv, REF_PIC_LIST_X, iPartIdx );

  } //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )

  setWpScalingDistParam( pcCU, -1, REF_PIC_LIST_X );
 // CTUW = iRoiWidth;
 // CTUH = iRoiHeight;
 // myfile << CTUH << ',' << CTUW << endl;
  return;
}


// AMVP
Void TEncSearch::xEstimateMvPredAMVP( TComDataCU* pcCU, TComYuv* pcOrgYuv, UInt uiPartIdx, RefPicList eRefPicList, Int iRefIdx, TComMv& rcMvPred, Bool bFilled, Distortion* puiDistBiP )
{

  AMVPInfo*  pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();

  TComMv     cBestMv;
  Int        iBestIdx   = 0;
  TComMv     cZeroMv;
  TComMv     cMvPred;
  Distortion uiBestCost = std::numeric_limits<Distortion>::max();
  UInt       uiPartAddr = 0;
  Int        iRoiWidth, iRoiHeight;
  Int        i;
 
  pcCU->getPartIndexAndSize( uiPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
 

  // Fill the MV Candidates
  if (!bFilled)
  {
    pcCU->fillMvpCand( uiPartIdx, uiPartAddr, eRefPicList, iRefIdx, pcAMVPInfo );
  }

  // initialize Mvp index & Mvp
  iBestIdx = 0;
  cBestMv  = pcAMVPInfo->m_acMvCand[0];
  if (pcAMVPInfo->iN <= 1)
  {
    rcMvPred = cBestMv;

    pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));

    if(pcCU->getSlice()->getMvdL1ZeroFlag() && eRefPicList==REF_PIC_LIST_1)
    {
      (*puiDistBiP) = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, rcMvPred, 0, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    }
    return;
  }

  if (bFilled)
  {
    assert(pcCU->getMVPIdx(eRefPicList,uiPartAddr) >= 0);
    rcMvPred = pcAMVPInfo->m_acMvCand[pcCU->getMVPIdx(eRefPicList,uiPartAddr)];
    return;
  }

  m_cYuvPredTemp.clear();
  //-- Check Minimum Cost.
  for ( i = 0 ; i < pcAMVPInfo->iN; i++)
  {
    Distortion uiTmpCost;
    uiTmpCost = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, pcAMVPInfo->m_acMvCand[i], i, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    if ( uiBestCost > uiTmpCost )
    {
      uiBestCost = uiTmpCost;
      cBestMv   = pcAMVPInfo->m_acMvCand[i];
      iBestIdx  = i;
      (*puiDistBiP) = uiTmpCost;
    }
  }

  m_cYuvPredTemp.clear();

  // Setting Best MVP
  rcMvPred = cBestMv;
  pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  return;
  
}

UInt TEncSearch::xGetMvpIdxBits(Int iIdx, Int iNum)
{
  assert(iIdx >= 0 && iNum >= 0 && iIdx < iNum);

  if (iNum == 1)
  {
    return 0;
  }

  UInt uiLength = 1;
  Int iTemp = iIdx;
  if ( iTemp == 0 )
  {
    return uiLength;
  }

  Bool bCodeLast = ( iNum-1 > iTemp );

  uiLength += (iTemp-1);

  if( bCodeLast )
  {
    uiLength++;
  }

  return uiLength;
}

Void TEncSearch::xGetBlkBits( PartSize eCUMode, Bool bPSlice, Int iPartIdx, UInt uiLastMode, UInt uiBlkBit[3])
{
  if ( eCUMode == SIZE_2Nx2N )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else if ( (eCUMode == SIZE_2NxN || eCUMode == SIZE_2NxnU) || eCUMode == SIZE_2NxnD )
  {
    UInt aauiMbBits[2][3][3] = { { {0,0,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7,5,7}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( (eCUMode == SIZE_Nx2N || eCUMode == SIZE_nLx2N) || eCUMode == SIZE_nRx2N )
  {
    UInt aauiMbBits[2][3][3] = { { {0,2,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7-2,7-2,9-2}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( eCUMode == SIZE_NxN )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else
  {
    printf("Wrong!\n");
    assert( 0 );
  }
}

Void TEncSearch::xCopyAMVPInfo (AMVPInfo* pSrc, AMVPInfo* pDst)
{
  pDst->iN = pSrc->iN;
  for (Int i = 0; i < pSrc->iN; i++)
  {
    pDst->m_acMvCand[i] = pSrc->m_acMvCand[i];
  }
}

Void TEncSearch::xCheckBestMVP ( TComDataCU* pcCU, RefPicList eRefPicList, TComMv cMv, TComMv& rcMvPred, Int& riMVPIdx, UInt& ruiBits, Distortion& ruiCost )
{
  AMVPInfo* pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();
  
  assert(pcAMVPInfo->m_acMvCand[riMVPIdx] == rcMvPred);

  if (pcAMVPInfo->iN < 2)
  {
    return;
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(0) );
  m_pcRdCost->setCostScale ( 0    );

  Int iBestMVPIdx = riMVPIdx;

  m_pcRdCost->setPredictor( rcMvPred );
  Int iOrgMvBits  = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
  iOrgMvBits += m_auiMVPIdxCost[riMVPIdx][AMVP_MAX_NUM_CANDS];
  Int iBestMvBits = iOrgMvBits;

  for (Int iMVPIdx = 0; iMVPIdx < pcAMVPInfo->iN; iMVPIdx++)
  {
    if (iMVPIdx == riMVPIdx)
    {
      continue;
    }

    m_pcRdCost->setPredictor( pcAMVPInfo->m_acMvCand[iMVPIdx] );

    Int iMvBits = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
    iMvBits += m_auiMVPIdxCost[iMVPIdx][AMVP_MAX_NUM_CANDS];

    if (iMvBits < iBestMvBits)
    {
      iBestMvBits = iMvBits;
      iBestMVPIdx = iMVPIdx;
    }
  }

  if (iBestMVPIdx != riMVPIdx)  //if changed
  {
    rcMvPred = pcAMVPInfo->m_acMvCand[iBestMVPIdx];

    riMVPIdx = iBestMVPIdx;
    UInt uiOrgBits = ruiBits;
    ruiBits = uiOrgBits - iOrgMvBits + iBestMvBits;
    ruiCost = (ruiCost - m_pcRdCost->getCost( uiOrgBits ))  + m_pcRdCost->getCost( ruiBits );
  }
  
}


Distortion TEncSearch::xGetTemplateCost( TComDataCU* pcCU,
                                         UInt        uiPartAddr,
                                         TComYuv*    pcOrgYuv,
                                         TComYuv*    pcTemplateCand,
                                         TComMv      cMvCand,
                                         Int         iMVPIdx,
                                         Int         iMVPNum,
                                         RefPicList  eRefPicList,
                                         Int         iRefIdx,
                                         Int         iSizeX,
                                         Int         iSizeY
                                         )
{
  Distortion uiCost = std::numeric_limits<Distortion>::max();

  TComPicYuv* pcPicYuvRef = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdx )->getPicYuvRec();

  pcCU->clipMv( cMvCand );

  // prediction pattern
  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, true, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }
  else
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, false, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }

  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xWeightedPredictionUni( pcCU, pcTemplateCand, uiPartAddr, iSizeX, iSizeY, eRefPicList, pcTemplateCand, iRefIdx );
  }

  // calc distortion

  uiCost = m_pcRdCost->getDistPart( pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA), pcTemplateCand->getAddr(COMPONENT_Y, uiPartAddr), pcTemplateCand->getStride(COMPONENT_Y), pcOrgYuv->getAddr(COMPONENT_Y, uiPartAddr), pcOrgYuv->getStride(COMPONENT_Y), iSizeX, iSizeY, COMPONENT_Y, DF_SAD );
  uiCost = (UInt) m_pcRdCost->calcRdCost( m_auiMVPIdxCost[iMVPIdx][iMVPNum], uiCost, DF_SAD );
  return uiCost;
}


Void TEncSearch::xMotionEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, RefPicList eRefPicList, TComMv* pcMvPred, Int iRefIdxPred, TComMv& rcMv, UInt& ruiBits, Distortion& ruiCost, Bool bBi  )
{
  UInt          uiPartAddr;
  Int           iRoiWidth;
  Int           iRoiHeight;

  TComMv        cMvHalf, cMvQter;
  TComMv        cMvSrchRngLT;
  TComMv        cMvSrchRngRB;
  // Distortion   INTCOST=0;
  TComYuv*      pcYuv = pcYuvOrg;
   
  assert(eRefPicList < MAX_NUM_REF_LIST_ADAPT_SR && iRefIdxPred<Int(MAX_IDX_ADAPT_SR));
  m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];

  Int           iSrchRng      = ( bBi ? m_bipredSearchRange : m_iSearchRange );
  TComPattern   tmpPattern;
  TComPattern*  pcPatternKey  = &tmpPattern;

  Double        fWeight       = 1.0;

  pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );

  if ( bBi ) // Bipredictive ME
  {
    TComYuv*  pcYuvOther = &m_acYuvPred[1-(Int)eRefPicList];
    pcYuv                = &m_cYuvPredTemp;

    pcYuvOrg->copyPartToPartYuv( pcYuv, uiPartAddr, iRoiWidth, iRoiHeight );

    pcYuv->removeHighFreq( pcYuvOther, uiPartAddr, iRoiWidth, iRoiHeight, pcCU->getSlice()->getSPS()->getBitDepths().recon, m_pcEncCfg->getClipForBiPredMeEnabled() );

    fWeight = 0.5;
  }
  m_cDistParam.bIsBiPred = bBi;

  //  Search key pattern initialization
  pcPatternKey->initPattern( pcYuv->getAddr  ( COMPONENT_Y, uiPartAddr ),
                             iRoiWidth,
                             iRoiHeight,
                             pcYuv->getStride(COMPONENT_Y),
                             pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );

  Pel*        piRefY      = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu() + uiPartAddr );
  Int         iRefStride  = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getStride(COMPONENT_Y);

  TComMv      cMvPred = *pcMvPred;

  if ( bBi )
  {
	  
    xSetSearchRange   ( pcCU, rcMv   , iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }
  else
  {
	  
    xSetSearchRange   ( pcCU, cMvPred, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }

  m_pcRdCost->selectMotionLambda(true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setPredictor  ( *pcMvPred );
  m_pcRdCost->setCostScale  ( 2 );

  setWpScalingDistParam( pcCU, iRefIdxPred, eRefPicList );
  //  Do integer search
  if ( (m_motionEstimationSearchMethod==MESEARCH_FULL) || bBi )
  {
    xPatternSearch      ( pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost );
  }
  else
  {
    rcMv = *pcMvPred;
    const TComMv *pIntegerMv2Nx2NPred=0;
    if (pcCU->getPartitionSize(0) != SIZE_2Nx2N || pcCU->getDepth(0) != 0)
    {
      pIntegerMv2Nx2NPred = &(m_integerMv2Nx2N[eRefPicList][iRefIdxPred]);
    }
    
    // EMI: Save Block width and height in global variables, to use in our NN
    PUHeight = iRoiHeight;
    PUWidth = iRoiWidth;

    xPatternSearchFast  ( pcCU, pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost, pIntegerMv2Nx2NPred );
    if (pcCU->getPartitionSize(0) == SIZE_2Nx2N)
    {
      m_integerMv2Nx2N[eRefPicList][iRefIdxPred] = rcMv;
    }
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );
  m_pcRdCost->setCostScale ( 1 );
  
  const Bool bIsLosslessCoded = pcCU->getCUTransquantBypass(uiPartAddr) != 0;
  xPatternSearchFracDIF( bIsLosslessCoded, pcPatternKey, piRefY, iRefStride, &rcMv, cMvHalf, cMvQter, ruiCost );

  m_pcRdCost->setCostScale( 0 );

  
  
  // EMI: Modification
  
  /* 
  Fractional Motion Estimation values computed by standard are stored in TComMv variables cMvHalf & cMvQter
  We create other TComMv variables, and replace the standard values with our NN predicted values
  Our NN modifies global variables MVX_HALF & MVX_QRTER, which in return are set used to set our new Mv
  */
  TComMv MV_HALF, MV_QRTER;
  MV_HALF.setHor(MVX_HALF);
  MV_HALF.setVer(MVY_HALF);
  MV_QRTER.setHor(MVX_QRTER);
  MV_QRTER.setVer(MVY_QRTER);

  // For finding Integer Motion Estimation, Set Horizontal and Vertical values to zero:

  // MV_HALF.setHor(0);
  // MV_HALF.setVer(0);
  // MV_QRTER.setHor(0);
  // MV_QRTER.setVer(0);

  /* 
  EMI: To Write the errors and output MV in a CSV file:
  Real values for errors: U,V,H           - NN values for errors: IN[]
  Real values for MV: cMvHalf, cMvQter    - NN values for MV: MV_HALF, MV_QRTER
  Block Width and Hight: iRoiWidth, iRoiHeight
  */
  
  // ofstream mv_nn;
  // ofstream errors;
  // errors.open("/home/vague/git-repos/data/HM16.9/extract_data/SSE_errors.csv", ios::app);
  // mv_nn.open("/home/vague/git-repos/data/HM16.9/extract_data/mv_nn.csv", ios::app);
  // mv_nn << NN_out << endl;
  // mv_nn << MV_HALF.getHor() << ',' << MV_QRTER.getHor() << ',' << MV_HALF.getVer() << ',' << MV_QRTER.getVer() << endl;
  // mv_nn << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer()  << endl;
  // errors << IN[8] << ',' << IN[9] << ',' << IN[10] << ',' << IN[11] << ',' << IN[12] << ',' << IN[13] << ',' << IN[14] << ',' << IN[15] << ',' << IN[16] << endl;
  // errors << IN[0] << ',' << IN[1] << ',' << IN[2] << ',' << IN[3] << ',' << IN[4] << ',' << IN[5] << ',' << IN[6] << ',' << IN[7] << endl;

  // errors << U1 << ',' << V1 << ',' << U2 << ',' << H1 << ',' << C << ',' << H2 << ',' << U3 << ',' << V2 << ',' << U4 << ',' << iRoiHeight << ',' << iRoiWidth  << endl;
  
  /*
  EXPERIMENTAL -> Write the values of the output class directly instead of coordinates "Works quite well":
  Half * 0.5 + Quarter * 0.25:  results in range from -0.75->0.75
  Add both X & Y + 0.75:        range is now 0->1.5
  Multiply X by 4:              X values are now [0, 1, 2, 3, 4, 5, 6]
  Multiply Y by 4*7=28:         Y values are now [0, 7, 14, 21, 28, 35, 42]
  Adding X+Y results in the desired output class, given that the mapping starts from 
  0 for top left corner, 24 center, and 48 for bottom right corner
  */
  
  // int MV_X = (((cMvHalf.getHor() * 0.5) + (cMvQter.getHor() * 0.25)) + 0.75) * 4;
  // int MV_Y = (((cMvHalf.getVer() * 0.5) + (cMvQter.getVer() * 0.25)) + 0.75) * 28;
  // int OUT_CLASS = MV_Y + MV_X;
  // mv_nn << OUT_CLASS << endl;
  // mv_nn << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer()  << endl;
  

  // Replace Motion Vector with values computed by our NN

  rcMv <<= 2;
  // rcMv += (cMvHalf <<= 1);
  // rcMv += cMvQter;
  rcMv += (MV_HALF <<= 1);
  rcMv += MV_QRTER;
  
  // End of modification

  UInt uiMvBits = m_pcRdCost->getBitsOfVectorWithPredictor( rcMv.getHor(), rcMv.getVer() );

  ruiBits      += uiMvBits;
  ruiCost       = (Distortion)( floor( fWeight * ( (Double)ruiCost - (Double)m_pcRdCost->getCost( uiMvBits ) ) ) + (Double)m_pcRdCost->getCost( ruiBits ) );
}


Void TEncSearch::xSetSearchRange ( const TComDataCU* const pcCU, const TComMv& cMvPred, const Int iSrchRng,
                                   TComMv& rcMvSrchRngLT, TComMv& rcMvSrchRngRB )
{
  Int  iMvShift = 2;
  TComMv cTmpMvPred = cMvPred;
  pcCU->clipMv( cTmpMvPred );

  rcMvSrchRngLT.setHor( cTmpMvPred.getHor() - (iSrchRng << iMvShift) );
  rcMvSrchRngLT.setVer( cTmpMvPred.getVer() - (iSrchRng << iMvShift) );

  rcMvSrchRngRB.setHor( cTmpMvPred.getHor() + (iSrchRng << iMvShift) );
  rcMvSrchRngRB.setVer( cTmpMvPred.getVer() + (iSrchRng << iMvShift) );
  pcCU->clipMv        ( rcMvSrchRngLT );
  pcCU->clipMv        ( rcMvSrchRngRB );

#if ME_ENABLE_ROUNDING_OF_MVS
  rcMvSrchRngLT.divideByPowerOf2(iMvShift);
  rcMvSrchRngRB.divideByPowerOf2(iMvShift);
#else
  rcMvSrchRngLT >>= iMvShift;
  rcMvSrchRngRB >>= iMvShift;
#endif
}


Void TEncSearch::xPatternSearch(const TComPattern* const pcPatternKey,
	const Pel*               piRefY,
	const Int                iRefStride,
	const TComMv* const      pcMvSrchRngLT,
	const TComMv* const      pcMvSrchRngRB,
	TComMv&      rcMv,
	Distortion&  ruiSAD)
{
	Int   iSrchRngHorLeft = pcMvSrchRngLT->getHor();
	Int   iSrchRngHorRight = pcMvSrchRngRB->getHor();
	Int   iSrchRngVerTop = pcMvSrchRngLT->getVer();
	Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

	Distortion  uiSad;
	Distortion  uiSadBest = std::numeric_limits<Distortion>::max();
	Int         iBestX = 0;
	Int         iBestY = 0;


	m_pcRdCost->setDistParam(pcPatternKey, piRefY, iRefStride, m_cDistParam);

	// fast encoder decision: use subsampled SAD for integer ME
	if (m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE3)
	{
		if (m_cDistParam.iRows > 8)
		{
			m_cDistParam.iSubShift = 1;
		}
	}

	piRefY += (iSrchRngVerTop * iRefStride);

	for (Int y = iSrchRngVerTop; y <= iSrchRngVerBottom; y++)
	{
		for (Int x = iSrchRngHorLeft; x <= iSrchRngHorRight; x++)
		{
			//  find min. distortion position
			m_cDistParam.pCur = piRefY + x;

			setDistParamComp(COMPONENT_Y);

			m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
			uiSad = m_cDistParam.DistFunc(&m_cDistParam);

			// motion cost
			uiSad += m_pcRdCost->getCostOfVectorWithPredictor(x, y);

			if (uiSad < uiSadBest)
			{
				uiSadBest = uiSad;
				iBestX = x;
				iBestY = y;
				m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
			}
		}
		piRefY += iRefStride;
	}




		rcMv.set(iBestX, iBestY);


		ruiSAD = uiSadBest - m_pcRdCost->getCostOfVectorWithPredictor(iBestX, iBestY);

		//getchar();
		return;
	}


Void TEncSearch::xPatternSearchFast( const TComDataCU* const  pcCU,
                                     const TComPattern* const pcPatternKey,
                                     const Pel* const         piRefY,
                                     const Int                iRefStride,
                                     const TComMv* const      pcMvSrchRngLT,
                                     const TComMv* const      pcMvSrchRngRB,
                                     TComMv&                  rcMv,
                                     Distortion&              ruiSAD,
                                     const TComMv* const      pIntegerMv2Nx2NPred )
{
  assert (MD_LEFT < NUM_MV_PREDICTORS);
  pcCU->getMvPredLeft       ( m_acMvPredictors[MD_LEFT] );
  assert (MD_ABOVE < NUM_MV_PREDICTORS);
  pcCU->getMvPredAbove      ( m_acMvPredictors[MD_ABOVE] );
  assert (MD_ABOVE_RIGHT < NUM_MV_PREDICTORS);
  pcCU->getMvPredAboveRight ( m_acMvPredictors[MD_ABOVE_RIGHT] );

  switch ( m_motionEstimationSearchMethod )
  {
    case MESEARCH_DIAMOND:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, false );
	  
      C = array_e[0];
      for (int i = 1; i <=index_ref - 1; i++)
      {
        if (array_e[i] < C)
          C = array_e[i];

      }
	 
      // index_ref = index_ref + 1;
      U1 = array_e[index_ref];
      V1 = array_e[index_ref + 1];
      U2 = array_e[index_ref + 2];
      H1 = array_e[index_ref + 3];	  
      H2 = array_e[index_ref + 4];
      U3 = array_e[index_ref + 5];
      V2 = array_e[index_ref + 6];
      U4 = array_e[index_ref + 7];
      	  
      // EMI: neural network implementation
      
      // Reset all values of arrays

      memset(IN, 0, sizeof(IN));
      memset(X1, 0, sizeof(X1));
      memset(X2, 0, sizeof(X2));
      memset(OUT, 0, sizeof(OUT));
      memset(array_e, 0, sizeof(array_e));
      N = 0; NN_out = 0; counter_i = 0; index_ref = 0;


      // Normalize input values using the computed mean and standard deviations

      IN[8] = (U1 - mean[0]) / stdev[0];
      IN[9] = (V1 - mean[1]) / stdev[1];
      IN[10] = (U2 - mean[2]) / stdev[2];
      IN[11] = (H1 - mean[3]) / stdev[3];
      IN[12] = (C - mean[4]) / stdev[4];
      IN[13] = (H2 - mean[5]) / stdev[5];
      IN[14] = (U3 - mean[6]) / stdev[6];
      IN[15] = (V2 - mean[7]) / stdev[7];
      IN[16] = (U4 - mean[8]) / stdev[8];

      // Input layer also consists of categorical variables, in which we will use embedding matrices depending on block Height and Width

      switch (PUHeight) {
        case 4:   IN[0] = embs0[1][0];  IN[1] = embs0[1][1];   IN[2] = embs0[1][2];   IN[3] = embs0[1][3];		break;
        case 8:   IN[0] = embs0[2][0];  IN[1] = embs0[2][1];   IN[2] = embs0[2][2];   IN[3] = embs0[2][3];		break;
        case 12:  IN[0] = embs0[3][0];  IN[1] = embs0[3][1];   IN[2] = embs0[3][2];   IN[3] = embs0[3][3];	  break;
        case 16:  IN[0] = embs0[4][0];  IN[1] = embs0[4][1];   IN[2] = embs0[4][2];   IN[3] = embs0[4][3];		break;
        case 24:  IN[0] = embs0[5][0];  IN[1] = embs0[5][1];   IN[2] = embs0[5][2];   IN[3] = embs0[5][3];	  break;
        case 32:  IN[0] = embs0[6][0];  IN[1] = embs0[6][1];   IN[2] = embs0[6][2];   IN[3] = embs0[6][3];		break;
        case 64:  IN[0] = embs0[7][0];  IN[1] = embs0[7][1];   IN[2] = embs0[7][2];   IN[3] = embs0[7][3];		break;
        default:  IN[0] = embs0[0][0];  IN[1] = embs0[0][1];   IN[2] = embs0[0][2];   IN[3] = embs0[0][3];		break;
      }

      switch (PUWidth) {
        case 4:   IN[4] = embs1[1][0];  IN[5] = embs1[1][1];   IN[6] = embs1[1][2];   IN[7] = embs1[1][3];		break;
        case 8:   IN[4] = embs1[2][0];  IN[5] = embs1[2][1];   IN[6] = embs1[2][2];   IN[7] = embs1[2][3];		break;
        case 12:  IN[4] = embs1[3][0];  IN[5] = embs1[3][1];   IN[6] = embs1[3][2];   IN[7] = embs1[3][3];	  break;
        case 16:  IN[4] = embs1[4][0];  IN[5] = embs1[4][1];   IN[6] = embs1[4][2];   IN[7] = embs1[4][3];		break;
        case 24:  IN[4] = embs1[5][0];  IN[5] = embs1[5][1];   IN[6] = embs1[5][2];   IN[7] = embs1[5][3];	  break;
        case 32:  IN[4] = embs1[6][0];  IN[5] = embs1[6][1];   IN[6] = embs1[6][2];   IN[7] = embs1[6][3];		break;
        case 64:  IN[4] = embs1[7][0];  IN[5] = embs1[7][1];   IN[6] = embs1[7][2];   IN[7] = embs1[7][3];		break;
        default:  IN[4] = embs1[0][0];  IN[5] = embs1[0][1];   IN[6] = embs1[0][2];   IN[7] = embs1[0][3];		break;
      }

      // Input Layer
      for(int i=0;i<9;i++){
        IN[i+8] = (IN[i+8] * BN_gamma_in[i]);	  
      }

      
      // First Hidden Layer
      for (int i = 0; i < 22; i++) {
        for (int j = 0; j < 17; j++) {
          X1[i] += (in_h1[i][j] * IN[j]);
        }
        X1[i] += b1[i];
        X1[i] = (relu(X1[i]) * BN_gamma_1[i]) + BN_beta_1[i];
      }

      // Second Hidden Layer
      for (int i = 0; i < 20; i++) {
        for (int j = 0; j < 22; j++) {
          X2[i] += (h1_h2[i][j] * X1[j]);
        }
        X2[i] += b2[i];
        X2[i] = (relu(X2[i]) * BN_gamma_2[i]) + BN_beta_2[i];
      }

      // OUTPUT LAYER
      for (int i = 0; i < 49; i++) {
        for (int j = 0; j < 20; j++) {
          OUT[i] += (h2_out[i][j] * X2[j]);
        }
        OUT[i] += bout[i];
      }
      
      // Decision: NN_out holds the index of the maximum element

      N = sizeof(OUT) / sizeof(float); // Size of OUT[] array, used in next step
      NN_out = std::distance(OUT, std::max_element(OUT, OUT + N));
      
      switch (NN_out) {
        case 0: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 1: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 2: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 3: MVX_HALF = 0;   MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 4: MVX_HALF = 0;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 5: MVX_HALF = 1;   MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 6: MVX_HALF = 1;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;

        case 7: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 8: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 9: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 10: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 11: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 12: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 13: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;

        case 14: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 15: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 16: MVX_HALF = 0;  MVX_QRTER = -1;   MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 17: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 18: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 19: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 20: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;

        case 21: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 22: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 23: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 24: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 25: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 26: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 27: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;

        case 28: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 29: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 30: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 31: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 32: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 33: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 34: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;

        case 35: MVX_HALF = -1; MVX_QRTER = -1;   MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 36: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 37: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 38: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 0;		break;
        case 39: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 40: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 41: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;

        case 42: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 43: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 44: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 45: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 1;	  break;
        case 46: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 47: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 48: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        default: MVX_HALF = 0;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
      }


      //end of neural network code

      break;



    case MESEARCH_SELECTIVE:
      xTZSearchSelective( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred );
      break;

    case MESEARCH_DIAMOND_ENHANCED:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, true );
      break;

    case MESEARCH_FULL: // shouldn't get here.
    default:
      break;
  }
}


Void TEncSearch::xTZSearch( const TComDataCU* const pcCU,
                            const TComPattern* const pcPatternKey,
                            const Pel* const         piRefY,
                            const Int                iRefStride,
                            const TComMv* const      pcMvSrchRngLT,
                            const TComMv* const      pcMvSrchRngRB,
                            TComMv&                  rcMv,
                            Distortion&              ruiSAD,
                            const TComMv* const      pIntegerMv2Nx2NPred,
                            const Bool               bExtendedSettings)
{
  const Bool bUseAdaptiveRaster                      = bExtendedSettings;
  const Int  iRaster                                 = 5;
  const Bool bTestOtherPredictedMV                   = bExtendedSettings;
  const Bool bTestZeroVector                         = true;
  const Bool bTestZeroVectorStart                    = bExtendedSettings;
  const Bool bTestZeroVectorStop                     = false;
  const Bool bFirstSearchDiamond                     = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bFirstCornersForDiamondDist1            = bExtendedSettings;
  const Bool bFirstSearchStop                        = m_pcEncCfg->getFastMEAssumingSmootherMVEnabled();
  const UInt uiFirstSearchRounds                     = 3;     // first search stop X rounds after best match (must be >=1)
  const Bool bEnableRasterSearch                     = true;
  const Bool bAlwaysRasterSearch                     = bExtendedSettings;  // true: BETTER but factor 2 slower
  const Bool bRasterRefinementEnable                 = false; // enable either raster refinement or star refinement
  const Bool bRasterRefinementDiamond                = false; // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bRasterRefinementCornersForDiamondDist1 = bExtendedSettings;
  const Bool bStarRefinementEnable                   = true;  // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond                  = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementCornersForDiamondDist1   = bExtendedSettings;
  const Bool bStarRefinementStop                     = false;
  const UInt uiStarRefinementRounds                  = 2;  // star refinement stop X rounds after best match (must be >=1)
  const Bool bNewZeroNeighbourhoodTest               = bExtendedSettings;

  UInt uiSearchRange = m_iSearchRange;
  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;

  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      if (cMv != rcMv && (cMv.getHor() != cStruct.iBestX && cMv.getVer() != cStruct.iBestY))
      {
        // only test cMV if not obviously previously tested.
        xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
      }
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    if ((rcMv.getHor() != 0 || rcMv.getVer() != 0) &&
        (0 != cStruct.iBestX || 0 != cStruct.iBestY))
    {
      // only test 0-vector if not obviously previously tested.
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
    }
  }

  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  if (pIntegerMv2Nx2NPred != 0)
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    if ((rcMv != integerMv2Nx2NPred) &&
        (integerMv2Nx2NPred.getHor() != cStruct.iBestX || integerMv2Nx2NPred.getVer() != cStruct.iBestY))
    {
      // only test integerMv2Nx2NPred if not obviously previously tested.
      xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);
    }

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // start search
  Int  iDist = 0;
  Int  iStartX = cStruct.iBestX;
  Int  iStartY = cStruct.iBestY;

  const Bool bBestCandidateZero = (cStruct.iBestX == 0) && (cStruct.iBestY == 0);

  // first search around best position up to now.
  // The following works as a "subsampled/log" window search around the best candidate
  for (iDist = 1; iDist <= (Int)uiSearchRange; iDist *= 2)
	  
  {
    if ( bFirstSearchDiamond == 1 )
    {
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bFirstCornersForDiamondDist1 );
    }
    else
    {
      xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
    }

    if ( bFirstSearchStop && ( cStruct.uiBestRound >= uiFirstSearchRounds ) ) // stop criterion
    {
      break;
    }
  }

  if (!bNewZeroNeighbourhoodTest)
  {
    // test whether zero Mv is a better start point than Median predictor
    if ( bTestZeroVectorStart && ((cStruct.iBestX != 0) || (cStruct.iBestY != 0)) )
    {
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
      if ( (cStruct.iBestX == 0) && (cStruct.iBestY == 0) )
      {
        // test its neighborhood
        for ( iDist = 1; iDist <= (Int)uiSearchRange; iDist*=2 )
        {
          xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
          if ( bTestZeroVectorStop && (cStruct.uiBestRound > 0) ) // stop criterion
          {
            break;
          }
        }
      }
    }
  }
  else
  {
    // Test also zero neighbourhood but with half the range
    // It was reported that the original (above) search scheme using bTestZeroVectorStart did not
    // make sense since one would have already checked the zero candidate earlier
    // and thus the conditions for that test would have not been satisfied
    if (bTestZeroVectorStart == true && bBestCandidateZero != true)
    {
      for ( iDist = 1; iDist <= ((Int)uiSearchRange >> 1); iDist*=2 )
      {
        xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
        if ( bTestZeroVectorStop && (cStruct.uiBestRound > 2) ) // stop criterion
        {
          break;
        }
      }
    }
  }

  // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
  if ( cStruct.uiBestDistance == 1 )
  {
    cStruct.uiBestDistance = 0;
    xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
  }

  // raster search if distance is too big
  if (bUseAdaptiveRaster)
  {
    int iWindowSize = iRaster;
    Int   iSrchRngRasterLeft   = iSrchRngHorLeft;
    Int   iSrchRngRasterRight  = iSrchRngHorRight;
    Int   iSrchRngRasterTop    = iSrchRngVerTop;
    Int   iSrchRngRasterBottom = iSrchRngVerBottom;

    if (!(bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster))))
    {
      iWindowSize ++;
      iSrchRngRasterLeft /= 2;
      iSrchRngRasterRight /= 2;
      iSrchRngRasterTop /= 2;
      iSrchRngRasterBottom /= 2;
    }
    cStruct.uiBestDistance = iWindowSize;
    for ( iStartY = iSrchRngRasterTop; iStartY <= iSrchRngRasterBottom; iStartY += iWindowSize )
    {
      for ( iStartX = iSrchRngRasterLeft; iStartX <= iSrchRngRasterRight; iStartX += iWindowSize )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iWindowSize );
      }
    }
  }
  else
  {
    if ( bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster) || bAlwaysRasterSearch ) )
    {
      cStruct.uiBestDistance = iRaster;
      for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += iRaster )
      {
        for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += iRaster )
        {
          xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iRaster );
        }
      }
    }
  }

  // raster refinement

  if ( bRasterRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      if ( cStruct.uiBestDistance > 1 )
      {
        iDist = cStruct.uiBestDistance >>= 1;
        if ( bRasterRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bRasterRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
      }

      // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // star refinement
  if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bStarRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }


  // EMI: BIG DIFFERENCE!
  // getting the 8 SAD points
  iDist = 1;
  iStartX = cStruct.iBestX;
  iStartY = cStruct.iBestY;
  index_ref = counter_i;
  
  xTZ8PointSquareSearch(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  iDist = 2;
  xTZ8PointSquareSearch2(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );
}


Void TEncSearch::xTZSearchSelective( const TComDataCU* const   pcCU,
                                     const TComPattern* const  pcPatternKey,
                                     const Pel* const          piRefY,
                                     const Int                 iRefStride,
                                     const TComMv* const       pcMvSrchRngLT,
                                     const TComMv* const       pcMvSrchRngRB,
                                     TComMv                   &rcMv,
                                     Distortion               &ruiSAD,
                                     const TComMv* const       pIntegerMv2Nx2NPred )
{
  const Bool bTestOtherPredictedMV    = true;
  const Bool bTestZeroVector          = true;
  const Bool bEnableRasterSearch      = true;
  const Bool bAlwaysRasterSearch      = false;  // 1: BETTER but factor 15x slower
  const Bool bStarRefinementEnable    = true;   // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond   = true;   // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementStop      = false;
  const UInt uiStarRefinementRounds   = 2;  // star refinement stop X rounds after best match (must be >=1)
  const UInt uiSearchRange            = m_iSearchRange;
  const Int  uiSearchRangeInitial     = m_iSearchRange >> 2;
  const Int  uiSearchStep             = 4;
  const Int  iMVDistThresh            = 8;

  Int   iSrchRngHorLeft         = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight        = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop          = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom       = pcMvSrchRngRB->getVer();
  Int   iFirstSrchRngHorLeft    = 0;
  Int   iFirstSrchRngHorRight   = 0;
  Int   iFirstSrchRngVerTop     = 0;
  Int   iFirstSrchRngVerBottom  = 0;
  Int   iStartX                 = 0;
  Int   iStartY                 = 0;
  Int   iBestX                  = 0;
  Int   iBestY                  = 0;
  Int   iDist                   = 0;

  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;
  cStruct.iBestX = 0;
  cStruct.iBestY = 0;


  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
  }

  if ( pIntegerMv2Nx2NPred != 0 )
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // Initial search
  iBestX = cStruct.iBestX;
  iBestY = cStruct.iBestY; 
  iFirstSrchRngHorLeft    = ((iBestX - uiSearchRangeInitial) > iSrchRngHorLeft)   ? (iBestX - uiSearchRangeInitial) : iSrchRngHorLeft;
  iFirstSrchRngVerTop     = ((iBestY - uiSearchRangeInitial) > iSrchRngVerTop)    ? (iBestY - uiSearchRangeInitial) : iSrchRngVerTop;
  iFirstSrchRngHorRight   = ((iBestX + uiSearchRangeInitial) < iSrchRngHorRight)  ? (iBestX + uiSearchRangeInitial) : iSrchRngHorRight;  
  iFirstSrchRngVerBottom  = ((iBestY + uiSearchRangeInitial) < iSrchRngVerBottom) ? (iBestY + uiSearchRangeInitial) : iSrchRngVerBottom;    

  for ( iStartY = iFirstSrchRngVerTop; iStartY <= iFirstSrchRngVerBottom; iStartY += uiSearchStep )
  {
    for ( iStartX = iFirstSrchRngHorLeft; iStartX <= iFirstSrchRngHorRight; iStartX += uiSearchStep )
    {
      xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 0 );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 1, false );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 2, false );
    }
  }

  Int iMaxMVDistToPred = (abs(cStruct.iBestX - iBestX) > iMVDistThresh || abs(cStruct.iBestY - iBestY) > iMVDistThresh);

  //full search with early exit if MV is distant from predictors
  if ( bEnableRasterSearch && (iMaxMVDistToPred || bAlwaysRasterSearch) )
  {
    for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += 1 )
    {
      for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += 1 )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 1 );
      }
    }
  }
  //Smaller MV, refine around predictor
  else if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    // start refinement
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, false );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );

}


Void TEncSearch::xPatternSearchFracDIF(
                                       Bool         bIsLosslessCoded,
                                       TComPattern* pcPatternKey,
                                       Pel*         piRefY,
                                       Int          iRefStride,
                                       TComMv*      pcMvInt,
                                       TComMv&      rcMvHalf,
                                       TComMv&      rcMvQter,
                                       Distortion&  ruiCost
                                      )
{
  //  Reference pattern initialization (integer scale)
	
  TComPattern cPatternRoi;
  Int         iOffset    = pcMvInt->getHor() + pcMvInt->getVer() * iRefStride;
  cPatternRoi.initPattern(piRefY + iOffset,
                          pcPatternKey->getROIYWidth(),
                          pcPatternKey->getROIYHeight(),
                          iRefStride,
                          pcPatternKey->getBitDepthY());

  //  Half-pel refinement
  xExtDIFUpSamplingH ( &cPatternRoi );

  rcMvHalf = *pcMvInt;   rcMvHalf <<= 1;    // for mv-cost
  TComMv baseRefMv(0, 0);
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 2, rcMvHalf, !bIsLosslessCoded );

  m_pcRdCost->setCostScale( 0 );

  xExtDIFUpSamplingQ ( &cPatternRoi, rcMvHalf );
  baseRefMv = rcMvHalf;
  baseRefMv <<= 1;

  rcMvQter = *pcMvInt;   rcMvQter <<= 1;    // for mv-cost
  rcMvQter += rcMvHalf;  rcMvQter <<= 1;
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 1, rcMvQter, !bIsLosslessCoded );
}


//! encode residual and calculate rate-distortion for a CU block
Void TEncSearch::encodeResAndCalcRdInterCU( TComDataCU* pcCU, TComYuv* pcYuvOrg, TComYuv* pcYuvPred,
                                            TComYuv* pcYuvResi, TComYuv* pcYuvResiBest, TComYuv* pcYuvRec,
                                            Bool bSkipResidual DEBUG_STRING_FN_DECLARE(sDebug) )
{
  assert ( !pcCU->isIntra(0) );

  const UInt cuWidthPixels      = pcCU->getWidth ( 0 );
  const UInt cuHeightPixels     = pcCU->getHeight( 0 );
  const Int  numValidComponents = pcCU->getPic()->getNumberValidComponents();
  const TComSPS &sps=*(pcCU->getSlice()->getSPS());

  // The pcCU is not marked as skip-mode at this point, and its m_pcTrCoeff, m_pcArlCoeff, m_puhCbf, m_puhTrIdx will all be 0.
  // due to prior calls to TComDataCU::initEstData(  );

  if ( bSkipResidual ) //  No residual coding : SKIP mode
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    pcYuvResi->clear();

    pcYuvPred->copyToPartYuv( pcYuvRec, 0 );
    Distortion distortion = 0;

    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID compID=ComponentID(comp);
      const UInt csx=pcYuvOrg->getComponentScaleX(compID);
      const UInt csy=pcYuvOrg->getComponentScaleY(compID);
      distortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID), pcYuvRec->getStride(compID), pcYuvOrg->getAddr(compID),
                                               pcYuvOrg->getStride(compID), cuWidthPixels >> csx, cuHeightPixels >> csy, compID);
    }

    m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST]);
    m_pcEntropyCoder->resetBits();

    if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex( pcCU, 0, true );

    UInt uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    pcCU->getTotalBits()       = uiBits;
    pcCU->getTotalDistortion() = distortion;
    pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( uiBits, distortion );

    m_pcRDGoOnSbacCoder->store(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_TEMP_BEST]);

#if DEBUG_STRING
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif

    return;
  }

  //  Residual coding.

   pcYuvResi->subtract( pcYuvOrg, pcYuvPred, 0, cuWidthPixels );

  TComTURecurse tuLevel0(pcCU, 0);

  Double     nonZeroCost       = 0;
  UInt       nonZeroBits       = 0;
  Distortion nonZeroDistortion = 0;
  Distortion zeroDistortion    = 0;

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_CURR_BEST ] );

  xEstimateInterResidualQT( pcYuvResi,  nonZeroCost, nonZeroBits, nonZeroDistortion, &zeroDistortion, tuLevel0 DEBUG_STRING_PASS_INTO(sDebug) );

  // -------------------------------------------------------
  // set the coefficients in the pcCU, and also calculates the residual data.
  // If a block full of 0's is efficient, then just use 0's.
  // The costs at this point do not include header bits.

  m_pcEntropyCoder->resetBits();
  m_pcEntropyCoder->encodeQtRootCbfZero( );
  const UInt   zeroResiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  const Double zeroCost     = (pcCU->isLosslessCoded( 0 )) ? (nonZeroCost+1) : (m_pcRdCost->calcRdCost( zeroResiBits, zeroDistortion ));

  if ( zeroCost < nonZeroCost || !pcCU->getQtRootCbf(0) )
  {
    const UInt uiQPartNum = tuLevel0.GetAbsPartIdxNumParts();
    ::memset( pcCU->getTransformIdx()     , 0, uiQPartNum * sizeof(UChar) );
    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID component = ComponentID(comp);
      ::memset( pcCU->getCbf( component ) , 0, uiQPartNum * sizeof(UChar) );
      ::memset( pcCU->getCrossComponentPredictionAlpha(component), 0, ( uiQPartNum * sizeof(SChar) ) );
    }
    static const UInt useTS[MAX_NUM_COMPONENT]={0,0,0};
    pcCU->setTransformSkipSubParts ( useTS, 0, pcCU->getDepth(0) );
#if DEBUG_STRING
    sDebug.clear();
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif
  }
  else
  {
    xSetInterResidualQTData( NULL, false, tuLevel0); // Call first time to set coefficients.
  }

  // all decisions now made. Fully encode the CU, including the headers:
  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST] );

  UInt finalBits = 0;
  xAddSymbolBitsInter( pcCU, finalBits );
  // we've now encoded the pcCU, and so have a valid bit cost

  if ( !pcCU->getQtRootCbf( 0 ) )
  {
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
  }
  else
  {
    xSetInterResidualQTData( pcYuvResiBest, true, tuLevel0 ); // else set the residual image data pcYUVResiBest from the various temp images.
  }
  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_TEMP_BEST ] );

  pcYuvRec->addClip ( pcYuvPred, pcYuvResiBest, 0, cuWidthPixels, sps.getBitDepths() );

  // update with clipped distortion and cost (previously unclipped reconstruction values were used)

  Distortion finalDistortion = 0;
  for(Int comp=0; comp<numValidComponents; comp++)
  {
    const ComponentID compID=ComponentID(comp);
    finalDistortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID ), pcYuvRec->getStride(compID ), pcYuvOrg->getAddr(compID ), pcYuvOrg->getStride(compID), cuWidthPixels >> pcYuvOrg->getComponentScaleX(compID), cuHeightPixels >> pcYuvOrg->getComponentScaleY(compID), compID);
  }

  pcCU->getTotalBits()       = finalBits;
  pcCU->getTotalDistortion() = finalDistortion;
  pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( finalBits, finalDistortion );
}



Void TEncSearch::xEstimateInterResidualQT( TComYuv    *pcResi,
                                           Double     &rdCost,
                                           UInt       &ruiBits,
                                           Distortion &ruiDist,
                                           Distortion *puiZeroDist,
                                           TComTU     &rTu
                                           DEBUG_STRING_FN_DECLARE(sDebug) )
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiDepth      = rTu.GetTransformDepthTotal();
  const UInt uiTrMode     = rTu.GetTransformDepthRel();
  const UInt subTUDepth   = uiTrMode + 1;
  const UInt numValidComp = pcCU->getPic()->getNumberValidComponents();
  DEBUG_STRING_NEW(sSingleStringComp[MAX_NUM_COMPONENT])

  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  UInt SplitFlag = ((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && pcCU->isInter(uiAbsPartIdx) && ( pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N ));
#if DEBUG_STRING
  const Int debugPredModeMask = DebugStringGetPredModeMask(pcCU->getPredictionMode(uiAbsPartIdx));
#endif

  Bool bCheckFull;

  if ( SplitFlag && uiDepth == pcCU->getDepth(uiAbsPartIdx) && ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) ) )
  {
    bCheckFull = false;
  }
  else
  {
    bCheckFull =  ( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
  }

  const Bool bCheckSplit  = ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

  assert( bCheckFull || bCheckSplit );

  // code full block
  Double     dSingleCost = MAX_DOUBLE;
  UInt       uiSingleBits                                                                                                        = 0;
  Distortion uiSingleDistComp            [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  Distortion uiSingleDist                                                                                                        = 0;
  TCoeff     uiAbsSum                    [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  UInt       uiBestTransformMode         [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  //  Stores the best explicit RDPCM mode for a TU encoded without split
  UInt       bestExplicitRdpcmModeUnSplit[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{3,3}, {3,3}, {3,3}};
  SChar      bestCrossCPredictionAlpha   [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};

  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );

  if( bCheckFull )
  {
    Double minCost[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/];
    Bool checkTransformSkip[MAX_NUM_COMPONENT];
    pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

    m_pcEntropyCoder->resetBits();

    memset( m_pTempPel, 0, sizeof( Pel ) * rTu.getRect(COMPONENT_Y).width * rTu.getRect(COMPONENT_Y).height ); // not necessary needed for inside of recursion (only at the beginning)

    const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    TCoeff *pcCoeffCurr[MAX_NUM_COMPONENT];
#if ADAPTIVE_QP_SELECTION
    TCoeff *pcArlCoeffCurr[MAX_NUM_COMPONENT];
#endif

    for(UInt i=0; i<numValidComp; i++)
    {
      minCost[i][0] = MAX_DOUBLE;
      minCost[i][1] = MAX_DOUBLE;
    }

    Pel crossCPredictedResidualBuffer[ MAX_TU_SIZE * MAX_TU_SIZE ];

    for(UInt i=0; i<numValidComp; i++)
    {
      checkTransformSkip[i]=false;
      const ComponentID compID=ComponentID(i);
      const Int channelBitDepth=pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
      pcCoeffCurr[compID]    = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
#if ADAPTIVE_QP_SELECTION
      pcArlCoeffCurr[compID] = m_ppcQTTempArlCoeff[compID ][uiQTTempAccessLayer] +  rTu.getCoefficientOffset(compID);
#endif

      if(rTu.ProcessComponentSection(compID))
      {
        const QpParam cQP(*pcCU, compID);

        checkTransformSkip[compID] = pcCU->getSlice()->getPPS()->getUseTransformSkip() &&
                                     TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(compID), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize()) &&
                                     (!pcCU->isLosslessCoded(0));

        const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

        TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

        const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

        do
        {
          const UInt           subTUIndex             = TUIterator.GetSectionNumber();
          const UInt           subTUAbsPartIdx        = TUIterator.GetAbsPartIdxTU(compID);
          const TComRectangle &tuCompRect             = TUIterator.getRect(compID);
          const UInt           subTUBufferOffset      = tuCompRect.width * tuCompRect.height * subTUIndex;

                TCoeff        *currentCoefficients    = pcCoeffCurr[compID] + subTUBufferOffset;
#if ADAPTIVE_QP_SELECTION
                TCoeff        *currentARLCoefficients = pcArlCoeffCurr[compID] + subTUBufferOffset;
#endif
          const Bool isCrossCPredictionAvailable      =    isChroma(compID)
                                                         && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                         && (pcCU->getCbf(subTUAbsPartIdx, COMPONENT_Y, uiTrMode) != 0);

          SChar preCalcAlpha = 0;
          const Pel *pLumaResi = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( COMPONENT_Y, rTu.getRect( COMPONENT_Y ).x0, rTu.getRect( COMPONENT_Y ).y0 );

          if (isCrossCPredictionAvailable)
          {
            const Bool bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
            const Pel  *const lumaResidualForEstimate       = bUseReconstructedResidualForEstimate ? pLumaResi                                                     : pcResi->getAddrPix(COMPONENT_Y, tuCompRect.x0, tuCompRect.y0);
            const UInt        lumaResidualStrideForEstimate = bUseReconstructedResidualForEstimate ? m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y) : pcResi->getStride(COMPONENT_Y);

            preCalcAlpha = xCalcCrossComponentPredictionAlpha(TUIterator,
                                                              compID,
                                                              lumaResidualForEstimate,
                                                              pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                              tuCompRect.width,
                                                              tuCompRect.height,
                                                              lumaResidualStrideForEstimate,
                                                              pcResi->getStride(compID));
          }

          const Int transformSkipModesToTest    = checkTransformSkip[compID] ? 2 : 1;
          const Int crossCPredictionModesToTest = (preCalcAlpha != 0)        ? 2 : 1; // preCalcAlpha cannot be anything other than 0 if isCrossCPredictionAvailable is false

          const Bool isOneMode                  = (crossCPredictionModesToTest == 1) && (transformSkipModesToTest == 1);

          for (Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
          {
            pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);

            for (Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
            {
              const Bool isFirstMode          = (transformSkipModeId == 0) && (crossCPredictionModeId == 0);
              const Bool bUseCrossCPrediction = crossCPredictionModeId != 0;

              m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
              m_pcEntropyCoder->resetBits();

              pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);
              pcCU->setCrossComponentPredictionAlphaPartRange((bUseCrossCPrediction ? preCalcAlpha : 0), compID, subTUAbsPartIdx, partIdxesPerSubTU );

              if ((compID != COMPONENT_Cr) && ((transformSkipModeId == 1) ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ()))
              {
                m_pcEntropyCoder->estimateBit(m_pcTrQuant->m_pcEstBitsSbac, tuCompRect.width, tuCompRect.height, toChannelType(compID));
              }

#if RDOQ_CHROMA_LAMBDA
              m_pcTrQuant->selectLambda(compID);
#endif

              Pel *pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
              UInt resiStride     = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);

              TCoeff bestCoeffComp   [MAX_TU_SIZE*MAX_TU_SIZE];
              Pel    bestResiComp    [MAX_TU_SIZE*MAX_TU_SIZE];

#if ADAPTIVE_QP_SELECTION
              TCoeff bestArlCoeffComp[MAX_TU_SIZE*MAX_TU_SIZE];
#endif
              TCoeff     currAbsSum   = 0;
              UInt       currCompBits = 0;
              Distortion currCompDist = 0;
              Double     currCompCost = 0;
              UInt       nonCoeffBits = 0;
              Distortion nonCoeffDist = 0;
              Double     nonCoeffCost = 0;

              if(!isOneMode && !isFirstMode)
              {
                memcpy(bestCoeffComp,    currentCoefficients,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(bestArlCoeffComp, currentARLCoefficients, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for(Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy(&bestResiComp[y * tuCompRect.width], (pcResiCurrComp + (y * resiStride)), (sizeof(Pel) * tuCompRect.width));
                }
              }

              if (bUseCrossCPrediction)
              {
                TComTrQuant::crossComponentPrediction(TUIterator,
                                                      compID,
                                                      pLumaResi,
                                                      pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                      crossCPredictedResidualBuffer,
                                                      tuCompRect.width,
                                                      tuCompRect.height,
                                                      m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                      pcResi->getStride(compID),
                                                      tuCompRect.width,
                                                      false);

                m_pcTrQuant->transformNxN(TUIterator, compID, crossCPredictedResidualBuffer, tuCompRect.width, currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }
              else
              {
                m_pcTrQuant->transformNxN(TUIterator, compID, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ), pcResi->getStride(compID), currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }

              if(isFirstMode || (currAbsSum == 0))
              {
                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pTempPel,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        tuCompRect.width,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        true);

                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride( compID ), pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }
                else
                {
                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pTempPel, tuCompRect.width, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }

                m_pcEntropyCoder->encodeQtCbfZero( TUIterator, toChannelType(compID) );

                if ( isCrossCPredictionAvailable )
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                nonCoeffBits = m_pcEntropyCoder->getNumberOfWrittenBits();
                nonCoeffCost = m_pcRdCost->calcRdCost( nonCoeffBits, nonCoeffDist );
              }

              if((puiZeroDist != NULL) && isFirstMode)
              {
                *puiZeroDist += nonCoeffDist; // initialized with zero residual distortion
              }

              DEBUG_STRING_NEW(sSingleStringTest)

              if( currAbsSum > 0 ) //if non-zero coefficients are present, a residual needs to be derived for further prediction
              {
                if (isFirstMode)
                {
                  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
                  m_pcEntropyCoder->resetBits();
                }

                m_pcEntropyCoder->encodeQtCbf( TUIterator, compID, true );

                if (isCrossCPredictionAvailable)
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                m_pcEntropyCoder->encodeCoeffNxN( TUIterator, currentCoefficients, compID );
                currCompBits = m_pcEntropyCoder->getNumberOfWrittenBits();

                pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 );

                m_pcTrQuant->invTransformNxN( TUIterator, compID, pcResiCurrComp, m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID), currentCoefficients, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sSingleStringTest, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );

                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        true);
                }

                currCompDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        pcResi->getStride(compID),
                                                        tuCompRect.width, tuCompRect.height, compID);

                currCompCost = m_pcRdCost->calcRdCost(currCompBits, currCompDist);
                  
                if (pcCU->isLosslessCoded(0))
                {
                  nonCoeffCost = MAX_DOUBLE;
                }
              }
              else if ((transformSkipModeId == 1) && !bUseCrossCPrediction)
              {
                currCompCost = MAX_DOUBLE;
              }
              else
              {
                currCompBits = nonCoeffBits;
                currCompDist = nonCoeffDist;
                currCompCost = nonCoeffCost;
              }

              // evaluate
              if ((currCompCost < minCost[compID][subTUIndex]) || ((transformSkipModeId == 1) && (currCompCost == minCost[compID][subTUIndex])))
              {
                bestExplicitRdpcmModeUnSplit[compID][subTUIndex] = pcCU->getExplicitRdpcmMode(compID, subTUAbsPartIdx);

                if(isFirstMode) //check for forced null
                {
                  if((nonCoeffCost < currCompCost) || (currAbsSum == 0))
                  {
                    memset(currentCoefficients, 0, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));

                    currAbsSum   = 0;
                    currCompBits = nonCoeffBits;
                    currCompDist = nonCoeffDist;
                    currCompCost = nonCoeffCost;
                  }
                }

#if DEBUG_STRING
                if (currAbsSum > 0)
                {
                  DEBUG_STRING_SWAP(sSingleStringComp[compID], sSingleStringTest)
                }
                else
                {
                  sSingleStringComp[compID].clear();
                }
#endif

                uiAbsSum                 [compID][subTUIndex] = currAbsSum;
                uiSingleDistComp         [compID][subTUIndex] = currCompDist;
                minCost                  [compID][subTUIndex] = currCompCost;
                uiBestTransformMode      [compID][subTUIndex] = transformSkipModeId;
                bestCrossCPredictionAlpha[compID][subTUIndex] = (crossCPredictionModeId == 1) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;

                if (uiAbsSum[compID][subTUIndex] == 0)
                {
                  if (bUseCrossCPrediction)
                  {
                    TComTrQuant::crossComponentPrediction(TUIterator,
                                                          compID,
                                                          pLumaResi,
                                                          m_pTempPel,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                          tuCompRect.width,
                                                          tuCompRect.height,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                          tuCompRect.width,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                          true);
                  }
                  else
                  {
                    pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
                    const UInt uiStride = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);
                    for(UInt uiY = 0; uiY < tuCompRect.height; uiY++)
                    {
                      memset(pcResiCurrComp, 0, (sizeof(Pel) * tuCompRect.width));
                      pcResiCurrComp += uiStride;
                    }
                  }
                }
              }
              else
              {
                // reset
                memcpy(currentCoefficients,    bestCoeffComp,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(currentARLCoefficients, bestArlCoeffComp, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for (Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy((pcResiCurrComp + (y * resiStride)), &bestResiComp[y * tuCompRect.width], (sizeof(Pel) * tuCompRect.width));
                }
              }
            }
          }

          pcCU->setExplicitRdpcmModePartRange            (   bestExplicitRdpcmModeUnSplit[compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU);
          pcCU->setTransformSkipPartRange                (   uiBestTransformMode         [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCbfPartRange                          ((((uiAbsSum                    [compID][subTUIndex] > 0) ? 1 : 0) << uiTrMode), compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCrossComponentPredictionAlphaPartRange(   bestCrossCPredictionAlpha   [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
        } while (TUIterator.nextSection(rTu)); //end of sub-TU loop
      } // processing section
    } // component loop

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      if (rTu.ProcessComponentSection(compID) && (rTu.getRect(compID).width != rTu.getRect(compID).height))
      {
        offsetSubTUCBFs(rTu, compID); //the CBFs up to now have been defined for two sub-TUs - shift them down a level and replace with the parent level CBF
      }
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    if( uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( 0, 5 - uiLog2TrSize );
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const UInt chOrderChange = ((ch + 1) == numValidComp) ? 0 : (ch + 1);
      const ComponentID compID=ComponentID(chOrderChange);
      if( rTu.ProcessComponentSection(compID) )
      {
        m_pcEntropyCoder->encodeQtCbf( rTu, compID, true );
      }
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if (rTu.ProcessComponentSection(compID))
      {
        if(isChroma(compID) && (uiAbsSum[COMPONENT_Y][0] != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, compID );
        }

        m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr[compID], compID );
        for (UInt subTUIndex = 0; subTUIndex < 2; subTUIndex++)
        {
          uiSingleDist += uiSingleDistComp[compID][subTUIndex];
        }
      }
    }

    uiSingleBits = m_pcEntropyCoder->getNumberOfWrittenBits();

    dSingleCost = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDist );
  } // check full

  // code sub-blocks
  if( bCheckSplit )
  {
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    Distortion uiSubdivDist = 0;
    UInt       uiSubdivBits = 0;
    Double     dSubdivCost = 0.0;

    //save the non-split CBFs in case we need to restore them later

    UInt bestCBF     [MAX_NUM_COMPONENT];
    UInt bestsubTUCBF[MAX_NUM_COMPONENT][2];
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);

      if (rTu.ProcessComponentSection(compID))
      {
        bestCBF[compID] = pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode);

        const TComRectangle &tuCompRect = rTu.getRect(compID);
        if (tuCompRect.width != tuCompRect.height)
        {
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

          for (UInt subTU = 0; subTU < 2; subTU++)
          {
            bestsubTUCBF[compID][subTU] = pcCU->getCbf ((uiAbsPartIdx + (subTU * partIdxesPerSubTU)), compID, subTUDepth);
          }
        }
      }
    }


    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiQPartNumSubdiv = tuRecurseChild.GetAbsPartIdxNumParts();

    DEBUG_STRING_NEW(sSplitString[MAX_NUM_COMPONENT])

    do
    {
      DEBUG_STRING_NEW(childString)
      xEstimateInterResidualQT( pcResi, dSubdivCost, uiSubdivBits, uiSubdivDist, bCheckFull ? NULL : puiZeroDist,  tuRecurseChild DEBUG_STRING_PASS_INTO(childString));
#if DEBUG_STRING
      // split the string by component and append to the relevant output (because decoder decodes in channel order, whereas this search searches by TU-order)
      std::size_t lastPos=0;
      const std::size_t endStrng=childString.find(debug_reorder_data_inter_token[MAX_NUM_COMPONENT], lastPos);
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        if (lastPos!=std::string::npos && childString.find(debug_reorder_data_inter_token[ch], lastPos)==lastPos)
        {
          lastPos+=strlen(debug_reorder_data_inter_token[ch]); // skip leading string
        }
        std::size_t pos=childString.find(debug_reorder_data_inter_token[ch+1], lastPos);
        if (pos!=std::string::npos && pos>endStrng)
        {
          lastPos=endStrng;
        }
        sSplitString[ch]+=childString.substr(lastPos, (pos==std::string::npos)? std::string::npos : (pos-lastPos) );
        lastPos=pos;
      }
#endif
    } while ( tuRecurseChild.nextSection(rTu) ) ;

    UInt uiCbfAny=0;
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      UInt uiYUVCbf = 0;
      for( UInt ui = 0; ui < 4; ++ui )
      {
        uiYUVCbf |= pcCU->getCbf( uiAbsPartIdx + ui * uiQPartNumSubdiv, ComponentID(ch),  uiTrMode + 1 );
      }
      UChar *pBase=pcCU->getCbf( ComponentID(ch) );
      const UInt flags=uiYUVCbf << uiTrMode;
      for( UInt ui = 0; ui < 4 * uiQPartNumSubdiv; ++ui )
      {
        pBase[uiAbsPartIdx + ui] |= flags;
      }
      uiCbfAny|=uiYUVCbf;
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    // when compID isn't a channel, code Cbfs:
    xEncodeInterResidualQT( MAX_NUM_COMPONENT, rTu );
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      xEncodeInterResidualQT( ComponentID(ch), rTu );
    }

    uiSubdivBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    dSubdivCost  = m_pcRdCost->calcRdCost( uiSubdivBits, uiSubdivDist );

    if (!bCheckFull || (uiCbfAny && (dSubdivCost < dSingleCost)))
    {
      rdCost += dSubdivCost;
      ruiBits += uiSubdivBits;
      ruiDist += uiSubdivDist;
#if DEBUG_STRING
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        DEBUG_STRING_APPEND(sDebug, sSplitString[ch])
      }
#endif
    }
    else
    {
      rdCost  += dSingleCost;
      ruiBits += uiSingleBits;
      ruiDist += uiSingleDist;

      //restore state to unsplit

      pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        const ComponentID compID=ComponentID(ch);

        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        if (rTu.ProcessComponentSection(compID))
        {
          DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])

          const Bool splitIntoSubTUs   = rTu.getRect(compID).width != rTu.getRect(compID).height;
          const UInt numberOfSections  = splitIntoSubTUs ? 2 : 1;
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> (splitIntoSubTUs ? 1 : 0);

          for (UInt subTUIndex = 0; subTUIndex < numberOfSections; subTUIndex++)
          {
            const UInt  uisubTUPartIdx = uiAbsPartIdx + (subTUIndex * partIdxesPerSubTU);

            if (splitIntoSubTUs)
            {
              const UChar combinedCBF = (bestsubTUCBF[compID][subTUIndex] << subTUDepth) | (bestCBF[compID] << uiTrMode);
              pcCU->setCbfPartRange(combinedCBF, compID, uisubTUPartIdx, partIdxesPerSubTU);
            }
            else
            {
              pcCU->setCbfPartRange((bestCBF[compID] << uiTrMode), compID, uisubTUPartIdx, partIdxesPerSubTU);
            }

            pcCU->setCrossComponentPredictionAlphaPartRange(bestCrossCPredictionAlpha[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setTransformSkipPartRange(uiBestTransformMode[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setExplicitRdpcmModePartRange(bestExplicitRdpcmModeUnSplit[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
          }
        }
      }

      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
    }
  }
  else
  {
    rdCost  += dSingleCost;
    ruiBits += uiSingleBits;
    ruiDist += uiSingleDist;
#if DEBUG_STRING
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[compID])

      if (rTu.ProcessComponentSection(compID))
      {
        DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])
      }
    }
#endif
  }
  DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[MAX_NUM_COMPONENT])
}



Void TEncSearch::xEncodeInterResidualQT( const ComponentID compID, TComTU &rTu )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  const UInt uiCurrTrMode = rTu.GetTransformDepthRel();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );

  const Bool bSubdiv = uiCurrTrMode != uiTrMode;

  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  if (compID==MAX_NUM_COMPONENT)  // we are not processing a channel, instead we always recurse and code the CBFs
  {
    if( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() && uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      if((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && (pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N))
      {
        assert(bSubdiv); // Inferred splitting rule - see derivation and use of interSplitFlag in the specification.
      }
      else
      {
        m_pcEntropyCoder->encodeTransformSubdivFlag( bSubdiv, 5 - uiLog2TrSize );
      }
    }

    assert( !pcCU->isIntra(uiAbsPartIdx) );

    const Bool bFirstCbfOfCU = uiCurrTrMode == 0;

    for (UInt ch=COMPONENT_Cb; ch<pcCU->getPic()->getNumberValidComponents(); ch++)
    {
      const ComponentID compIdInner=ComponentID(ch);
      if( bFirstCbfOfCU || rTu.ProcessingAllQuadrants(compIdInner) )
      {
        if( bFirstCbfOfCU || pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) )
        {
          m_pcEntropyCoder->encodeQtCbf( rTu, compIdInner, !bSubdiv );
        }
      }
      else
      {
        assert( pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode ) == pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) );
      }
    }

    if (!bSubdiv)
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }

  if( !bSubdiv )
  {
    if (compID != MAX_NUM_COMPONENT) // we have already coded the CBFs, so now we code coefficients
    {
      if (rTu.ProcessComponentSection(compID))
      {
        if (isChroma(compID) && (pcCU->getCbf(uiAbsPartIdx, COMPONENT_Y, uiTrMode) != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction(rTu, compID);
        }

        if (pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode) != 0)
        {
          const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
          TCoeff *pcCoeffCurr = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
          m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr, compID );
        }
      }
    }
  }
  else
  {
    if( compID==MAX_NUM_COMPONENT || pcCU->getCbf( uiAbsPartIdx, compID, uiCurrTrMode ) )
    {
      TComTURecurse tuRecurseChild(rTu, false);
      do
      {
        xEncodeInterResidualQT( compID, tuRecurseChild );
      } while (tuRecurseChild.nextSection(rTu));
    }
  }
}




Void TEncSearch::xSetInterResidualQTData( TComYuv* pcResi, Bool bSpatial, TComTU &rTu ) // TODO: turn this into two functions for bSpatial=true and false.
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiCurrTrMode=rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );
  const TComSPS *sps=pcCU->getSlice()->getSPS();

  if( uiCurrTrMode == uiTrMode )
  {
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTTempAccessLayer = sps->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if( bSpatial )
    {
      // Data to be copied is in the spatial domain, i.e., inverse-transformed.

      for(UInt i=0; i<pcResi->getNumberValidComponents(); i++)
      {
        const ComponentID compID=ComponentID(i);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          m_pcQTTempTComYuv[uiQTTempAccessLayer].copyPartToPartComponentMxN    ( compID, pcResi, rectCompTU );
        }
      }
    }
    else
    {
      for (UInt ch=0; ch < getNumberValidComponents(sps->getChromaFormatIdc()); ch++)
      {
        const ComponentID compID   = ComponentID(ch);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          const UInt numCoeffInBlock    = rectCompTU.width * rectCompTU.height;
          const UInt offset             = rTu.getCoefficientOffset(compID);
          TCoeff* dest                  = pcCU->getCoeff(compID)                        + offset;
          const TCoeff* src             = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + offset;
          ::memcpy( dest, src, sizeof(TCoeff)*numCoeffInBlock );

#if ADAPTIVE_QP_SELECTION
          TCoeff* pcArlCoeffSrc            = m_ppcQTTempArlCoeff[compID][uiQTTempAccessLayer] + offset;
          TCoeff* pcArlCoeffDst            = pcCU->getArlCoeff(compID)                        + offset;
          ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * numCoeffInBlock );
#endif
        }
      }
    }
  }
  else
  {

    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetInterResidualQTData( pcResi, bSpatial, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}




UInt TEncSearch::xModeBitsIntra( TComDataCU* pcCU, UInt uiMode, UInt uiPartOffset, UInt uiDepth, const ChannelType chType )
{
  // Reload only contexts required for coding intra mode information
  m_pcRDGoOnSbacCoder->loadIntraDirMode( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST], chType );

  // Temporarily set the intra dir being tested, and only
  // for absPartIdx, since encodeIntraDirModeLuma/Chroma only use
  // the entry at absPartIdx.

  UChar &rIntraDirVal=pcCU->getIntraDir( chType )[uiPartOffset];
  UChar origVal=rIntraDirVal;
  rIntraDirVal = uiMode;
  //pcCU->setIntraDirSubParts ( chType, uiMode, uiPartOffset, uiDepth + uiInitTrDepth );

  m_pcEntropyCoder->resetBits();
  if (isLuma(chType))
  {
    m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiPartOffset);
  }
  else
  {
    m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiPartOffset);
  }

  rIntraDirVal = origVal; // restore

  return m_pcEntropyCoder->getNumberOfWrittenBits();
}




UInt TEncSearch::xUpdateCandList( UInt uiMode, Double uiCost, UInt uiFastCandNum, UInt * CandModeList, Double * CandCostList )
{
  UInt i;
  UInt shift=0;

  while ( shift<uiFastCandNum && uiCost<CandCostList[ uiFastCandNum-1-shift ] )
  {
    shift++;
  }

  if( shift!=0 )
  {
    for(i=1; i<shift; i++)
    {
      CandModeList[ uiFastCandNum-i ] = CandModeList[ uiFastCandNum-1-i ];
      CandCostList[ uiFastCandNum-i ] = CandCostList[ uiFastCandNum-1-i ];
    }
    CandModeList[ uiFastCandNum-shift ] = uiMode;
    CandCostList[ uiFastCandNum-shift ] = uiCost;
    return 1;
  }

  return 0;
}





/** add inter-prediction syntax elements for a CU block
 * \param pcCU
 * \param uiQp
 * \param uiTrMode
 * \param ruiBits
 * \returns Void
 */
Void  TEncSearch::xAddSymbolBitsInter( TComDataCU* pcCU, UInt& ruiBits )
{
  if(pcCU->getMergeFlag( 0 ) && pcCU->getPartitionSize( 0 ) == SIZE_2Nx2N && !pcCU->getQtRootCbf( 0 ))
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    m_pcEntropyCoder->resetBits();
    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }
    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex(pcCU, 0, true);

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
  else
  {
    m_pcEntropyCoder->resetBits();

    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag ( pcCU, 0, true );
    m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
    m_pcEntropyCoder->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );
    m_pcEntropyCoder->encodePredInfo( pcCU, 0 );

    Bool codeDeltaQp = false;
    Bool codeChromaQpAdj = false;
    m_pcEntropyCoder->encodeCoeff   ( pcCU, 0, pcCU->getDepth(0), codeDeltaQp, codeChromaQpAdj );

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
}





/**
 * \brief Generate half-sample interpolated block
 *
 * \param pattern Reference picture ROI
 * \param biPred    Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingH( TComPattern* pattern )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;
  Int halfFilterSize = (filterSize>>1);
  Pel *srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[0].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 0, false, chFmt, pattern->getBitDepthY());
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[2].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 2, false, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + halfFilterSize * intStride + 1;
  dstPtr = m_filteredBlock[0][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
  dstPtr = m_filteredBlock[2][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+1, 2, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
  dstPtr = m_filteredBlock[0][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[2][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+1, 2, false, true, chFmt, pattern->getBitDepthY());
}





/**
 * \brief Generate quarter-sample interpolated blocks
 *
 * \param pattern    Reference picture ROI
 * \param halfPelRef Half-pel mv
 * \param biPred     Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingQ( TComPattern* pattern, TComMv halfPelRef )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Pel *srcPtr;
  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;

  Int halfFilterSize = (filterSize>>1);

  Int extHeight = (halfPelRef.getVer() == 0) ? height + filterSize : height + filterSize-1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  // Horizontal filter 1/4
  srcPtr = pattern->getROIY() - halfFilterSize * srcStride - 1;
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() >= 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 1, false, chFmt, pattern->getBitDepthY());

  // Horizontal filter 3/4
  srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() > 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 3, false, chFmt, pattern->getBitDepthY());

  // Generate @ 1,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][1].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());

  if (halfPelRef.getVer() != 0)
  {
    // Generate @ 2,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][1].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 2,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][3].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 0,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][1].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 0,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][3].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());
  }

  if (halfPelRef.getHor() != 0)
  {
    // Generate @ 1,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[1][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[3][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 1,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[1][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[3][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }

  // Generate @ 1,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][3].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
}





//! set wp tables
Void  TEncSearch::setWpScalingDistParam( TComDataCU* pcCU, Int iRefIdx, RefPicList eRefPicListCur )
{
  if ( iRefIdx<0 )
  {
    m_cDistParam.bApplyWeight = false;
    return;
  }

  TComSlice       *pcSlice  = pcCU->getSlice();
  WPScalingParam  *wp0 , *wp1;

  m_cDistParam.bApplyWeight = ( pcSlice->getSliceType()==P_SLICE && pcSlice->testWeightPred() ) || ( pcSlice->getSliceType()==B_SLICE && pcSlice->testWeightBiPred() ) ;

  if ( !m_cDistParam.bApplyWeight )
  {
    return;
  }

  Int iRefIdx0 = ( eRefPicListCur == REF_PIC_LIST_0 ) ? iRefIdx : (-1);
  Int iRefIdx1 = ( eRefPicListCur == REF_PIC_LIST_1 ) ? iRefIdx : (-1);

  getWpScaling( pcCU, iRefIdx0, iRefIdx1, wp0 , wp1 );

  if ( iRefIdx0 < 0 )
  {
    wp0 = NULL;
  }
  if ( iRefIdx1 < 0 )
  {
    wp1 = NULL;
  }

  m_cDistParam.wpCur  = NULL;

  if ( eRefPicListCur == REF_PIC_LIST_0 )
  {
    m_cDistParam.wpCur = wp0;
  }
  else
  {
    m_cDistParam.wpCur = wp1;
  }
}



//! \}
