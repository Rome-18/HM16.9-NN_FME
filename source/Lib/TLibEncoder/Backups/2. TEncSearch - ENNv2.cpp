/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2016, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     TEncSearch.cpp
 \brief    encoder search class
 */

#include "TLibCommon/CommonDef.h"
#include "TLibCommon/TComRom.h"
#include "TLibCommon/TComMotionInfo.h"
#include "TEncSearch.h"
#include "TLibCommon/TComTU.h"
#include "TLibCommon/Debug.h"
#include <math.h>
#include <limits>
#include <fstream>
using namespace std;
// variables decleration

int counter_i ;
long int array[100000];

extern int counter_ME=0;
extern int counter_FME=0;
//extern int CNT;
int CTUH, CTUW;
int CTUH1, CTUW1;
int CTUH2, CTUW2;
int CTUH3, CTUW3;
int index_ref=0;
double A, B, C2, D, E, F;
double  C, H1, H2, V1, V2, U1, U2, U3, U4;
double A00, A10, A20, AN10, AN20, A01, A02,A0N1,A0N2, A1N1, A2N1, AN1N1, AN2N1, A1N2, A2N2, AN1N2, AN2N2, A11, A21, AN11, AN21, A12, A22, AN12, AN22;
double  R31, R32, R33, R34, R35, R36, R41, R42, R43, R44, R45, R46, R61, R62, R63, R64, R65, R66, R71, R72, R73, R74, R75, R76;
//double C1, C2, C3, C4, C5, C6, C7, C8, C9;
double F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25;
double  F34YLD, F34YLU, F34RYD, F34RYU, F34YN, F34YP, F34XN, F34XP;
double SADD1U, SADD1D, SADD2U, SADD2D, SADD3U, SADD3D, SADD4U, SADD4D, SADD5U, SADD5D;
double FN2, FN1, F0;
long int SAD_Best;
signed short MVX_Best;
signed short MVY_Best;
double CH, CW;
double XMIN;
double YMIN;
double MT_VCX=0;
double MT_VCY=0;
signed short MVX_HALF=0;
signed short MVX_QRTER=0;
signed short MVY_HALF=0;
signed short MVY_QRTER=0;
double CNYL1=0;
double  CNYL2=0;

double FQRTERYL=0;
double FHALFYL=0;
double CNYR1=0;
double   CNYR2=0;
double FQRTERYR=0;
double FHALFYR=0;
double CNROW11D=0;
double  CNROW12D=0;
double FQRTERD1=0;
double FHALFYD1=0;
double CNROW21D=0;
double  CNROW22D=0;
double FQRTERD2=0;
double FHALFYD2=0;
double	CNX1=0;
double   CNX2=0;
double FQRTERX=0;
double FHALFX=0;
double FQRTERXN=0;
double FHALFXN=0;
double FQRTERY=0;
double FHALFY=0;
double FQRTERYN=0;
double FHALFYN=0;
double	CNY1=0;
double   CNY2=0;
int flag_start;
int flag_2point;
int flag_star;

// NEW


double FQRTERYLD;
double FHALFYLD;
double FQRTERYLU;
double FHALFYLU;

double FQRTERYRD;
double FHALFYRD;
double FQRTERYRU;
double FHALFYRU;
double CNROW11;
double CNROW12;

double CNROW21;
double CNROW22;
double CNROW41;
double CNROW42;
double CNROW51;
double CNROW52;




double SADD1, SADD2, SADD3, SADD4, SADD5, SADD6, SADD7, SADD8, SADD9, SADD10, SADD11, SADD12, SADD13, SADD14, SADD15, SADD16, SADD17, SADD18, SADD19, SADD20, SADD21, SADD22, SADD23, SADD24, SADD25;
double SAD1, SAD2,SAD3, SAD4, SAD5, SAD6, SAD7, SAD8,SAD9, SAD10,SAD11,SAD12,SAD13,SAD14,SAD15, SAD16, SAD17,SAD18, SAD19, SAD20, SAD21, SAD22,SAD23, SAD24, SAD25;
double SAD26, SAD27, SAD28, SAD29, SAD30, SAD31, SAD32, SAD33, SAD34, SAD35, SAD36, SAD37, SAD38, SAD39, SAD40, SAD41, SAD42, SAD43, SAD44, SAD45, SAD46, SAD47, SAD48, SAD49;
//END


// ehab modification


double inputs[9]= {};
double IN[9] = {};

double IN_norm[9] = {};
double X1[40] = {};
double X2[40] = {};
double X3[40] = {};
double OUT[49] = {};

double in_h1[40][9] = {
  { 1.0771117,0.1605732,-0.2248379,0.71740484,-0.22043157,-1.0351088,0.37189096,-0.30246046,0.22253218 },
  { 0.9299714,0.15416846,-0.48657992,-0.3028047,-0.7067685,2.560315,-0.020979522,0.44174415,-2.4050593 },
  { 0.36957234,0.32848918,0.48845974,-0.64461106,-1.7262844,-1.6618066,0.49056515,1.2050772,1.3883871 },
  { 0.28291973,-0.19810398,0.71352094,-0.8629978,-0.17017582,-0.19616674,-0.89781576,-0.31790268,-0.508306 },
  { -1.25194,0.7505528,-0.16126567,0.27543604,1.4870232,-0.20694235,-0.17939577,0.5484353,-1.5918083 },
  { 1.1032183,0.46523285,0.33682263,-1.6083747,-0.13417944,0.91093785,-0.26711497,0.4615957,1.1459246 },
  { 0.3229207,0.4344704,0.53349346,0.5766234,-0.50246024,2.1297798,-0.9381529,-0.0990184,0.74385583 },
  { 0.19387384,-0.2535992,-1.0637829,-1.0232714,0.5600107,-1.9027278,-0.109853834,0.5002987,0.37941226 },
  { 0.30753064,0.35356587,-0.20459485,-0.09574186,-1.7478218,-1.5159606,0.14050928,0.09593538,1.7736769 },
  { 0.52099323,-0.6999147,-1.3205328,0.37263632,0.66004694,0.5795027,-0.21589397,0.7089102,0.24014528 },
  { 0.57245016,-0.6177932,-0.5110719,1.6314515,-0.15004332,0.6794385,-0.2841772,-0.42527938,1.8082432 },
  { -0.8986685,-0.19355106,0.869241,0.57745945,-0.27375206,0.53862613,0.754539,0.09141527,-0.20737584 },
  { -0.6822032,0.7727754,-0.25248364,-0.04241114,0.5476873,0.7832145,0.6062326,-2.165301,-0.51768744 },
  { 0.8489946,-1.1858046,0.6188399,0.19220643,-0.8267944,-0.14773029,0.48308697,0.86365426,-0.28265613 },
  { 0.7789424,0.6189352,-0.40557194,-0.17431152,0.28532013,-2.3277326,-0.06542246,0.006834502,2.2812462 },
  { -0.82812905,-0.41759723,-0.1567999,0.1450397,1.6730939,-0.17218828,-1.1470194,0.62763053,-0.83160543 },
  { 1.1939552,-0.20603177,-0.57147,-0.018140733,-0.8177658,-0.3243205,0.049100794,0.09172445,1.5359409 },
  { -0.048662025,0.038570475,0.18319808,1.0472881,-0.4263281,-2.5644321,-0.4316659,0.43403786,-0.9849943 },
  { -0.8504833,0.12193143,-0.2235882,1.4912263,-1.4416625,0.2415953,-1.0932139,0.6186312,1.9496789 },
  { 0.017611219,-0.017707512,0.16612254,-0.18281154,2.1594682,0.14023279,0.6125588,-0.5587058,1.0388812 },
  { -0.049907748,0.13448702,0.43548,-0.7641591,-1.3384403,-0.81251603,0.14669189,0.08710511,-0.37793925 },
  { 0.97551024,-0.0944547,0.19424158,-0.9798682,-1.8100612,1.0576574,1.0973791,-0.11262397,0.09433481 },
  { -0.585456,-0.5470111,0.5210053,0.50104433,-2.6464665,0.55201006,-0.46634096,1.2263218,-0.02564027 },
  { 0.7727739,0.5097606,0.8195838,-0.072278336,1.5135673,-0.77421224,0.14611104,-1.5272874,2.366218 },
  { -0.74853384,0.077849895,-0.08555322,0.37168694,1.0712547,0.32817137,-0.054105707,0.50147396,-1.0049782 },
  { 2.339996,-0.35746408,0.99594927,-0.2703262,0.024929747,1.7574556,0.464157,-0.38462502,-1.1884387 },
  { -0.18520714,0.3341151,0.3088196,-0.3791776,-0.42293584,-1.1551248,0.9849585,0.85319984,0.72225624 },
  { -0.11933004,1.3257703,-0.17535904,0.86604017,-1.8041941,0.3246603,-0.21066919,-0.15570869,-1.3101468 },
  { 0.12652364,-0.62941206,0.72509533,0.02455669,0.28317624,-1.3844839,-0.03916889,0.503199,-1.2324069 },
  { 0.6167527,0.77565557,-0.07035841,0.26466647,-1.694135,-0.8069427,-0.38847303,0.60554075,2.0644639 },
  { -1.1780996,-1.280787,-1.042292,-0.548852,0.27050164,0.6500635,0.38372648,-0.5050422,-0.3584425 },
  { 2.2069068,-0.04980629,-0.1356574,0.6189951,-0.36530972,0.21876419,-0.31663275,0.42228392,1.4394146 },
  { -0.3185801,0.2086347,0.17892228,0.2692923,0.3535064,3.1563432,-0.22454503,0.41866958,0.40726742 },
  { -0.54636556,-0.29152685,-0.2624433,-0.83378506,-0.38887927,-0.4465771,-0.05251738,0.11762779,-0.2933284 },
  { 1.071673,-0.592188,-0.036072224,-0.9639014,0.2655629,-0.11655771,-0.21722303,-1.3513368,-0.99307835 },
  { 0.20611906,0.5260437,0.7924851,1.5243601,-0.15234938,0.38882107,0.24262682,0.10238805,1.488346 },
  { 1.3982712,0.37124616,0.6212355,-0.09007624,1.2311505,-1.6473554,-0.23281556,0.20622286,0.27741283 },
  { 1.1638818,-0.13558443,-0.27346116,-0.3316667,-0.77767015,0.2861454,0.575258,0.7017713,2.544772 },
  { 0.010060678,-0.72779727,0.13194859,0.06349131,1.7360171,-0.12097041,0.14347185,1.5964676,-0.6401279 },
  { 0.1189101,0.6619991,-0.9551319,-0.34060597,0.65143865,-1.0146891,0.3491523,-0.10179971,-0.36554372 } 
};

double h1_h2[40][40] = {
  { -0.41893834,-8.308497,-0.51852125,2.925283,1.3660022,-1.4046017,0.6372667,-0.6280802,-0.819238,0.2555748,1.0589215,0.65628546,-0.0531931,0.8365,-4.51318,-0.01536402,-0.25932035,-0.8811652,-2.527603,-0.5197397,0.23193689,-0.66849935,0.99487174,-1.1101373,3.369974,-0.19757815,-0.5163748,1.0134128,0.33420387,-2.4231486,-0.014553905,-1.5895526,0.17605703,-0.0075382087,-0.22752887,0.0062880223,-2.6609495,-1.5315897,0.05385281,-1.0568316 },
  { -0.82130486,1.8484657,-0.28080776,-0.0948688,-0.2269543,0.4560526,0.45552853,-1.124773,-0.18208718,-1.5370032,-0.65459996,-0.25717252,0.99369675,-0.043499116,-0.47688767,-0.33529386,-0.15866709,-2.8625145,0.17057899,0.8464053,0.037698235,0.7517486,0.20718038,-0.41518393,-1.2370213,0.030066457,0.029615918,-0.39151192,-0.77571464,0.59763634,-0.1745667,0.3237628,0.471349,-0.0616617,0.29639986,0.0958341,-0.14225829,0.13876854,-0.5963822,-2.153491 },
  { 0.31783858,0.42956716,-0.29125732,-0.7033921,-0.5910682,-0.059751857,-0.5907697,0.5885763,-1.5986767,0.83120817,0.31801355,0.21535797,-0.42953345,0.30168542,0.14797556,-0.71380115,1.5551876,0.3148424,0.14427611,0.06509509,1.4682564,0.03549189,0.09388743,-0.27711257,-0.2026959,-0.31759927,0.36628357,-0.8480897,0.6500813,0.3990602,0.06769345,0.39597476,0.12245766,-0.06910244,0.36395684,0.18007791,-0.22007479,0.7018627,0.17906001,0.41789445 },
  { -1.7698836,3.498486,-0.120910995,1.977591,2.126809,-1.2066215,-0.18998791,-0.18877712,0.35357288,-0.49743402,-0.41576603,0.9926314,0.30720484,-2.065499,0.5841261,-0.2531269,-0.520874,0.34141287,2.174186,-0.11282044,0.4584906,0.12568457,0.18073641,-0.49372265,0.9353699,-0.40475872,1.6410636,-0.3318277,0.30097017,-0.4470533,-0.23539215,-1.5052011,-0.17069793,-0.0003512933,-0.014719324,-0.20668101,-1.295488,-0.37348264,-0.2721346,0.5011929 },
  { -0.9685134,-1.7052187,1.0426933,-0.9295216,0.6040664,1.9128491,2.0501692,0.26465744,0.6847477,-0.31156465,1.0589913,-1.3457462,-0.36927882,-0.214401,-0.061112236,-0.18899544,-0.68100095,-0.19704747,-0.6031565,-0.7698928,0.081386015,-0.19118604,-0.53194827,0.48492497,0.11320848,0.0007985917,-1.2884778,-0.40379834,-2.452237,0.37908632,-0.11694094,0.42216048,-0.19279914,-0.002598535,0.3755263,-0.31886104,0.29122797,-0.8462948,0.048669685,-0.40224627 },
  { 0.8832275,0.08882447,-0.4840702,-0.74793786,-0.65284985,0.095773116,-0.0007655778,-0.3361635,1.0531795,0.2032498,-0.37163904,-0.10847998,-0.38811597,-0.21613604,-0.90156096,-0.60954803,0.7599714,0.39934605,0.21463317,-0.093581274,-0.35137686,0.7612289,-0.7685198,-0.22173178,-0.42374673,0.1522125,0.20168267,0.51474416,0.38889024,0.022541553,-0.11965936,0.5515558,-0.29007593,0.05009047,1.0549738,-0.15755945,1.1262715,-0.26604003,0.13921724,-0.7838745 },
  { 0.025626121,0.07197533,-0.81530553,0.71055216,-0.48770797,-0.078573994,0.09674311,0.34516072,1.7892478,-0.359126,-0.2819056,-0.1416804,-0.34617373,-0.0186803,0.17021805,-0.35382366,0.53695804,0.2532293,-0.82494867,-0.13650034,0.9772391,0.7826021,-0.054118913,0.3001693,-1.1580983,-0.3509494,1.2833054,-0.67762786,-0.56845176,1.2850932,-0.3119227,0.44071355,-0.31687483,-0.0056565227,-0.17406093,0.023606967,0.3914653,0.4149274,0.044098996,-0.4943255 },
  { -0.99981034,1.2285651,0.9085786,-0.59115714,0.060884006,0.10098812,0.5529994,0.3547387,-0.09394823,-0.21858221,0.7484155,0.26158372,0.022736685,-0.102941185,0.7447894,0.6067163,-0.3692628,-0.2636244,0.3366645,-0.1685086,-0.333475,-0.45053124,0.83472985,-0.892652,0.8876933,-0.33136052,-0.16891594,-0.07510212,-0.3281416,0.055858918,0.7135135,-0.09297602,0.60625696,0.07976445,0.47777164,0.3223866,-1.4218999,0.5122807,0.16203912,-0.7930418 },
  { -0.24081752,0.2756491,-0.07625612,-8.186713,1.0535352,0.2815109,-0.26061553,-0.9790926,-0.28418007,0.9350257,0.27082026,0.2558749,2.1334054,0.42131495,-0.27290592,-0.19362558,-0.28984684,0.4773288,0.016378792,-0.34383565,-0.3175747,-0.7011531,-0.68084925,0.8903521,-0.29483178,-0.42624778,-0.1880239,-1.0426925,0.6177856,-0.6100266,0.2902135,-0.6157344,-0.043905433,-0.0792316,-0.03206022,0.599727,-0.36967757,-0.0184106,-0.07498028,1.4626696 },
  { -0.21662392,-1.6557511,-0.10725744,-1.6946328,0.21193399,0.2797308,0.0883783,-0.76938266,0.057814084,0.34893456,0.22524863,-0.039008066,-0.45483556,-0.61734,0.29353774,0.1902519,-0.26794657,0.3703913,1.0058038,0.08743639,-1.1040477,-0.5343507,-0.11372241,0.17519976,-0.31043476,-0.25416642,0.42505267,0.10087035,-0.9931444,0.70759696,-0.06086772,-0.21781577,0.13809498,-4.1617866e-05,-1.6344734,0.29600307,-0.96222293,0.32134184,-0.1700008,3.1585076 },
  { -0.016671209,1.3546191,0.035307325,-5.949931,0.8965073,-1.0191491,-0.6585714,0.8665534,0.055499934,0.80604243,0.30336756,-0.20733437,-1.9752355,0.56254876,0.7098439,0.11392348,0.44184577,0.65210855,-0.2953655,-0.22110763,-0.93141663,-0.302852,-0.042058386,-0.08747285,0.14940317,0.054593664,0.27285397,0.6573997,1.379955,-0.03731988,0.3924445,-0.5879672,-0.3493883,-0.0067462767,-0.13365625,-0.27647245,0.32543102,0.12767792,0.25235265,1.124693 },
  { -0.3401629,0.7406285,1.3003814,2.392222,0.03615047,-0.3484567,0.37993196,1.1130893,-1.9730858,0.281198,-0.28875095,0.08244538,0.46442413,-0.17590249,-0.48417917,0.66594154,-0.9353747,0.75516176,0.7273457,-0.04466996,0.33275098,0.14709462,-0.8156376,-0.7223227,0.5150273,0.8256186,0.1095213,1.8849754,0.26147744,0.064449005,-0.2122745,-1.2566422,0.79309475,0.055734538,-0.31976125,0.20251547,-0.37923723,-0.44389948,-0.005219269,2.0801656 },
  { -0.27091917,0.2538938,-0.34108707,-0.43644497,0.46530214,0.51994455,0.2372369,-0.07195486,0.31034374,0.21792729,-0.16542916,-0.4206709,-2.26015,0.98245865,-0.6481121,0.34686488,-0.22780482,-0.64312613,-0.8680655,0.008867408,0.3095033,-0.014620209,0.29156503,-0.19727255,-0.29464337,-0.14695862,-0.24000423,0.44568917,-1.3564283,0.0914028,-0.530818,0.69579315,0.049374066,0.019495623,0.07103379,-0.20495701,0.24821824,-0.3452672,0.11945647,-1.2844933 },
  { 0.4162278,-0.94271785,-0.39334914,0.6593948,0.11208631,-0.67249095,-0.53261054,-0.4374342,0.9124867,-1.0532126,-0.5814059,-0.07128612,-0.68867624,-0.0795756,1.0399314,-0.03040519,-0.20133075,3.3528953,-0.7335836,-0.04948899,-0.0076087047,0.13007377,-0.07018698,-0.06978705,0.2903484,-0.21553737,0.08508751,-0.8541757,0.6028484,0.3583318,-0.18257874,-0.42088306,-1.0659302,0.0006385134,0.20804627,0.08943137,1.5158422,-0.2058907,0.2354779,-0.06415521 },
  { 0.11698531,-0.59264314,-0.19390272,-0.45358813,-3.3519719,0.20472372,0.32836458,-0.41482535,-1.192715,0.20366246,0.12715566,0.111956514,0.7678049,0.15992588,0.37142107,-0.41993544,0.25074133,0.33143952,-0.5116727,-0.8324302,-0.6901036,1.2327206,1.413228,-0.23756477,-1.4260569,-0.4249903,0.07904906,0.6002268,0.40971604,0.5427004,0.5873005,-0.20582232,-0.3070103,0.00198114,0.20699148,-0.12532136,-0.4441159,0.03806608,-0.600247,-1.256996 },
  { -1.0504085,-13.352931,-0.44347182,-0.73981446,3.1782892,0.07748095,0.057889696,-0.020323915,-0.06505753,-0.24546067,-0.26244587,-0.89036256,0.055392567,-7.5852723,-1.2775229,0.5033867,-0.07150042,-0.037544012,-8.117602,-2.4528668,-0.025035122,-0.01984495,-0.14603049,-0.8218017,4.7274013,-0.13870305,-1.7393471,-4.0194864,-5.1494503,-0.6294202,0.23695211,-0.7989252,-0.4554794,0.09034597,0.19857064,-0.53387004,-0.35698378,-0.93001,-0.024244672,-0.09090424 },
  { -0.3398545,0.6034491,-0.13775136,-0.42610574,-0.010632692,0.96584946,-1.010776,-0.12046565,-0.18838699,0.19581725,0.4182866,0.7463026,-1.2115815,-0.22892357,-0.85098565,-0.76191664,0.17531793,-2.539968,-0.8212105,0.23522249,1.4291636,0.51032275,-0.024499835,-0.17579447,0.2623797,-0.08453904,0.30448896,0.48989242,-1.9024218,0.0657036,-0.39494538,-0.5528828,0.42244256,0.026732363,1.2178117,-0.04550694,-0.9147039,0.0750179,0.2188326,0.33253628 },
  { -0.5613523,4.8704224,-0.24799328,-1.7813581,-0.1975216,0.36430684,0.3668298,0.3829877,0.5018871,0.78768635,0.42695275,-0.31752545,-1.5015093,-0.078201,-0.16300315,0.11396862,-0.24202323,-0.00921653,1.5041645,-0.36687532,-0.7918598,-0.028930202,0.23273575,-0.5028423,0.30547854,-0.015543168,-0.31073472,-0.77225244,2.187193,1.260379,0.045158293,0.24782091,-0.054575633,0.015188973,-0.19891775,-0.004669528,0.8392771,-0.5459007,0.6112511,0.099225886 },
  { 1.1759262,0.32943422,0.11189082,-0.1579066,1.3627275,-1.4748975,-0.99114984,0.010052716,0.17653164,0.32148317,-0.7876315,-0.45528603,-0.053680856,0.42208433,0.22910014,0.21258226,0.20322186,0.60248286,-1.433455,0.11044153,0.113607325,-0.44167235,-0.27025405,-0.31591898,0.20429154,-0.5026548,-0.064522475,0.0125730615,0.9267514,-0.0672433,-0.35827208,0.39034626,-1.125337,-0.00065758586,-0.011095531,-0.2644769,0.9212559,-1.0287583,-0.12091324,0.43401176 },
  { 0.6029033,-0.8388792,0.037665866,1.6360304,-0.5677826,-0.012917534,-0.26627883,-0.05087473,-0.14017226,-0.24621505,-0.4645086,-0.16029015,0.40379265,0.28339863,-0.026987338,-0.34218848,0.8543178,0.49335217,0.7120127,0.092428856,-0.078128174,0.276418,-0.19684283,1.3080138,-0.4734716,-0.0833527,-0.17805812,-1.7092868,0.78754085,-0.4231745,-0.0717212,0.49937007,-0.8866049,0.022461778,-0.47296488,-0.62414783,1.846988,0.18574865,0.13039061,-1.5568161 },
  { -4.5596595,-9.009537,0.11037856,4.385673,4.7889214,-1.2813342,-0.24224809,0.5943925,-0.14495851,0.34510997,-0.9322708,-0.006173332,1.1749661,-0.8430527,-0.39222556,-0.12586097,-0.17643484,-0.1467138,1.5178491,-4.665024,-1.1651417,-0.50500745,-0.07085323,0.01824071,5.4845963,-0.95174146,1.1711391,0.5404013,1.3691823,-2.7677603,0.034957644,-3.9978325,-1.1985146,0.023636252,-0.04405546,-1.4750109,-2.1280296,0.9317853,0.9691364,0.09952742 },
  { -0.5957815,1.6085596,-0.32611126,2.019384,-0.060039483,1.9109906,-1.0691974,0.14527343,-0.21649468,-0.44239536,-1.3630764,-0.6751717,0.034338593,-0.9809036,-0.013613811,-0.122997396,-0.5321648,-0.39521924,0.67272735,0.41539526,0.914665,-0.28233021,-0.4049975,-0.8602414,-0.6615962,-0.28197792,0.22115228,-0.7475501,0.09865001,-0.30444568,-1.3471148,-0.23666917,-0.12692662,-0.002211167,0.2076762,-0.49890038,2.195301,-0.74800444,0.7579093,1.2329867 },
  { -2.6889398,-8.9798565,-0.83253986,-1.8803798,1.4101248,0.0789972,0.3671793,-0.024647124,-0.104799874,0.47355554,-0.51127887,-0.24455336,-0.23205076,-3.6205957,-1.8921416,0.4213987,0.20980002,-0.7748149,-11.712347,-4.4089875,-0.24741888,0.0057537393,-0.17801648,-0.115447864,3.0482838,-1.7189218,-1.9735084,2.54645,-2.0033696,-0.5734721,-0.094437,-0.7679458,0.48984975,0.3503624,-0.8533433,-0.47993246,-0.97123563,-1.2716799,-0.3498433,-0.15205498 },
  { -1.3076534,-0.96141076,-3.687369,5.8367105,2.7739253,0.65518254,-1.8860284,0.21512172,0.12294806,-0.09806882,-0.18906921,-1.6092614,0.3185363,-5.118941,1.1087788,-0.19182889,0.076389894,0.1945457,0.011110262,2.0824404,0.3209858,-3.052269,-0.5206054,-1.8032035,2.8335865,-0.13548635,-4.3615913,4.080701,-2.0032158,1.3752147,0.3945118,-3.5017526,-1.3885225,-0.00070308766,0.20027067,-3.0249374,-0.913817,0.66902745,-0.43159595,-0.6888399 },
  { -0.28968874,-0.17024077,-0.22446524,0.3266115,-0.1602162,-0.16605921,-0.03740527,0.19226757,1.3624574,-0.24252726,-0.0666908,-0.105200656,-0.3528956,0.58752406,-0.7830385,-0.040514264,0.6047638,0.008942173,-0.068844445,-0.54941475,0.075536095,1.0657904,1.4076464,-0.03838953,-1.3425856,-0.22026424,-0.07187865,1.0988494,-0.4584774,0.6479954,0.2150541,-0.055706214,-0.38418037,-0.0011345508,-0.02627435,-0.1959779,-0.8816075,-0.21483478,-0.40985686,-0.19799303 },
  { -0.3141056,0.19786038,-0.78197706,0.6901178,-0.032289594,-0.2344452,-0.14397289,-0.010684602,0.33357933,-1.6490651,-0.27422377,0.5357834,0.10727252,0.4029922,-0.86782855,-0.8440767,-0.8943756,0.2756528,-0.19901092,-0.099061914,1.1162416,0.4830471,0.32860932,-0.26052442,0.33173382,-0.089570306,0.902678,1.9633185,0.758476,-1.4877274,-0.3581955,-0.64612526,-0.14323048,0.02519407,-0.27452767,-0.09244282,0.15681197,-0.39966154,0.12576157,2.1327753 },
  { -0.8711771,-0.7459656,0.26891658,-1.9869559,0.095919505,-0.3792022,0.7037353,0.18966794,0.5688438,0.009827959,0.5842543,-0.0898241,-0.8808333,-0.45316327,-0.26401776,-0.025149748,-0.20071533,0.3274674,0.6561545,-0.19523822,0.21841244,-0.29396716,0.40865242,-0.116943546,-0.118831314,-0.24297313,-0.3038509,0.92476624,1.2110204,1.0760263,-0.14031811,0.78110224,0.051833965,-0.094761156,-0.3773602,1.0848306,-1.9128265,-0.5576139,-0.25627023,-1.052556 },
  { 0.03367471,2.2371242,-0.39252195,0.4294253,-0.15861522,-0.09836338,-0.44758958,-0.98075503,-0.12804772,0.8072872,0.6913784,-0.029875051,-0.69518924,0.13066669,0.9644945,-0.015456581,-0.0694392,-0.8567913,-0.49760053,0.40281233,-0.17240678,0.3156209,0.37681088,-0.8176744,0.6257943,-0.16837661,-0.113321654,-0.8053161,1.1926706,-0.2963805,-0.107429564,0.05398876,0.4473284,0.011545579,-0.2352414,-0.077976294,-0.8477643,0.43125734,0.3656934,0.8580306 },
  { -0.107658036,0.75145155,-0.018730426,1.4148487,-0.09303065,-0.40932396,0.2755517,-0.28566337,0.40677965,-1.4337434,-0.11677724,-0.014388887,-0.4834594,0.39453918,-0.5513736,0.052157834,0.36799234,1.8147657,0.1741307,-0.2227986,-0.499204,-0.10405728,0.9856105,-0.49804416,0.48841137,-0.043078728,0.24568962,-1.2687654,1.1202794,0.5967577,0.45115095,-0.34363753,0.15091108,0.005640878,1.0879909,0.07244617,0.12910067,0.13157794,0.3494577,-3.0893052 },
  { 0.4610038,-2.1479547,0.18907729,-0.12656666,-1.820937,-0.20650575,0.14552495,-0.43447128,0.5290918,-0.52688086,0.19314046,0.10873064,-0.055325206,-1.0928421,0.20872195,-0.1282878,0.32135183,-0.28891858,-1.9737856,0.38884014,-0.20298076,0.07291621,-0.1048212,-0.894179,-0.6161139,-0.027976252,-0.16219622,-1.764215,-1.6588603,0.35912335,0.00769913,1.0177487,0.20128164,-0.0012803595,-0.0872549,0.5160416,1.5577767,0.065502524,-0.1998275,0.030190127 },
  { 0.23113398,-1.0024688,1.0228789,0.44190207,-0.41323534,-0.4804692,0.52624494,-0.21823251,0.8094684,0.55642813,0.6274789,-0.010914291,1.14267,-0.33384287,0.14537826,-0.6445371,0.37782466,-1.2012818,-0.9931653,-0.18961748,-0.6852475,0.09694568,-0.32613006,0.095541306,-0.49497986,-0.2870036,-0.3292561,-0.16539176,-0.8468693,-0.0706985,-0.6003131,0.13070849,0.62264913,0.020312808,-0.27289858,0.97629875,-0.7907839,0.06674073,-0.6251685,-0.415609 },
  { -1.0157515,-0.14614415,-0.75413495,-0.3371232,0.80663526,1.5499394,-0.71276385,0.32774144,-0.6146473,-0.484043,0.070154496,-0.48657203,-0.9451833,0.4029119,-0.14817248,-0.74721384,-0.07568621,-1.1202327,-0.11647055,-0.100377575,-0.02978137,0.13576984,0.26293403,0.26274347,-0.084903486,0.1602974,0.22122647,-0.46951956,0.34453335,-0.061548613,0.022497032,-0.5314566,-0.18653822,-0.01216797,-0.16764648,-0.21221769,0.9349289,0.059491247,0.30598935,-0.74385434 },
  { -0.07420974,0.20206729,-0.33077604,0.74588674,0.48725092,-0.43806928,-0.2240911,-0.5531565,0.052835435,-1.1481383,-0.21560729,0.01734252,0.33005542,0.23120615,-1.0334381,-0.042090777,-0.62726575,-0.5418305,-0.32888672,-0.04896622,0.7500879,0.5769311,0.11188716,-0.48603413,-0.79083747,-0.13006532,-0.43241566,2.3673306,0.36491254,-0.52381647,-0.444785,0.2754986,-0.20549044,-0.006956299,-0.16852528,0.02187701,0.8879518,-0.5783489,-0.10760348,-0.7059436 },
  { -0.0014673781,-1.0636355,0.35606787,0.8380862,-0.06603079,-0.6248057,0.3398428,1.8995513,0.3867455,0.3357713,0.360613,-0.3651935,0.6020853,0.43819675,-0.124989875,-0.68923587,0.43382332,-1.798369,-0.5667782,0.25061202,0.040922947,0.17299667,-0.6488266,0.4386881,-0.4532119,0.7229789,-0.5899649,-0.3169447,-0.7966268,0.07808115,-2.4399688,0.7006525,-0.1548738,0.010012048,-0.57905114,-0.2201175,-0.206101,0.80917513,-0.55278283,0.7884858 },
  { 0.89846647,3.4743176,-0.248146,0.5305421,-0.541335,-0.78441185,0.32277867,-0.05270344,-0.68270177,0.15099391,0.13752088,0.622469,0.75812805,-0.1824885,0.28989425,-0.1793933,-0.28231612,0.22414392,-0.6327189,0.3455437,-0.6526233,0.045816407,0.107705735,0.20109285,-0.3165698,-0.043981243,-0.661847,0.47156513,-0.12817565,-1.8733426,0.31662118,-0.7612931,0.5520317,-0.0022032894,-0.068303764,-0.17656952,0.2973277,-0.2478753,-0.124536276,-1.1648277 },
  { 1.2257221,0.9165343,-0.49932054,-0.051698714,-1.9817559,-0.60997164,-0.6738908,-0.48031256,-0.46080953,0.29518446,-0.50885934,0.31105343,0.8050814,0.044408977,-0.11459411,-0.01840236,0.061708074,-1.347454,-0.4891462,0.46880847,-0.014765696,0.80899286,-0.23814629,0.8109387,-0.8575624,0.19398892,0.12429511,-0.41509357,0.37294978,-0.09555074,-0.25768492,0.8885376,-0.6756169,-0.00077076885,-0.06091208,0.26195347,0.25487107,-0.05523292,0.25376824,0.26186064 },
  { 1.6015805,-2.0437298,-0.83824414,-0.7368327,-2.0433462,-0.022160562,-1.0061741,-0.0023427056,0.060615066,-0.046138916,-0.12487973,-0.30420673,-0.2558004,-0.70055676,-0.014248393,-0.0063181818,0.0979016,-0.32569906,-0.7800206,0.25241196,0.039482266,0.20066266,0.035198335,1.429886,-1.7037457,-0.024965784,1.135934,-3.1052885,-0.21160401,0.08188167,-0.2858349,0.3886267,-0.48578152,2.03763e-06,0.008026775,0.035653904,2.4995694,-0.3872595,-0.17141952,0.18684995 },
  { -0.32334384,1.098842,-0.2557564,-0.96146166,-0.012141775,-0.79983336,0.027807495,0.3344504,0.5268805,-0.7649147,-0.6818088,0.37451628,-1.8575436,0.35135296,-0.46738514,-0.1440262,-0.12047519,0.17746355,-0.08490844,-0.35891494,-0.5123285,0.5203551,0.5760407,-0.99136215,0.56843954,0.03806945,0.3689359,1.9851551,0.25498733,1.0077019,-0.5945229,-0.49366596,0.19781813,0.095898926,2.3574667,0.3039712,-0.7524983,0.16222893,0.36546364,0.3861894 },
  { 0.24246573,0.03094954,-0.97241014,2.9343047,-1.0617031,-0.18851683,0.35918367,-1.8612175,0.5498851,-1.1293154,-0.5121262,0.53363234,0.7431953,0.27429014,0.049813006,-0.7258708,0.72731894,-2.0623176,0.05484651,0.028583644,-0.41435254,0.34386107,1.2904779,0.007817751,-0.6324374,-0.3036755,0.3059973,0.12755603,-1.1012439,0.6504247,0.07667606,0.28753424,0.19177914,0.06445444,0.27091488,0.07625878,-0.27601826,0.4830909,0.2067238,-3.6559808 },
  { 0.28987044,-1.1923392,-0.48420438,1.1246223,-0.5476042,-0.51419735,0.35621536,-0.72121054,1.758023,-0.42723748,-0.06839452,0.09373714,-1.0196993,0.4561464,0.56219316,-0.046343245,0.8483055,-0.10728714,0.16797733,0.19698554,-0.66254574,0.8520768,-0.029669203,-0.46492347,-0.21299702,-0.00082887,0.032668985,-0.89746875,0.9604589,0.100644045,-1.126073,0.12140218,-0.0631982,0.08729238,-2.3996212,0.11894569,-0.3138704,0.06039589,0.46554396,2.4397678 } 
};

double h2_h3[40][40] = {
  { 2.194519,-0.83401424,0.2659623,-1.0960158,-0.6654363,0.86063117,0.22431497,-0.024197107,-0.58608186,-0.13116741,-0.09428804,-0.5105836,-0.84869635,-0.27432004,1.3973787,10.811531,-0.36935183,-0.47799444,-1.3855512,-1.1605448,2.692485,1.5983394,2.4832277,12.905781,-0.38926446,0.675056,-0.14391695,-1.7376558,-0.11536216,-8.156402,-0.17923965,-0.48436782,0.9451967,-0.4143812,0.64322335,-0.44449565,-1.4948368,0.14378063,-0.35872418,0.29488826 },
  { 2.340826,-0.28482774,0.069773585,-0.7019838,0.09719108,1.0104462,0.16911747,-0.49962968,-0.7515917,-0.48141107,-0.5199938,-0.78950894,0.19921896,-1.4425095,-0.2169904,0.93181616,-0.5401728,0.207019,-1.0387152,-2.194223,-0.9275957,-1.1012954,-12.022339,-0.8412522,0.4822079,0.91480416,0.213701,-0.8328562,-0.02918999,-1.4663419,-0.7244834,-2.2723827,-0.39375144,0.0037066094,0.03449368,-0.89272296,-1.9669124,0.9441444,1.062147,0.6818168 },
  { 1.7473747,0.23512039,0.30469304,-2.9815075,-0.16492371,0.66904587,-0.043552153,-0.8092889,-0.69563985,-0.13807075,0.6541644,-0.78480047,-0.21650618,-1.34629,-0.5343116,-1.1839894,-1.0897704,0.6623013,3.2361474,-1.9204537,-3.5768073,0.17266572,-4.425047,1.1162878,-0.17629199,0.18848376,-0.16112974,-2.7859216,-0.9877378,-1.010536,0.0065641855,-0.602981,0.25316048,-0.39068744,1.0048015,-0.86540246,-4.3423595,-0.034248527,1.1393502,0.46014935 },
  { -0.42904842,-2.2905905,0.24176097,0.757021,-0.048320074,0.30665419,0.21546306,-0.6703216,-0.4690992,0.38028196,0.21865305,-0.4475777,-2.6921036,-0.35241872,0.7198541,-3.7690077,-0.7207543,-0.3325376,-3.6933672,-0.047969043,-0.11308867,-0.58109397,2.5403254,-2.901964,-0.2692442,0.074638344,0.27957258,0.53314334,-0.15030076,0.7732184,-1.0342066,1.1879283,0.591317,0.4637736,-0.79742485,-0.5522596,-0.34425634,0.707584,0.37508053,-0.22016715 },
  { 2.5455694,0.83155274,-0.2854095,0.15536906,-0.5871423,-0.3053357,0.32513633,-0.40533164,-0.06532523,0.12917304,-1.2957795,-0.44043005,0.016492864,-2.364303,-0.8243296,-2.956821,0.59785247,0.5436345,-4.9369955,-3.4437,-1.9597863,1.9873803,-2.8228056,-0.4855586,-0.5813784,0.9123628,-0.6832913,0.0067096264,-0.48662704,-1.4970899,-0.01916837,-0.034704033,0.21359712,0.2809278,0.18103182,-0.75819516,-1.9902374,-0.2790805,0.8734435,-0.2903488 },
  { -0.28940824,1.6767408,-0.05859706,-0.80618846,0.5393691,-0.5602338,-0.09952659,-0.09636697,-0.43432,-0.9858205,-0.22844525,0.06101691,1.737195,0.4917547,-0.121467255,-0.013470829,0.17736414,-0.04397516,-1.5413686,0.15988061,3.5318947,-1.3206904,-1.5382525,1.5098945,4.5061088,-0.5827117,0.51605356,-0.98957723,0.3174157,-0.009268904,0.26931196,-0.19210093,-0.791046,-1.4064288,-0.8070838,0.41813356,-0.5695081,0.62512696,1.1721773,-0.23055081 },
  { 1.4837834,-0.5058512,0.29780814,-1.1841382,-1.3236597,-0.038966957,-0.15724608,-0.11159702,-0.5029405,-0.946474,-0.9431546,-0.20754302,0.6283191,-0.76631147,6.785458,-5.0041347,-0.8367845,-0.076641604,-3.0883312,-0.13248798,-0.7890217,-1.1857156,-5.283142,-4.76702,2.136604,0.81662047,-0.08950453,-0.12778704,-0.16299185,-1.8858355,0.42317316,-0.28503928,1.405178,-0.01662114,-0.025793793,-0.58492285,0.54312176,0.11250956,0.9019557,0.24378231 },
  { 0.8243798,-0.25719693,-0.09122904,-12.844093,0.35772985,0.25604343,-0.6274707,-0.29582286,-0.29389623,-0.5012921,-0.02304123,-1.047629,0.77269036,-1.8201647,0.6937537,9.471344,-0.6837671,0.52159303,0.91702557,-1.3631725,-0.55078506,-0.3220515,0.4393249,4.910473,-0.1475309,-3.7738228,0.58702815,-0.44641393,-0.63525057,-1.8495543,-1.7227216,-2.5182014,-0.26427928,-1.0641346,0.51507115,-0.00070698146,-6.2986608,0.05561887,1.1806577,0.37915808 },
  { -0.5354568,-0.48462662,0.8611495,-8.109643,-0.12283445,0.21350303,-0.16885315,-0.4996897,-0.33469117,-0.09430841,-0.88561875,0.010460611,0.11567405,-1.1623868,1.8342113,5.7633176,-0.6140265,0.45988727,0.09461228,-1.0369569,-1.8142225,0.55177724,2.139087,11.139642,-1.6870651,-0.57304853,-0.55446464,-0.11964518,-0.7825112,-1.5662316,0.799655,-0.1022677,0.08459417,-0.74344885,0.13102986,-0.27254876,-0.08058536,0.6819504,0.22731453,0.66883427 },
  { 0.4359241,-0.62463695,0.03176852,-10.450489,-1.7058418,1.0489826,-0.16981183,-0.7309955,0.012216769,-0.10406749,0.28713897,-0.6219416,-0.93681204,-1.2964039,-0.34742957,1.6643221,-1.7764887,0.09759581,0.24134265,-1.1473562,-0.9016632,-3.9025245,4.4663754,0.72125506,-0.95893097,0.14816807,-0.03243567,-0.08794611,0.36712947,-0.10364159,0.6274379,-0.43754554,0.20773321,-0.6983625,0.74396265,-0.64744866,-2.378394,-0.11256502,0.8308752,0.33971122 },
  { 0.25652945,1.0114533,-0.5206838,0.5179228,-0.462141,0.9404509,-0.0050042677,-1.2302843,-0.57469064,0.9545844,-0.26804528,-0.6666072,-0.5240297,0.6822093,0.73154455,3.7783518,-0.7635794,-0.6413174,1.9902542,-0.9624836,3.1764407,0.77035046,4.713805,0.34514832,-0.8658615,1.1789494,0.091289476,-4.849634,-0.9262793,-3.5260136,0.40993765,-1.482457,0.46514493,-0.5128197,0.3175124,-0.62861186,-3.191586,0.1272281,0.7117075,0.1414324 },
  { -5.461201,0.3931642,0.19580583,-0.19002786,-0.28840023,0.050703168,0.29187855,-0.64743,-0.043930437,-0.29335248,-0.44208914,-0.18911013,0.23408094,-0.95420724,0.42845815,10.832867,-0.74320775,0.23923449,-6.4445395,-2.7143202,4.0159526,-0.7039609,3.2870543,7.846265,-0.07524033,0.21342815,0.087556854,-0.79270923,-0.75716543,-0.20001155,-0.5866227,-1.0054305,0.16234703,0.20494461,0.08727107,-0.7598184,-1.6390516,0.34802136,1.1428206,0.06313061 },
  { -1.3821411,0.159395,-0.18958423,-7.9435525,-0.53018564,-0.2781057,0.14694418,-0.46351406,-1.4284401,0.07709907,-0.5374221,-0.24143822,-0.33632204,0.12093699,3.9785101,-15.26589,-0.78569204,0.15314423,0.95790714,-2.1684673,0.17673352,1.0164297,0.6574493,-3.7873433,0.7178075,-2.1167932,-0.12698777,-0.43575042,-0.71329415,-3.7861915,-0.64165473,0.17228265,0.70171785,1.2248559,-0.70062083,-0.6131439,-1.894661,0.2694057,0.056369904,0.99505675 },
  { 1.3097914,-1.3074932,-0.13828215,0.5767179,-0.9759625,0.5458495,1.0748223,-1.3474662,0.025555812,-0.52345645,-1.8740692,-0.64742446,1.0493553,1.5451244,-1.5674565,-2.3459692,-1.4329324,0.79817575,-0.63057315,-2.4785438,3.5974727,-0.02577402,-1.9003389,-2.264758,0.34257427,1.4289789,-0.94104916,-0.89899886,0.99741805,0.85784054,-2.2915761,-2.1915426,0.71978915,-1.089346,-5.1214247,-2.186,-3.6268122,0.08399466,-0.46031842,0.48281768 },
  { -0.013832788,-1.6751809,-0.6025447,-2.5752702,0.031444907,-0.18061808,0.31194746,-0.22127157,-1.2353523,1.1560745,-2.2733948,-0.87048703,-0.19552131,0.95950705,3.2860415,0.97221285,-0.78126293,0.26022637,1.277469,-1.0463145,-0.38000947,1.9355465,-1.8076788,6.328441,0.87079626,-1.0613197,-0.3688528,-2.9437077,0.4794424,-1.3350792,-0.782794,0.81775236,0.3065252,-0.15658966,0.5629142,-0.5615958,-2.1470022,0.24939454,-0.23772925,0.46005735 },
  { -0.548725,-0.44291645,0.04938238,-0.12855633,-0.09812292,0.2603269,-0.0020544403,-0.46866575,-0.23097128,0.1761324,0.18100385,-0.7155825,-2.3068812,-0.3904853,-0.31580094,-4.8066287,-2.2781198,-0.43967664,-0.45259747,-0.42356828,2.2895057,-6.284956,0.16466893,0.54848206,-4.919681,-0.1909317,0.34578973,-0.08203141,0.76817864,-4.0084624,-0.31731686,-4.928712,-0.030863183,0.22998047,0.559789,-0.311377,-0.65580803,0.24376038,0.14481659,-0.10345958 },
  { -0.6381837,-0.7798701,0.7516031,-1.2512872,-0.566503,0.76955795,0.16570818,-0.6517085,-0.50148624,0.39054176,-0.10941105,-0.6352678,0.0011500431,0.83499324,-1.0053449,11.914721,-0.45987844,-0.39035097,-2.9886518,-1.8842427,3.3586519,-0.33149913,5.079807,9.690386,-0.005222947,-0.12411409,0.5141329,-0.20223173,0.14761163,-0.94772255,0.041974198,-2.1977186,0.7034335,-0.34205362,-1.2714671,-0.68790495,-2.218287,0.11514027,0.705157,0.3145721 },
  { 2.423741,0.67306805,0.19206035,-0.203126,1.0790765,0.3590807,0.12385345,-0.26881674,-0.09951937,-0.8154083,-1.666633,-0.8671833,1.2882898,-1.0582963,-1.3765473,11.719287,-0.98477024,0.58223695,6.203864,-1.7125773,3.0762794,0.851274,1.4148575,13.48156,2.4333332,-0.29938293,-0.49723747,-0.9163639,-1.0119767,-0.13064998,-1.8149222,-0.11680696,0.08988949,-2.4317374,1.2669541,-1.4831969,-3.86115,-0.07462337,0.60041547,-0.10798704 },
  { 0.45213813,1.2915465,0.41125754,-1.9075711,-1.4561465,-0.5039207,-0.32901302,-0.43962514,-0.20832554,-1.8754777,-0.78590256,-0.5110675,-0.08742483,-0.3648154,-1.1841173,-5.4272633,0.15874311,0.19247317,0.51524454,-2.597868,-3.45605,1.5606961,0.2636963,0.3470264,-3.030254,0.62761396,-0.106137395,0.06553059,-0.0861183,-0.34829387,0.9630447,-2.0578058,-1.0248487,-1.1286541,-0.38023776,-0.6146293,-2.9736924,-0.30504715,1.071395,0.5913449 },
  { 5.507068,-0.08598022,0.29935277,-7.971658,-0.6931705,0.13764113,0.018968696,-0.105794154,-0.7667425,0.663229,0.02402547,-1.0855341,-0.67957526,1.6635522,1.1792194,-1.5517753,-0.74626696,0.12630233,-1.1262395,-2.2735112,2.0358768,1.7006881,-1.75111,-2.5618155,1.3603029,-3.6496515,-0.035022233,-0.21664877,-0.20139281,-1.1119729,0.9166019,-1.2732078,-3.0766613,-0.9039308,0.71815455,-0.16760208,-4.8128657,0.035052277,-0.8260331,0.405838 },
  { -0.93187135,0.53208095,0.20137118,-0.6618877,-0.32490036,0.73353404,0.36530042,-0.5450279,-0.41282138,-0.47077262,-0.1493072,-0.0755644,-1.0312017,0.35196787,-2.0382762,0.9489356,0.21850675,-1.2100302,1.5447545,-0.68628216,3.2631457,-0.7995713,-6.3902183,-1.9784522,0.02776672,0.39119062,0.999607,-1.1542068,-1.7008084,-1.3738223,-0.1405084,-0.3666861,0.14948559,0.025343128,-0.6986243,-0.6066374,-0.10298018,0.3142095,0.730777,-0.48659998 },
  { -15.644834,-0.40102136,-0.40955332,0.13182342,-0.048429333,-0.24093238,-0.11052531,-0.8152108,-1.3393633,0.20659497,-1.02392,-0.96355695,0.8573515,1.7668229,0.9099672,-0.4963387,-0.8546472,-0.11543002,-1.9793842,-0.78669626,2.656074,0.28422135,0.55938256,1.4891444,-0.4924017,-2.225947,1.106585,-2.189935,-0.54612386,-2.49698,-0.08463978,1.02316,0.44082978,0.32502955,0.65240484,-0.8541715,-3.6747367,-0.3272014,0.43345758,0.19259635 },
  { 1.8029051,0.69761735,-0.58667827,-0.45365486,-0.71998006,-0.12888618,-0.12580538,-0.9697399,0.08268483,-0.5578314,1.1537242,-0.35602075,-0.3040722,-18.46516,1.8715944,0.7471474,0.98899364,0.7089498,3.4156964,-1.0260471,4.3462768,-5.485957,-0.9955126,0.10696094,-1.4900091,-0.22192779,0.12854233,-2.215591,-1.1081475,-0.49396482,0.5344376,-1.2529118,-0.21028735,-0.47059095,0.62718725,-0.23434599,-3.5704775,0.17346588,1.1257316,-0.16339584 },
  { -0.0050605144,-0.20372884,1.0376375,-1.0498838,-1.1050541,-0.47133723,0.113521114,-0.9322539,-0.5975583,-0.6077443,-0.8887003,-0.8026684,1.1486003,-0.24660178,-0.33228356,10.689408,-0.6072866,0.35104033,-5.094736,-1.5330312,-0.09921309,2.7402935,7.579313,8.900158,-0.66989076,0.1371936,-0.07672987,-0.013747445,0.4631413,-0.29580218,-0.5605628,-0.62429583,0.09506457,0.27185112,0.5384937,-0.6723027,-4.0700808,0.68330383,0.766535,-0.20028895 },
  { -0.51358235,0.6863256,-0.56041867,0.2351489,-0.42769846,0.71063524,0.10716165,-0.0943732,-1.7284899,-1.8540915,-0.33183807,-0.8751832,-1.8510383,-0.4732555,2.074346,-1.0538666,-0.2857476,-0.029299738,2.2706254,-0.48774362,1.1859521,0.41250095,0.63675934,0.8791292,0.7540758,-0.39336413,1.0381866,0.7887138,0.44370484,0.34171236,1.8767264,-1.4263846,0.32789287,-0.057557363,-0.7201971,-0.7422449,0.39180607,0.30770466,0.004346557,-0.17407899 },
  { -0.4819076,0.34175104,-0.72458535,0.927795,-3.2263849,0.987541,-1.5358053,-1.4639581,-0.55717856,0.27645013,-7.0262275,-0.38977388,0.40693596,-4.3887014,0.62597156,1.1129171,0.36257717,-5.1976905,-1.9084791,-5.778207,3.415749,-0.08188181,-1.4554714,-0.6685202,-1.4367186,0.3082974,-1.2810979,-3.3093822,-1.187753,-3.4138596,-0.086381905,-0.7197767,0.09594465,0.35262948,0.1768522,-0.23510186,-5.271693,-0.6761824,0.6954081,0.91883403 },
  { -0.17034751,2.99144,-0.773052,-3.153778,0.18185867,-1.0748711,-5.0018826,-0.08427048,0.3673418,-0.23456879,3.2915473,-0.31905174,0.72765374,1.1696128,-4.0032244,2.9993544,0.12127894,-1.1375779,8.17611,-3.9768631,-0.25854552,-1.9542826,0.7361836,1.8347212,8.334868,-0.64348716,-8.434643,2.0913727,0.5731951,-5.0379567,0.8565745,0.34604502,3.0209289,-0.11771127,-5.390815,-6.6691484,-12.969441,-3.9535465,-0.36285993,-0.5509283 },
  { 1.1598573,-0.28209716,0.09905546,-0.43760514,-5.989713,0.38124913,-0.9913205,-0.6473655,0.54002416,-1.0039514,-1.6627369,-0.37775904,1.8145622,0.9426354,-0.3514879,-2.037415,-2.0238664,-0.94676095,0.35072878,-1.8665395,0.69393164,-6.823009,-6.7303286,0.2153019,-1.3678684,0.82228297,0.39735836,0.024614502,0.70311296,-9.014765,-1.9665393,-0.8851576,-0.06464349,-0.39272952,-0.45834348,-0.94382286,-19.244923,0.05153095,0.73984456,1.1319616 },
  { -0.25283697,-0.49420378,-0.08167268,0.9031807,0.16819935,-0.3947191,0.01387718,-1.4740015,-1.0313387,0.08053881,-0.74904364,-0.58882964,1.9188793,0.4327222,0.13682057,-1.9063511,0.28900635,-0.3025175,-1.7016878,-2.5410743,0.8478579,-0.80768996,7.4056773,-2.4461415,2.0559752,1.0506624,0.26445124,-1.1217402,0.13270584,0.95315045,-0.4635527,-1.3971958,0.26629034,0.5459028,0.17954631,-0.56638324,-3.3585174,1.0240128,0.26092994,-0.06797067 },
  { 0.8274232,0.22154772,0.63647217,0.23584554,-0.7654737,-0.65885884,0.6922713,-0.51842904,-1.6970742,-0.6970169,-1.5896451,-0.5034857,0.08428427,0.14303166,0.29347044,-0.4998752,-0.17221004,0.16434303,2.6632051,-1.3471758,1.5901219,1.914862,-2.339123,3.6028981,1.6050915,0.66620433,0.42700136,-1.6093812,-0.025032885,-1.9828774,0.20985435,-0.0040411837,-0.31666738,-0.54566395,-0.034317024,-0.26706946,-3.495388,0.32249644,0.38418007,-0.058459688 },
  { 0.90990156,-0.061392877,0.2926743,0.118982024,0.5482051,-0.2379539,-1.585895,-0.5905821,-0.16002758,-0.51659083,1.442972,-0.49835327,-0.5674025,-1.5467027,0.57585466,11.643839,-0.2922627,0.81898785,5.9890027,-1.0751039,2.064862,2.8049366,1.0077827,10.003885,6.215694,1.1406018,0.20850645,-0.4573049,-0.7284408,-2.8465338,0.9889287,-0.46689853,-0.65383506,-1.2180101,0.2630033,-0.182726,-1.6804954,-1.5955583,0.28663853,0.48902857 },
  { 0.61012936,-0.20179433,0.12590802,-0.21664779,-1.0573467,-2.601887,0.062581435,-0.599001,-0.00084554264,-1.5925026,-1.540365,-0.38136476,-0.2025894,-0.23452443,0.1760234,1.5079676,-0.5458924,-0.28109443,-5.05547,-4.7801175,2.4623754,1.7386928,0.23538668,5.597076,-0.41788247,0.73700005,-0.44294956,-0.8322768,0.5909414,-1.268032,1.1552675,1.2092026,-0.59464264,-0.73554033,-0.5719038,-1.2361859,-1.6912658,0.9559021,1.2003325,0.24777737 },
  { -1.4368178,0.6801183,1.010079,-2.0420394,-0.46196958,0.7684974,0.382215,-0.5650937,-0.56645167,-0.11686882,-0.5497043,-0.6808784,1.3966562,0.6333313,1.6793364,-0.9163863,-0.5938037,0.07305363,3.8862765,-0.8239393,-0.5414741,2.1139255,-2.7297034,1.0943303,0.6236336,0.56548965,-0.29599276,-1.2722648,-0.7160641,-0.545034,-1.0846673,-0.39590946,0.5053082,-0.12955378,-2.7131329,-1.3181711,-1.4144247,0.7651545,0.646486,0.5107442 },
  { 0.04508941,-0.6783164,0.041601922,0.60201794,-1.4905243,0.07648171,-2.0845246,-0.94375294,-0.25530595,-0.46872583,-0.34924293,-0.3640795,0.53050286,-0.8706006,-0.8963359,0.86250186,-0.40643778,-5.8370266,3.1834664,-1.0446653,0.09152276,-0.32977024,-0.32988065,3.0880277,-0.41812363,0.50811386,-0.8547785,-0.8001843,-0.29334238,-1.0038147,0.0044810777,-0.52619433,0.77611667,0.10856225,-0.36120746,-0.17422484,-18.104155,0.34698188,0.6570936,0.19930972 },
  { -11.267536,0.23160295,0.44950527,1.373775,-0.5934826,0.01274079,-0.4277185,-0.46671402,-0.089720644,0.35267898,-0.71713454,-0.4470488,0.9232248,1.0649242,-0.27246895,-1.7325132,-1.0267738,0.26278445,0.99273455,-0.5971845,3.5727425,2.6723063,-1.4691538,1.2807357,-0.14196786,-0.8330015,-0.25928515,-0.21763222,0.34350044,-3.6869783,-0.421861,-0.7166276,-3.6818614,-0.6243483,0.12852763,0.14939532,-5.6869783,-1.4066664,0.62619436,0.13597901 },
  { -0.9276714,-0.26971006,0.87040293,-1.1022674,0.12620544,0.64624625,0.12629841,-0.3654239,-0.2217571,0.033898357,0.58761305,0.051124796,-0.17746606,0.46937284,1.0561106,-1.6504657,0.08664001,-1.0543172,1.9557061,0.0032631855,2.1543398,1.4180812,-1.0769051,-1.8005801,13.848619,-1.7171669,-3.5815613,0.13603729,-0.24562883,-0.5856385,2.2312133,0.057988346,0.8059267,-3.0406218,-3.7913022,-1.5783408,0.43053216,-0.7663135,0.097028926,-0.09440328 },
  { -0.28206825,1.8686167,0.0831205,0.66718704,-0.17522828,-0.24663009,0.6300704,-1.8989613,-0.8470821,0.37858507,0.21333128,-0.35699785,-0.18861602,1.044566,-1.7564063,4.3229957,0.7315091,0.2246463,3.7837732,-3.6384244,1.5909468,-0.6024323,0.3448876,6.7513494,2.415377,0.8449202,-1.4582204,-1.8753573,-0.7218126,-0.91687614,0.01985228,0.39642113,0.35467067,0.51179993,-1.6238377,-1.8380164,-4.0569124,-0.44139853,0.8587247,-0.17082602 },
  { 2.4134603,-0.35457838,1.2230513,-3.1747892,0.38508487,0.14877445,-1.3147681,-0.42266336,-0.30345553,-0.97755384,-2.1449454,-1.2350147,0.9506366,1.4994863,1.6901356,-8.930181,-0.7714533,-0.67272985,-2.897032,-1.7486464,1.1501353,1.7876893,1.7692533,-3.0854669,-0.80727106,0.020938149,0.5934087,0.7964274,0.7324911,-0.48283076,0.52904457,-0.04611662,-1.1987003,-0.33806595,0.043137785,-0.7978091,-7.078278,-1.3116717,-0.32110658,1.0134671 },
  { -3.3916075,0.9436131,-0.039247926,0.17018956,0.054581963,0.72625494,-0.044500027,-0.60213816,-1.2029892,0.45771942,0.47791797,-0.23675874,-1.124151,-1.9387172,-2.412111,-5.0873427,1.1101177,0.04177186,-4.2890773,-0.7947649,-0.33970943,0.0505886,0.760773,-3.156159,-1.3372835,0.58122,-0.06819621,1.2965484,-1.6414708,-1.4037727,-0.22929798,0.12826267,0.07499218,-0.07062067,-0.09597037,-0.31930754,-0.83112264,-0.94998884,0.34944272,-0.7183796 },
  { 0.06968526,-0.7163491,0.30980003,0.33274576,-6.0339355,-0.048326988,-0.45991793,-1.6090875,-0.19279128,-0.93775725,-0.40910992,-0.49189293,1.8128234,-2.7665107,1.0167863,-9.108716,-0.559173,-1.7321904,2.1485465,-5.5330396,2.466382,-2.7354834,-7.887745,4.563183,2.2555516,0.96278536,-1.4366964,-0.15551518,-0.2706004,-4.178251,-3.0761619,-1.8286272,1.6274515,-0.7493957,-1.3731003,-1.8610163,-4.635402,0.59505326,1.222435,0.3945522 } 
};

double h3_out[49][40] = {
  { -0.456714,-0.54715496,2.8090281,-0.5941978,0.36690995,-1.4065447,0.3157462,-3.4493277,-3.6816108,-6.0418377,-0.50654596,0.025966045,-2.322806,0.47866374,-2.7833242,-0.3050297,-1.7747442,-2.9419928,0.8684149,-3.4245458,-0.7398909,1.3876408,-1.034578,-2.9741175,-2.9305072,-0.26827303,-6.4402194,-1.9472364,0.4176709,-0.29670995,0.36933827,1.1539487,-1.3326887,2.54319,1.4686425,-1.6113627,-0.76385283,-3.1852012,-2.9909806,1.1803348 },
  { 0.77208084,0.16811492,-0.4508634,-1.5069418,0.2763836,-0.51358485,0.10660908,-3.5431828,-3.0787632,-4.653157,-0.40228805,-2.3835158,-5.2930374,-0.049536183,-0.6272092,0.39490467,-0.5327335,-0.5009121,2.3616815,-2.1049979,-1.375826,2.3747814,0.48210534,-1.6362815,-2.1446033,-1.5684917,-4.68004,1.0061218,-0.20991233,-0.39443114,0.4690851,2.012267,-2.4052043,-0.6376552,1.6236191,-1.3879467,-5.718231,-2.8427143,-2.2687573,0.31125575 },
  { -0.44672012,0.72795135,-1.3576742,-1.677205,-0.18816112,-0.504998,0.82483643,-4.1559887,-0.7253843,-0.73536426,-3.7079568,-3.1969664,-7.259042,1.3201582,-0.90999913,-0.3861167,-1.491948,0.101439364,2.5285175,-0.5041527,-0.8411191,1.1043836,-0.18654661,0.5780217,-1.8305657,-7.7313614,-6.5819435,1.4467297,-2.6664143,-0.5897278,-0.16760084,0.08542676,-2.7733269,-1.5822189,1.1677557,-1.1351049,-2.3819923,1.2562308,-2.760542,-2.1726053 },
  { 0.21107405,-0.8503641,0.300463,-0.7796691,-2.667346,0.11730484,0.5500692,-1.5993001,-0.38893613,-0.08347972,-5.461875,-3.6190848,2.311678,0.8633357,-4.172642,-1.9780439,-1.2224394,0.9258207,0.7632484,-11.610064,-0.19558907,0.15740983,-2.604781,0.1289271,0.024480022,-3.5559897,-0.6486613,1.074571,-6.077387,-1.4356624,1.0800835,-0.7704291,-1.285036,4.380856,0.40397015,0.1304481,0.87519544,2.7816744,-1.1359681,-5.3334556 },
  { -2.0122054,-2.4425917,-2.0037968,-2.1931472,-0.19771113,-0.5006045,-0.17146847,1.2764753,0.90407616,0.28746986,-0.9160175,-1.4789107,-3.6697993,-1.2553492,-2.0221364,0.5369002,0.48486012,-0.7201478,0.2989031,-3.8270233,-0.8896399,-0.88592815,-3.9172895,0.9408523,0.9753251,-8.438996,-4.065664,-1.7991542,-1.538997,-2.2189884,-0.14059737,-1.527515,-2.3306081,-7.268583,1.431993,-1.206462,0.22424482,3.3107517,-0.8413259,-5.2705235 },
  { -1.5722004,-1.254446,-1.5303454,-2.8620117,-0.45852175,-1.0729148,-1.5837601,1.2275074,1.0408465,1.1427879,-1.717526,-1.7683394,-3.5688128,-2.0014014,-4.4047513,-0.501023,0.82948524,-1.5236108,-0.20232488,1.9979851,-1.0571487,-0.8452034,-2.9923425,-0.39780605,0.8019071,-8.945897,-3.910496,-3.2215517,-0.27464366,-2.6989205,0.38084355,-1.3741872,-1.6074445,-7.63833,1.3462027,-1.4389527,-0.2668479,0.46787044,1.0591496,-5.0995517 },
  { -1.8642234,0.052780185,-0.06944658,-2.088521,-0.44195196,-2.1043003,-1.2435373,0.67712593,-0.022615492,-0.69324535,-1.5177977,-2.4292784,1.8946632,-2.0632977,-5.205057,-2.9149327,-0.03174488,0.8913895,0.61987764,2.6054566,-1.3288691,0.3474652,-2.5869904,-1.7268153,0.07347394,-6.0422254,-3.425079,-2.7078066,-1.786576,-1.0108206,-1.0645972,-1.9839786,-0.21661168,-7.2204213,0.49021047,-1.2802262,-0.8940914,-2.611262,1.1778095,-3.607251 },
  { -1.86835,-2.1473706,-1.9777454,0.43247896,0.0682213,-0.919598,-0.837604,-1.366933,-2.982766,-1.1266638,0.44623494,0.43207648,-4.17262,0.20578639,-3.4735363,-0.392308,-2.3537838,-0.8152587,-2.0921392,-2.2503777,-0.61151135,-0.26167482,-1.883569,-1.2813507,-1.0454181,0.4983655,-6.521055,-7.2495646,0.2920361,0.36055523,-1.4517827,2.7879071,-1.0330039,0.7373825,0.7611816,-1.3282939,0.778163,-2.9443877,-2.2765076,0.5234572 },
  { -0.19095746,-0.3316991,-4.146247,0.015234634,0.6060249,-0.24037962,-0.265606,-1.3785678,-2.005076,-3.68902,0.55583704,-1.081086,-6.5111904,0.31591153,-2.157661,-0.8462622,-0.9305187,1.2538338,0.83874154,-0.48623407,-0.5644663,1.3963175,0.47086367,-0.049814597,-1.8074253,-0.46752518,-2.4972057,-2.0764828,0.40230593,-0.53092426,0.56625444,2.5628104,-2.4599226,0.58543646,1.6744763,-0.67159176,-1.7277449,-3.5667548,-2.9879346,0.92864853 },
  { 0.02316755,0.61953676,-2.6489146,-0.30536738,-1.2921354,-0.015806966,0.1677051,-1.9728531,0.11553691,-3.082112,-1.1385098,-2.1469216,-9.234799,1.188733,-1.7827185,0.42976242,-1.9789879,1.2696729,2.053559,-0.6419462,-0.5791901,0.26410663,0.22420952,1.533202,-1.9265137,-5.298668,-5.721698,0.98367816,-0.6436736,-0.49546197,-0.8426539,1.1476572,-1.7486522,-1.5589099,0.9463534,-1.5705848,-2.218603,-0.9286625,-3.250341,-0.60292757 },
  { -0.183178,0.4811091,-3.1333914,-0.6500036,-1.4160764,-0.004353827,0.51081884,-0.00085117156,0.13677436,-0.16574249,-2.9386256,-1.9313127,-1.903872,1.4232638,-2.821578,1.2171959,-1.2485801,0.85314065,0.567872,-2.399451,-0.7250892,-0.8217992,-0.9675292,2.4734561,-0.08816725,-8.785652,2.5074644,1.2739415,-3.5177653,-1.6818312,1.4018323,-0.6341009,-1.5756567,-1.9876224,0.7522465,0.4990015,-0.14596274,2.5195527,-1.3284781,-3.253535 },
  { -1.4184914,-0.11829158,-2.1182597,-1.3645277,-0.8227498,-0.27860972,-0.7496955,0.81482,1.2854332,0.44910708,-0.60370016,-1.5382752,-4.1579566,0.6602389,-3.201456,1.6957432,1.3079259,0.4943375,-0.22074713,-0.442722,-1.0923496,-1.8441685,-1.6094052,1.737863,-0.25578403,-8.442327,-3.686667,-1.4966246,-3.0869305,-2.0301132,-1.1817888,-0.71218675,-0.8074764,-8.895925,0.34818333,-0.91479504,-1.0029045,0.9877946,0.2593833,-1.405763 },
  { -0.18111329,-0.110296525,-0.5620362,-1.1723931,-0.08834902,-1.0157201,-2.1366136,0.3775956,1.2533771,0.0442414,-3.0688477,-0.61561596,-2.5652428,-0.83687913,-4.4619107,0.8498592,1.4176292,0.6039809,-1.4420632,2.3659291,-0.9907404,-0.19019808,-0.39076218,0.4974008,0.062677175,-10.090425,-0.16499966,-0.9994986,-2.5254786,-2.6545808,-0.31136113,-0.6211316,-0.20422362,-9.711184,0.63191944,-0.32575032,-1.919874,-2.073924,1.0076292,-2.9063704 },
  { -0.039130077,0.54492044,-0.10924589,-0.6662102,-1.1221972,-1.8232988,-2.4679565,-0.5444041,0.7672015,-1.3582313,-2.311923,0.025204485,3.8019724,-1.6099888,-2.944393,-1.4148616,-0.1516141,-0.7125257,-1.0959733,3.9863422,-1.7942941,-0.6358125,0.639065,-0.1219375,-1.2087203,-6.2711363,-3.5103035,-1.5858686,-2.1335306,-2.5777898,-2.3865116,-1.8164779,0.80476284,-8.564479,-0.25754136,-0.5488675,-1.4527485,-3.038114,1.6430099,-3.0171502 },
  { -0.9046294,-2.0347285,-1.452453,0.27000615,0.5834271,-0.9151054,-0.8294718,-0.58207583,-2.5826943,-0.8497265,-0.25379372,-1.202963,-5.4138703,-2.4041314,-4.123092,-1.0907997,-2.5895712,-1.284851,-1.8549064,-2.7730043,-1.0587788,0.484285,-2.097643,-1.2832419,-2.2559829,4.7659216,-3.991761,-6.874719,-0.56341255,0.5728118,-0.31816965,1.5276998,0.58991486,-3.1747315,0.5089211,-0.95045716,1.9847744,-2.7953076,-0.8230329,-2.8419201 },
  { -0.63081014,-2.2384593,-4.1770453,-0.35660782,1.1813222,0.26016524,-0.8144155,-1.088233,-0.879695,-1.0204611,-0.29029018,-1.0944219,-7.161224,-2.0658762,-2.9800332,-1.082147,-0.86522675,0.034087017,0.74061114,-2.7084768,-0.1771211,0.7296267,0.35265857,0.46289498,-1.9394358,2.8546238,-4.596951,-5.0033846,0.42492986,0.23426256,-1.5185649,1.8045107,-0.39802727,-0.21412489,0.9270471,-0.8897521,0.33551884,-2.7288618,-0.7347849,-0.5312472 },
  { -0.22359794,0.17236938,-2.036768,0.17843677,0.10127776,0.35281605,0.23460285,0.42229584,0.22643234,-1.761019,-0.04088277,-0.67405474,-4.9162498,-0.2223994,-3.2859724,-0.37805647,-3.5616412,-0.19679707,1.164931,-1.9674252,-0.27471703,-0.9975171,0.5614852,1.3291769,-1.1672912,-1.3599081,-3.9120436,-1.8328396,0.4579472,0.8119313,-0.36061636,0.72981036,0.09896347,0.54392,1.0097278,-0.9764884,-1.0741065,-2.3986623,-1.8456565,0.55074364 },
  { 0.26942486,0.6783466,-1.5911754,-0.1816654,-0.56595534,0.2237737,0.5016883,0.42048404,0.7549533,-0.06517748,-2.512172,-0.15030813,2.037675,0.57967025,-4.3841743,-0.75049734,-0.77258617,-0.214728,0.050980967,-3.6002011,-1.0977182,-2.1942072,-1.2329457,1.4281379,0.59875935,-3.4121552,0.31013042,0.8943552,-0.19271393,0.4894442,1.1590495,0.17523769,0.42104092,-0.14777735,-0.36227784,-0.028652247,-1.9216238,0.6523662,0.06784156,-0.75914603 },
  { -0.6502229,0.67141813,-0.07981962,-0.53062505,-0.17085265,-0.017891372,-0.5925561,-0.026418908,0.9274803,0.67404264,-3.4354863,-0.18868017,-0.7074674,1.4188849,-3.112676,1.6427144,1.0729052,-0.58745176,-2.1972759,0.35279816,-0.9793084,-0.86984956,-2.0563822,0.77137285,0.66170484,-6.1572943,-3.2564642,0.8699919,-1.5936055,0.111320674,-0.1608352,-0.873434,0.5798024,-6.900477,-1.1347376,-0.48950875,-1.2751985,-0.15205146,-0.04493837,-3.1745138 },
  { -0.44262832,-0.19840775,0.9275841,-0.03295044,-1.5889472,-0.47915205,-2.1246805,-1.3598404,0.3729312,0.18777117,-1.9263611,-1.0507118,-0.38481593,0.70668733,-2.6695573,2.094919,1.6709975,-1.6463982,-1.2380382,1.7970625,-0.5377217,-0.03927306,-1.6611937,-0.9361417,-0.8660584,-9.718056,-2.069346,-1.0189177,-2.8974829,-0.6123123,-0.65855616,-0.49660155,0.9717621,-7.268298,0.028005622,-0.611154,-1.4367855,-1.4807484,-0.17095949,-3.267351 },
  { -0.89824164,-0.8469207,0.6365006,-0.15429364,-3.830026,-1.237443,-1.7390544,-3.0237646,-0.5465387,-1.1604193,-0.81516695,-0.6404637,3.2684581,1.133304,-0.38933048,-0.7339298,0.8214045,-1.942521,-0.5638334,2.8281827,-1.4908937,-0.42142618,-0.16475742,-0.85122025,-1.6711686,-6.7000484,-2.1534975,-2.1334176,-2.717014,-0.61063105,-1.393376,-1.7111583,1.4175826,-7.6140285,-0.8800113,-0.058042932,-0.5986126,-1.2723707,0.046604812,-5.1139197 },
  { -0.38949051,-3.695979,-0.11070682,0.8421784,-0.15556923,-0.14178972,-0.20290041,0.081694014,0.40369993,-3.654823,-1.6648535,-5.3368206,2.5129433,-1.7974865,-0.42127478,3.996207,-3.8771973,1.3894418,0.49342093,-0.26144478,0.04920964,-4.560732,-2.9195778,0.16332501,-0.6737155,4.355096,-2.5136926,-9.967603,-2.5028176,0.7296354,-1.2398599,-0.7197092,0.32456788,2.5987635,-3.5009522,1.0547146,0.85350573,-2.6670423,0.11837618,0.8042243 },
  { -0.064925484,-4.294976,-2.3346663,0.74463415,0.9838229,0.31830645,-0.9642095,0.022127125,0.049152125,-0.38777786,-0.70450795,0.048074327,-0.4185867,-3.1224072,-0.64964795,-0.55343056,-2.6706138,1.3278768,0.71225494,0.46411923,-0.35879275,-4.333333,0.4196057,0.67836934,-1.01599,4.7807846,2.3691354,-7.21995,-0.5631552,0.6646771,-1.4494482,-0.45794722,0.19685304,-2.432694,-0.6389205,1.01603,0.95166916,-0.077391766,0.4249584,-5.5830793 },
  { -1.2529448,-0.3264385,-0.25281963,0.631523,0.41970697,0.3404276,0.30648515,1.0341964,0.41312715,-1.8121337,-0.30472398,0.6615214,1.3836217,-2.0123324,-0.48143473,1.401976,-3.44118,0.5203766,0.7785364,0.6342183,0.31069756,-5.806073,0.5188586,0.5360656,0.49753353,2.6728308,-4.0327373,-8.235914,0.36779982,0.81927955,-2.055725,-0.43236682,0.2598425,0.3058931,-1.5892593,0.88494474,0.38884953,-1.2271929,-0.16687277,-0.12022104 },
  { 0.358997,0.33952957,0.089033335,-0.70067006,-1.6242356,0.1594946,0.4898874,0.3789143,0.8875141,-1.0064799,-1.4014864,0.9159409,4.390573,-1.2187092,-0.529848,-2.781715,-0.21372317,0.69720817,-0.7165871,0.3885411,0.45845708,-3.6574252,-0.3292735,-0.6019713,0.8923087,-1.0991597,13.136192,-0.37533295,0.44111276,0.6892889,1.219686,0.1924411,0.14476049,4.200206,-3.3259454,1.034766,0.35970035,0.18005016,-1.6416225,1.0179237 },
  { 0.35282078,0.5280569,0.23869576,0.7576532,-3.1906657,0.2149599,0.0011430951,-0.558027,0.5740156,0.7269454,-1.5120912,-0.08104416,0.22435908,0.6894107,0.00211547,0.6458321,0.5528204,-0.12237871,-1.539642,0.35173842,0.40186006,-0.8305373,-1.2859511,-0.6215698,0.4731789,-2.8992648,-1.3985481,0.7773345,0.051651776,0.50381345,-2.6043212,-0.14788353,0.32711846,-2.9040918,-4.354086,0.8451793,-0.09471909,1.5761582,-0.31453055,-0.45406154 },
  { 0.35940808,-0.9296494,-1.3030088,0.77369535,-3.13326,-0.23497976,-1.4729546,-1.4474496,-0.1981586,-0.5512506,-0.5864241,-2.8812425,-1.2899705,1.884476,0.2955783,2.7073855,1.3425324,-0.6145951,0.89362097,0.48437196,0.28464118,0.021160997,-0.31520313,-2.6132097,-1.1052098,-8.927402,1.6453861,0.3029987,-1.0164909,0.2893866,-0.043414615,-0.5635195,0.44184673,-2.7701166,-1.7974743,0.9052271,0.277654,0.6781948,-0.8082811,-5.4933214 },
  { 0.8302285,-3.1972413,-1.6770011,0.95066684,-3.9504166,-0.30375794,-1.2833982,-0.9707496,-0.09439389,-0.4686181,-1.6733009,-4.913801,2.1928422,2.0377493,-0.19524366,-4.7711067,-0.00989402,0.9714491,-0.40771592,1.4227551,0.29942155,1.6452613,-1.2058152,-2.1955333,-1.1936178,1.0145457,0.9246445,-1.8182393,-1.856863,0.4180031,-2.0339396,-0.32229233,0.38437977,-1.4998153,-8.4434595,0.8835996,0.42244184,3.7618294,-0.96285546,-3.3504286 },
  { -1.1501496,-1.1915987,-0.60396373,-0.75040144,0.70819265,-0.35133553,-1.7233359,-0.91219395,-0.6434284,-0.91954005,-0.48438165,-0.003556943,2.4592838,-3.3999002,0.65434134,-0.99862546,-3.9193475,2.7199304,-1.2650849,-2.0362408,-0.6626855,-1.3974658,-1.4682294,-0.1043376,-1.6492827,-1.5466528,-4.4834013,-5.6305456,-1.6472014,-0.5498518,-3.0157602,-2.1172729,0.59969276,-8.704858,0.89277077,-0.7829741,0.30009922,-2.3928516,0.5384617,-4.124043 },
  { -0.8293013,-0.5422998,-0.59181726,-0.980271,0.138993,0.3601836,-1.6265519,1.2879602,-0.56167454,-1.3801575,-0.4758529,0.9960224,-0.72932255,-3.270163,-0.42519578,-1.4793793,-1.5986092,1.730581,-0.29501164,-2.8645475,-0.47316796,-0.9627829,0.6930879,-0.9923378,-1.4635556,2.98557,-1.7893069,-3.8821695,-1.775333,-1.4168749,-2.4665828,-1.3076395,0.33797604,-7.8114758,1.3969655,-0.65256935,0.49693662,-2.5541456,1.3648369,-6.957008 },
  { -2.0586386,0.34891158,0.38355672,-0.8524992,-0.0963327,0.19951095,-0.1844282,1.3232837,-0.4693488,-2.201872,0.6289619,1.3140532,-1.8894045,-1.2130593,0.5447553,-1.7499136,-0.9470715,-0.6871496,0.13748623,-1.0637472,0.19403477,-1.3134079,1.0875511,-1.2125192,0.79341674,4.44612,-4.0247555,-4.0849433,-0.6204452,-0.62731737,-0.19156368,-1.5129198,-0.3708914,-3.8059132,0.8689871,-0.6277528,0.5302596,-2.2466218,0.8896333,-5.7755146 },
  { -0.35467356,0.37325856,0.10133081,-0.6504383,-0.17897666,-0.024192713,0.4932046,-0.7154208,0.03556698,-0.20374632,0.26080862,0.967031,0.59710854,-2.216151,-0.53791547,-2.1975336,0.34656537,-2.309046,-0.83808947,-1.0635073,0.58375925,1.638267,0.67224026,-3.0175834,1.1399766,2.0415876,-2.6083612,-4.363355,0.4497709,-0.077483304,1.432556,-0.4141331,-0.53551716,1.953024,-0.46809486,-0.033235136,0.033343736,-0.25183067,0.22897366,-0.5809399 },
  { 0.7345958,0.7331996,-1.3187506,0.09731359,-0.6897694,-0.3485931,0.43920264,-1.9614364,-0.015241213,0.86118263,-0.15701291,0.120063975,-5.9841676,-1.9767928,-0.5796038,0.026558563,0.32379678,-2.4725525,-1.8890684,-0.823735,0.8390622,2.1502059,-1.2854372,-0.9122972,0.35095352,-3.7634113,-5.448702,0.34665233,0.41601893,0.19578692,-0.80908394,-0.6973837,-1.0401982,1.0884814,0.1723432,-0.6141568,0.020184556,-1.3587701,0.30833477,1.1588298 },
  { 1.5497084,0.23888147,-2.0483594,-0.011961699,-2.075058,-0.7738967,-0.6850127,-2.1103578,-1.5602857,-0.5230105,0.15939386,-1.9584163,-7.9422092,0.8495916,-2.1900563,1.7703694,0.4896039,-0.77418935,-1.2992727,-1.04423,0.7808386,0.028395977,-3.0991054,-2.8958576,-1.7048644,-7.3287134,-4.1678824,1.3137156,0.06324889,-0.8599422,-1.0822822,-0.8490707,0.044133488,-2.4907405,0.8029305,-1.1602783,-0.031916395,-1.0581619,-0.70114774,-0.57818484 },
  { 0.8908048,-0.9253303,-2.4907172,0.24246924,-2.3288403,-1.3102968,-1.2525654,-1.6453539,-3.14666,-1.6600139,-0.09077043,-2.2630212,-6.8001513,2.0890014,-2.772909,-0.12959847,-0.4494396,-1.5013027,-0.9923536,-1.1562731,0.36106554,-1.3925811,-3.604355,-2.950969,-2.7339032,-7.413312,-4.2591076,0.1267823,-0.4413776,-0.72757274,-0.18300769,-1.6850775,1.0468867,-6.0033994,-1.3842145,-1.1036543,1.4965807,0.80813843,-0.6926389,-2.4953568 },
  { -1.0303345,0.62941206,0.19696364,-1.1986076,-0.45707515,-0.56024206,-2.5633416,1.591285,-1.2541775,-3.3180017,-0.18126556,0.72427267,2.124474,-2.5594587,0.27638692,-2.156866,-2.0046265,2.5854802,-1.2613759,-1.3142902,-1.301529,2.2944837,-1.3533318,-2.0587413,-2.4407954,-6.4009395,-3.4655628,-5.8308153,-1.4050654,-2.6935375,-2.8144412,-2.1264453,0.13003485,-7.021784,0.34454226,-1.052655,-0.5427045,-3.254995,2.066219,-4.085007 },
  { -0.6711516,0.17488998,0.6654944,-1.2729136,-1.1411955,0.27940488,-2.153042,2.1079826,-0.6683667,-3.6205826,0.62523454,0.89842606,-2.9037116,-2.918258,0.14366148,-1.6972662,-0.5576602,0.46989593,-1.4652236,-1.0520965,-0.86547357,1.0619645,0.9092837,-1.1077069,-0.8044655,-0.6165392,-0.31075215,-4.3897486,-0.6604729,-2.7352977,-0.23445615,-1.0505594,-1.3571146,-8.230615,0.9549478,-0.5141687,-0.44544685,-1.7684349,1.9381142,-7.3595243 },
  { -1.556352,-1.4427136,1.8844032,-0.754632,-1.5967752,0.1413723,-0.911616,0.8004331,-1.1689883,-1.868977,0.85665977,0.98831755,-4.2497835,-3.446054,-1.0911446,-1.2356898,-0.10726381,-1.9461237,-0.7941727,-1.0425789,0.059503783,2.468484,1.315134,-0.45004335,0.8179571,3.4660802,-2.1088207,-3.5936835,-0.9025511,-2.1937668,-0.7436514,-1.4457542,-1.7820241,-5.4157305,0.58649886,-0.93710685,-0.49930635,-1.8468179,1.471969,-8.070606 },
  { -0.79824615,-2.7748582,1.3089318,-0.56713724,-0.036896985,-0.44866017,0.41136667,-2.1861317,-0.90346956,0.17105842,0.9975186,0.39951077,-2.502061,-2.6818666,-1.9866245,-1.0474625,0.17273769,-0.91438043,-0.8460511,-1.3758307,0.22100979,2.9943125,0.83718574,-1.2973392,1.1592755,5.084577,2.8848767,-4.6355724,-1.0894226,-1.6007699,1.9324299,-0.12165132,-2.156667,0.41094816,0.81875354,0.40776566,-0.53545415,-0.022183195,0.5631047,-7.218017 },
  { 0.61795837,-0.908246,-0.11586962,-0.74221563,0.08337665,-0.8471966,0.38761026,-2.8339,-1.1860368,1.2446462,0.96610165,0.32338658,-8.99141,-4.6586723,-1.44424,-0.15996113,-0.506549,-0.972117,-3.359176,-1.5733993,0.8467161,0.68911916,-0.648862,1.1029224,-0.40106818,2.4181201,-5.706159,-3.3724747,0.47622657,-1.647114,-2.101359,-0.60389346,-2.2532377,1.7131081,1.3776337,-1.163158,-0.20869516,-0.91462374,0.25007164,-0.12338909 },
  { 1.4500471,0.68841547,-2.8474221,-0.32102233,-0.35675192,-1.6940062,0.017818907,-1.2991639,-2.7160203,0.15685374,0.9689438,-0.66072255,-7.3728824,-2.392555,-3.0499117,1.6634173,-0.8823563,0.44443154,-3.2075412,-1.0302877,0.70609695,-0.09802412,-4.037303,-0.05708574,-1.7185714,-1.6131971,-3.9580398,0.72263384,0.42543644,-1.2547178,-1.3974426,-0.4026508,-2.1166008,0.3524626,1.9034201,-0.6395973,0.30522156,-0.020794842,-0.16375029,1.9022295 },
  { 1.829789,-0.6731804,-2.217962,0.39412346,-1.3739383,-1.9805357,-0.29582727,-0.9054683,-3.140488,-2.4334948,-0.30795383,-0.9176412,-7.4378247,0.587879,-3.4690387,-0.0019677521,-1.3194982,-0.90803087,-3.2901456,-0.3040044,0.40476874,-1.5275227,-4.35196,-1.6289761,-3.1557493,-4.9641995,-3.6378653,0.611063,0.54484123,-1.4549831,-1.0706606,-1.1436691,0.04932195,-3.4801974,-0.41646913,-1.5163909,0.9872523,-1.5072917,0.48785827,0.97697276 },
  { -1.1998534,-0.00059639144,0.8596464,-1.6028614,0.39719072,-0.81098837,-1.6332282,2.782749,-1.3395884,-3.518955,0.038902793,0.014558598,2.9859266,-2.3811045,-0.975512,0.13785559,-1.4928092,0.061463945,0.2749692,-0.19495623,-1.5679783,1.5738189,-2.2688231,-5.1902504,-0.74798954,-5.208642,-4.6518054,-7.100741,0.3675055,-1.3566769,-1.491235,-2.33791,-0.8389885,-8.726482,0.009201227,-1.0887098,-1.2086585,-3.033928,0.78813934,-2.7532437 },
  { -1.9161757,-0.7218366,1.5335207,-1.445302,-1.0598397,0.20029072,-2.237822,2.4616783,-1.4523894,-3.6853478,0.38541034,-0.74894786,-3.6365404,-3.4962993,-2.8524086,-0.9743036,-0.53703535,-1.934255,-0.41716638,-0.8270084,-1.0980793,2.422828,0.9619662,-2.4676867,-0.07144496,-5.513907,-4.7538977,-5.8991766,-0.9377792,-1.8121825,1.3529117,-1.3085301,-1.8185506,-9.795767,0.47609022,-1.3567116,-0.6702521,-1.0805969,0.9179465,-3.0815563 },
  { -2.0046248,-3.818665,1.7843124,-1.069765,-1.3008068,-0.041690458,-0.90307313,1.0442961,-1.0655146,-1.3632268,-0.13760683,-0.6371109,-3.8676784,-3.2963848,-2.9507265,0.22575763,-0.084079646,-3.6743243,-0.0042657843,-2.2192783,-0.4793542,5.131173,1.5230818,-1.1915582,1.2280753,-1.0748073,-4.978465,-4.269135,-0.89940554,-1.4058188,0.68737507,-1.4689472,-2.826176,-7.3426747,-0.09857259,-1.1354684,-0.34917766,-0.75880045,0.29906145,-3.9236143 },
  { 0.03669002,-2.3020146,1.2693174,-1.4005336,0.004790169,-0.20195404,0.025605364,-2.4763207,-0.268571,0.4653145,-0.56900805,-4.339677,0.9349904,0.81914085,-4.737147,-3.0639913,-0.5862152,-0.74322265,0.49018517,-1.3576957,0.41586477,2.5924745,0.2905875,-3.8456845,0.2695076,6.2633348,-3.3080091,-5.1476207,-8.053515,-0.3289116,1.954132,0.07163572,-0.9015092,-0.4761532,0.06905312,0.14806771,-0.4291701,0.033088326,-1.1568277,2.4827538 },
  { -0.059630256,-1.8887305,0.8827842,-1.5049288,0.25699592,-0.92619354,0.57016957,-4.217679,-1.1249921,1.7277566,1.2083497,0.8029618,-6.43872,-4.4153,-1.1333779,-0.009566755,-2.7340043,-1.1766039,-1.9165136,-1.8114977,-0.026311962,-0.014374868,0.30870825,-0.33565757,-1.4077828,3.8634715,-9.450816,-4.1808043,-0.42901182,-1.0651983,0.058622956,-0.7525787,-2.1999853,2.8111765,0.7609756,-1.7816511,-1.2118791,-0.23050228,-1.1760582,-5.6318316 },
  { 1.4334874,0.13512272,-0.3311692,-1.9044445,0.76685464,-1.671321,0.24757642,-3.166899,-2.5234604,1.2826905,0.69813097,0.477005,-5.643162,-8.542487,-1.812926,1.3920997,-2.412242,-0.9783024,-4.258806,-1.2904683,0.1731706,-1.156793,-2.018008,-0.06804692,-2.1912627,0.15673546,-8.296532,0.028176816,0.5608368,-0.7084968,-0.7995989,-0.94717735,-2.0004385,2.1965134,0.88804656,-1.6970762,-1.431533,0.16076009,-0.66063225,1.2950507 },
  { 0.85339683,0.14299381,0.36332446,-0.76789755,0.49505445,-1.7930585,0.20331123,-2.2717028,-3.9029984,0.31536472,0.19225343,0.03186009,-2.9890833,-1.9950792,-3.1323607,-2.3078334,-1.8194358,-0.23986469,-3.3076217,-0.8451626,-0.17375052,-1.0145013,-4.2177434,-1.7129563,-2.9421391,-1.5456473,-7.160411,0.24226786,0.16956802,-0.7596862,-3.5590835,-0.06663959,-1.3049499,-0.04433434,-1.5400358,-1.2012058,0.28486627,1.6130672,-1.7033753,2.230756 } 
};

double b1[40] = {
  0.07534194, 0.0067797005, -0.0045424555, -0.13115442, 0.079330005, 0.026487838, 0.10977702, -0.16734038, -0.024992634, -0.050387703, 0.040137667, 0.16290623, -0.0274617, 0.059717096, 0.012662451, 0.11469916, 0.021008477, 0.019269938, 0.01556178, 0.08394084, -0.050767682, 0.037788723, 0.039997496, 0.12996602, 0.06676604, -0.07238781, 0.13195232, 0.063535295, 0.006101735, 0.07967129, -0.22704414, 0.13189974, 0.1659173, -0.27944207, -0.22555122, 0.31325963, 0.14155976, 0.082671195, 0.14157777, -0.023291117 
};

double b2[40] = {
  0.015183652, 0.088564105, 0.07671961, 0.025317786, 0.02988492, 0.056455478, 0.029746782, -0.026787277, 0.15045162, -0.0064366395, -0.023442196, 0.09067601, -0.010317268, 0.010053277, 0.024832163, -0.08861254, 0.081395194, -0.00031025434, -0.01101204, 0.031301767, 0.014384737, 0.04000708, -0.15128134, -0.0030634536, -0.010507201, 0.08023116, 0.008028346, 0.012493783, 0.03344402, 0.016619517, 0.062687546, 0.053757023, 0.020934489, -0.03132004, 0.0094315, 0.01295561, 0.004437075, 0.032859813, 0.06510537, 0.067550324 
};

double b3[40] = {
  0.22180408, 0.046031002, 0.13893403, 0.05893824, -0.011730612, 0.32145345, 0.17077428, 0.10798032, 0.1073478, 0.040647306, 0.00069566595, 0.077821724, 0.083297804, 0.050823223, 0.020850971, 0.11805462, 0.0909385, 0.15373158, 0.12577416, 0.079942465, 0.46172702, 0.06355343, 0.075400926, -0.019486396, 0.16309136, 0.071532734, 0.049605142, 0.057208702, 0.015047002, 0.054465417, 0.12053321, 0.25486323, 0.13801156, 0.12086698, 0.09780555, 0.38793558, 0.14390853, 0.1413884, 0.1446064, 0.1011544 
};

double bout[49] = {
  -0.35973328, -0.7627899, -0.689541, -0.03878343, -0.7358602, -0.92687476, -0.42726097, -1.112559, -0.4538522, -0.88778496, 0.08224709, -0.8529885, -0.5103995, -1.1037264, -0.63942236, -0.7914322, -0.18701416, 0.35370308, -0.14480187, -0.7302203, -0.78146094, -0.054282673, 0.05917022, 0.22167818, 2.2852597, 0.18941982, 0.1663005, -0.20140566, -0.78305733, -0.7886255, -0.17008743, 0.36559713, -0.18592598, -0.67109317, -0.6713313, -1.0405992, -0.5728319, -0.8957188, 0.22942272, -0.8477211, -0.42242256, -1.0896487, -0.48128793, -0.93919975, -0.72173417, 0.11432353, -0.6740375, -0.91693354, -0.578322 
};

double BN_gamma_in[9] = {
  0.24660325, 0.6797115, 0.652628, 0.658528, 0.42079353, 0.2018795, 0.59054875, 0.51794845, 0.10557282 
};

double BN_gamma_1[40] = {
  1.1005571, 1.3231599, 1.0349503, 1.2777556, 0.858232, 1.1483414, 0.8646311, 1.0772725, 0.9520973, 1.0436034, 1.0718299, 1.0500765, 0.84567803, 1.4284317, 1.3667452, 0.455183, 0.43062487, 1.0996606, 1.3465705, 0.96818763, 0.79402786, 0.94432545, 0.76641726, 1.117902, 0.9751899, 0.9802513, 1.3214303, 1.1820564, 1.2248446, 0.99004143, 0.679907, 1.1949854, 0.98248816, 0.5287536, 2.6560452, 0.6177295, 0.66191494, 0.8997601, 0.9265922, 0.7289147 
};

double BN_gamma_2[40] = {
  0.9026776, 0.7139782, 0.9347488, 1.2287049, 0.9313608, 1.0726986, 1.0734888, 1.2881067, 0.8896738, 0.9319139, 0.8406709, 0.8371545, 0.9321486, 1.1650306, 1.1044804, 0.45532072, 0.9094187, 0.84157866, 1.4335066, 1.2529867, 1.1004812, 1.1471182, 0.38583812, 0.68237734, 1.3897316, 0.88705957, 0.83461916, 0.98978186, 1.0018729, 1.0448587, 0.8613362, 1.1461585, 1.4063003, 0.78399265, 1.0006351, 1.2129438, 1.1652675, 0.76425123, 0.91878396, 1.1622217 
};

double BN_gamma_3[40] = {
  1.043359, 0.7178932, 0.8336511, 0.9649177, 0.8957939, 0.84772307, 0.86749065, 1.121426, 0.9310377, 1.2261738, 0.9305054, 1.1169248, 0.9191569, 1.0048423, 1.3692089, 1.6540956, 0.7344388, 1.0060059, 0.8588518, 0.9505845, 0.70756006, 0.8929924, 0.7672083, 1.0006113, 0.7779372, 1.2005087, 1.2861784, 0.90043014, 1.3326136, 1.1172073, 1.0616407, 0.83257884, 0.8173635, 0.81785005, 1.008697, 0.7088391, 0.95956045, 1.0507529, 0.6776846, 1.0653154 
};

double BN_beta_1[40] = {
  -0.005242121, -6.717414e-05, -0.000115963776, -0.00013234331, -0.0010378694, -0.0056065116, -0.00253636, -0.019516123, -0.016185632, -0.012112781, -0.0008509388, -0.012819291, -0.015584876, -0.00023076776, -0.0028455688, -0.011559461, -0.023618769, -0.01733201, -3.818249e-05, -0.000517987, -0.0141468765, -0.026670873, -0.04498531, -0.007814383, -0.0011331202, 0.0007442636, -0.0045483257, -0.0010071573, -0.000435101, -0.017150182, -0.011938417, -0.0046867854, -0.011834145, 0.00022634017, -4.2224296e-05, -0.002221362, -0.004578931, -7.70128e-05, -0.015857661, -0.011427897
};

double BN_beta_2[40] = {
  -0.0025961, -0.029586198, -0.02550546, -0.00047598718, -0.0064421985, -0.007053362, -0.0017999784, -0.03263965, -0.115909874, -0.00946358, -0.0037570237, -0.09871996, -0.008086727, -0.0025880986, -0.0017370178, 0.0005028043, -0.002464412, -0.00872359, -0.0016331315, -0.0050890436, -0.013706348, 0.00043145762, 0.0002238409, -0.001106421, -0.00033534406, -0.0071983836, -0.0035606085, -0.0019493406, -0.044837035, 0.0006146621, -0.004107502, 0.0005847065, -0.0030746392, -0.0033284542, -0.00022811412, -0.0018226242, -0.0016040726, -0.008047363, -0.026059909, -0.05421379
};

double BN_beta_3[40] = {
  -0.119452916, -0.013067603, -0.048280455, -0.021810703, -0.041727114, -0.15775801, -0.072252795, -0.014778215, -0.033608396, -0.009835651, -0.026190896, -0.01596854, -0.003506765, -0.015052716, 0.0066970745, -0.038229514, -0.024035612, -0.06530334, -0.047815785, -0.022845784, -0.20899558, -0.020724475, -0.015909195, -0.004205456, -0.047210608, -0.001289013, -0.01242048, -0.00445316, -0.0059900205, -0.003362425, -0.05397743, -0.1058955, -0.058405798, -0.012889294, -0.038268615, -0.15526545, -0.040719647, -0.032119587, -0.09054264, -0.0015589274
};

double relu(double x){
	if (x<0)	{	return 0; }
	else { return x; }
}

double sigmoid(double x){
	return (1 / (1 + exp(-x)));
}

//end of modification
//! \ingroup TLibEncoder
//! \{

static const TComMv s_acMvRefineH[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static const TComMv s_acMvRefineQ[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static Void offsetSubTUCBFs(TComTU &rTu, const ComponentID compID)
{
        TComDataCU *pcCU              = rTu.getCU();
  const UInt        uiTrDepth         = rTu.GetTransformDepthRel();
  const UInt        uiAbsPartIdx      = rTu.GetAbsPartIdxTU(compID);
  const UInt        partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

  //move the CBFs down a level and set the parent CBF

  UChar subTUCBF[2];
  UChar combinedSubTUCBF = 0;

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);

    subTUCBF[subTU]   = pcCU->getCbf(subTUAbsPartIdx, compID, uiTrDepth);
    combinedSubTUCBF |= subTUCBF[subTU];
  }

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);
    const UChar compositeCBF = (subTUCBF[subTU] << 1) | combinedSubTUCBF;

    pcCU->setCbfPartRange((compositeCBF << uiTrDepth), compID, subTUAbsPartIdx, partIdxesPerSubTU);
  }
}


TEncSearch::TEncSearch()
: m_puhQTTempTrIdx(NULL)
, m_pcQTTempTComYuv(NULL)
, m_pcEncCfg (NULL)
, m_pcTrQuant (NULL)
, m_pcRdCost (NULL)
, m_pcEntropyCoder (NULL)
, m_iSearchRange (0)
, m_bipredSearchRange (0)
, m_motionEstimationSearchMethod (MESEARCH_FULL)
, m_pppcRDSbacCoder (NULL)
, m_pcRDGoOnSbacCoder (NULL)
, m_pTempPel (NULL)
, m_isInitialized (false)
{
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    m_ppcQTTempCoeff[ch]                           = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]                        = NULL;
#endif
    m_puhQTTempCbf[ch]                             = NULL;
    m_phQTTempCrossComponentPredictionAlpha[ch]    = NULL;
    m_pSharedPredTransformSkip[ch]                 = NULL;
    m_pcQTTempTUCoeff[ch]                          = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = NULL;
#endif
    m_puhQTTempTransformSkipFlag[ch]               = NULL;
  }

  for (Int i=0; i<MAX_NUM_REF_LIST_ADAPT_SR; i++)
  {
    memset (m_aaiAdaptSR[i], 0, MAX_IDX_ADAPT_SR * sizeof (Int));
  }
  for (Int i=0; i<AMVP_MAX_NUM_CANDS+1; i++)
  {
    memset (m_auiMVPIdxCost[i], 0, (AMVP_MAX_NUM_CANDS+1) * sizeof (UInt) );
  }

  setWpScalingDistParam( NULL, -1, REF_PIC_LIST_X );
}


Void TEncSearch::destroy()
{
  assert (m_isInitialized);
  if ( m_pTempPel )
  {
    delete [] m_pTempPel;
    m_pTempPel = NULL;
  }

  if ( m_pcEncCfg )
  {
    const UInt uiNumLayersAllocated = m_pcEncCfg->getQuadtreeTULog2MaxSize()-m_pcEncCfg->getQuadtreeTULog2MinSize()+1;

    for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
    {
      for (UInt layer = 0; layer < uiNumLayersAllocated; layer++)
      {
        delete[] m_ppcQTTempCoeff[ch][layer];
#if ADAPTIVE_QP_SELECTION
        delete[] m_ppcQTTempArlCoeff[ch][layer];
#endif
      }
      delete[] m_ppcQTTempCoeff[ch];
      delete[] m_puhQTTempCbf[ch];
#if ADAPTIVE_QP_SELECTION
      delete[] m_ppcQTTempArlCoeff[ch];
#endif
    }

    for( UInt layer = 0; layer < uiNumLayersAllocated; layer++ )
    {
      m_pcQTTempTComYuv[layer].destroy();
    }
  }

  delete[] m_puhQTTempTrIdx;
  delete[] m_pcQTTempTComYuv;

  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    delete[] m_pSharedPredTransformSkip[ch];
    delete[] m_pcQTTempTUCoeff[ch];
#if ADAPTIVE_QP_SELECTION
    delete[] m_ppcQTTempTUArlCoeff[ch];
#endif
    delete[] m_phQTTempCrossComponentPredictionAlpha[ch];
    delete[] m_puhQTTempTransformSkipFlag[ch];
  }
  m_pcQTTempTransformSkipTComYuv.destroy();

  m_tmpYuvPred.destroy();
  m_isInitialized = false;
}

TEncSearch::~TEncSearch()
{
  if (m_isInitialized)
  {
    destroy();
  }
}




Void TEncSearch::init(TEncCfg*       pcEncCfg,
                      TComTrQuant*   pcTrQuant,
                      Int            iSearchRange,
                      Int            bipredSearchRange,
                      MESearchMethod motionEstimationSearchMethod,
                      const UInt     maxCUWidth,
                      const UInt     maxCUHeight,
                      const UInt     maxTotalCUDepth,
                      TEncEntropy*   pcEntropyCoder,
                      TComRdCost*    pcRdCost,
                      TEncSbac***    pppcRDSbacCoder,
                      TEncSbac*      pcRDGoOnSbacCoder
                      )
{
  assert (!m_isInitialized);
  m_pcEncCfg                     = pcEncCfg;
  m_pcTrQuant                    = pcTrQuant;
  m_iSearchRange                 = iSearchRange;
  m_bipredSearchRange            = bipredSearchRange;
  m_motionEstimationSearchMethod = motionEstimationSearchMethod;
  m_pcEntropyCoder               = pcEntropyCoder;
  m_pcRdCost                     = pcRdCost;

  m_pppcRDSbacCoder              = pppcRDSbacCoder;
  m_pcRDGoOnSbacCoder            = pcRDGoOnSbacCoder;
  
  for (UInt iDir = 0; iDir < MAX_NUM_REF_LIST_ADAPT_SR; iDir++)
  {
    for (UInt iRefIdx = 0; iRefIdx < MAX_IDX_ADAPT_SR; iRefIdx++)
    {
      m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange;
    }
  }

  // initialize motion cost
  for( Int iNum = 0; iNum < AMVP_MAX_NUM_CANDS+1; iNum++)
  {
    for( Int iIdx = 0; iIdx < AMVP_MAX_NUM_CANDS; iIdx++)
    {
      if (iIdx < iNum)
      {
        m_auiMVPIdxCost[iIdx][iNum] = xGetMvpIdxBits(iIdx, iNum);
      }
      else
      {
        m_auiMVPIdxCost[iIdx][iNum] = MAX_INT;
      }
    }
  }

  const ChromaFormat cform=pcEncCfg->getChromaFormatIdc();
  initTempBuff(cform);

  m_pTempPel = new Pel[maxCUWidth*maxCUHeight];

  const UInt uiNumLayersToAllocate = pcEncCfg->getQuadtreeTULog2MaxSize()-pcEncCfg->getQuadtreeTULog2MinSize()+1;
  const UInt uiNumPartitions = 1<<(maxTotalCUDepth<<1);
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    const UInt csx=::getComponentScaleX(ComponentID(ch), cform);
    const UInt csy=::getComponentScaleY(ComponentID(ch), cform);
    m_ppcQTTempCoeff[ch] = new TCoeff* [uiNumLayersToAllocate];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]  = new TCoeff*[uiNumLayersToAllocate];
#endif
    m_puhQTTempCbf[ch] = new UChar  [uiNumPartitions];

    for (UInt layer = 0; layer < uiNumLayersToAllocate; layer++)
    {
      m_ppcQTTempCoeff[ch][layer] = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy)];
#if ADAPTIVE_QP_SELECTION
      m_ppcQTTempArlCoeff[ch][layer]  = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy) ];
#endif
    }

    m_phQTTempCrossComponentPredictionAlpha[ch]    = new SChar  [uiNumPartitions];
    m_pSharedPredTransformSkip[ch]                 = new Pel   [MAX_CU_SIZE*MAX_CU_SIZE];
    m_pcQTTempTUCoeff[ch]                          = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#endif
    m_puhQTTempTransformSkipFlag[ch]               = new UChar [uiNumPartitions];
  }
  m_puhQTTempTrIdx   = new UChar  [uiNumPartitions];
  m_pcQTTempTComYuv  = new TComYuv[uiNumLayersToAllocate];
  for( UInt ui = 0; ui < uiNumLayersToAllocate; ++ui )
  {
    m_pcQTTempTComYuv[ui].create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  }
  m_pcQTTempTransformSkipTComYuv.create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  m_tmpYuvPred.create(MAX_CU_SIZE, MAX_CU_SIZE, pcEncCfg->getChromaFormatIdc());
  m_isInitialized = true;
}


__inline Void TEncSearch::xTZSearchHelp( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const Int iSearchX, const Int iSearchY, const UChar ucPointNr, const UInt uiDistance )
{
  Distortion  uiSad = 0;

  const Pel* const  piRefSrch = rcStruct.piRefY + iSearchY * rcStruct.iYStride + iSearchX;

  //-- jclee for using the SAD function pointer
  m_pcRdCost->setDistParam( pcPatternKey, piRefSrch, rcStruct.iYStride,  m_cDistParam );

  setDistParamComp(COMPONENT_Y);

  // distortion
  m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
  m_cDistParam.m_maximumDistortionForEarlyExit = rcStruct.uiBestSad;

  if((m_pcEncCfg->getRestrictMESampling() == false) && m_pcEncCfg->getMotionEstimationSearchMethod() == MESEARCH_SELECTIVE)
  {
    Int isubShift = 0;
    // motion cost
    Distortion uiBitCost = m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

    // Skip search if bit cost is already larger than best SAD
    if (uiBitCost < rcStruct.uiBestSad)
    {
      if ( m_cDistParam.iRows > 32 )
      {
        m_cDistParam.iSubShift = 4;
      }
      else if ( m_cDistParam.iRows > 16 )
      {
        m_cDistParam.iSubShift = 3;
      }
      else if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 2;
      }
      else
      {
        m_cDistParam.iSubShift = 1;
      }

      Distortion uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
      if((uiTempSad + uiBitCost) < rcStruct.uiBestSad)
      {
        uiSad += uiTempSad >>  m_cDistParam.iSubShift;
        while(m_cDistParam.iSubShift > 0)
        {
          isubShift         = m_cDistParam.iSubShift -1;
          m_cDistParam.pOrg = pcPatternKey->getROIY() + (pcPatternKey->getPatternLStride() << isubShift);
          m_cDistParam.pCur = piRefSrch + (rcStruct.iYStride << isubShift);
          uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
          uiSad += uiTempSad >>  m_cDistParam.iSubShift;
          if(((uiSad << isubShift) + uiBitCost) > rcStruct.uiBestSad)
          {
            break;
          }

          m_cDistParam.iSubShift--;
        }

        if(m_cDistParam.iSubShift == 0)
        {
          uiSad += uiBitCost;
          if( uiSad < rcStruct.uiBestSad )
          {
            rcStruct.uiBestSad      = uiSad;
            rcStruct.iBestX         = iSearchX;
            rcStruct.iBestY         = iSearchY;
            rcStruct.uiBestDistance = uiDistance;
            rcStruct.uiBestRound    = 0;
            rcStruct.ucPointNr      = ucPointNr;
            m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
          }
        }
      }
    }
  }
  else
  {
    // fast encoder decision: use subsampled SAD when rows > 8 for integer ME
    if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE3 )
    {
      if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 1;
      }
    }

    uiSad = m_cDistParam.DistFunc( &m_cDistParam );

	// modification here

	array[counter_i] = uiSad;
	//cout << "\narray    " << array[counter_i];
	//cout << "   number   " << counter_i;
	// end of modification
    // only add motion cost if uiSad is smaller than best. Otherwise pointless
    // to add motion cost.
    if( uiSad < rcStruct.uiBestSad )
    {
      // motion cost
      uiSad += m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

      if( uiSad < rcStruct.uiBestSad )
      {
        rcStruct.uiBestSad      = uiSad;
        rcStruct.iBestX         = iSearchX;
        rcStruct.iBestY         = iSearchY;
        rcStruct.uiBestDistance = uiDistance;
        rcStruct.uiBestRound    = 0;
        rcStruct.ucPointNr      = ucPointNr;
        m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
      }
    }
  }
  counter_i = counter_i + 1;
}

__inline Void TEncSearch::xTZ2PointSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB )
{
  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 2 point search,                   //   1 2 3
  // check only the 2 untested points  //   4 0 5
  // around the start point            //   6 7 8
  Int iStartX = rcStruct.iBestX;
  Int iStartY = rcStruct.iBestY;
  switch( rcStruct.ucPointNr )
  {
    case 1:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY, 0, 2 );
      }
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
    }
      break;
    case 2:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 3:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
    }
      break;
    case 4:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 5:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 6:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY , 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    case 7:
    {
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 8:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    default:
    {
      assert( false );
    }
      break;
  } // switch( rcStruct.ucPointNr )
}




__inline Void TEncSearch::xTZ8PointSquareSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iTop >= iSrchRngVerTop ) // check top
  {
    if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
    }
    // top middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );

    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
    }
  } // check top
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
  }
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
  }
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
    if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
    }
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );

    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
    }
  } // check bottom
}


//additing other square search

__inline Void TEncSearch::xTZ8PointSquareSearch2( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;
// check top
  if ( iTop >= iSrchRngVerTop ) // check top
  {
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iLeft, iTop, 9, iDist);
    }
	  
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iStartX - 1, iTop, 10, iDist);
    }
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 11, iDist );
	
	if (iRight <= iSrchRngHorRight) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX +1, iTop, 12, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 13, iDist );
    }
  }

  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY-1, 14, iDist );
  }

  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY-1, 15, iDist );
  }
  
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 16, iDist );
  }
  
  
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 17, iDist );
  }
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY+1, 18, iDist );
  }
  
  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY+1, 19, iDist );
  }
  
  
  
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 20, iDist );
    }  
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iBottom, 21, iDist );
    }   
	  
	  
    
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 22, iDist );

	if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iBottom, 23, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 24, iDist );
    }
  } 
  
  // check bottom
}











__inline Void TEncSearch::xTZ8PointDiamondSearch( const TComPattern*const  pcPatternKey,
                                                  IntTZSearchStruct& rcStruct,
                                                  const TComMv*const  pcMvSrchRngLT,
                                                  const TComMv*const  pcMvSrchRngRB,
                                                  const Int iStartX,
                                                  const Int iStartY,
                                                  const Int iDist,
                                                  const Bool bCheckCornersAtDist1 )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert ( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iDist == 1 )
  {
    if ( iTop >= iSrchRngVerTop ) // check top
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
      }
    }
    if ( iLeft >= iSrchRngHorLeft ) // check middle left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
    }
    if ( iRight <= iSrchRngHorRight ) // check middle right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
    }
    if ( iBottom <= iSrchRngVerBottom ) // check bottom
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
      }
    }
  }
  else
  {
    if ( iDist <= 8 )
    {
      const Int iTop_2      = iStartY - (iDist>>1);
      const Int iBottom_2   = iStartY + (iDist>>1);
      const Int iLeft_2     = iStartX - (iDist>>1);
      const Int iRight_2    = iStartX + (iDist>>1);

      if (  iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iTop,      2, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iTop_2,    1, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2,    3, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,    iStartY,   4, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,   iStartY,   5, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iBottom_2, 6, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iBottom,   7, iDist    );
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        }
        if ( iTop_2 >= iSrchRngVerTop ) // check half top
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iTop_2, 1, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2, 3, (iDist>>1) );
          }
        } // check half top
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
        }
        if ( iBottom_2 <= iSrchRngVerBottom ) // check half bottom
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iBottom_2, 6, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, (iDist>>1) );
          }
        } // check half bottom
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        }
      } // check border
    }
    else // iDist > 8
    {
      if ( iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop,    0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,   iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,  iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
        }
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 0, iDist );
        }
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 0, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 0, iDist );
        }
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        }
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);

          if ( iPosYT >= iSrchRngVerTop ) // check top
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
            }
          } // check top
          if ( iPosYB <= iSrchRngVerBottom ) // check bottom
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
            }
          } // check bottom
        } // for ...
      } // check border
    } // iDist <= 8
  } // iDist == 1
}

Distortion TEncSearch::xPatternRefinement( TComPattern* pcPatternKey,
                                           TComMv baseRefMv,
                                           Int iFrac, TComMv& rcMvFrac,
                                           Bool bAllowUseOfHadamard
                                         )
{
  Distortion  uiDist;
  Distortion  uiDistBest  = std::numeric_limits<Distortion>::max();
  UInt        uiDirecBest = 0;

  Pel*  piRefPos;
  Int iRefStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);

  m_pcRdCost->setDistParam( pcPatternKey, m_filteredBlock[0][0].getAddr(COMPONENT_Y), iRefStride, 1, m_cDistParam, m_pcEncCfg->getUseHADME() && bAllowUseOfHadamard );

  const TComMv* pcMvRefine = (iFrac == 2 ? s_acMvRefineH : s_acMvRefineQ);

  for (UInt i = 0; i < 9; i++)
  {
    TComMv cMvTest = pcMvRefine[i];
    cMvTest += baseRefMv;

    Int horVal = cMvTest.getHor() * iFrac;
    Int verVal = cMvTest.getVer() * iFrac;
    piRefPos = m_filteredBlock[ verVal & 3 ][ horVal & 3 ].getAddr(COMPONENT_Y);
    if ( horVal == 2 && ( verVal & 1 ) == 0 )
    {
      piRefPos += 1;
    }
    if ( ( horVal & 1 ) == 0 && verVal == 2 )
    {
      piRefPos += iRefStride;
    }
    cMvTest = pcMvRefine[i];
    cMvTest += rcMvFrac;

    setDistParamComp(COMPONENT_Y);

    m_cDistParam.pCur = piRefPos;
    m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
    uiDist = m_cDistParam.DistFunc( &m_cDistParam );
    uiDist += m_pcRdCost->getCostOfVectorWithPredictor( cMvTest.getHor(), cMvTest.getVer() );

    if ( uiDist < uiDistBest )
    {
      uiDistBest  = uiDist;
      uiDirecBest = i;
      m_cDistParam.m_maximumDistortionForEarlyExit = uiDist;
    }
  }

  rcMvFrac = pcMvRefine[uiDirecBest];

  return uiDistBest;
}



Void
TEncSearch::xEncSubdivCbfQT(TComTU      &rTu,
                            Bool         bLuma,
                            Bool         bChroma )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx         = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth            = rTu.GetTransformDepthRel();
  const UInt uiTrMode             = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt uiSubdiv             = ( uiTrMode > uiTrDepth ? 1 : 0 );
  const UInt uiLog2LumaTrafoSize  = rTu.GetLog2LumaTrSize();

  if( pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_NxN && uiTrDepth == 0 )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize > pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getSlice()->getSPS()->getQuadtreeTULog2MinSize() )
  {
    assert( !uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
  {
    assert( !uiSubdiv );
  }
  else
  {
    assert( uiLog2LumaTrafoSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );
    if( bLuma )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( uiSubdiv, 5 - uiLog2LumaTrafoSize );
    }
  }

  if ( bChroma )
  {
    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if( rTu.ProcessingAllQuadrants(compID) && (uiTrDepth==0 || pcCU->getCbf( uiAbsPartIdx, compID, uiTrDepth-1 ) ))
      {
        m_pcEntropyCoder->encodeQtCbf(rTu, compID, (uiSubdiv == 0));
      }
    }
  }

  if( uiSubdiv )
  {
    TComTURecurse tuRecurse(rTu, false);
    do
    {
      xEncSubdivCbfQT( tuRecurse, bLuma, bChroma );
    } while (tuRecurse.nextSection(rTu));
  }
  else
  {
    //===== Cbfs =====
    if( bLuma )
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }
}




Void
TEncSearch::xEncCoeffQT(TComTU &rTu,
                        const ComponentID  component,
                        Bool         bRealCoeff )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();

  const UInt  uiTrMode        = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt  uiSubdiv        = ( uiTrMode > uiTrDepth ? 1 : 0 );

  if( uiSubdiv )
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xEncCoeffQT( tuRecurseChild, component, bRealCoeff );
    } while (tuRecurseChild.nextSection(rTu) );
  }
  else if (rTu.ProcessComponentSection(component))
  {
    //===== coefficients =====
    const UInt  uiLog2TrafoSize = rTu.GetLog2LumaTrSize();
    UInt    uiCoeffOffset   = rTu.getCoefficientOffset(component);
    UInt    uiQTLayer       = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrafoSize;
    TCoeff* pcCoeff         = bRealCoeff ? pcCU->getCoeff(component) : m_ppcQTTempCoeff[component][uiQTLayer];

    if (isChroma(component) && (pcCU->getCbf( rTu.GetAbsPartIdxTU(), COMPONENT_Y, uiTrMode ) != 0) && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag() )
    {
      m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, component );
    }

    m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeff+uiCoeffOffset, component );
  }
}




Void
TEncSearch::xEncIntraHeader( TComDataCU*  pcCU,
                            UInt         uiTrDepth,
                            UInt         uiAbsPartIdx,
                            Bool         bLuma,
                            Bool         bChroma )
{
  if( bLuma )
  {
    // CU header
    if( uiAbsPartIdx == 0 )
    {
      if( !pcCU->getSlice()->isIntra() )
      {
        if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
        {
          m_pcEntropyCoder->encodeCUTransquantBypassFlag( pcCU, 0, true );
        }
        m_pcEntropyCoder->encodeSkipFlag( pcCU, 0, true );
        m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
      }
      m_pcEntropyCoder  ->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );

      if (pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_2Nx2N )
      {
        m_pcEntropyCoder->encodeIPCMInfo( pcCU, 0, true );

        if ( pcCU->getIPCMFlag (0))
        {
          return;
        }
      }
    }
    // luma prediction mode
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N )
    {
      if (uiAbsPartIdx==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, 0 );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      if (uiTrDepth>0 && (uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiAbsPartIdx );
      }
    }
  }

  if( bChroma )
  {
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N || !enable4ChromaPUsInIntraNxNCU(pcCU->getPic()->getChromaFormat()))
    {
      if(uiAbsPartIdx==0)
      {
         m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      assert(uiTrDepth>0);
      if ((uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
  }
}




UInt
TEncSearch::xGetIntraBitsQT(TComTU &rTu,
                            Bool         bLuma,
                            Bool         bChroma,
                            Bool         bRealCoeff /* just for test */ )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();
  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiTrDepth, uiAbsPartIdx, bLuma, bChroma );
  xEncSubdivCbfQT ( rTu, bLuma, bChroma );

  if( bLuma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Y,      bRealCoeff );
  }
  if( bChroma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Cb,  bRealCoeff );
    xEncCoeffQT   ( rTu, COMPONENT_Cr,  bRealCoeff );
  }
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  return uiBits;
}

UInt TEncSearch::xGetIntraBitsQTChroma(TComTU &rTu,
                                       ComponentID compID,
                                       Bool         bRealCoeff /* just for test */ )
{
  m_pcEntropyCoder->resetBits();
  xEncCoeffQT   ( rTu, compID,  bRealCoeff );
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  return uiBits;
}

Void TEncSearch::xIntraCodingTUBlock(       TComYuv*    pcOrgYuv,
                                            TComYuv*    pcPredYuv,
                                            TComYuv*    pcResiYuv,
                                            Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      const Bool        checkCrossCPrediction,
                                            Distortion& ruiDist,
                                      const ComponentID compID,
                                            TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug)
                                           ,Int         default0Save1Load2
                                     )
{
  if (!rTu.ProcessComponentSection(compID))
  {
    return;
  }
  const Bool           bIsLuma          = isLuma(compID);
  const TComRectangle &rect             = rTu.getRect(compID);
        TComDataCU    *pcCU             = rTu.getCU();
  const UInt           uiAbsPartIdx     = rTu.GetAbsPartIdxTU();
  const TComSPS       &sps              = *(pcCU->getSlice()->getSPS());

  const UInt           uiTrDepth        = rTu.GetTransformDepthRelAdj(compID);
  const UInt           uiFullDepth      = rTu.GetTransformDepthTotal();
  const UInt           uiLog2TrSize     = rTu.GetLog2LumaTrSize();
  const ChromaFormat   chFmt            = pcOrgYuv->getChromaFormat();
  const ChannelType    chType           = toChannelType(compID);
  const Int            bitDepth         = sps.getBitDepth(chType);

  const UInt           uiWidth          = rect.width;
  const UInt           uiHeight         = rect.height;
  const UInt           uiStride         = pcOrgYuv ->getStride (compID);
        Pel           *piOrg            = pcOrgYuv ->getAddr( compID, uiAbsPartIdx );
        Pel           *piPred           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piResi           = pcResiYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piReco           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
  const UInt           uiQTLayer        = sps.getQuadtreeTULog2MaxSize() - uiLog2TrSize;
        Pel           *piRecQt          = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
  const UInt           uiRecQtStride    = m_pcQTTempTComYuv[ uiQTLayer ].getStride(compID);
  const UInt           uiZOrder         = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
        Pel           *piRecIPred       = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
        UInt           uiRecIPredStride = pcCU->getPic()->getPicYuvRec()->getStride  ( compID );
        TCoeff        *pcCoeff          = m_ppcQTTempCoeff[compID][uiQTLayer] + rTu.getCoefficientOffset(compID);
        Bool           useTransformSkip = pcCU->getTransformSkip(uiAbsPartIdx, compID);

#if ADAPTIVE_QP_SELECTION
        TCoeff        *pcArlCoeff       = m_ppcQTTempArlCoeff[compID][ uiQTLayer ] + rTu.getCoefficientOffset(compID);
#endif

  const UInt           uiChPredMode     = pcCU->getIntraDir( chType, uiAbsPartIdx );
  const UInt           partsPerMinCU    = 1<<(2*(sps.getMaxTotalCUDepth() - sps.getLog2DiffMaxMinCodingBlockSize()));
  const UInt           uiChCodedMode    = (uiChPredMode==DM_CHROMA_IDX && !bIsLuma) ? pcCU->getIntraDir(CHANNEL_TYPE_LUMA, getChromasCorrespondingPULumaIdx(uiAbsPartIdx, chFmt, partsPerMinCU)) : uiChPredMode;
  const UInt           uiChFinalMode    = ((chFmt == CHROMA_422)       && !bIsLuma) ? g_chroma422IntraAngleMappingTable[uiChCodedMode] : uiChCodedMode;

  const Int            blkX                                 = g_auiRasterToPelX[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            blkY                                 = g_auiRasterToPelY[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            bufferOffset                         = blkX + (blkY * MAX_CU_SIZE);
        Pel  *const    encoderLumaResidual                  = resiLuma[RESIDUAL_ENCODER_SIDE ] + bufferOffset;
        Pel  *const    reconstructedLumaResidual            = resiLuma[RESIDUAL_RECONSTRUCTED] + bufferOffset;
  const Bool           bUseCrossCPrediction                 = isChroma(compID) && (uiChPredMode == DM_CHROMA_IDX) && checkCrossCPrediction;
  const Bool           bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
        Pel *const     lumaResidualForEstimate              = bUseReconstructedResidualForEstimate ? reconstructedLumaResidual : encoderLumaResidual;

#if DEBUG_STRING
  const Int debugPredModeMask=DebugStringGetPredModeMask(MODE_INTRA);
#endif

  //===== init availability pattern =====
  DEBUG_STRING_NEW(sTemp)

#if !DEBUG_STRING
  if( default0Save1Load2 != 2 )
#endif
  {
    const Bool bUseFilteredPredictions=TComPrediction::filteringIntraReferenceSamples(compID, uiChFinalMode, uiWidth, uiHeight, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

    initIntraPatternChType( rTu, compID, bUseFilteredPredictions DEBUG_STRING_PASS_INTO(sDebug) );

    //===== get prediction signal =====
    predIntraAng( compID, uiChFinalMode, piOrg, uiStride, piPred, uiStride, rTu, bUseFilteredPredictions );

    // save prediction
    if( default0Save1Load2 == 1 )
    {
      Pel*  pPred   = piPred;
      Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
      Int k = 0;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pPredBuf[ k ++ ] = pPred[ uiX ];
        }
        pPred += uiStride;
      }
    }
  }
#if !DEBUG_STRING
  else
  {
    // load prediction
    Pel*  pPred   = piPred;
    Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
    Int k = 0;
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pPred[ uiX ] = pPredBuf[ k ++ ];
      }
      pPred += uiStride;
    }
  }
#endif

  //===== get residual signal =====
  {
    // get residual
    Pel*  pOrg    = piOrg;
    Pel*  pPred   = piPred;
    Pel*  pResi   = piResi;

    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pResi[ uiX ] = pOrg[ uiX ] - pPred[ uiX ];
      }

      pOrg  += uiStride;
      pResi += uiStride;
      pPred += uiStride;
    }
  }

  if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
  {
    if (bUseCrossCPrediction)
    {
      if (xCalcCrossComponentPredictionAlpha( rTu, compID, lumaResidualForEstimate, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride ) == 0)
      {
        return;
      }
      TComTrQuant::crossComponentPrediction ( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, false );
    }
    else if (isLuma(compID) && !bUseReconstructedResidualForEstimate)
    {
      xStoreCrossComponentPredictionResult( encoderLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
    }
  }

  //===== transform and quantization =====
  //--- init rate estimation arrays for RDOQ ---
  if( useTransformSkip ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ() )
  {
    m_pcEntropyCoder->estimateBit( m_pcTrQuant->m_pcEstBitsSbac, uiWidth, uiHeight, chType );
  }

  //--- transform and quantization ---
  TCoeff uiAbsSum = 0;
  if (bIsLuma)
  {
    pcCU       ->setTrIdxSubParts ( uiTrDepth, uiAbsPartIdx, uiFullDepth );
  }

  const QpParam cQP(*pcCU, compID);

#if RDOQ_CHROMA_LAMBDA
  m_pcTrQuant->selectLambda     (compID);
#endif

  m_pcTrQuant->transformNxN     ( rTu, compID, piResi, uiStride, pcCoeff,
#if ADAPTIVE_QP_SELECTION
    pcArlCoeff,
#endif
    uiAbsSum, cQP
    );

  //--- inverse transform ---

#if DEBUG_STRING
  if ( (uiAbsSum > 0) || (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask) )
#else
  if ( uiAbsSum > 0 )
#endif
  {
    m_pcTrQuant->invTransformNxN ( rTu, compID, piResi, uiStride, pcCoeff, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sDebug, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );
  }
  else
  {
    Pel* pResi = piResi;
    memset( pcCoeff, 0, sizeof( TCoeff ) * uiWidth * uiHeight );
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      memset( pResi, 0, sizeof( Pel ) * uiWidth );
      pResi += uiStride;
    }
  }


  //===== reconstruction =====
  {
    Pel* pPred      = piPred;
    Pel* pResi      = piResi;
    Pel* pReco      = piReco;
    Pel* pRecQt     = piRecQt;
    Pel* pRecIPred  = piRecIPred;

    if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
    {
      if (bUseCrossCPrediction)
      {
        TComTrQuant::crossComponentPrediction( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, true );
      }
      else if (isLuma(compID))
      {
        xStoreCrossComponentPredictionResult( reconstructedLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
      }
    }

 #if DEBUG_STRING
    std::stringstream ss(stringstream::out);
    const Bool bDebugPred=((DebugOptionList::DebugString_Pred.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugResi=((DebugOptionList::DebugString_Resi.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugReco=((DebugOptionList::DebugString_Reco.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));

    if (bDebugPred || bDebugResi || bDebugReco)
    {
      ss << "###: " << "CompID: " << compID << " pred mode (ch/fin): " << uiChPredMode << "/" << uiChFinalMode << " absPartIdx: " << rTu.GetAbsPartIdxTU() << "\n";
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        ss << "###: ";
        if (bDebugPred)
        {
          ss << " - pred: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pPred[ uiX ] << ", ";
          }
        }
        if (bDebugResi)
        {
          ss << " - resi: ";
        }
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          if (bDebugResi)
          {
            ss << pResi[ uiX ] << ", ";
          }
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        if (bDebugReco)
        {
          ss << " - reco: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pReco[ uiX ] << ", ";
          }
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
        ss << "\n";
      }
      DEBUG_STRING_APPEND(sDebug, ss.str())
    }
    else
#endif
    {

      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }

  //===== update distortion =====
  ruiDist += m_pcRdCost->getDistPart( bitDepth, piReco, uiStride, piOrg, uiStride, uiWidth, uiHeight, compID );
}




Void
TEncSearch::xRecurIntraCodingLumaQT(TComYuv*    pcOrgYuv,
                                    TComYuv*    pcPredYuv,
                                    TComYuv*    pcResiYuv,
                                    Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                    Distortion& ruiDistY,
#if HHI_RQT_INTRA_SPEEDUP
                                    Bool        bCheckFirst,
#endif
                                    Double&     dRDCost,
                                    TComTU&     rTu
                                    DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU   *pcCU          = rTu.getCU();
  const UInt    uiAbsPartIdx  = rTu.GetAbsPartIdxTU();
  const UInt    uiFullDepth   = rTu.GetTransformDepthTotal();
  const UInt    uiTrDepth     = rTu.GetTransformDepthRel();
  const UInt    uiLog2TrSize  = rTu.GetLog2LumaTrSize();
        Bool    bCheckFull    = ( uiLog2TrSize  <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
        Bool    bCheckSplit   = ( uiLog2TrSize  >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

        Pel     resiLumaSplit [NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];
        Pel     resiLumaSingle[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

#if HHI_RQT_INTRA_SPEEDUP
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // don't check split if TU size is less or equal to max TU size
  Bool noSplitIntraMaxTuSize = bCheckFull;
  if(m_pcEncCfg->getRDpenalty() && ! isIntraSlice)
  {
    // in addition don't check split if TU size is less or equal to 16x16 TU size for non-intra slice
    noSplitIntraMaxTuSize = ( uiLog2TrSize  <= min(maxTuSize,4) );

    // if maximum RD-penalty don't check TU size 32x32
    if(m_pcEncCfg->getRDpenalty()==2)
    {
      bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
    }
  }
  if( bCheckFirst && noSplitIntraMaxTuSize )

  {
    bCheckSplit = false;
  }
#else
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // if maximum RD-penalty don't check TU size 32x32
  if((m_pcEncCfg->getRDpenalty()==2)  && !isIntraSlice)
  {
    bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
  }
#endif
  Double     dSingleCost                        = MAX_DOUBLE;
  Distortion uiSingleDistLuma                   = 0;
  UInt       uiSingleCbfLuma                    = 0;
  Bool       checkTransformSkip  = pcCU->getSlice()->getPPS()->getUseTransformSkip();
  Int        bestModeId[MAX_NUM_COMPONENT] = { 0, 0, 0};
  checkTransformSkip           &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());
  checkTransformSkip           &= (!pcCU->getCUTransquantBypass(0));

  assert (rTu.ProcessComponentSection(COMPONENT_Y));
  const UInt totalAdjustedDepthChan   = rTu.GetTransformDepthTotalAdj(COMPONENT_Y);

  if ( m_pcEncCfg->getUseTransformSkipFast() )
  {
    checkTransformSkip       &= (pcCU->getPartitionSize(uiAbsPartIdx)==SIZE_NxN);
  }

  if( bCheckFull )
  {
    if(checkTransformSkip == true)
    {
      //----- store original entropy coding status -----
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );

      Distortion singleDistTmpLuma                    = 0;
      UInt       singleCbfTmpLuma                     = 0;
      Double     singleCostTmp                        = 0;
      Int        firstCheckId                         = 0;

      for(Int modeId = firstCheckId; modeId < 2; modeId ++)
      {
        DEBUG_STRING_NEW(sModeString)
        Int  default0Save1Load2 = 0;
        singleDistTmpLuma=0;
        if(modeId == firstCheckId)
        {
          default0Save1Load2 = 1;
        }
        else
        {
          default0Save1Load2 = 2;
        }


        pcCU->setTransformSkipSubParts ( modeId, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
        xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, singleDistTmpLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sModeString), default0Save1Load2 );

        singleCbfTmpLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );

        //----- determine rate and r-d cost -----
        if(modeId == 1 && singleCbfTmpLuma == 0)
        {
          //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
          singleCostTmp = MAX_DOUBLE;
        }
        else
        {
          UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );
          singleCostTmp     = m_pcRdCost->calcRdCost( uiSingleBits, singleDistTmpLuma );
        }
        if(singleCostTmp < dSingleCost)
        {
          DEBUG_STRING_SWAP(sDebug, sModeString)
          dSingleCost   = singleCostTmp;
          uiSingleDistLuma = singleDistTmpLuma;
          uiSingleCbfLuma = singleCbfTmpLuma;

          bestModeId[COMPONENT_Y] = modeId;
          if(bestModeId[COMPONENT_Y] == firstCheckId)
          {
            xStoreIntraResultQT(COMPONENT_Y, rTu );
            m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
          }

          if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
          {
            const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
            const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
            for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
            {
              if (bMaintainResidual[storedResidualIndex])
              {
                xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
              }
            }
          }
        }
        if (modeId == firstCheckId)
        {
          m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
        }
      }

      pcCU ->setTransformSkipSubParts ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

      if(bestModeId[COMPONENT_Y] == firstCheckId)
      {
        xLoadIntraResultQT(COMPONENT_Y, rTu );
        pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, rTu.GetTransformDepthTotalAdj(COMPONENT_Y) );

        m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
      }
    }
    else
    {
      //----- store original entropy coding status -----
      if( bCheckSplit )
      {
        m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
      }
      //----- code luma/chroma block with given intra prediction mode and store Cbf-----
      dSingleCost   = 0.0;

      pcCU ->setTransformSkipSubParts ( 0, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
      xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, uiSingleDistLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sDebug));

      if( bCheckSplit )
      {
        uiSingleCbfLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );
      }
      //----- determine rate and r-d cost -----
      UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );

      if(m_pcEncCfg->getRDpenalty() && (uiLog2TrSize==5) && !isIntraSlice)
      {
        uiSingleBits=uiSingleBits*4;
      }

      dSingleCost       = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDistLuma );

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }
    }
  }

  if( bCheckSplit )
  {
    //----- store full entropy coding status, load original entropy coding status -----
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    else
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    //----- code splitted block -----
    Double     dSplitCost      = 0.0;
    Distortion uiSplitDistLuma = 0;
    UInt       uiSplitCbfLuma  = 0;

    TComTURecurse tuRecurseChild(rTu, false);
    DEBUG_STRING_NEW(sSplit)
    do
    {
      DEBUG_STRING_NEW(sChild)
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, bCheckFirst, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#endif
      DEBUG_STRING_APPEND(sSplit, sChild)
      uiSplitCbfLuma |= pcCU->getCbf( tuRecurseChild.GetAbsPartIdxTU(), COMPONENT_Y, tuRecurseChild.GetTransformDepthRel() );
    } while (tuRecurseChild.nextSection(rTu) );

    UInt    uiPartsDiv     = rTu.GetAbsPartIdxNumParts();
    {
      if (uiSplitCbfLuma)
      {
        const UInt flag=1<<uiTrDepth;
        UChar *pBase=pcCU->getCbf( COMPONENT_Y );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
    //----- restore context states -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    
    //----- determine rate and r-d cost -----
    UInt uiSplitBits = xGetIntraBitsQT( rTu, true, false, false );
    dSplitCost       = m_pcRdCost->calcRdCost( uiSplitBits, uiSplitDistLuma );

    //===== compare and set best =====
    if( dSplitCost < dSingleCost )
    {
      //--- update cost ---
      DEBUG_STRING_SWAP(sSplit, sDebug)
      ruiDistY += uiSplitDistLuma;
      dRDCost  += dSplitCost;

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSplit[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }

      return;
    }

    //----- set entropy coding status -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );

    //--- set transform index and Cbf values ---
    pcCU->setTrIdxSubParts( uiTrDepth, uiAbsPartIdx, uiFullDepth );
    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
    pcCU ->setTransformSkipSubParts  ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

    //--- set reconstruction for next intra prediction blocks ---
    const UInt  uiQTLayer   = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt  uiZOrder    = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
    const UInt  uiWidth     = tuRect.width;
    const UInt  uiHeight    = tuRect.height;
    Pel*  piSrc       = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( COMPONENT_Y, uiAbsPartIdx );
    UInt  uiSrcStride = m_pcQTTempTComYuv[ uiQTLayer ].getStride  ( COMPONENT_Y );
    Pel*  piDes       = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
    UInt  uiDesStride = pcCU->getPic()->getPicYuvRec()->getStride  ( COMPONENT_Y );

    for( UInt uiY = 0; uiY < uiHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        piDes[ uiX ] = piSrc[ uiX ];
      }
    }
  }
  ruiDistY += uiSingleDistLuma;
  dRDCost  += dSingleCost;
}


Void
TEncSearch::xSetIntraResultLumaQT(TComYuv* pcRecoYuv, TComTU &rTu)
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiTrDepth    = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====

    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    const UInt coeffOffset = rTu.getCoefficientOffset(COMPONENT_Y);
    const UInt numCoeffInBlock = tuRect.width * tuRect.height;

    if (numCoeffInBlock!=0)
    {
      const TCoeff* srcCoeff = m_ppcQTTempCoeff[COMPONENT_Y][uiQTLayer] + coeffOffset;
      TCoeff* destCoeff      = pcCU->getCoeff(COMPONENT_Y) + coeffOffset;
      ::memcpy( destCoeff, srcCoeff, sizeof(TCoeff)*numCoeffInBlock );
#if ADAPTIVE_QP_SELECTION
      const TCoeff* srcArlCoeff = m_ppcQTTempArlCoeff[COMPONENT_Y][ uiQTLayer ] + coeffOffset;
      TCoeff* destArlCoeff      = pcCU->getArlCoeff (COMPONENT_Y)               + coeffOffset;
      ::memcpy( destArlCoeff, srcArlCoeff, sizeof( TCoeff ) * numCoeffInBlock );
#endif
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Y, pcRecoYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }

  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultLumaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}


Void
TEncSearch::xStoreIntraResultQT(const ComponentID compID, TComTU &rTu )
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff    = tuRect.width * tuRect.height;
      TCoeff* pcCoeffSrc = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffDst = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffDst = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( compID, &m_pcQTTempTransformSkipTComYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }
  }
}


Void
TEncSearch::xLoadIntraResultQT(const ComponentID compID, TComTU &rTu)
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt uiZOrder     = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff = tuRect.width * tuRect.height;
      TCoeff* pcCoeffDst = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffSrc = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffDst = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffSrc = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTransformSkipTComYuv.copyPartToPartComponent( compID, &m_pcQTTempTComYuv[ uiQTLayer ], uiAbsPartIdx, tuRect.width, tuRect.height );

      Pel*    piRecIPred        = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
      UInt    uiRecIPredStride  = pcCU->getPic()->getPicYuvRec()->getStride (compID);
      Pel*    piRecQt           = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
      UInt    uiRecQtStride     = m_pcQTTempTComYuv[ uiQTLayer ].getStride  (compID);
      UInt    uiWidth           = tuRect.width;
      UInt    uiHeight          = tuRect.height;
      Pel* pRecQt               = piRecQt;
      Pel* pRecIPred            = piRecIPred;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pRecIPred[ uiX ] = pRecQt   [ uiX ];
        }
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }
}

Void
TEncSearch::xStoreCrossComponentPredictionResult(       Pel    *pResiDst,
                                                  const Pel    *pResiSrc,
                                                        TComTU &rTu,
                                                  const Int     xOffset,
                                                  const Int     yOffset,
                                                  const Int     strideDst,
                                                  const Int     strideSrc )
{
  const Pel *pSrc = pResiSrc + yOffset * strideSrc + xOffset;
        Pel *pDst = pResiDst + yOffset * strideDst + xOffset;

  for( Int y = 0; y < rTu.getRect( COMPONENT_Y ).height; y++ )
  {
    ::memcpy( pDst, pSrc, sizeof(Pel) * rTu.getRect( COMPONENT_Y ).width );
    pDst += strideDst;
    pSrc += strideSrc;
  }
}

SChar
TEncSearch::xCalcCrossComponentPredictionAlpha(       TComTU &rTu,
                                                const ComponentID compID,
                                                const Pel*        piResiL,
                                                const Pel*        piResiC,
                                                const Int         width,
                                                const Int         height,
                                                const Int         strideL,
                                                const Int         strideC )
{
  const Pel *pResiL = piResiL;
  const Pel *pResiC = piResiC;

        TComDataCU *pCU = rTu.getCU();
  const Int  absPartIdx = rTu.GetAbsPartIdxTU( compID );
  const Int diffBitDepth = pCU->getSlice()->getSPS()->getDifferentialLumaChromaBitDepth();

  SChar alpha = 0;
  Int SSxy  = 0;
  Int SSxx  = 0;

  for( UInt uiY = 0; uiY < height; uiY++ )
  {
    for( UInt uiX = 0; uiX < width; uiX++ )
    {
      const Pel scaledResiL = rightShift( pResiL[ uiX ], diffBitDepth );
      SSxy += ( scaledResiL * pResiC[ uiX ] );
      SSxx += ( scaledResiL * scaledResiL   );
    }

    pResiL += strideL;
    pResiC += strideC;
  }

  if( SSxx != 0 )
  {
    Double dAlpha = SSxy / Double( SSxx );
    alpha = SChar(Clip3<Int>(-16, 16, (Int)(dAlpha * 16)));

    static const SChar alphaQuant[17] = {0, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8};

    alpha = (alpha < 0) ? -alphaQuant[Int(-alpha)] : alphaQuant[Int(alpha)];
  }
  pCU->setCrossComponentPredictionAlphaPartRange( alpha, compID, absPartIdx, rTu.GetAbsPartIdxNumParts( compID ) );

  return alpha;
}

Void
TEncSearch::xRecurIntraChromaCodingQT(TComYuv*    pcOrgYuv,
                                      TComYuv*    pcPredYuv,
                                      TComYuv*    pcResiYuv,
                                      Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      Distortion& ruiDist,
                                      TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU         *pcCU                  = rTu.getCU();
  const UInt          uiTrDepth             = rTu.GetTransformDepthRel();
  const UInt          uiAbsPartIdx          = rTu.GetAbsPartIdxTU();
  const ChromaFormat  format                = rTu.GetChromaFormat();
  UInt                uiTrMode              = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt          numberValidComponents = getNumberValidComponents(format);

  if(  uiTrMode == uiTrDepth )
  {
    if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      return;
    }

    const UInt uiFullDepth = rTu.GetTransformDepthTotal();

    Bool checkTransformSkip = pcCU->getSlice()->getPPS()->getUseTransformSkip();
    checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Cb), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

    if ( m_pcEncCfg->getUseTransformSkipFast() )
    {
      checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

      if (checkTransformSkip)
      {
        Int nbLumaSkip = 0;
        const UInt maxAbsPartIdxSub=uiAbsPartIdx + (rTu.ProcessingAllQuadrants(COMPONENT_Cb)?1:4);
        for(UInt absPartIdxSub = uiAbsPartIdx; absPartIdxSub < maxAbsPartIdxSub; absPartIdxSub ++)
        {
          nbLumaSkip += pcCU->getTransformSkip(absPartIdxSub, COMPONENT_Y);
        }
        checkTransformSkip &= (nbLumaSkip > 0);
      }
    }


    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      DEBUG_STRING_NEW(sDebugBestMode)

      //use RDO to decide whether Cr/Cb takes TS
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[uiFullDepth][CI_QT_TRAFO_ROOT] );

      const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

      TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

      const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

      do
      {
        const UInt subTUAbsPartIdx   = TUIterator.GetAbsPartIdxTU(compID);

        Double     dSingleCost               = MAX_DOUBLE;
        Int        bestModeId                = 0;
        Distortion singleDistC               = 0;
        UInt       singleCbfC                = 0;
        Distortion singleDistCTmp            = 0;
        Double     singleCostTmp             = 0;
        UInt       singleCbfCTmp             = 0;
        SChar      bestCrossCPredictionAlpha = 0;
        Int        bestTransformSkipMode     = 0;

        const Bool checkCrossComponentPrediction =    (pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, subTUAbsPartIdx) == DM_CHROMA_IDX)
                                                   &&  pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                   && (pcCU->getCbf(subTUAbsPartIdx,  COMPONENT_Y, uiTrDepth) != 0);

        const Int  crossCPredictionModesToTest = checkCrossComponentPrediction ? 2 : 1;
        const Int  transformSkipModesToTest    = checkTransformSkip            ? 2 : 1;
        const Int  totalModesToTest            = crossCPredictionModesToTest * transformSkipModesToTest;
              Int  currModeId                  = 0;
              Int  default0Save1Load2          = 0;

        for(Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
        {
          for(Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
          {
            pcCU->setCrossComponentPredictionAlphaPartRange(0, compID, subTUAbsPartIdx, partIdxesPerSubTU);
            DEBUG_STRING_NEW(sDebugMode)
            pcCU->setTransformSkipPartRange( transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU );
            currModeId++;

            const Bool isOneMode  = (totalModesToTest == 1);
            const Bool isLastMode = (currModeId == totalModesToTest); // currModeId is indexed from 1

            if (isOneMode)
            {
              default0Save1Load2 = 0;
            }
            else if (!isOneMode && (transformSkipModeId == 0) && (crossCPredictionModeId == 0))
            {
              default0Save1Load2 = 1; //save prediction on first mode
            }
            else
            {
              default0Save1Load2 = 2; //load it on subsequent modes
            }

            singleDistCTmp = 0;

            xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, (crossCPredictionModeId != 0), singleDistCTmp, compID, TUIterator DEBUG_STRING_PASS_INTO(sDebugMode), default0Save1Load2);
            singleCbfCTmp = pcCU->getCbf( subTUAbsPartIdx, compID, uiTrDepth);

            if (  ((crossCPredictionModeId == 1) && (pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) == 0))
               || ((transformSkipModeId    == 1) && (singleCbfCTmp == 0))) //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
            {
              singleCostTmp = MAX_DOUBLE;
            }
            else if (!isOneMode)
            {
              UInt bitsTmp = xGetIntraBitsQTChroma( TUIterator, compID, false );
              singleCostTmp  = m_pcRdCost->calcRdCost( bitsTmp, singleDistCTmp);
            }

            if(singleCostTmp < dSingleCost)
            {
              DEBUG_STRING_SWAP(sDebugBestMode, sDebugMode)
              dSingleCost               = singleCostTmp;
              singleDistC               = singleDistCTmp;
              bestCrossCPredictionAlpha = (crossCPredictionModeId != 0) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;
              bestTransformSkipMode     = transformSkipModeId;
              bestModeId                = currModeId;
              singleCbfC                = singleCbfCTmp;

              if (!isOneMode && !isLastMode)
              {
                xStoreIntraResultQT(compID, TUIterator);
                m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
              }
            }

            if (!isOneMode && !isLastMode)
            {
              m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
            }
          }
        }

        if(bestModeId < totalModesToTest)
        {
          xLoadIntraResultQT(compID, TUIterator);
          pcCU->setCbfPartRange( singleCbfC << uiTrDepth, compID, subTUAbsPartIdx, partIdxesPerSubTU );

          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
        }

        DEBUG_STRING_APPEND(sDebug, sDebugBestMode)
        pcCU ->setTransformSkipPartRange                ( bestTransformSkipMode,     compID, subTUAbsPartIdx, partIdxesPerSubTU );
        pcCU ->setCrossComponentPredictionAlphaPartRange( bestCrossCPredictionAlpha, compID, subTUAbsPartIdx, partIdxesPerSubTU );
        ruiDist += singleDistC;
      } while (TUIterator.nextSection(rTu));

      if (splitIntoSubTUs)
      {
        offsetSubTUCBFs(rTu, compID);
      }
    }
  }
  else
  {
    UInt    uiSplitCbf[MAX_NUM_COMPONENT] = {0,0,0};

    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiTrDepthChild   = tuRecurseChild.GetTransformDepthRel();
    do
    {
      DEBUG_STRING_NEW(sChild)

      xRecurIntraChromaCodingQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, ruiDist, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );

      DEBUG_STRING_APPEND(sDebug, sChild)
      const UInt uiAbsPartIdxSub=tuRecurseChild.GetAbsPartIdxTU();

      for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
      {
        uiSplitCbf[ch] |= pcCU->getCbf( uiAbsPartIdxSub, ComponentID(ch), uiTrDepthChild );
      }
    } while ( tuRecurseChild.nextSection(rTu) );


    UInt uiPartsDiv = rTu.GetAbsPartIdxNumParts();
    for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      if (uiSplitCbf[ch])
      {
        const UInt flag=1<<uiTrDepth;
        ComponentID compID=ComponentID(ch);
        UChar *pBase=pcCU->getCbf( compID );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
  }
}




Void
TEncSearch::xSetIntraResultChromaQT(TComYuv*    pcRecoYuv, TComTU &rTu)
{
  if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
  {
    return;
  }
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth   = rTu.GetTransformDepthRel();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====
    const TComRectangle &tuRectCb=rTu.getRect(COMPONENT_Cb);
    UInt uiNumCoeffC    = tuRectCb.width*tuRectCb.height;//( pcCU->getSlice()->getSPS()->getMaxCUWidth() * pcCU->getSlice()->getSPS()->getMaxCUHeight() ) >> ( uiFullDepth << 1 );
    const UInt offset = rTu.getCoefficientOffset(COMPONENT_Cb);

    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID component = ComponentID(ch);
      const TCoeff* src           = m_ppcQTTempCoeff[component][uiQTLayer] + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      TCoeff* dest                = pcCU->getCoeff(component) + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      ::memcpy( dest, src, sizeof(TCoeff)*uiNumCoeffC );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[component][ uiQTLayer ] + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      TCoeff* pcArlCoeffDst = pcCU->getArlCoeff(component)                + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeffC );
#endif
    }

    //===== copy reconstruction =====

    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cb, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cr, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultChromaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}



Void
TEncSearch::estIntraPredLumaQT(TComDataCU* pcCU,
                               TComYuv*    pcOrgYuv,
                               TComYuv*    pcPredYuv,
                               TComYuv*    pcResiYuv,
                               TComYuv*    pcRecoYuv,
                               Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                               DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt         uiDepth               = pcCU->getDepth(0);
  const UInt         uiInitTrDepth         = pcCU->getPartitionSize(0) == SIZE_2Nx2N ? 0 : 1;
  const UInt         uiNumPU               = 1<<(2*uiInitTrDepth);
  const UInt         uiQNumParts           = pcCU->getTotalNumPart() >> 2;
  const UInt         uiWidthBit            = pcCU->getIntraSizeIdx(0);
  const ChromaFormat chFmt                 = pcCU->getPic()->getChromaFormat();
  const UInt         numberValidComponents = getNumberValidComponents(chFmt);
  const TComSPS     &sps                   = *(pcCU->getSlice()->getSPS());
  const TComPPS     &pps                   = *(pcCU->getSlice()->getPPS());
        Distortion   uiOverallDistY        = 0;
        UInt         CandNum;
        Double       CandCostList[ FAST_UDI_MAX_RDMODE_NUM ];
        Pel          resiLumaPU[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

  // Lambda calculation at equivalent Qp of 4 is recommended because at that Qp, the quantisation divisor is 1.
#if FULL_NBIT
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#else
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12 - 6 * (sps.getBitDepth(CHANNEL_TYPE_LUMA) - 8)) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#endif

  //===== set QP and clear Cbf =====
  if ( pps.getUseDQP() == true)
  {
    pcCU->setQPSubParts( pcCU->getQP(0), 0, uiDepth );
  }
  else
  {
    pcCU->setQPSubParts( pcCU->getSlice()->getSliceQp(), 0, uiDepth );
  }

  //===== loop over partitions =====
  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);

  do
  {
    const UInt uiPartOffset=tuRecurseWithPU.GetAbsPartIdxTU();
//  for( UInt uiPU = 0, uiPartOffset=0; uiPU < uiNumPU; uiPU++, uiPartOffset += uiQNumParts )
  //{
    //===== init pattern for luma prediction =====
    DEBUG_STRING_NEW(sTemp2)

    //===== determine set of modes to be tested (using prediction signal only) =====
    Int numModesAvailable     = 35; //total number of Intra modes
    UInt uiRdModeList[FAST_UDI_MAX_RDMODE_NUM];
    Int numModesForFullRD = m_pcEncCfg->getFastUDIUseMPMEnabled()?g_aucIntraModeNumFast_UseMPM[ uiWidthBit ] : g_aucIntraModeNumFast_NotUseMPM[ uiWidthBit ];

    // this should always be true
    assert (tuRecurseWithPU.ProcessComponentSection(COMPONENT_Y));
    initIntraPatternChType( tuRecurseWithPU, COMPONENT_Y, true DEBUG_STRING_PASS_INTO(sTemp2) );

    Bool doFastSearch = (numModesForFullRD != numModesAvailable);
    if (doFastSearch)
    {
      assert(numModesForFullRD < numModesAvailable);

      for( Int i=0; i < numModesForFullRD; i++ )
      {
        CandCostList[ i ] = MAX_DOUBLE;
      }
      CandNum = 0;

      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt uiAbsPartIdx=tuRecurseWithPU.GetAbsPartIdxTU();

      Pel* piOrg         = pcOrgYuv ->getAddr( COMPONENT_Y, uiAbsPartIdx );
      Pel* piPred        = pcPredYuv->getAddr( COMPONENT_Y, uiAbsPartIdx );
      UInt uiStride      = pcPredYuv->getStride( COMPONENT_Y );
      DistParam distParam;
      const Bool bUseHadamard=pcCU->getCUTransquantBypass(0) == 0;
      m_pcRdCost->setDistParam(distParam, sps.getBitDepth(CHANNEL_TYPE_LUMA), piOrg, uiStride, piPred, uiStride, puRect.width, puRect.height, bUseHadamard);
      distParam.bApplyWeight = false;
      for( Int modeIdx = 0; modeIdx < numModesAvailable; modeIdx++ )
      {
        UInt       uiMode = modeIdx;
        Distortion uiSad  = 0;

        const Bool bUseFilter=TComPrediction::filteringIntraReferenceSamples(COMPONENT_Y, uiMode, puRect.width, puRect.height, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

        predIntraAng( COMPONENT_Y, uiMode, piOrg, uiStride, piPred, uiStride, tuRecurseWithPU, bUseFilter, TComPrediction::UseDPCMForFirstPassIntraEstimation(tuRecurseWithPU, uiMode) );

        // use hadamard transform here
        uiSad+=distParam.DistFunc(&distParam);

        UInt   iModeBits = 0;

        // NB xModeBitsIntra will not affect the mode for chroma that may have already been pre-estimated.
        iModeBits+=xModeBitsIntra( pcCU, uiMode, uiPartOffset, uiDepth, CHANNEL_TYPE_LUMA );

        Double cost      = (Double)uiSad + (Double)iModeBits * sqrtLambdaForFirstPass;

#if DEBUG_INTRA_SEARCH_COSTS
        std::cout << "1st pass mode " << uiMode << " SAD = " << uiSad << ", mode bits = " << iModeBits << ", cost = " << cost << "\n";
#endif

        CandNum += xUpdateCandList( uiMode, cost, numModesForFullRD, uiRdModeList, CandCostList );
      }

      if (m_pcEncCfg->getFastUDIUseMPMEnabled())
      {
        Int uiPreds[NUM_MOST_PROBABLE_MODES] = {-1, -1, -1};

        Int iMode = -1;
        pcCU->getIntraDirPredictor( uiPartOffset, uiPreds, COMPONENT_Y, &iMode );

        const Int numCand = ( iMode >= 0 ) ? iMode : Int(NUM_MOST_PROBABLE_MODES);

        for( Int j=0; j < numCand; j++)
        {
          Bool mostProbableModeIncluded = false;
          Int mostProbableMode = uiPreds[j];

          for( Int i=0; i < numModesForFullRD; i++)
          {
            mostProbableModeIncluded |= (mostProbableMode == uiRdModeList[i]);
          }
          if (!mostProbableModeIncluded)
          {
            uiRdModeList[numModesForFullRD++] = mostProbableMode;
          }
        }
      }
    }
    else
    {
      for( Int i=0; i < numModesForFullRD; i++)
      {
        uiRdModeList[i] = i;
      }
    }

    //===== check modes (using r-d costs) =====
#if HHI_RQT_INTRA_SPEEDUP_MOD
    UInt   uiSecondBestMode  = MAX_UINT;
    Double dSecondBestPUCost = MAX_DOUBLE;
#endif
    DEBUG_STRING_NEW(sPU)
    UInt       uiBestPUMode  = 0;
    Distortion uiBestPUDistY = 0;
    Double     dBestPUCost   = MAX_DOUBLE;

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
    UInt max=numModesForFullRD;

    if (DebugOptionList::ForceLumaMode.isSet())
    {
      max=0;  // we are forcing a direction, so don't bother with mode check
    }
    for ( UInt uiMode = 0; uiMode < max; uiMode++)
#else
    for( UInt uiMode = 0; uiMode < numModesForFullRD; uiMode++ )
#endif
    {
      // set luma prediction mode
      UInt uiOrgMode = uiRdModeList[uiMode];

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );

      DEBUG_STRING_NEW(sMode)
      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, true, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#endif

#if DEBUG_INTRA_SEARCH_COSTS
      std::cout << "2nd pass [luma,chroma] mode [" << Int(pcCU->getIntraDir(CHANNEL_TYPE_LUMA, uiPartOffset)) << "," << Int(pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, uiPartOffset)) << "] cost = " << dPUCost << "\n";
#endif

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sMode)
#if HHI_RQT_INTRA_SPEEDUP_MOD
        uiSecondBestMode  = uiBestPUMode;
        dSecondBestPUCost = dBestPUCost;
#endif
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();

        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
#if HHI_RQT_INTRA_SPEEDUP_MOD
      else if( dPUCost < dSecondBestPUCost )
      {
        uiSecondBestMode  = uiOrgMode;
        dSecondBestPUCost = dPUCost;
      }
#endif
    } // Mode loop

#if HHI_RQT_INTRA_SPEEDUP
#if HHI_RQT_INTRA_SPEEDUP_MOD
    for( UInt ui =0; ui < 2; ++ui )
#endif
    {
#if HHI_RQT_INTRA_SPEEDUP_MOD
      UInt uiOrgMode   = ui ? uiSecondBestMode  : uiBestPUMode;
      if( uiOrgMode == MAX_UINT )
      {
        break;
      }
#else
      UInt uiOrgMode = uiBestPUMode;
#endif

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
      if (DebugOptionList::ForceLumaMode.isSet())
      {
        uiOrgMode = DebugOptionList::ForceLumaMode.getInt();
      }
#endif

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );
      DEBUG_STRING_NEW(sModeTree)

      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;

      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, false, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sModeTree));

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sModeTree)
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );

        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
    } // Mode loop
#endif

    DEBUG_STRING_APPEND(sDebug, sPU)

    //--- update overall distortion ---
    uiOverallDistY += uiBestPUDistY;

    //--- update transform index and cbf ---
    const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
    ::memcpy( pcCU->getTransformIdx()       + uiPartOffset, m_puhQTTempTrIdx,  uiQPartNum * sizeof( UChar ) );
    for (UInt component = 0; component < numberValidComponents; component++)
    {
      const ComponentID compID = ComponentID(component);
      ::memcpy( pcCU->getCbf( compID  ) + uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
      ::memcpy( pcCU->getTransformSkip( compID  ) + uiPartOffset, m_puhQTTempTransformSkipFlag[compID ], uiQPartNum * sizeof( UChar ) );
    }

    //--- set reconstruction for next intra prediction blocks ---
    if( !tuRecurseWithPU.IsLastSection() )
    {
      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt  uiCompWidth   = puRect.width;
      const UInt  uiCompHeight  = puRect.height;

      const UInt  uiZOrder      = pcCU->getZorderIdxInCtu() + uiPartOffset;
            Pel*  piDes         = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
      const UInt  uiDesStride   = pcCU->getPic()->getPicYuvRec()->getStride( COMPONENT_Y);
      const Pel*  piSrc         = pcRecoYuv->getAddr( COMPONENT_Y, uiPartOffset );
      const UInt  uiSrcStride   = pcRecoYuv->getStride( COMPONENT_Y);

      for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
      {
        for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
        {
          piDes[ uiX ] = piSrc[ uiX ];
        }
      }
    }

    //=== update PU data ====
    pcCU->setIntraDirSubParts     ( CHANNEL_TYPE_LUMA, uiBestPUMode, uiPartOffset, uiDepth + uiInitTrDepth );
	
  } while (tuRecurseWithPU.nextSection(tuRecurseCU));


  if( uiNumPU > 1 )
  { // set Cbf for all blocks
    UInt uiCombCbfY = 0;
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfY |= pcCU->getCbf( uiPartIdx, COMPONENT_Y,  1 );
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Y  )[ uiOffs ] |= uiCombCbfY;
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  //===== reset context models =====
  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  //===== set distortion (rate and r-d costs are determined later) =====
  pcCU->getTotalDistortion() = uiOverallDistY;
}




Void
TEncSearch::estIntraPredChromaQT(TComDataCU* pcCU,
                                 TComYuv*    pcOrgYuv,
                                 TComYuv*    pcPredYuv,
                                 TComYuv*    pcResiYuv,
                                 TComYuv*    pcRecoYuv,
                                 Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                                 DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt    uiInitTrDepth  = pcCU->getPartitionSize(0) != SIZE_2Nx2N && enable4ChromaPUsInIntraNxNCU(pcOrgYuv->getChromaFormat()) ? 1 : 0;

  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);
  const UInt    uiQNumParts    = tuRecurseWithPU.GetAbsPartIdxNumParts();
  const UInt    uiDepthCU=tuRecurseWithPU.getCUDepth();
  const UInt    numberValidComponents = pcCU->getPic()->getNumberValidComponents();

  do
  {
    UInt       uiBestMode  = 0;
    Distortion uiBestDist  = 0;
    Double     dBestCost   = MAX_DOUBLE;

    //----- init mode list -----
    if (tuRecurseWithPU.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      UInt uiModeList[FAST_UDI_MAX_RDMODE_NUM];
      const UInt  uiQPartNum     = uiQNumParts;
      const UInt  uiPartOffset   = tuRecurseWithPU.GetAbsPartIdxTU();
      {
        UInt  uiMinMode = 0;
        UInt  uiMaxMode = NUM_CHROMA_MODE;

        //----- check chroma modes -----
        pcCU->getAllowedChromaDir( uiPartOffset, uiModeList );

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
        if (DebugOptionList::ForceChromaMode.isSet())
        {
          uiMinMode=DebugOptionList::ForceChromaMode.getInt();
          if (uiModeList[uiMinMode]==34)
          {
            uiMinMode=4; // if the fixed mode has been renumbered because DM_CHROMA covers it, use DM_CHROMA.
          }
          uiMaxMode=uiMinMode+1;
        }
#endif

        DEBUG_STRING_NEW(sPU)

        for( UInt uiMode = uiMinMode; uiMode < uiMaxMode; uiMode++ )
        {
          //----- restore context models -----
          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          
          DEBUG_STRING_NEW(sMode)
          //----- chroma coding -----
          Distortion uiDist = 0;
          pcCU->setIntraDirSubParts  ( CHANNEL_TYPE_CHROMA, uiModeList[uiMode], uiPartOffset, uiDepthCU+uiInitTrDepth );
          xRecurIntraChromaCodingQT       ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );

          if( pcCU->getSlice()->getPPS()->getUseTransformSkip() )
          {
            m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          }

          UInt    uiBits = xGetIntraBitsQT( tuRecurseWithPU, false, true, false );
          Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );

          //----- compare -----
          if( dCost < dBestCost )
          {
            DEBUG_STRING_SWAP(sPU, sMode);
            dBestCost   = dCost;
            uiBestDist  = uiDist;
            uiBestMode  = uiModeList[uiMode];

            xSetIntraResultChromaQT( pcRecoYuv, tuRecurseWithPU );
            for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
            {
              const ComponentID compID = ComponentID(componentIndex);
              ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_puhQTTempTransformSkipFlag[compID], pcCU->getTransformSkip( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_phQTTempCrossComponentPredictionAlpha[compID], pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, uiQPartNum * sizeof( SChar ) );
            }
          }
        }

        DEBUG_STRING_APPEND(sDebug, sPU)

        //----- set data -----
        for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
        {
          const ComponentID compID = ComponentID(componentIndex);
          ::memcpy( pcCU->getCbf( compID )+uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getTransformSkip( compID )+uiPartOffset, m_puhQTTempTransformSkipFlag[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, m_phQTTempCrossComponentPredictionAlpha[compID], uiQPartNum * sizeof( SChar ) );
        }
      }

      if( ! tuRecurseWithPU.IsLastSection() )
      {
        for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
        {
          const ComponentID compID    = ComponentID(ch);
          const TComRectangle &tuRect = tuRecurseWithPU.getRect(compID);
          const UInt  uiCompWidth     = tuRect.width;
          const UInt  uiCompHeight    = tuRect.height;
          const UInt  uiZOrder        = pcCU->getZorderIdxInCtu() + tuRecurseWithPU.GetAbsPartIdxTU();
                Pel*  piDes           = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
          const UInt  uiDesStride     = pcCU->getPic()->getPicYuvRec()->getStride( compID);
          const Pel*  piSrc           = pcRecoYuv->getAddr( compID, uiPartOffset );
          const UInt  uiSrcStride     = pcRecoYuv->getStride( compID);

          for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
          {
            for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
            {
              piDes[ uiX ] = piSrc[ uiX ];
            }
          }
        }
      }

      pcCU->setIntraDirSubParts( CHANNEL_TYPE_CHROMA, uiBestMode, uiPartOffset, uiDepthCU+uiInitTrDepth );
      pcCU->getTotalDistortion      () += uiBestDist;
    }

  } while (tuRecurseWithPU.nextSection(tuRecurseCU));

  //----- restore context models -----

  if( uiInitTrDepth != 0 )
  { // set Cbf for all blocks
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
}




/** Function for encoding and reconstructing luma/chroma samples of a PCM mode CU.
 * \param pcCU pointer to current CU
 * \param uiAbsPartIdx part index
 * \param pOrg pointer to original sample arrays
 * \param pPCM pointer to PCM code arrays
 * \param pPred pointer to prediction signal arrays
 * \param pResi pointer to residual signal arrays
 * \param pReco pointer to reconstructed sample arrays
 * \param uiStride stride of the original/prediction/residual sample arrays
 * \param uiWidth block width
 * \param uiHeight block height
 * \param compID texture component type
 */
Void TEncSearch::xEncPCM (TComDataCU* pcCU, UInt uiAbsPartIdx, Pel* pOrg, Pel* pPCM, Pel* pPred, Pel* pResi, Pel* pReco, UInt uiStride, UInt uiWidth, UInt uiHeight, const ComponentID compID )
{
  const UInt uiReconStride   = pcCU->getPic()->getPicYuvRec()->getStride(compID);
  const UInt uiPCMBitDepth   = pcCU->getSlice()->getSPS()->getPCMBitDepth(toChannelType(compID));
  const Int  channelBitDepth = pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
  Pel* pRecoPic = pcCU->getPic()->getPicYuvRec()->getAddr(compID, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu()+uiAbsPartIdx);

  const Int pcmShiftRight=(channelBitDepth - Int(uiPCMBitDepth));

  assert(pcmShiftRight >= 0);

  for( UInt uiY = 0; uiY < uiHeight; uiY++ )
  {
    for( UInt uiX = 0; uiX < uiWidth; uiX++ )
    {
      // Reset pred and residual
      pPred[uiX] = 0;
      pResi[uiX] = 0;
      // Encode
      pPCM[uiX] = (pOrg[uiX]>>pcmShiftRight);
      // Reconstruction
      pReco   [uiX] = (pPCM[uiX]<<(pcmShiftRight));
      pRecoPic[uiX] = pReco[uiX];
    }
    pPred += uiStride;
    pResi += uiStride;
    pPCM += uiWidth;
    pOrg += uiStride;
    pReco += uiStride;
    pRecoPic += uiReconStride;
  }
}


//!  Function for PCM mode estimation.
Void TEncSearch::IPCMSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv )
{
  UInt              uiDepth      = pcCU->getDepth(0);
  const Distortion  uiDistortion = 0;
  UInt              uiBits;

  Double dCost;

  for (UInt ch=0; ch < pcCU->getPic()->getNumberValidComponents(); ch++)
  {
    const ComponentID compID  = ComponentID(ch);
    const UInt width  = pcCU->getWidth(0)  >> pcCU->getPic()->getComponentScaleX(compID);
    const UInt height = pcCU->getHeight(0) >> pcCU->getPic()->getComponentScaleY(compID);
    const UInt stride = pcPredYuv->getStride(compID);

    Pel * pOrig    = pcOrgYuv->getAddr  (compID, 0, width);
    Pel * pResi    = pcResiYuv->getAddr(compID, 0, width);
    Pel * pPred    = pcPredYuv->getAddr(compID, 0, width);
    Pel * pReco    = pcRecoYuv->getAddr(compID, 0, width);
    Pel * pPCM     = pcCU->getPCMSample (compID);

    xEncPCM ( pcCU, 0, pOrig, pPCM, pPred, pResi, pReco, stride, width, height, compID );

  }

  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiDepth, 0, true, false);
  uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  dCost = m_pcRdCost->calcRdCost( uiBits, uiDistortion );

  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  pcCU->getTotalBits()       = uiBits;
  pcCU->getTotalCost()       = dCost;
  pcCU->getTotalDistortion() = uiDistortion;

  pcCU->copyToPic(uiDepth);
}




Void TEncSearch::xGetInterPredictionError( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, Distortion& ruiErr, Bool /*bHadamard*/ )
{
  motionCompensation( pcCU, &m_tmpYuvPred, REF_PIC_LIST_X, iPartIdx );

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;
  pcCU->getPartIndexAndSize( iPartIdx, uiAbsPartIdx, iWidth, iHeight );

  DistParam cDistParam;

  cDistParam.bApplyWeight = false;


  m_pcRdCost->setDistParam( cDistParam, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA),
                            pcYuvOrg->getAddr( COMPONENT_Y, uiAbsPartIdx ), pcYuvOrg->getStride(COMPONENT_Y),
                            m_tmpYuvPred .getAddr( COMPONENT_Y, uiAbsPartIdx ), m_tmpYuvPred.getStride(COMPONENT_Y),
                            iWidth, iHeight, m_pcEncCfg->getUseHADME() && (pcCU->getCUTransquantBypass(iPartIdx) == 0) );

  ruiErr = cDistParam.DistFunc( &cDistParam );
}

//! estimation of best merge coding
Void TEncSearch::xMergeEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPUIdx, UInt& uiInterDir, TComMvField* pacMvField, UInt& uiMergeIndex, Distortion& ruiCost, TComMvField* cMvFieldNeighbours, UChar* uhInterDirNeighbours, Int& numValidMergeCand )
{
	//ofstream myfile;

	//myfile.open("C:\\RACEHOECES2_CTU.csv", ios::app);

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;

 
  pcCU->getPartIndexAndSize( iPUIdx, uiAbsPartIdx, iWidth, iHeight );
  UInt uiDepth = pcCU->getDepth( uiAbsPartIdx );
 // CTUH1 = iHeight;
 // CTUW1 = iWidth;
 // myfile << CTUH1 << ',' << CTUW1 << endl;
  PartSize partSize = pcCU->getPartitionSize( 0 );
  if ( pcCU->getSlice()->getPPS()->getLog2ParallelMergeLevelMinus2() && partSize != SIZE_2Nx2N && pcCU->getWidth( 0 ) <= 8 )
  {
    if ( iPUIdx == 0 )
    {
      pcCU->setPartSizeSubParts( SIZE_2Nx2N, 0, uiDepth ); // temporarily set
      pcCU->getInterMergeCandidates( 0, 0, cMvFieldNeighbours,uhInterDirNeighbours, numValidMergeCand );
      pcCU->setPartSizeSubParts( partSize, 0, uiDepth ); // restore
    }
  }
  else
  {
    pcCU->getInterMergeCandidates( uiAbsPartIdx, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );
  }

  xRestrictBipredMergeCand( pcCU, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );

  ruiCost = std::numeric_limits<Distortion>::max();
  for( UInt uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )
  {
    Distortion uiCostCand = std::numeric_limits<Distortion>::max();
    UInt       uiBitsCand = 0;

    PartSize ePartSize = pcCU->getPartitionSize( 0 );

    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( cMvFieldNeighbours[0 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( cMvFieldNeighbours[1 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );

    xGetInterPredictionError( pcCU, pcYuvOrg, iPUIdx, uiCostCand, m_pcEncCfg->getUseHADME() );
    uiBitsCand = uiMergeCand + 1;
    if (uiMergeCand == m_pcEncCfg->getMaxNumMergeCand() -1)
    {
        uiBitsCand--;
    }
    uiCostCand = uiCostCand + m_pcRdCost->getCost( uiBitsCand );
    if ( uiCostCand < ruiCost )
    {
      ruiCost = uiCostCand;
      pacMvField[0] = cMvFieldNeighbours[0 + 2*uiMergeCand];
      pacMvField[1] = cMvFieldNeighbours[1 + 2*uiMergeCand];
      uiInterDir = uhInterDirNeighbours[uiMergeCand];
      uiMergeIndex = uiMergeCand;
    }
  }
 
}

/** convert bi-pred merge candidates to uni-pred
 * \param pcCU
 * \param puIdx
 * \param mvFieldNeighbours
 * \param interDirNeighbours
 * \param numValidMergeCand
 * \returns Void
 */
Void TEncSearch::xRestrictBipredMergeCand( TComDataCU* pcCU, UInt puIdx, TComMvField* mvFieldNeighbours, UChar* interDirNeighbours, Int numValidMergeCand )
{
	
  if ( pcCU->isBipredRestriction(puIdx) )
  {
    for( UInt mergeCand = 0; mergeCand < numValidMergeCand; ++mergeCand )
    {
      if ( interDirNeighbours[mergeCand] == 3 )
      {
        interDirNeighbours[mergeCand] = 1;
        mvFieldNeighbours[(mergeCand << 1) + 1].setMvField(TComMv(0,0), -1);
      }
    }
  }
}

//! search of the best candidate for inter prediction
#if AMP_MRG
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv DEBUG_STRING_FN_DECLARE(sDebug), Bool bUseRes, Bool bUseMRG )
#else
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv, Bool bUseRes )
#endif
{
  for(UInt i=0; i<NUM_REF_PIC_LIST_01; i++)
  {
    m_acYuvPred[i].clear();
  }
  m_cYuvPredTemp.clear();
  pcPredYuv->clear();

  if ( !bUseRes )
  {
    pcResiYuv->clear();
  }

  pcRecoYuv->clear();
  
 // ofstream myfile;

//  myfile.open("C:\\RACEHOECES1_CTU.csv", ios::app);
  TComMv       cMvSrchRngLT;
  TComMv       cMvSrchRngRB;

  TComMv       cMvZero;
  TComMv       TempMv; //kolya

  TComMv       cMv[2];
  TComMv       cMvBi[2];
  TComMv       cMvTemp[2][33];

  Int          iNumPart    = pcCU->getNumPartitions();
  Int          iNumPredDir = pcCU->getSlice()->isInterP() ? 1 : 2;

  TComMv       cMvPred[2][33];

  TComMv       cMvPredBi[2][33];
  Int          aaiMvpIdxBi[2][33];

  Int          aaiMvpIdx[2][33];
  Int          aaiMvpNum[2][33];

  AMVPInfo     aacAMVPInfo[2][33];

  Int          iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
  Int          iRefIdxBi[2];

  UInt         uiPartAddr;
  Int          iRoiWidth, iRoiHeight;

  UInt         uiMbBits[3] = {1, 1, 0};

  UInt         uiLastMode = 0;
  Int          iRefStart, iRefEnd;

  PartSize     ePartSize = pcCU->getPartitionSize( 0 );

  Int          bestBiPRefIdxL1 = 0;
  Int          bestBiPMvpL1 = 0;
  Distortion   biPDistTemp = std::numeric_limits<Distortion>::max();
  counter_ME = counter_ME + 1;

  TComMvField cMvFieldNeighbours[MRG_MAX_NUM_CANDS << 1]; // double length for mv of both lists
  UChar uhInterDirNeighbours[MRG_MAX_NUM_CANDS];
  Int numValidMergeCand = 0 ;

  for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
  {
    Distortion   uiCost[2] = { std::numeric_limits<Distortion>::max(), std::numeric_limits<Distortion>::max() };
    Distortion   uiCostBi  =   std::numeric_limits<Distortion>::max();
    Distortion   uiCostTemp;

    UInt         uiBits[3];
    UInt         uiBitsTemp;
    Distortion   bestBiPDist = std::numeric_limits<Distortion>::max();

    Distortion   uiCostTempL0[MAX_NUM_REF];
    for (Int iNumRef=0; iNumRef < MAX_NUM_REF; iNumRef++)
    {
      uiCostTempL0[iNumRef] = std::numeric_limits<Distortion>::max();
    }
    UInt         uiBitsTempL0[MAX_NUM_REF];

    TComMv       mvValidList1;
    Int          refIdxValidList1 = 0;
    UInt         bitsValidList1 = MAX_UINT;
    Distortion   costValidList1 = std::numeric_limits<Distortion>::max();

    xGetBlkBits( ePartSize, pcCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);

    pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
	
	
#if AMP_MRG
    Bool bTestNormalMC = true;

    if ( bUseMRG && pcCU->getWidth( 0 ) > 8 && iNumPart == 2 )
    {
      bTestNormalMC = false;
    }

    if (bTestNormalMC)
    {
#endif

    //  Uni-directional prediction
    for ( Int iRefList = 0; iRefList < iNumPredDir; iRefList++ )
    {
      RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

      for ( Int iRefIdxTemp = 0; iRefIdxTemp < pcCU->getSlice()->getNumRefIdx(eRefPicList); iRefIdxTemp++ )
      {
        uiBitsTemp = uiMbBits[iRefList];
        if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
        {
          uiBitsTemp += iRefIdxTemp+1;
          if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
          {
            uiBitsTemp--;
          }
        }
        xEstimateMvPredAMVP( pcCU, pcOrgYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
        aaiMvpIdx[iRefList][iRefIdxTemp] = pcCU->getMVPIdx(eRefPicList, uiPartAddr);
        aaiMvpNum[iRefList][iRefIdxTemp] = pcCU->getMVPNum(eRefPicList, uiPartAddr);

        if(pcCU->getSlice()->getMvdL1ZeroFlag() && iRefList==1 && biPDistTemp < bestBiPDist)
        {
          bestBiPDist = biPDistTemp;
          bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
          bestBiPRefIdxL1 = iRefIdxTemp;
        }

        uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];

        if ( m_pcEncCfg->getFastMEForGenBLowDelayEnabled() && iRefList == 1 )    // list 1
        {
          if ( pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) >= 0 )
          {
            cMvTemp[1][iRefIdxTemp] = cMvTemp[0][pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            uiCostTemp = uiCostTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            /*first subtract the bit-rate part of the cost of the other list*/
            uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )] );
            /*correct the bit-rate part of the current ref*/
            m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
            uiBitsTemp += m_pcRdCost->getBitsOfVectorWithPredictor( cMvTemp[1][iRefIdxTemp].getHor(), cMvTemp[1][iRefIdxTemp].getVer() );
            /*calculate the correct cost*/
            uiCostTemp += m_pcRdCost->getCost( uiBitsTemp );
          }
          else
          {
            xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
          }
        }
        else
        {
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
        }
        xCopyAMVPInfo(pcCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
        xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

        if ( iRefList == 0 )
        {
          uiCostTempL0[iRefIdxTemp] = uiCostTemp;
          uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
        }
        if ( uiCostTemp < uiCost[iRefList] )
        {
          uiCost[iRefList] = uiCostTemp;
          uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

          // set motion
          cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
          iRefIdx[iRefList] = iRefIdxTemp;
        }

        if ( iRefList == 1 && uiCostTemp < costValidList1 && pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
        {
          costValidList1 = uiCostTemp;
          bitsValidList1 = uiBitsTemp;

          // set motion
          mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
          refIdxValidList1 = iRefIdxTemp;
        }
      }
    }

    //  Bi-predictive Motion estimation
    if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )
    {

      cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
      iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];

      ::memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
      ::memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));

      UInt uiMotBits[2];

      if(pcCU->getSlice()->getMvdL1ZeroFlag())
      {
        xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
        pcCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
        cMvPredBi[1][bestBiPRefIdxL1]   = pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo()->m_acMvCand[bestBiPMvpL1];

        cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
        iRefIdxBi[1] = bestBiPRefIdxL1;
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        TComYuv* pcYuvPred = &m_acYuvPred[REF_PIC_LIST_1];
        motionCompensation( pcCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );

        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiMbBits[1];

        if ( pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1) > 1 )
        {
          uiMotBits[1] += bestBiPRefIdxL1+1;
          if ( bestBiPRefIdxL1 == pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1)-1 )
          {
            uiMotBits[1]--;
          }
        }

        uiMotBits[1] += m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][AMVP_MAX_NUM_CANDS];

        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

        cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
      }
      else
      {
        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiBits[1] - uiMbBits[1];
        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
      }

      // 4-times iteration (default)
      Int iNumIter = 4;

      // fast encoder setting: only one iteration
      if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 || pcCU->getSlice()->getMvdL1ZeroFlag() )
      {
        iNumIter = 1;
      }

      for ( Int iIter = 0; iIter < iNumIter; iIter++ )
      {
        Int         iRefList    = iIter % 2;

        if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 )
        {
          if( uiCost[0] <= uiCost[1] )
          {
            iRefList = 1;
          }
          else
          {
            iRefList = 0;
          }
        }
        else if ( iIter == 0 )
        {
          iRefList = 0;
        }
        if ( iIter == 0 && !pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllMv( cMv[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllRefIdx( iRefIdx[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          TComYuv*  pcYuvPred = &m_acYuvPred[1-iRefList];
          motionCompensation ( pcCU, pcYuvPred, RefPicList(1-iRefList), iPartIdx );
        }

        RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

        if(pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          iRefList = 0;
          eRefPicList = REF_PIC_LIST_0;
        }

        Bool bChanged = false;

        iRefStart = 0;
        iRefEnd   = pcCU->getSlice()->getNumRefIdx(eRefPicList)-1;

        for ( Int iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
        {
          uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
          if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
          {
            uiBitsTemp += iRefIdxTemp+1;
            if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
            {
              uiBitsTemp--;
            }
          }
          uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];
          // call ME
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );

          xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], pcCU->getCUMvField(eRefPicList)->getAMVPInfo());
          xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

          if ( uiCostTemp < uiCostBi )
          {
            bChanged = true;

            cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
            iRefIdxBi[iRefList] = iRefIdxTemp;

            uiCostBi            = uiCostTemp;
            uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
            uiBits[2]           = uiBitsTemp;

            if(iNumIter!=1)
            {
              //  Set motion
              pcCU->getCUMvField( eRefPicList )->setAllMv( cMvBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
              pcCU->getCUMvField( eRefPicList )->setAllRefIdx( iRefIdxBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );

              TComYuv* pcYuvPred = &m_acYuvPred[iRefList];
              motionCompensation( pcCU, pcYuvPred, eRefPicList, iPartIdx );
            }
          }
        } // for loop-iRefIdxTemp

        if ( !bChanged )
        {
          if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
          {
            xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
            xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
            if(!pcCU->getSlice()->getMvdL1ZeroFlag())
            {
              xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
              xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
            }
          }
          break;
        }
      } // for loop-iter
    } // if (B_SLICE)

#if AMP_MRG
    } //end if bTestNormalMC
#endif
    //  Clear Motion Field
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );

    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

    UInt uiMEBits = 0;
    // Set Motion Field_
    cMv[1] = mvValidList1;
	
    iRefIdx[1] = refIdxValidList1;
    uiBits[1] = bitsValidList1;
    uiCost[1] = costValidList1;

#if AMP_MRG
    if (bTestNormalMC)
    {
#endif
    if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
    {
      uiLastMode = 2;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMvBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdxBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 3, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[2];
    }
    else if ( uiCost[0] <= uiCost[1] )
    {
      uiLastMode = 0;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[0];
    }
    else
    {
      uiLastMode = 1;
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMv[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdx[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 2, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[1];
    }
#if AMP_MRG
    } // end if bTestNormalMC
#endif

    if ( pcCU->getPartitionSize( uiPartAddr ) != SIZE_2Nx2N )
    {
      UInt uiMRGInterDir = 0;
      TComMvField cMRGMvField[2];
      UInt uiMRGIndex = 0;

      UInt uiMEInterDir = 0;
      TComMvField cMEMvField[2];

      m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

#if AMP_MRG
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      Distortion uiMECost  = std::numeric_limits<Distortion>::max();

      if (bTestNormalMC)
      {
        xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
        uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
      }
#else
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
      Distortion uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
#endif
      // save ME result.
      uiMEInterDir = pcCU->getInterDir( uiPartAddr );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

      // find Merge result
      Distortion uiMRGCost = std::numeric_limits<Distortion>::max();

      xMergeEstimation( pcCU, pcOrgYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);

      if ( uiMRGCost < uiMECost )
      {
        // set Merge result
        pcCU->setMergeFlagSubParts ( true,          uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setMergeIndexSubParts( uiMRGIndex,    uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts  ( uiMRGInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMRGMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMRGMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      }
      else
      {
        // set ME result
        pcCU->setMergeFlagSubParts( false,        uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts ( uiMEInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMEMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMEMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );
      }
    }

    //  MC
    motionCompensation ( pcCU, pcPredYuv, REF_PIC_LIST_X, iPartIdx );

  } //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )

  setWpScalingDistParam( pcCU, -1, REF_PIC_LIST_X );
 // CTUW = iRoiWidth;
 // CTUH = iRoiHeight;
 // myfile << CTUH << ',' << CTUW << endl;
  return;
}


// AMVP
Void TEncSearch::xEstimateMvPredAMVP( TComDataCU* pcCU, TComYuv* pcOrgYuv, UInt uiPartIdx, RefPicList eRefPicList, Int iRefIdx, TComMv& rcMvPred, Bool bFilled, Distortion* puiDistBiP )
{
	
	//ofstream myfile;

	//myfile.open("C:\\RACEHOECES3_CTU.csv", ios::app);
  AMVPInfo*  pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();

  TComMv     cBestMv;
  Int        iBestIdx   = 0;
  TComMv     cZeroMv;
  TComMv     cMvPred;
  Distortion uiBestCost = std::numeric_limits<Distortion>::max();
  UInt       uiPartAddr = 0;
  Int        iRoiWidth, iRoiHeight;
  Int        i;
 
  pcCU->getPartIndexAndSize( uiPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
 

  // Fill the MV Candidates
  if (!bFilled)
  {
    pcCU->fillMvpCand( uiPartIdx, uiPartAddr, eRefPicList, iRefIdx, pcAMVPInfo );
  }

  // initialize Mvp index & Mvp
  iBestIdx = 0;
  cBestMv  = pcAMVPInfo->m_acMvCand[0];
  if (pcAMVPInfo->iN <= 1)
  {
    rcMvPred = cBestMv;

    pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));

    if(pcCU->getSlice()->getMvdL1ZeroFlag() && eRefPicList==REF_PIC_LIST_1)
    {
      (*puiDistBiP) = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, rcMvPred, 0, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    }
    return;
  }

  if (bFilled)
  {
    assert(pcCU->getMVPIdx(eRefPicList,uiPartAddr) >= 0);
    rcMvPred = pcAMVPInfo->m_acMvCand[pcCU->getMVPIdx(eRefPicList,uiPartAddr)];
    return;
  }

  m_cYuvPredTemp.clear();
  //-- Check Minimum Cost.
  for ( i = 0 ; i < pcAMVPInfo->iN; i++)
  {
    Distortion uiTmpCost;
    uiTmpCost = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, pcAMVPInfo->m_acMvCand[i], i, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    if ( uiBestCost > uiTmpCost )
    {
      uiBestCost = uiTmpCost;
      cBestMv   = pcAMVPInfo->m_acMvCand[i];
      iBestIdx  = i;
      (*puiDistBiP) = uiTmpCost;
    }
  }

  m_cYuvPredTemp.clear();

  // Setting Best MVP
  rcMvPred = cBestMv;
  pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  CTUW2 = iRoiWidth;
  CTUH2 = iRoiHeight;

//  myfile << CTUH2 << ',' << CTUW2 << endl;
  return;
  
}

UInt TEncSearch::xGetMvpIdxBits(Int iIdx, Int iNum)
{
  assert(iIdx >= 0 && iNum >= 0 && iIdx < iNum);

  if (iNum == 1)
  {
    return 0;
  }

  UInt uiLength = 1;
  Int iTemp = iIdx;
  if ( iTemp == 0 )
  {
    return uiLength;
  }

  Bool bCodeLast = ( iNum-1 > iTemp );

  uiLength += (iTemp-1);

  if( bCodeLast )
  {
    uiLength++;
  }

  return uiLength;
}

Void TEncSearch::xGetBlkBits( PartSize eCUMode, Bool bPSlice, Int iPartIdx, UInt uiLastMode, UInt uiBlkBit[3])
{
  if ( eCUMode == SIZE_2Nx2N )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else if ( (eCUMode == SIZE_2NxN || eCUMode == SIZE_2NxnU) || eCUMode == SIZE_2NxnD )
  {
    UInt aauiMbBits[2][3][3] = { { {0,0,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7,5,7}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( (eCUMode == SIZE_Nx2N || eCUMode == SIZE_nLx2N) || eCUMode == SIZE_nRx2N )
  {
    UInt aauiMbBits[2][3][3] = { { {0,2,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7-2,7-2,9-2}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( eCUMode == SIZE_NxN )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else
  {
    printf("Wrong!\n");
    assert( 0 );
  }
}

Void TEncSearch::xCopyAMVPInfo (AMVPInfo* pSrc, AMVPInfo* pDst)
{
  pDst->iN = pSrc->iN;
  for (Int i = 0; i < pSrc->iN; i++)
  {
    pDst->m_acMvCand[i] = pSrc->m_acMvCand[i];
  }
}

Void TEncSearch::xCheckBestMVP ( TComDataCU* pcCU, RefPicList eRefPicList, TComMv cMv, TComMv& rcMvPred, Int& riMVPIdx, UInt& ruiBits, Distortion& ruiCost )
{
  AMVPInfo* pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();
  
  assert(pcAMVPInfo->m_acMvCand[riMVPIdx] == rcMvPred);

  if (pcAMVPInfo->iN < 2)
  {
    return;
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(0) );
  m_pcRdCost->setCostScale ( 0    );

  Int iBestMVPIdx = riMVPIdx;

  m_pcRdCost->setPredictor( rcMvPred );
  Int iOrgMvBits  = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
  iOrgMvBits += m_auiMVPIdxCost[riMVPIdx][AMVP_MAX_NUM_CANDS];
  Int iBestMvBits = iOrgMvBits;

  for (Int iMVPIdx = 0; iMVPIdx < pcAMVPInfo->iN; iMVPIdx++)
  {
    if (iMVPIdx == riMVPIdx)
    {
      continue;
    }

    m_pcRdCost->setPredictor( pcAMVPInfo->m_acMvCand[iMVPIdx] );

    Int iMvBits = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
    iMvBits += m_auiMVPIdxCost[iMVPIdx][AMVP_MAX_NUM_CANDS];

    if (iMvBits < iBestMvBits)
    {
      iBestMvBits = iMvBits;
      iBestMVPIdx = iMVPIdx;
    }
  }

  if (iBestMVPIdx != riMVPIdx)  //if changed
  {
    rcMvPred = pcAMVPInfo->m_acMvCand[iBestMVPIdx];

    riMVPIdx = iBestMVPIdx;
    UInt uiOrgBits = ruiBits;
    ruiBits = uiOrgBits - iOrgMvBits + iBestMvBits;
    ruiCost = (ruiCost - m_pcRdCost->getCost( uiOrgBits ))  + m_pcRdCost->getCost( ruiBits );
  }
  
}


Distortion TEncSearch::xGetTemplateCost( TComDataCU* pcCU,
                                         UInt        uiPartAddr,
                                         TComYuv*    pcOrgYuv,
                                         TComYuv*    pcTemplateCand,
                                         TComMv      cMvCand,
                                         Int         iMVPIdx,
                                         Int         iMVPNum,
                                         RefPicList  eRefPicList,
                                         Int         iRefIdx,
                                         Int         iSizeX,
                                         Int         iSizeY
                                         )
{
  Distortion uiCost = std::numeric_limits<Distortion>::max();

  TComPicYuv* pcPicYuvRef = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdx )->getPicYuvRec();

  pcCU->clipMv( cMvCand );

  // prediction pattern
  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, true, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }
  else
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, false, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }

  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xWeightedPredictionUni( pcCU, pcTemplateCand, uiPartAddr, iSizeX, iSizeY, eRefPicList, pcTemplateCand, iRefIdx );
  }

  // calc distortion

  uiCost = m_pcRdCost->getDistPart( pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA), pcTemplateCand->getAddr(COMPONENT_Y, uiPartAddr), pcTemplateCand->getStride(COMPONENT_Y), pcOrgYuv->getAddr(COMPONENT_Y, uiPartAddr), pcOrgYuv->getStride(COMPONENT_Y), iSizeX, iSizeY, COMPONENT_Y, DF_SAD );
  uiCost = (UInt) m_pcRdCost->calcRdCost( m_auiMVPIdxCost[iMVPIdx][iMVPNum], uiCost, DF_SAD );
  return uiCost;
}


Void TEncSearch::xMotionEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, RefPicList eRefPicList, TComMv* pcMvPred, Int iRefIdxPred, TComMv& rcMv, UInt& ruiBits, Distortion& ruiCost, Bool bBi  )
{
  UInt          uiPartAddr;
  Int           iRoiWidth;
  Int           iRoiHeight;

  TComMv        cMvHalf, cMvQter;
  TComMv        cMvSrchRngLT;
  TComMv        cMvSrchRngRB;

  TComYuv*      pcYuv = pcYuvOrg;
 
 //ofstream myfile;
 // ofstream myfile2;
  //ofstream myfile3;
 // myfile.open("C:\\FB_CTU.csv", ios::app);
//  myfile2.open("C:\\BLOWINGBUBBLES_MV.csv", ios::app);
  
  
  assert(eRefPicList < MAX_NUM_REF_LIST_ADAPT_SR && iRefIdxPred<Int(MAX_IDX_ADAPT_SR));
  m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];

  Int           iSrchRng      = ( bBi ? m_bipredSearchRange : m_iSearchRange );
  TComPattern   tmpPattern;
  TComPattern*  pcPatternKey  = &tmpPattern;

  Double        fWeight       = 1.0;

  pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
  CH = iRoiHeight;
  CW = iRoiWidth;
 //myfile << CH << ',' << CW << endl;

  if ( bBi ) // Bipredictive ME
  {
    TComYuv*  pcYuvOther = &m_acYuvPred[1-(Int)eRefPicList];
    pcYuv                = &m_cYuvPredTemp;

    pcYuvOrg->copyPartToPartYuv( pcYuv, uiPartAddr, iRoiWidth, iRoiHeight );

    pcYuv->removeHighFreq( pcYuvOther, uiPartAddr, iRoiWidth, iRoiHeight, pcCU->getSlice()->getSPS()->getBitDepths().recon, m_pcEncCfg->getClipForBiPredMeEnabled() );

    fWeight = 0.5;
  }
  m_cDistParam.bIsBiPred = bBi;

  //  Search key pattern initialization
  pcPatternKey->initPattern( pcYuv->getAddr  ( COMPONENT_Y, uiPartAddr ),
                             iRoiWidth,
                             iRoiHeight,
                             pcYuv->getStride(COMPONENT_Y),
                             pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );

  Pel*        piRefY      = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu() + uiPartAddr );
  Int         iRefStride  = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getStride(COMPONENT_Y);

  TComMv      cMvPred = *pcMvPred;

  if ( bBi )
  {
	  
    xSetSearchRange   ( pcCU, rcMv   , iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }
  else
  {
	  
    xSetSearchRange   ( pcCU, cMvPred, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }

  m_pcRdCost->selectMotionLambda(true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setPredictor  ( *pcMvPred );
  m_pcRdCost->setCostScale  ( 2 );

  setWpScalingDistParam( pcCU, iRefIdxPred, eRefPicList );
  //  Do integer search
  if ( (m_motionEstimationSearchMethod==MESEARCH_FULL) || bBi )
  {
    xPatternSearch      ( pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost );
  }
  else
  {
    rcMv = *pcMvPred;
    const TComMv *pIntegerMv2Nx2NPred=0;
    if (pcCU->getPartitionSize(0) != SIZE_2Nx2N || pcCU->getDepth(0) != 0)
    {
      pIntegerMv2Nx2NPred = &(m_integerMv2Nx2N[eRefPicList][iRefIdxPred]);
    }
    xPatternSearchFast  ( pcCU, pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost, pIntegerMv2Nx2NPred );
    if (pcCU->getPartitionSize(0) == SIZE_2Nx2N)
    {
      m_integerMv2Nx2N[eRefPicList][iRefIdxPred] = rcMv;
    }
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );
  m_pcRdCost->setCostScale ( 1 );

  const Bool bIsLosslessCoded = pcCU->getCUTransquantBypass(uiPartAddr) != 0;
 xPatternSearchFracDIF( bIsLosslessCoded, pcPatternKey, piRefY, iRefStride, &rcMv, cMvHalf, cMvQter, ruiCost );

  m_pcRdCost->setCostScale( 0 );

  

 //myfile2 << rcMv.getHor() << ',' << rcMv.getVer() << ',' << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer()<<','<<cMvQter.getVer() << endl;

  TComMv MV_HALF;

  TComMv MV_QRTER;

  /*
 MV_HALF.setHor(MVX_HALF);
 MV_HALF.setVer(MVY_HALF);
 MV_QRTER.setHor(MVX_QRTER);
 MV_QRTER.setVer(MVY_QRTER);
 */

 
 MV_HALF.setHor(0);
 MV_HALF.setVer(0);
 MV_QRTER.setHor(0);
 MV_QRTER.setVer(0);
 
// ofstream myfile2;

  //myfile2.open("C:\\FB_MV.csv", ios::app);
// myfile2 << MV_HALF.getHor() << ',' << MV_QRTER.getHor() << ',' << MV_HALF.getVer() << ',' << MV_QRTER.getVer() << ',' << cMvHalf.getHor() << ',' << cMvQter.getHor() << ',' << cMvHalf.getVer() << ',' << cMvQter.getVer() << ','<<rcMv.getHor()<<','<<rcMv.getVer() <<endl;

  rcMv <<= 2;

 rcMv += (MV_HALF <<= 1);

  rcMv += MV_QRTER;
// rcMv += (cMvHalf <<= 1);
//rcMv += cMvQter;

  UInt uiMvBits = m_pcRdCost->getBitsOfVectorWithPredictor( rcMv.getHor(), rcMv.getVer() );

  ruiBits      += uiMvBits;
  ruiCost       = (Distortion)( floor( fWeight * ( (Double)ruiCost - (Double)m_pcRdCost->getCost( uiMvBits ) ) ) + (Double)m_pcRdCost->getCost( ruiBits ) );
}


Void TEncSearch::xSetSearchRange ( const TComDataCU* const pcCU, const TComMv& cMvPred, const Int iSrchRng,
                                   TComMv& rcMvSrchRngLT, TComMv& rcMvSrchRngRB )
{
  Int  iMvShift = 2;
  TComMv cTmpMvPred = cMvPred;
  pcCU->clipMv( cTmpMvPred );

  rcMvSrchRngLT.setHor( cTmpMvPred.getHor() - (iSrchRng << iMvShift) );
  rcMvSrchRngLT.setVer( cTmpMvPred.getVer() - (iSrchRng << iMvShift) );

  rcMvSrchRngRB.setHor( cTmpMvPred.getHor() + (iSrchRng << iMvShift) );
  rcMvSrchRngRB.setVer( cTmpMvPred.getVer() + (iSrchRng << iMvShift) );
  pcCU->clipMv        ( rcMvSrchRngLT );
  pcCU->clipMv        ( rcMvSrchRngRB );

#if ME_ENABLE_ROUNDING_OF_MVS
  rcMvSrchRngLT.divideByPowerOf2(iMvShift);
  rcMvSrchRngRB.divideByPowerOf2(iMvShift);
#else
  rcMvSrchRngLT >>= iMvShift;
  rcMvSrchRngRB >>= iMvShift;
#endif
}


Void TEncSearch::xPatternSearch(const TComPattern* const pcPatternKey,
	const Pel*               piRefY,
	const Int                iRefStride,
	const TComMv* const      pcMvSrchRngLT,
	const TComMv* const      pcMvSrchRngRB,
	TComMv&      rcMv,
	Distortion&  ruiSAD)
{
	Int   iSrchRngHorLeft = pcMvSrchRngLT->getHor();
	Int   iSrchRngHorRight = pcMvSrchRngRB->getHor();
	Int   iSrchRngVerTop = pcMvSrchRngLT->getVer();
	Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

	Distortion  uiSad;
	Distortion  uiSadBest = std::numeric_limits<Distortion>::max();
	Int         iBestX = 0;
	Int         iBestY = 0;

	



	

	//////////modified variables///////////
	int dimHor = 0;
	int dimVer = 0;
	//-- jclee for using the SAD function pointer
	m_pcRdCost->setDistParam(pcPatternKey, piRefY, iRefStride, m_cDistParam);

	// fast encoder decision: use subsampled SAD for integer ME
	if (m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE3)
	{
		if (m_cDistParam.iRows > 8)
		{
			m_cDistParam.iSubShift = 1;
		}
	}

	piRefY += (iSrchRngVerTop * iRefStride);

	



	int Distance_x;
	int Distance_y;


	if (iSrchRngHorLeft <= 0 && iSrchRngHorRight>0)
	{
		Distance_x = ((abs(iSrchRngHorLeft) + abs(iSrchRngHorRight)) / 2);
		
	}
	else if (iSrchRngHorLeft <= 0 && iSrchRngHorRight <= 0)
	{
		Distance_x = ((abs(iSrchRngHorLeft) - abs(iSrchRngHorRight)) / 2);
		
	}

	else if (iSrchRngHorLeft >= 0 && iSrchRngHorRight >= 0)
	{

		Distance_x = ((abs(iSrchRngHorRight) - abs(iSrchRngHorLeft)) / 2);
		

	}





	if (iSrchRngVerTop <= 0 && iSrchRngVerBottom > 0)
	{
		Distance_y = ((abs(iSrchRngVerTop) + abs(iSrchRngVerBottom)) / 2);
		
	}
	else if (iSrchRngVerTop <= 0 && iSrchRngVerBottom <= 0)
	{
		Distance_y = ((abs(iSrchRngVerTop) - abs(iSrchRngVerBottom)) / 2);
		
	}

	else if (iSrchRngVerTop >= 0 && iSrchRngVerBottom >= 0)
	{

		Distance_y = ((abs(iSrchRngVerBottom) - abs(iSrchRngVerTop)) / 2);
	

	}



	/////////////modification_Here////////////

	if (((iSrchRngVerBottom - iSrchRngVerTop) % 2 == 0) && ((iSrchRngHorRight - iSrchRngHorLeft) % 2 == 0))
	{

		dimHor = ((2 * Distance_x) + 1);
		dimVer = ((2 * Distance_y) + 1);

	}

	else if (((iSrchRngVerBottom - iSrchRngVerTop) % 2 == 0) && ((iSrchRngHorRight - iSrchRngHorLeft) % 2 != 0))
	{
		dimHor = ((2 * Distance_x) + 2);
		dimVer = ((2 * Distance_y) + 1);

	}

	else if (((iSrchRngVerBottom - iSrchRngVerTop) % 2 != 0) && ((iSrchRngHorRight - iSrchRngHorLeft) % 2 == 0))
	{
		dimHor = ((2 * Distance_x) + 1);
		dimVer = ((2 * Distance_y) + 2);

	}

	else if (((iSrchRngVerBottom - iSrchRngVerTop) % 2 != 0) && ((iSrchRngHorRight - iSrchRngHorLeft) % 2 != 0))
	{
		dimHor = ((2 * Distance_x) + 2);
		dimVer = ((2 * Distance_y) + 2);

	}

	/////////end of modification////////////////





	/////////////////modifying//////////////

	int shift_y;
	int shift_x;

	if (abs(iSrchRngVerTop) == abs(iSrchRngVerBottom) && abs(iSrchRngHorLeft) == abs(iSrchRngHorRight))
	{
		shift_y = Distance_y;
		shift_x = Distance_x;
	}

	else

	{

		if (iSrchRngVerTop <= 0 && abs(iSrchRngHorLeft) == abs(iSrchRngHorRight))


		{
			shift_y = abs(iSrchRngVerTop);
			shift_x = Distance_x;
		}

		else if (iSrchRngVerTop > 0 && abs(iSrchRngHorLeft) == abs(iSrchRngHorRight))

		{
			shift_y = -abs(iSrchRngVerTop);
			shift_x = Distance_x;
		}

		else if (iSrchRngHorLeft <= 0 && abs(iSrchRngVerTop) == abs(iSrchRngVerBottom))
		{
			shift_x = abs(iSrchRngHorLeft);
			shift_y = Distance_y;
		}

		else if (iSrchRngHorLeft > 0 && abs(iSrchRngVerTop) == abs(iSrchRngVerBottom))
		{

			shift_x = -abs(iSrchRngHorLeft);
			shift_y = Distance_y;
		}

		else if (iSrchRngHorLeft > 0 && iSrchRngVerTop > 0)
		{

			shift_x = -abs(iSrchRngHorLeft);
			shift_y = -abs(iSrchRngVerTop);
		}

		else if (iSrchRngHorLeft <= 0 && iSrchRngVerTop <= 0)

		{
			shift_x = abs(iSrchRngHorLeft);
			shift_y = abs(iSrchRngVerTop);

		}

		else if (iSrchRngHorLeft <= 0 && iSrchRngVerTop > 0)

		{
			shift_x = abs(iSrchRngHorLeft);
			shift_y = -abs(iSrchRngVerTop);

		}

		else if (iSrchRngHorLeft > 0 && iSrchRngVerTop <= 0)

		{
			shift_x = -abs(iSrchRngHorLeft);
			shift_y = abs(iSrchRngVerTop);

		}




	}




	///////////////end of modifying////////////////






	//	iSrchRngVerTop = -Distance_y;
	//  iSrchRngVerBottom = Distance_y;

	//	iSrchRngHorLeft = -Distance_x;
	//iSrchRngHorRight = Distance_x;


	int **dynamicArray = 0;
	dynamicArray = new int *[dimVer];
	for (int i = 0; i < dimVer; i++)
		dynamicArray[i] = new int[dimHor];

	//cout << "\nshift_y" << shift_y;
	//cout << "      shift_x " << shift_x;



	for (Int y = iSrchRngVerTop; y <= iSrchRngVerBottom; y++)
	{
		for (Int x = iSrchRngHorLeft; x <= iSrchRngHorRight; x++)
		{



			// end of decleration

			//  find min. distortion position
			m_cDistParam.pCur = piRefY + x;

			setDistParamComp(COMPONENT_Y);

			m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
			uiSad = m_cDistParam.DistFunc(&m_cDistParam);

			//cout << "\nX=" << x;
			//cout << "    y=" << y;


			// motion cost
			uiSad += m_pcRdCost->getCostOfVectorWithPredictor(x, y);






			dynamicArray[y + shift_y][x + shift_x] = uiSad;





			if (uiSad < uiSadBest)
			{
				uiSadBest = uiSad;
				iBestX = x;
				iBestY = y;
				m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
			}
		}
		piRefY += iRefStride;
	}

	//cout << "\n\nbestsad     " << uiSadBest;
	//cout << "\nXbest= " << iBestX;
	//cout << " Ybest  " << iBestY;


	// initiate the SAD window

	///// modifying to get the error window




	if ((((iBestX - 4) >= iSrchRngHorLeft) && ((iBestX + 4) <= iSrchRngHorRight)) && (((iBestY - 4) >= iSrchRngVerTop) && ((iBestY + 4) <= iSrchRngVerBottom)))
		 

	
	{





		// horizontal axis
		float A00 = dynamicArray[iBestY + shift_y][iBestX + shift_x];
		float A10 = dynamicArray[iBestY + shift_y][iBestX + shift_x + 1];
		float A20 = dynamicArray[iBestY + shift_y][iBestX + shift_x + 2];
		
		float AN10 = dynamicArray[iBestY + shift_y][iBestX + shift_x - 1];
		float AN20 = dynamicArray[iBestY + shift_y][iBestX + shift_x - 2];
		

		// vertical axis

		float A01 = dynamicArray[iBestY + shift_y + 1][iBestX + shift_x];
		float A02 = dynamicArray[iBestY + shift_y + 2][iBestX + shift_x];
		
		float A0N1 = dynamicArray[iBestY + shift_y - 1][iBestX + shift_x];
		float A0N2 = dynamicArray[iBestY + shift_y - 2][iBestX + shift_x];
		

		// u1,u2 corner

		float A1N1 = dynamicArray[iBestY + shift_y - 1][iBestX + shift_x + 1];
		float A2N1 = dynamicArray[iBestY + shift_y - 1][iBestX + shift_x + 2];
		
		float AN1N1 = dynamicArray[iBestY + shift_y - 1][iBestX + shift_x - 1];
		float AN2N1 = dynamicArray[iBestY + shift_y - 1][iBestX + shift_x - 2];
		


		float A1N2 = dynamicArray[iBestY + shift_y - 2][iBestX + shift_x + 1];
		float A2N2 = dynamicArray[iBestY + shift_y - 2][iBestX + shift_x + 2];
		
		float AN1N2 = dynamicArray[iBestY + shift_y - 2][iBestX + shift_x - 1];
		float AN2N2 = dynamicArray[iBestY + shift_y - 2][iBestX + shift_x - 2];
		


		


		// U3,U4 Corner


		float A11 = dynamicArray[iBestY + shift_y + 1][iBestX + shift_x + 1];
		float A21 = dynamicArray[iBestY + shift_y + 1][iBestX + shift_x + 2];
		
		float AN11 = dynamicArray[iBestY + shift_y + 1][iBestX + shift_x - 1];
		float AN21 = dynamicArray[iBestY + shift_y + 1][iBestX + shift_x - 2];
		


		float A12 = dynamicArray[iBestY + shift_y + 2][iBestX + shift_x + 1];
		float A22 = dynamicArray[iBestY + shift_y + 2][iBestX + shift_x + 2];
		
		float AN12 = dynamicArray[iBestY + shift_y + 2][iBestX + shift_x - 1];
		float AN22 = dynamicArray[iBestY + shift_y + 2][iBestX + shift_x - 2];
		


	

		

		// final result 

		if (MT_VCX == 0)

		{

			MVX_HALF = 0;
			MVX_QRTER = 0;

		}


		else if (MT_VCX == 0.25)

		{



			MVX_HALF = 0;
			MVX_QRTER = 1;

		}

		else if (MT_VCX == 0.5)

		{


			MVX_HALF = 1;
			MVX_QRTER = 0;

		}
		else if (MT_VCX == 0.75)

		{


			MVX_HALF = 1;
			MVX_QRTER = 1;

		}

		else if (MT_VCX == -0.5)

		{


			MVX_HALF = -1;
			MVX_QRTER = 0;

		}

		else if (MT_VCX == -0.25)

		{


			MVX_HALF = 0;
			MVX_QRTER = -1;

		}

		else if (MT_VCX == -0.75)

		{


			MVX_HALF = -1;
			MVX_QRTER = -1;

		}

		//MVY
		if (MT_VCY == 0)

		{

			MVY_HALF = 0;
			MVY_QRTER = 0;

		}


		else if (MT_VCY == 0.25)

		{



			MVY_HALF = 0;
			MVY_QRTER = 1;

		}

		else if (MT_VCY == 0.5)

		{

			MVY_HALF = 1;
			MVY_QRTER = 0;

		}
		else if (MT_VCY == 0.75)

		{

			MVY_HALF = 1;
			MVY_QRTER = 1;

		}


		else if (MT_VCY == -0.5)

		{


			MVY_HALF = -1;
			MVY_QRTER = 0;

		}

		else if (MT_VCY == -0.25)

		{


			MVY_HALF = 0;
			MVY_QRTER = -1;

		}
		else if (MT_VCY == -0.75)

		{


			MVY_HALF = -1;
			MVY_QRTER = -1;

		}


		


	}


	





	  
		  
			 



		 






	  


	  


		// end of modifying the SAD Window


		for (int i = 0; i < dimVer; i++)
			delete[] dynamicArray[i];
		delete[] dynamicArray;


		rcMv.set(iBestX, iBestY);


		ruiSAD = uiSadBest - m_pcRdCost->getCostOfVectorWithPredictor(iBestX, iBestY);

		//getchar();
		return;
	}


Void TEncSearch::xPatternSearchFast( const TComDataCU* const  pcCU,
                                     const TComPattern* const pcPatternKey,
                                     const Pel* const         piRefY,
                                     const Int                iRefStride,
                                     const TComMv* const      pcMvSrchRngLT,
                                     const TComMv* const      pcMvSrchRngRB,
                                     TComMv&                  rcMv,
                                     Distortion&              ruiSAD,
                                     const TComMv* const      pIntegerMv2Nx2NPred )
{
	//ofstream myfile;
	//ofstream myfile2;
	//myfile.open("C:\\FB_SSE.csv", ios::app);
	//myfile2.open("C:\\FB_Flag.csv", ios::app);
  assert (MD_LEFT < NUM_MV_PREDICTORS);
  pcCU->getMvPredLeft       ( m_acMvPredictors[MD_LEFT] );
  assert (MD_ABOVE < NUM_MV_PREDICTORS);
  pcCU->getMvPredAbove      ( m_acMvPredictors[MD_ABOVE] );
  assert (MD_ABOVE_RIGHT < NUM_MV_PREDICTORS);
  pcCU->getMvPredAboveRight ( m_acMvPredictors[MD_ABOVE_RIGHT] );

  switch ( m_motionEstimationSearchMethod )
  {
    case MESEARCH_DIAMOND:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, false );
	  
	  C = array[0];
	  for (int i = 1; i <=index_ref - 1; i++)
	  {
		  if (array[i] < C)
			  C = array[i];

	  }
	 
	 // index_ref = index_ref + 1;
	  U1 = array[index_ref];
	  V1 = array[index_ref + 1];
	  U2 = array[index_ref + 2];
	  H1 = array[index_ref + 3];
	  
	  H2 = array[index_ref + 4];
	  U3 = array[index_ref + 5];
	  V2 = array[index_ref + 6];
	  U4 = array[index_ref + 7];
	 
	 
	  
	   A00 = C;
	   A10 = H2;
	   A20 = array[index_ref + 16];

	  AN10 = H1;
	  AN20 = array[index_ref + 15];


	  // vertical axis

	   A01 = V2;
	   A02 = array[index_ref + 21];

	   A0N1 = V1;
	   A0N2 = array[index_ref + 10];


	  // u1,u2 corner

	   A1N1 = U2;
	   A2N1 = array[index_ref + 14];

	   AN1N1 = U1;
	   AN2N1 = array[index_ref + 13];



	   A1N2 = array[index_ref + 11];
	   A2N2 = array[index_ref + 12];

	   AN1N2 = array[index_ref + 9];
	   AN2N2 = array[index_ref + 8];






	  // U3,U4 Corner


	   A11 = U4;
	   A21 = array[index_ref + 18];

	   AN11 = U3;
	   AN21 = array[index_ref + 17];



	   A12 = array[index_ref + 22];
	   A22 = array[index_ref + 23];

	  AN12 = array[index_ref + 20];
	  AN22 = array[index_ref + 19];
	  
	  


	  // neural network implementation
	  
	  
	  inputs[0] = U1;
	  inputs[1] = V1;
	  inputs[2] = U2;
	  inputs[3] = H1;
	  inputs[4] = C;
	  inputs[5] = H2;
	  inputs[6] = U3;
	  inputs[7] = V2;
	  inputs[8] = U4;

	  IN[0] = (inputs[0] - 20243.63083) / 140021.1865;
	  IN[1] = (inputs[1] - 15269.39007) / 115404.6936;
	  IN[2] = (inputs[2] - 21755.52693) / 150640.1796;
	  IN[3] = (inputs[3] - 16539.1768) / 128876.155;
	  IN[4] = (inputs[4] - 8755.97938) / 98305.47864;
	  IN[5] = (inputs[5] - 16416.20724) / 128638.1432;
	  IN[6] = (inputs[6] - 22069.84058) / 151819.7337;
	  IN[7] = (inputs[7] - 15592.27331) / 116696.186;
	  IN[8] = (inputs[8] - 20410.4815) / 141399.6972;

	  
	  // Input Layer

	  for(int i=0;i<9;i++){
		  IN_norm[i] = (IN[i] * BN_gamma_in[i]);	  
	  }
	  
    // First Hidden Layer

    for (int i = 0; i < 40; i++) {
      for (int j = 0; j < 9; j++) {
        X1[i] += in_h1[i][j] * IN_norm[j];
      }
      X1[i] += b1[i];
      X1[i] = (relu(X1[i]) * BN_gamma_1[i]) + BN_beta_1[i];
    }

    // Second Hidden Layer

    for (int i = 0; i < 40; i++) {
      for (int j = 0; j < 40; j++) {
        X2[i] += h1_h2[i][j] * X1[j];
      }
      X2[i] += b2[i];
      X2[i] = (relu(X2[i]) * BN_gamma_2[i]) + BN_beta_2[i];
    }

    // Third Hidden Layer

    for (int i = 0; i < 40; i++) {
      for (int j = 0; j < 40; j++) {
        X3[i] += h2_h3[i][j] * X2[j];
      }
      X3[i] += b3[i];
      X3[i] = (relu(X3[i]) * BN_gamma_3[i]) + BN_beta_3[i];
    }

    // OUTPUT LAYER

    for (int i = 0; i < 49; i++) {
      for (int j = 0; j < 40; j++) {
        OUT[i] += h3_out[i][j] * X3[j];
      }
      OUT[i] += bout[i];
      OUT[i] = sigmoid(OUT[i]);
    }


    // int N = sizeof(OUT) / sizeof(double);
    // int output = std::distance(OUT, std::max_element(OUT, OUT + N));

    // switch (output) {
    //   case 0: MT_VCX = -0.75;		MT_VCY = -0.75;		break;
    //   case 1: MT_VCX = -0.5;		MT_VCY = -0.75;		break;
    //   case 2: MT_VCX = -0.25;		MT_VCY = -0.75;		break;
    //   case 3: MT_VCX = 0;			  MT_VCY = -0.75;	  break;
    //   case 4: MT_VCX = 0.25;		MT_VCY = -0.75;		break;
    //   case 5: MT_VCX = 0.5;		  MT_VCY = -0.75;	  break;
    //   case 6: MT_VCX = 0.75;		MT_VCY = -0.75;		break;

    //   case 7: MT_VCX = -0.75;		MT_VCY = -0.5;		break;
    //   case 8: MT_VCX = -0.5;		MT_VCY = -0.5;		break;
    //   case 9: MT_VCX = -0.25;		MT_VCY = -0.5;		break;
    //   case 10: MT_VCX = 0;	  	MT_VCY = -0.5;		break;
    //   case 11: MT_VCX = 0.25;		MT_VCY = -0.5;		break;
    //   case 12: MT_VCX = 0.5;		MT_VCY = -0.5;		break;
    //   case 13: MT_VCX = 0.75;		MT_VCY = -0.5;		break;

    //   case 14: MT_VCX = -0.75;	MT_VCY = -0.25;		break;
    //   case 15: MT_VCX = -0.5;		MT_VCY = -0.25;		break;
    //   case 16: MT_VCX = -0.25;	MT_VCY = -0.25;		break;
    //   case 17: MT_VCX = 0;	  	MT_VCY = -0.25;		break;
    //   case 18: MT_VCX = 0.25;		MT_VCY = -0.25;		break;
    //   case 19: MT_VCX = 0.5;		MT_VCY = -0.25;		break;
    //   case 20: MT_VCX = 0.75;		MT_VCY = -0.25;		break;

    //   case 21: MT_VCX = -0.75;	MT_VCY = 0;		  	break;
    //   case 22: MT_VCX = -0.5;		MT_VCY = 0;		  	break;
    //   case 23: MT_VCX = -0.25;	MT_VCY = 0;		  	break;
    //   case 24: MT_VCX = 0;	  	MT_VCY = 0;			  break;
    //   case 25: MT_VCX = 0.25;		MT_VCY = 0;		  	break;
    //   case 26: MT_VCX = 0.5;		MT_VCY = 0;		  	break;
    //   case 27: MT_VCX = 0.75;		MT_VCY = 0;			  break;

    //   case 28: MT_VCX = -0.75;	MT_VCY = 0.25;		break;
    //   case 29: MT_VCX = -0.5;		MT_VCY = 0.25;		break;
    //   case 30: MT_VCX = -0.25;	MT_VCY = 0.25;		break;
    //   case 31: MT_VCX = 0;	  	MT_VCY = 0.25;		break;
    //   case 32: MT_VCX = 0.25;		MT_VCY = 0.25;		break;
    //   case 33: MT_VCX = 0.5;		MT_VCY = 0.25;		break;
    //   case 34: MT_VCX = 0.75;		MT_VCY = 0.25;		break;

    //   case 35: MT_VCX = -0.75;	MT_VCY = 0.5;	  	break;
    //   case 36: MT_VCX = -0.5;		MT_VCY = 0.5;	  	break;
    //   case 37: MT_VCX = -0.25;	MT_VCY = 0.5;	  	break;
    //   case 38: MT_VCX = 0;	  	MT_VCY = 0.5;		  break;
    //   case 39: MT_VCX = 0.25;		MT_VCY = 0.5;	  	break;
    //   case 40: MT_VCX = 0.5;		MT_VCY = 0.5;	  	break;
    //   case 41: MT_VCX = 0.75;		MT_VCY = 0.5;	  	break;

    //   case 42: MT_VCX = -0.75;	MT_VCY = 0.75;		break;
    //   case 43: MT_VCX = -0.5;		MT_VCY = 0.75;		break;
    //   case 44: MT_VCX = -0.25;	MT_VCY = 0.75;		break;
    //   case 45: MT_VCX = 0;	  	MT_VCY = 0.75;	  break;
    //   case 46: MT_VCX = 0.25;		MT_VCY = 0.75;		break;
    //   case 47: MT_VCX = 0.5;		MT_VCY = 0.75;		break;
    //   case 48: MT_VCX = 0.75;		MT_VCY = 0.75;		break;
    // }

//1
	 
if((OUT[0]>OUT[1])&&(OUT[0]>OUT[2])&&(OUT[0]>OUT[3])&&(OUT[0]>OUT[4])&&(OUT[0]>OUT[5])&&(OUT[0]>OUT[6])&&(OUT[0]>OUT[7])&&(OUT[0]>OUT[8])&&(OUT[0]>OUT[9])&&(OUT[0]>OUT[10])
&&(OUT[0]>OUT[11])&&(OUT[0]>OUT[12])&&(OUT[0]>OUT[13])&&(OUT[0]>OUT[14])&&(OUT[0]>OUT[15])&&(OUT[0]>OUT[16])&&(OUT[0]>OUT[17])&&(OUT[0]>OUT[18])&&(OUT[0]>OUT[19])
&&(OUT[0]>OUT[20])&&(OUT[0]>OUT[21])&&(OUT[0]>OUT[22])&&(OUT[0]>OUT[23])&&(OUT[0]>OUT[24])&&(OUT[0]>OUT[25])&&(OUT[0]>OUT[26])&&(OUT[0]>OUT[27])&&(OUT[0]>OUT[28])
&&(OUT[0]>OUT[29])&&(OUT[0]>OUT[30])&&(OUT[0]>OUT[31])&&(OUT[0]>OUT[32])&&(OUT[0]>OUT[33])&&(OUT[0]>OUT[34])&&(OUT[0]>OUT[35])&&(OUT[0]>OUT[36])&&(OUT[0]>OUT[37])
&&(OUT[0]>OUT[38])&&(OUT[0]>OUT[39])&&(OUT[0]>OUT[40])&&(OUT[0]>OUT[41])&&(OUT[0]>OUT[42])&&(OUT[0]>OUT[43])&&(OUT[0]>OUT[44])&&(OUT[0]>OUT[45])&&(OUT[0]>OUT[46])
&&(OUT[0]>OUT[47])&&(OUT[0]>OUT[48]) ) 
	 
{
MT_VCX=-0.75;
MT_VCY=-0.75;		 
		 
}
		 
//2
	 
	else if((OUT[1]>OUT[0])&&(OUT[1]>OUT[2])&&(OUT[1]>OUT[3])&&(OUT[1]>OUT[4])&&(OUT[1]>OUT[5])&&(OUT[1]>OUT[6])&&(OUT[1]>OUT[7])&&(OUT[1]>OUT[8])&&(OUT[1]>OUT[9])&&(OUT[1]>OUT[10])
&&(OUT[1]>OUT[11])&&(OUT[1]>OUT[12])&&(OUT[1]>OUT[13])&&(OUT[1]>OUT[14])&&(OUT[1]>OUT[15])&&(OUT[1]>OUT[16])&&(OUT[1]>OUT[17])&&(OUT[1]>OUT[18])&&(OUT[1]>OUT[19])
&&(OUT[1]>OUT[20])&&(OUT[1]>OUT[21])&&(OUT[1]>OUT[22])&&(OUT[1]>OUT[23])&&(OUT[1]>OUT[24])&&(OUT[1]>OUT[25])&&(OUT[1]>OUT[26])&&(OUT[1]>OUT[27])&&(OUT[1]>OUT[28])
&&(OUT[1]>OUT[29])&&(OUT[1]>OUT[30])&&(OUT[1]>OUT[31])&&(OUT[1]>OUT[32])&&(OUT[1]>OUT[33])&&(OUT[1]>OUT[34])&&(OUT[1]>OUT[35])&&(OUT[1]>OUT[36])&&(OUT[1]>OUT[37])
&&(OUT[1]>OUT[38])&&(OUT[1]>OUT[39])&&(OUT[1]>OUT[40])&&(OUT[1]>OUT[41])&&(OUT[1]>OUT[42])&&(OUT[1]>OUT[43])&&(OUT[1]>OUT[44])&&(OUT[1]>OUT[45])&&(OUT[1]>OUT[46])
&&(OUT[1]>OUT[47])&&(OUT[1]>OUT[48]) ) 
{
MT_VCX=-0.5;
MT_VCY=-0.75;		
	
}

//3

else if((OUT[2]>OUT[0])&&(OUT[2]>OUT[1])&&(OUT[2]>OUT[3])&&(OUT[2]>OUT[4])&&(OUT[2]>OUT[5])&&(OUT[2]>OUT[6])&&(OUT[2]>OUT[7])&&(OUT[2]>OUT[8])&&(OUT[2]>OUT[9])&&(OUT[2]>OUT[10])
&&(OUT[2]>OUT[11])&&(OUT[2]>OUT[12])&&(OUT[2]>OUT[13])&&(OUT[2]>OUT[14])&&(OUT[2]>OUT[15])&&(OUT[2]>OUT[16])&&(OUT[2]>OUT[17])&&(OUT[2]>OUT[18])&&(OUT[2]>OUT[19])
&&(OUT[2]>OUT[20])&&(OUT[2]>OUT[21])&&(OUT[2]>OUT[22])&&(OUT[2]>OUT[23])&&(OUT[2]>OUT[24])&&(OUT[2]>OUT[25])&&(OUT[2]>OUT[26])&&(OUT[2]>OUT[27])&&(OUT[2]>OUT[28])
&&(OUT[2]>OUT[29])&&(OUT[2]>OUT[30])&&(OUT[2]>OUT[31])&&(OUT[2]>OUT[32])&&(OUT[2]>OUT[33])&&(OUT[2]>OUT[34])&&(OUT[2]>OUT[35])&&(OUT[2]>OUT[36])&&(OUT[2]>OUT[37])
&&(OUT[2]>OUT[38])&&(OUT[2]>OUT[39])&&(OUT[2]>OUT[40])&&(OUT[2]>OUT[41])&&(OUT[2]>OUT[42])&&(OUT[2]>OUT[43])&&(OUT[2]>OUT[44])&&(OUT[2]>OUT[45])&&(OUT[2]>OUT[46])
&&(OUT[2]>OUT[47])&&(OUT[2]>OUT[48]) ) 
{
MT_VCX=-0.25;
MT_VCY=-0.75;		
	
}
	 
//4
else if((OUT[3]>OUT[0])&&(OUT[3]>OUT[1])&&(OUT[3]>OUT[2])&&(OUT[3]>OUT[4])&&(OUT[3]>OUT[5])&&(OUT[3]>OUT[6])&&(OUT[3]>OUT[7])&&(OUT[3]>OUT[8])&&(OUT[3]>OUT[9])&&(OUT[3]>OUT[10])
&&(OUT[3]>OUT[11])&&(OUT[3]>OUT[12])&&(OUT[3]>OUT[13])&&(OUT[3]>OUT[14])&&(OUT[3]>OUT[15])&&(OUT[3]>OUT[16])&&(OUT[3]>OUT[17])&&(OUT[3]>OUT[18])&&(OUT[3]>OUT[19])
&&(OUT[3]>OUT[20])&&(OUT[3]>OUT[21])&&(OUT[3]>OUT[22])&&(OUT[3]>OUT[23])&&(OUT[3]>OUT[24])&&(OUT[3]>OUT[25])&&(OUT[3]>OUT[26])&&(OUT[3]>OUT[27])&&(OUT[3]>OUT[28])
&&(OUT[3]>OUT[29])&&(OUT[3]>OUT[30])&&(OUT[3]>OUT[31])&&(OUT[3]>OUT[32])&&(OUT[3]>OUT[33])&&(OUT[3]>OUT[34])&&(OUT[3]>OUT[35])&&(OUT[3]>OUT[36])&&(OUT[3]>OUT[37])
&&(OUT[3]>OUT[38])&&(OUT[3]>OUT[39])&&(OUT[3]>OUT[40])&&(OUT[3]>OUT[41])&&(OUT[3]>OUT[42])&&(OUT[3]>OUT[43])&&(OUT[3]>OUT[44])&&(OUT[3]>OUT[45])&&(OUT[3]>OUT[46])
&&(OUT[3]>OUT[47])&&(OUT[3]>OUT[48]) ) 
{
MT_VCX=0;
MT_VCY=-0.75;		
	
}

//5

else if((OUT[4]>OUT[0])&&(OUT[4]>OUT[1])&&(OUT[4]>OUT[2])&&(OUT[4]>OUT[3])&&(OUT[4]>OUT[5])&&(OUT[4]>OUT[6])&&(OUT[4]>OUT[7])&&(OUT[4]>OUT[8])&&(OUT[4]>OUT[9])&&(OUT[4]>OUT[10])
&&(OUT[4]>OUT[11])&&(OUT[4]>OUT[12])&&(OUT[4]>OUT[13])&&(OUT[4]>OUT[14])&&(OUT[4]>OUT[15])&&(OUT[4]>OUT[16])&&(OUT[4]>OUT[17])&&(OUT[4]>OUT[18])&&(OUT[4]>OUT[19])
&&(OUT[4]>OUT[20])&&(OUT[4]>OUT[21])&&(OUT[4]>OUT[22])&&(OUT[4]>OUT[23])&&(OUT[4]>OUT[24])&&(OUT[4]>OUT[25])&&(OUT[4]>OUT[26])&&(OUT[4]>OUT[27])&&(OUT[4]>OUT[28])
&&(OUT[4]>OUT[29])&&(OUT[4]>OUT[30])&&(OUT[4]>OUT[31])&&(OUT[4]>OUT[32])&&(OUT[4]>OUT[33])&&(OUT[4]>OUT[34])&&(OUT[4]>OUT[35])&&(OUT[4]>OUT[36])&&(OUT[4]>OUT[37])
&&(OUT[4]>OUT[38])&&(OUT[4]>OUT[39])&&(OUT[4]>OUT[40])&&(OUT[4]>OUT[41])&&(OUT[4]>OUT[42])&&(OUT[4]>OUT[43])&&(OUT[4]>OUT[44])&&(OUT[4]>OUT[45])&&(OUT[4]>OUT[46])
&&(OUT[4]>OUT[47])&&(OUT[4]>OUT[48]) ) 
{
MT_VCX=0.25;
MT_VCY=-0.75;		
	
}

//6


else if((OUT[5]>OUT[0])&&(OUT[5]>OUT[1])&&(OUT[5]>OUT[2])&&(OUT[5]>OUT[3])&&(OUT[5]>OUT[4])&&(OUT[5]>OUT[6])&&(OUT[5]>OUT[7])&&(OUT[5]>OUT[8])&&(OUT[5]>OUT[9])&&(OUT[5]>OUT[10])
&&(OUT[5]>OUT[11])&&(OUT[5]>OUT[12])&&(OUT[5]>OUT[13])&&(OUT[5]>OUT[14])&&(OUT[5]>OUT[15])&&(OUT[5]>OUT[16])&&(OUT[5]>OUT[17])&&(OUT[5]>OUT[18])&&(OUT[5]>OUT[19])
&&(OUT[5]>OUT[20])&&(OUT[5]>OUT[21])&&(OUT[5]>OUT[22])&&(OUT[5]>OUT[23])&&(OUT[5]>OUT[24])&&(OUT[5]>OUT[25])&&(OUT[5]>OUT[26])&&(OUT[5]>OUT[27])&&(OUT[5]>OUT[28])
&&(OUT[5]>OUT[29])&&(OUT[5]>OUT[30])&&(OUT[5]>OUT[31])&&(OUT[5]>OUT[32])&&(OUT[5]>OUT[33])&&(OUT[5]>OUT[34])&&(OUT[5]>OUT[35])&&(OUT[5]>OUT[36])&&(OUT[5]>OUT[37])
&&(OUT[5]>OUT[38])&&(OUT[5]>OUT[39])&&(OUT[5]>OUT[40])&&(OUT[5]>OUT[41])&&(OUT[5]>OUT[42])&&(OUT[5]>OUT[43])&&(OUT[5]>OUT[44])&&(OUT[5]>OUT[45])&&(OUT[5]>OUT[46])
&&(OUT[5]>OUT[47])&&(OUT[5]>OUT[48]) ) 
{
MT_VCX=0.5;
MT_VCY=-0.75;		
	
}

//7

else if((OUT[6]>OUT[0])&&(OUT[6]>OUT[1])&&(OUT[6]>OUT[2])&&(OUT[6]>OUT[3])&&(OUT[6]>OUT[4])&&(OUT[6]>OUT[5])&&(OUT[6]>OUT[7])&&(OUT[6]>OUT[8])&&(OUT[6]>OUT[9])&&(OUT[6]>OUT[10])
&&(OUT[6]>OUT[11])&&(OUT[6]>OUT[12])&&(OUT[6]>OUT[13])&&(OUT[6]>OUT[14])&&(OUT[6]>OUT[15])&&(OUT[6]>OUT[16])&&(OUT[6]>OUT[17])&&(OUT[6]>OUT[18])&&(OUT[6]>OUT[19])
&&(OUT[6]>OUT[20])&&(OUT[6]>OUT[21])&&(OUT[6]>OUT[22])&&(OUT[6]>OUT[23])&&(OUT[6]>OUT[24])&&(OUT[6]>OUT[25])&&(OUT[6]>OUT[26])&&(OUT[6]>OUT[27])&&(OUT[6]>OUT[28])
&&(OUT[6]>OUT[29])&&(OUT[6]>OUT[30])&&(OUT[6]>OUT[31])&&(OUT[6]>OUT[32])&&(OUT[6]>OUT[33])&&(OUT[6]>OUT[34])&&(OUT[6]>OUT[35])&&(OUT[6]>OUT[36])&&(OUT[6]>OUT[37])
&&(OUT[6]>OUT[38])&&(OUT[6]>OUT[39])&&(OUT[6]>OUT[40])&&(OUT[6]>OUT[41])&&(OUT[6]>OUT[42])&&(OUT[6]>OUT[43])&&(OUT[6]>OUT[44])&&(OUT[6]>OUT[45])&&(OUT[6]>OUT[46])
&&(OUT[6]>OUT[47])&&(OUT[6]>OUT[48]) ) 
{
MT_VCX=0.75;
MT_VCY=-0.75;		
	
}

//8

else if((OUT[7]>OUT[0])&&(OUT[7]>OUT[1])&&(OUT[7]>OUT[2])&&(OUT[7]>OUT[3])&&(OUT[7]>OUT[4])&&(OUT[7]>OUT[5])&&(OUT[7]>OUT[6])&&(OUT[7]>OUT[8])&&(OUT[7]>OUT[9])&&(OUT[7]>OUT[10])
&&(OUT[7]>OUT[11])&&(OUT[7]>OUT[12])&&(OUT[7]>OUT[13])&&(OUT[7]>OUT[14])&&(OUT[7]>OUT[15])&&(OUT[7]>OUT[16])&&(OUT[7]>OUT[17])&&(OUT[7]>OUT[18])&&(OUT[7]>OUT[19])
&&(OUT[7]>OUT[20])&&(OUT[7]>OUT[21])&&(OUT[7]>OUT[22])&&(OUT[7]>OUT[23])&&(OUT[7]>OUT[24])&&(OUT[7]>OUT[25])&&(OUT[7]>OUT[26])&&(OUT[7]>OUT[27])&&(OUT[7]>OUT[28])
&&(OUT[7]>OUT[29])&&(OUT[7]>OUT[30])&&(OUT[7]>OUT[31])&&(OUT[7]>OUT[32])&&(OUT[7]>OUT[33])&&(OUT[7]>OUT[34])&&(OUT[7]>OUT[35])&&(OUT[7]>OUT[36])&&(OUT[7]>OUT[37])
&&(OUT[7]>OUT[38])&&(OUT[7]>OUT[39])&&(OUT[7]>OUT[40])&&(OUT[7]>OUT[41])&&(OUT[7]>OUT[42])&&(OUT[7]>OUT[43])&&(OUT[7]>OUT[44])&&(OUT[7]>OUT[45])&&(OUT[7]>OUT[46])
&&(OUT[7]>OUT[47])&&(OUT[7]>OUT[48]) ) 
{
MT_VCX=-0.75;
MT_VCY=-0.5;		
	
}

//9


else if((OUT[8]>OUT[0])&&(OUT[8]>OUT[1])&&(OUT[8]>OUT[2])&&(OUT[8]>OUT[3])&&(OUT[8]>OUT[4])&&(OUT[8]>OUT[5])&&(OUT[8]>OUT[6])&&(OUT[8]>OUT[7])&&(OUT[8]>OUT[9])&&(OUT[8]>OUT[10])
&&(OUT[8]>OUT[11])&&(OUT[8]>OUT[12])&&(OUT[8]>OUT[13])&&(OUT[8]>OUT[14])&&(OUT[8]>OUT[15])&&(OUT[8]>OUT[16])&&(OUT[8]>OUT[17])&&(OUT[8]>OUT[18])&&(OUT[8]>OUT[19])
&&(OUT[8]>OUT[20])&&(OUT[8]>OUT[21])&&(OUT[8]>OUT[22])&&(OUT[8]>OUT[23])&&(OUT[8]>OUT[24])&&(OUT[8]>OUT[25])&&(OUT[8]>OUT[26])&&(OUT[8]>OUT[27])&&(OUT[8]>OUT[28])
&&(OUT[8]>OUT[29])&&(OUT[8]>OUT[30])&&(OUT[8]>OUT[31])&&(OUT[8]>OUT[32])&&(OUT[8]>OUT[33])&&(OUT[8]>OUT[34])&&(OUT[8]>OUT[35])&&(OUT[8]>OUT[36])&&(OUT[8]>OUT[37])
&&(OUT[8]>OUT[38])&&(OUT[8]>OUT[39])&&(OUT[8]>OUT[40])&&(OUT[8]>OUT[41])&&(OUT[8]>OUT[42])&&(OUT[8]>OUT[43])&&(OUT[8]>OUT[44])&&(OUT[8]>OUT[45])&&(OUT[8]>OUT[46])
&&(OUT[8]>OUT[47])&&(OUT[8]>OUT[48]) ) 
{
MT_VCX=-0.5;
MT_VCY=-0.5;	
	
}


//10


else if((OUT[9]>OUT[0])&&(OUT[9]>OUT[1])&&(OUT[9]>OUT[2])&&(OUT[9]>OUT[3])&&(OUT[9]>OUT[4])&&(OUT[9]>OUT[5])&&(OUT[9]>OUT[6])&&(OUT[9]>OUT[7])&&(OUT[9]>OUT[8])&&(OUT[9]>OUT[10])
&&(OUT[9]>OUT[11])&&(OUT[9]>OUT[12])&&(OUT[9]>OUT[13])&&(OUT[9]>OUT[14])&&(OUT[9]>OUT[15])&&(OUT[9]>OUT[16])&&(OUT[9]>OUT[17])&&(OUT[9]>OUT[18])&&(OUT[9]>OUT[19])
&&(OUT[9]>OUT[20])&&(OUT[9]>OUT[21])&&(OUT[9]>OUT[22])&&(OUT[9]>OUT[23])&&(OUT[9]>OUT[24])&&(OUT[9]>OUT[25])&&(OUT[9]>OUT[26])&&(OUT[9]>OUT[27])&&(OUT[9]>OUT[28])
&&(OUT[9]>OUT[29])&&(OUT[9]>OUT[30])&&(OUT[9]>OUT[31])&&(OUT[9]>OUT[32])&&(OUT[9]>OUT[33])&&(OUT[9]>OUT[34])&&(OUT[9]>OUT[35])&&(OUT[9]>OUT[36])&&(OUT[9]>OUT[37])
&&(OUT[9]>OUT[38])&&(OUT[9]>OUT[39])&&(OUT[9]>OUT[40])&&(OUT[9]>OUT[41])&&(OUT[9]>OUT[42])&&(OUT[9]>OUT[43])&&(OUT[9]>OUT[44])&&(OUT[9]>OUT[45])&&(OUT[9]>OUT[46])
&&(OUT[9]>OUT[47])&&(OUT[9]>OUT[48]) ) 
{
MT_VCX=-0.25;
MT_VCY=-0.5;	
	
}

//11

else if((OUT[10]>OUT[0])&&(OUT[10]>OUT[1])&&(OUT[10]>OUT[2])&&(OUT[10]>OUT[3])&&(OUT[10]>OUT[4])&&(OUT[10]>OUT[5])&&(OUT[10]>OUT[6])&&(OUT[10]>OUT[7])&&(OUT[10]>OUT[8])&&(OUT[10]>OUT[9])
&&(OUT[10]>OUT[11])&&(OUT[10]>OUT[12])&&(OUT[10]>OUT[13])&&(OUT[10]>OUT[14])&&(OUT[10]>OUT[15])&&(OUT[10]>OUT[16])&&(OUT[10]>OUT[17])&&(OUT[10]>OUT[18])&&(OUT[10]>OUT[19])
&&(OUT[10]>OUT[20])&&(OUT[10]>OUT[21])&&(OUT[10]>OUT[22])&&(OUT[10]>OUT[23])&&(OUT[10]>OUT[24])&&(OUT[10]>OUT[25])&&(OUT[10]>OUT[26])&&(OUT[10]>OUT[27])&&(OUT[10]>OUT[28])
&&(OUT[10]>OUT[29])&&(OUT[10]>OUT[30])&&(OUT[10]>OUT[31])&&(OUT[10]>OUT[32])&&(OUT[10]>OUT[33])&&(OUT[10]>OUT[34])&&(OUT[10]>OUT[35])&&(OUT[10]>OUT[36])&&(OUT[10]>OUT[37])
&&(OUT[10]>OUT[38])&&(OUT[10]>OUT[39])&&(OUT[10]>OUT[40])&&(OUT[10]>OUT[41])&&(OUT[10]>OUT[42])&&(OUT[10]>OUT[43])&&(OUT[10]>OUT[44])&&(OUT[10]>OUT[45])&&(OUT[10]>OUT[46])
&&(OUT[10]>OUT[47])&&(OUT[10]>OUT[48]) ) 
{
MT_VCX=0;
MT_VCY=-0.5;	
		
	
}

//12

else if((OUT[11]>OUT[0])&&(OUT[11]>OUT[1])&&(OUT[11]>OUT[2])&&(OUT[11]>OUT[3])&&(OUT[11]>OUT[4])&&(OUT[11]>OUT[5])&&(OUT[11]>OUT[6])&&(OUT[11]>OUT[7])&&(OUT[11]>OUT[8])&&(OUT[11]>OUT[9])
&&(OUT[11]>OUT[10])&&(OUT[11]>OUT[12])&&(OUT[11]>OUT[13])&&(OUT[11]>OUT[14])&&(OUT[11]>OUT[15])&&(OUT[11]>OUT[16])&&(OUT[11]>OUT[17])&&(OUT[11]>OUT[18])&&(OUT[11]>OUT[19])
&&(OUT[11]>OUT[20])&&(OUT[11]>OUT[21])&&(OUT[11]>OUT[22])&&(OUT[11]>OUT[23])&&(OUT[11]>OUT[24])&&(OUT[11]>OUT[25])&&(OUT[11]>OUT[26])&&(OUT[11]>OUT[27])&&(OUT[11]>OUT[28])
&&(OUT[11]>OUT[29])&&(OUT[11]>OUT[30])&&(OUT[11]>OUT[31])&&(OUT[11]>OUT[32])&&(OUT[11]>OUT[33])&&(OUT[11]>OUT[34])&&(OUT[11]>OUT[35])&&(OUT[11]>OUT[36])&&(OUT[11]>OUT[37])
&&(OUT[11]>OUT[38])&&(OUT[11]>OUT[39])&&(OUT[11]>OUT[40])&&(OUT[11]>OUT[41])&&(OUT[11]>OUT[42])&&(OUT[11]>OUT[43])&&(OUT[11]>OUT[44])&&(OUT[11]>OUT[45])&&(OUT[11]>OUT[46])
&&(OUT[11]>OUT[47])&&(OUT[11]>OUT[48]) ) 
{
MT_VCX=0.25;
MT_VCY=-0.5;	
	
	
}


//13

else if((OUT[12]>OUT[0])&&(OUT[12]>OUT[1])&&(OUT[12]>OUT[2])&&(OUT[12]>OUT[3])&&(OUT[12]>OUT[4])&&(OUT[12]>OUT[5])&&(OUT[12]>OUT[6])&&(OUT[12]>OUT[7])&&(OUT[12]>OUT[8])&&(OUT[12]>OUT[9])
&&(OUT[12]>OUT[10])&&(OUT[12]>OUT[11])&&(OUT[12]>OUT[13])&&(OUT[12]>OUT[14])&&(OUT[12]>OUT[15])&&(OUT[12]>OUT[16])&&(OUT[12]>OUT[17])&&(OUT[12]>OUT[18])&&(OUT[12]>OUT[19])
&&(OUT[12]>OUT[20])&&(OUT[12]>OUT[21])&&(OUT[12]>OUT[22])&&(OUT[12]>OUT[23])&&(OUT[12]>OUT[24])&&(OUT[12]>OUT[25])&&(OUT[12]>OUT[26])&&(OUT[12]>OUT[27])&&(OUT[12]>OUT[28])
&&(OUT[12]>OUT[29])&&(OUT[12]>OUT[30])&&(OUT[12]>OUT[31])&&(OUT[12]>OUT[32])&&(OUT[12]>OUT[33])&&(OUT[12]>OUT[34])&&(OUT[12]>OUT[35])&&(OUT[12]>OUT[36])&&(OUT[12]>OUT[37])
&&(OUT[12]>OUT[38])&&(OUT[12]>OUT[39])&&(OUT[12]>OUT[40])&&(OUT[12]>OUT[41])&&(OUT[12]>OUT[42])&&(OUT[12]>OUT[43])&&(OUT[12]>OUT[44])&&(OUT[12]>OUT[45])&&(OUT[12]>OUT[46])
&&(OUT[12]>OUT[47])&&(OUT[12]>OUT[48]) ) 
{
MT_VCX=0.5;
MT_VCY=-0.5;		
	
}

//14

else if((OUT[13]>OUT[0])&&(OUT[13]>OUT[1])&&(OUT[13]>OUT[2])&&(OUT[13]>OUT[3])&&(OUT[13]>OUT[4])&&(OUT[13]>OUT[5])&&(OUT[13]>OUT[6])&&(OUT[13]>OUT[7])&&(OUT[13]>OUT[8])&&(OUT[13]>OUT[9])
&&(OUT[13]>OUT[10])&&(OUT[13]>OUT[11])&&(OUT[13]>OUT[12])&&(OUT[13]>OUT[14])&&(OUT[13]>OUT[15])&&(OUT[13]>OUT[16])&&(OUT[13]>OUT[17])&&(OUT[13]>OUT[18])&&(OUT[13]>OUT[19])
&&(OUT[13]>OUT[20])&&(OUT[13]>OUT[21])&&(OUT[13]>OUT[22])&&(OUT[13]>OUT[23])&&(OUT[13]>OUT[24])&&(OUT[13]>OUT[25])&&(OUT[13]>OUT[26])&&(OUT[13]>OUT[27])&&(OUT[13]>OUT[28])
&&(OUT[13]>OUT[29])&&(OUT[13]>OUT[30])&&(OUT[13]>OUT[31])&&(OUT[13]>OUT[32])&&(OUT[13]>OUT[33])&&(OUT[13]>OUT[34])&&(OUT[13]>OUT[35])&&(OUT[13]>OUT[36])&&(OUT[13]>OUT[37])
&&(OUT[13]>OUT[38])&&(OUT[13]>OUT[39])&&(OUT[13]>OUT[40])&&(OUT[13]>OUT[41])&&(OUT[13]>OUT[42])&&(OUT[13]>OUT[43])&&(OUT[13]>OUT[44])&&(OUT[13]>OUT[45])&&(OUT[13]>OUT[46])
&&(OUT[13]>OUT[47])&&(OUT[13]>OUT[48]) ) 
{
MT_VCX=0.75;
MT_VCY=-0.5;		
	
}

//15

else if((OUT[14]>OUT[0])&&(OUT[14]>OUT[1])&&(OUT[14]>OUT[2])&&(OUT[14]>OUT[3])&&(OUT[14]>OUT[4])&&(OUT[14]>OUT[5])&&(OUT[14]>OUT[6])&&(OUT[14]>OUT[7])&&(OUT[14]>OUT[8])&&(OUT[14]>OUT[9])
&&(OUT[14]>OUT[10])&&(OUT[14]>OUT[11])&&(OUT[14]>OUT[12])&&(OUT[14]>OUT[13])&&(OUT[14]>OUT[15])&&(OUT[14]>OUT[16])&&(OUT[14]>OUT[17])&&(OUT[14]>OUT[18])&&(OUT[14]>OUT[19])
&&(OUT[14]>OUT[20])&&(OUT[14]>OUT[21])&&(OUT[14]>OUT[22])&&(OUT[14]>OUT[23])&&(OUT[14]>OUT[24])&&(OUT[14]>OUT[25])&&(OUT[14]>OUT[26])&&(OUT[14]>OUT[27])&&(OUT[14]>OUT[28])
&&(OUT[14]>OUT[29])&&(OUT[14]>OUT[30])&&(OUT[14]>OUT[31])&&(OUT[14]>OUT[32])&&(OUT[14]>OUT[33])&&(OUT[14]>OUT[34])&&(OUT[14]>OUT[35])&&(OUT[14]>OUT[36])&&(OUT[14]>OUT[37])
&&(OUT[14]>OUT[38])&&(OUT[14]>OUT[39])&&(OUT[14]>OUT[40])&&(OUT[14]>OUT[41])&&(OUT[14]>OUT[42])&&(OUT[14]>OUT[43])&&(OUT[14]>OUT[44])&&(OUT[14]>OUT[45])&&(OUT[14]>OUT[46])
&&(OUT[14]>OUT[47])&&(OUT[14]>OUT[48]) ) 
{
MT_VCX=-0.75;
MT_VCY=-0.25;			
	
}

//16

else if((OUT[15]>OUT[0])&&(OUT[15]>OUT[1])&&(OUT[15]>OUT[2])&&(OUT[15]>OUT[3])&&(OUT[15]>OUT[4])&&(OUT[15]>OUT[5])&&(OUT[15]>OUT[6])&&(OUT[15]>OUT[7])&&(OUT[15]>OUT[8])&&(OUT[15]>OUT[9])
&&(OUT[15]>OUT[10])&&(OUT[15]>OUT[11])&&(OUT[15]>OUT[12])&&(OUT[15]>OUT[13])&&(OUT[15]>OUT[14])&&(OUT[15]>OUT[16])&&(OUT[15]>OUT[17])&&(OUT[15]>OUT[18])&&(OUT[15]>OUT[19])
&&(OUT[15]>OUT[20])&&(OUT[15]>OUT[21])&&(OUT[15]>OUT[22])&&(OUT[15]>OUT[23])&&(OUT[15]>OUT[24])&&(OUT[15]>OUT[25])&&(OUT[15]>OUT[26])&&(OUT[15]>OUT[27])&&(OUT[15]>OUT[28])
&&(OUT[15]>OUT[29])&&(OUT[15]>OUT[30])&&(OUT[15]>OUT[31])&&(OUT[15]>OUT[32])&&(OUT[15]>OUT[33])&&(OUT[15]>OUT[34])&&(OUT[15]>OUT[35])&&(OUT[15]>OUT[36])&&(OUT[15]>OUT[37])
&&(OUT[15]>OUT[38])&&(OUT[15]>OUT[39])&&(OUT[15]>OUT[40])&&(OUT[15]>OUT[41])&&(OUT[15]>OUT[42])&&(OUT[15]>OUT[43])&&(OUT[15]>OUT[44])&&(OUT[15]>OUT[45])&&(OUT[15]>OUT[46])
&&(OUT[15]>OUT[47])&&(OUT[15]>OUT[48]) ) 
{
MT_VCX=-0.5;
MT_VCY=-0.25;		
	
}

//17

else if((OUT[16]>OUT[0])&&(OUT[16]>OUT[1])&&(OUT[16]>OUT[2])&&(OUT[16]>OUT[3])&&(OUT[16]>OUT[4])&&(OUT[16]>OUT[5])&&(OUT[16]>OUT[6])&&(OUT[16]>OUT[7])&&(OUT[16]>OUT[8])&&(OUT[16]>OUT[9])
&&(OUT[16]>OUT[10])&&(OUT[16]>OUT[11])&&(OUT[16]>OUT[12])&&(OUT[16]>OUT[13])&&(OUT[16]>OUT[14])&&(OUT[16]>OUT[15])&&(OUT[16]>OUT[17])&&(OUT[16]>OUT[18])&&(OUT[16]>OUT[19])
&&(OUT[16]>OUT[20])&&(OUT[16]>OUT[21])&&(OUT[16]>OUT[22])&&(OUT[16]>OUT[23])&&(OUT[16]>OUT[24])&&(OUT[16]>OUT[25])&&(OUT[16]>OUT[26])&&(OUT[16]>OUT[27])&&(OUT[16]>OUT[28])
&&(OUT[16]>OUT[29])&&(OUT[16]>OUT[30])&&(OUT[16]>OUT[31])&&(OUT[16]>OUT[32])&&(OUT[16]>OUT[33])&&(OUT[16]>OUT[34])&&(OUT[16]>OUT[35])&&(OUT[16]>OUT[36])&&(OUT[16]>OUT[37])
&&(OUT[16]>OUT[38])&&(OUT[16]>OUT[39])&&(OUT[16]>OUT[40])&&(OUT[16]>OUT[41])&&(OUT[16]>OUT[42])&&(OUT[16]>OUT[43])&&(OUT[16]>OUT[44])&&(OUT[16]>OUT[45])&&(OUT[16]>OUT[46])
&&(OUT[16]>OUT[47])&&(OUT[16]>OUT[48]) ) 
{
MT_VCX=-0.25;
MT_VCY=-0.25;		
	
}

//18
	
else if((OUT[17]>OUT[0])&&(OUT[17]>OUT[1])&&(OUT[17]>OUT[2])&&(OUT[17]>OUT[3])&&(OUT[17]>OUT[4])&&(OUT[17]>OUT[5])&&(OUT[17]>OUT[6])&&(OUT[17]>OUT[7])&&(OUT[17]>OUT[8])&&(OUT[17]>OUT[9])
&&(OUT[17]>OUT[10])&&(OUT[17]>OUT[11])&&(OUT[17]>OUT[12])&&(OUT[17]>OUT[13])&&(OUT[17]>OUT[14])&&(OUT[17]>OUT[15])&&(OUT[17]>OUT[16])&&(OUT[17]>OUT[18])&&(OUT[17]>OUT[19])
&&(OUT[17]>OUT[20])&&(OUT[17]>OUT[21])&&(OUT[17]>OUT[22])&&(OUT[17]>OUT[23])&&(OUT[17]>OUT[24])&&(OUT[17]>OUT[25])&&(OUT[17]>OUT[26])&&(OUT[17]>OUT[27])&&(OUT[17]>OUT[28])
&&(OUT[17]>OUT[29])&&(OUT[17]>OUT[30])&&(OUT[17]>OUT[31])&&(OUT[17]>OUT[32])&&(OUT[17]>OUT[33])&&(OUT[17]>OUT[34])&&(OUT[17]>OUT[35])&&(OUT[17]>OUT[36])&&(OUT[17]>OUT[37])
&&(OUT[17]>OUT[38])&&(OUT[17]>OUT[39])&&(OUT[17]>OUT[40])&&(OUT[17]>OUT[41])&&(OUT[17]>OUT[42])&&(OUT[17]>OUT[43])&&(OUT[17]>OUT[44])&&(OUT[17]>OUT[45])&&(OUT[17]>OUT[46])
&&(OUT[17]>OUT[47])&&(OUT[17]>OUT[48]) ) 
{
MT_VCX=0;
MT_VCY=-0.25;		
	
}

//19

else if((OUT[18]>OUT[0])&&(OUT[18]>OUT[1])&&(OUT[18]>OUT[2])&&(OUT[18]>OUT[3])&&(OUT[18]>OUT[4])&&(OUT[18]>OUT[5])&&(OUT[18]>OUT[6])&&(OUT[18]>OUT[7])&&(OUT[18]>OUT[8])&&(OUT[18]>OUT[9])
&&(OUT[18]>OUT[10])&&(OUT[18]>OUT[11])&&(OUT[18]>OUT[12])&&(OUT[18]>OUT[13])&&(OUT[18]>OUT[14])&&(OUT[18]>OUT[15])&&(OUT[18]>OUT[16])&&(OUT[18]>OUT[17])&&(OUT[18]>OUT[19])
&&(OUT[18]>OUT[20])&&(OUT[18]>OUT[21])&&(OUT[18]>OUT[22])&&(OUT[18]>OUT[23])&&(OUT[18]>OUT[24])&&(OUT[18]>OUT[25])&&(OUT[18]>OUT[26])&&(OUT[18]>OUT[27])&&(OUT[18]>OUT[28])
&&(OUT[18]>OUT[29])&&(OUT[18]>OUT[30])&&(OUT[18]>OUT[31])&&(OUT[18]>OUT[32])&&(OUT[18]>OUT[33])&&(OUT[18]>OUT[34])&&(OUT[18]>OUT[35])&&(OUT[18]>OUT[36])&&(OUT[18]>OUT[37])
&&(OUT[18]>OUT[38])&&(OUT[18]>OUT[39])&&(OUT[18]>OUT[40])&&(OUT[18]>OUT[41])&&(OUT[18]>OUT[42])&&(OUT[18]>OUT[43])&&(OUT[18]>OUT[44])&&(OUT[18]>OUT[45])&&(OUT[18]>OUT[46])
&&(OUT[18]>OUT[47])&&(OUT[18]>OUT[48]) ) 
{
MT_VCX=0.25;
MT_VCY=-0.25;		
	
}

//20

else if((OUT[19]>OUT[0])&&(OUT[19]>OUT[1])&&(OUT[19]>OUT[2])&&(OUT[19]>OUT[3])&&(OUT[19]>OUT[4])&&(OUT[19]>OUT[5])&&(OUT[19]>OUT[6])&&(OUT[19]>OUT[7])&&(OUT[19]>OUT[8])&&(OUT[19]>OUT[9])
&&(OUT[19]>OUT[10])&&(OUT[19]>OUT[11])&&(OUT[19]>OUT[12])&&(OUT[19]>OUT[13])&&(OUT[19]>OUT[14])&&(OUT[19]>OUT[15])&&(OUT[19]>OUT[16])&&(OUT[19]>OUT[17])&&(OUT[19]>OUT[18])
&&(OUT[19]>OUT[20])&&(OUT[19]>OUT[21])&&(OUT[19]>OUT[22])&&(OUT[19]>OUT[23])&&(OUT[19]>OUT[24])&&(OUT[19]>OUT[25])&&(OUT[19]>OUT[26])&&(OUT[19]>OUT[27])&&(OUT[19]>OUT[28])
&&(OUT[19]>OUT[29])&&(OUT[19]>OUT[30])&&(OUT[19]>OUT[31])&&(OUT[19]>OUT[32])&&(OUT[19]>OUT[33])&&(OUT[19]>OUT[34])&&(OUT[19]>OUT[35])&&(OUT[19]>OUT[36])&&(OUT[19]>OUT[37])
&&(OUT[19]>OUT[38])&&(OUT[19]>OUT[39])&&(OUT[19]>OUT[40])&&(OUT[19]>OUT[41])&&(OUT[19]>OUT[42])&&(OUT[19]>OUT[43])&&(OUT[19]>OUT[44])&&(OUT[19]>OUT[45])&&(OUT[19]>OUT[46])
&&(OUT[19]>OUT[47])&&(OUT[19]>OUT[48]) ) 
{
MT_VCX=0.5;
MT_VCY=-0.25;		
	
}

//21

else if((OUT[20]>OUT[0])&&(OUT[20]>OUT[1])&&(OUT[20]>OUT[2])&&(OUT[20]>OUT[3])&&(OUT[20]>OUT[4])&&(OUT[20]>OUT[5])&&(OUT[20]>OUT[6])&&(OUT[20]>OUT[7])&&(OUT[20]>OUT[8])&&(OUT[20]>OUT[9])
&&(OUT[20]>OUT[10])&&(OUT[20]>OUT[11])&&(OUT[20]>OUT[12])&&(OUT[20]>OUT[13])&&(OUT[20]>OUT[14])&&(OUT[20]>OUT[15])&&(OUT[20]>OUT[16])&&(OUT[20]>OUT[17])&&(OUT[20]>OUT[18])
&&(OUT[20]>OUT[19])&&(OUT[20]>OUT[21])&&(OUT[20]>OUT[22])&&(OUT[20]>OUT[23])&&(OUT[20]>OUT[24])&&(OUT[20]>OUT[25])&&(OUT[20]>OUT[26])&&(OUT[20]>OUT[27])&&(OUT[20]>OUT[28])
&&(OUT[20]>OUT[29])&&(OUT[20]>OUT[30])&&(OUT[20]>OUT[31])&&(OUT[20]>OUT[32])&&(OUT[20]>OUT[33])&&(OUT[20]>OUT[34])&&(OUT[20]>OUT[35])&&(OUT[20]>OUT[36])&&(OUT[20]>OUT[37])
&&(OUT[20]>OUT[38])&&(OUT[20]>OUT[39])&&(OUT[20]>OUT[40])&&(OUT[20]>OUT[41])&&(OUT[20]>OUT[42])&&(OUT[20]>OUT[43])&&(OUT[20]>OUT[44])&&(OUT[20]>OUT[45])&&(OUT[20]>OUT[46])
&&(OUT[20]>OUT[47])&&(OUT[20]>OUT[48]) ) 
{
MT_VCX=0.75;
MT_VCY=-0.25;		
	
}

//22

else if((OUT[21]>OUT[0])&&(OUT[21]>OUT[1])&&(OUT[21]>OUT[2])&&(OUT[21]>OUT[3])&&(OUT[21]>OUT[4])&&(OUT[21]>OUT[5])&&(OUT[21]>OUT[6])&&(OUT[21]>OUT[7])&&(OUT[21]>OUT[8])&&(OUT[21]>OUT[9])
&&(OUT[21]>OUT[10])&&(OUT[21]>OUT[11])&&(OUT[21]>OUT[12])&&(OUT[21]>OUT[13])&&(OUT[21]>OUT[14])&&(OUT[21]>OUT[15])&&(OUT[21]>OUT[16])&&(OUT[21]>OUT[17])&&(OUT[21]>OUT[18])
&&(OUT[21]>OUT[19])&&(OUT[21]>OUT[20])&&(OUT[21]>OUT[22])&&(OUT[21]>OUT[23])&&(OUT[21]>OUT[24])&&(OUT[21]>OUT[25])&&(OUT[21]>OUT[26])&&(OUT[21]>OUT[27])&&(OUT[21]>OUT[28])
&&(OUT[21]>OUT[29])&&(OUT[21]>OUT[30])&&(OUT[21]>OUT[31])&&(OUT[21]>OUT[32])&&(OUT[21]>OUT[33])&&(OUT[21]>OUT[34])&&(OUT[21]>OUT[35])&&(OUT[21]>OUT[36])&&(OUT[21]>OUT[37])
&&(OUT[21]>OUT[38])&&(OUT[21]>OUT[39])&&(OUT[21]>OUT[40])&&(OUT[21]>OUT[41])&&(OUT[21]>OUT[42])&&(OUT[21]>OUT[43])&&(OUT[21]>OUT[44])&&(OUT[21]>OUT[45])&&(OUT[21]>OUT[46])
&&(OUT[21]>OUT[47])&&(OUT[21]>OUT[48]) ) 
{
MT_VCX=-0.75;
MT_VCY=0;	
	
}

//23

else if((OUT[22]>OUT[0])&&(OUT[22]>OUT[1])&&(OUT[22]>OUT[2])&&(OUT[22]>OUT[3])&&(OUT[22]>OUT[4])&&(OUT[22]>OUT[5])&&(OUT[22]>OUT[6])&&(OUT[22]>OUT[7])&&(OUT[22]>OUT[8])&&(OUT[22]>OUT[9])
&&(OUT[22]>OUT[10])&&(OUT[22]>OUT[11])&&(OUT[22]>OUT[12])&&(OUT[22]>OUT[13])&&(OUT[22]>OUT[14])&&(OUT[22]>OUT[15])&&(OUT[22]>OUT[16])&&(OUT[22]>OUT[17])&&(OUT[22]>OUT[18])
&&(OUT[22]>OUT[19])&&(OUT[22]>OUT[20])&&(OUT[22]>OUT[21])&&(OUT[22]>OUT[23])&&(OUT[22]>OUT[24])&&(OUT[22]>OUT[25])&&(OUT[22]>OUT[26])&&(OUT[22]>OUT[27])&&(OUT[22]>OUT[28])
&&(OUT[22]>OUT[29])&&(OUT[22]>OUT[30])&&(OUT[22]>OUT[31])&&(OUT[22]>OUT[32])&&(OUT[22]>OUT[33])&&(OUT[22]>OUT[34])&&(OUT[22]>OUT[35])&&(OUT[22]>OUT[36])&&(OUT[22]>OUT[37])
&&(OUT[22]>OUT[38])&&(OUT[22]>OUT[39])&&(OUT[22]>OUT[40])&&(OUT[22]>OUT[41])&&(OUT[22]>OUT[42])&&(OUT[22]>OUT[43])&&(OUT[22]>OUT[44])&&(OUT[22]>OUT[45])&&(OUT[22]>OUT[46])
&&(OUT[22]>OUT[47])&&(OUT[22]>OUT[48]) ) 
{
MT_VCX=-0.5;
MT_VCY=0;		
	
}

//24

else if((OUT[23]>OUT[0])&&(OUT[23]>OUT[1])&&(OUT[23]>OUT[2])&&(OUT[23]>OUT[3])&&(OUT[23]>OUT[4])&&(OUT[23]>OUT[5])&&(OUT[23]>OUT[6])&&(OUT[23]>OUT[7])&&(OUT[23]>OUT[8])&&(OUT[23]>OUT[9])
&&(OUT[23]>OUT[10])&&(OUT[23]>OUT[11])&&(OUT[23]>OUT[12])&&(OUT[23]>OUT[13])&&(OUT[23]>OUT[14])&&(OUT[23]>OUT[15])&&(OUT[23]>OUT[16])&&(OUT[23]>OUT[17])&&(OUT[23]>OUT[18])
&&(OUT[23]>OUT[19])&&(OUT[23]>OUT[20])&&(OUT[23]>OUT[21])&&(OUT[23]>OUT[22])&&(OUT[23]>OUT[24])&&(OUT[23]>OUT[25])&&(OUT[23]>OUT[26])&&(OUT[23]>OUT[27])&&(OUT[23]>OUT[28])
&&(OUT[23]>OUT[29])&&(OUT[23]>OUT[30])&&(OUT[23]>OUT[31])&&(OUT[23]>OUT[32])&&(OUT[23]>OUT[33])&&(OUT[23]>OUT[34])&&(OUT[23]>OUT[35])&&(OUT[23]>OUT[36])&&(OUT[23]>OUT[37])
&&(OUT[23]>OUT[38])&&(OUT[23]>OUT[39])&&(OUT[23]>OUT[40])&&(OUT[23]>OUT[41])&&(OUT[23]>OUT[42])&&(OUT[23]>OUT[43])&&(OUT[23]>OUT[44])&&(OUT[23]>OUT[45])&&(OUT[23]>OUT[46])
&&(OUT[23]>OUT[47])&&(OUT[23]>OUT[48]) ) 
{
MT_VCX=-0.25;
MT_VCY=0;		
	
}

//25

else if((OUT[24]>OUT[0])&&(OUT[24]>OUT[1])&&(OUT[24]>OUT[2])&&(OUT[24]>OUT[3])&&(OUT[24]>OUT[4])&&(OUT[24]>OUT[5])&&(OUT[24]>OUT[6])&&(OUT[24]>OUT[7])&&(OUT[24]>OUT[8])&&(OUT[24]>OUT[9])
&&(OUT[24]>OUT[10])&&(OUT[24]>OUT[11])&&(OUT[24]>OUT[12])&&(OUT[24]>OUT[13])&&(OUT[24]>OUT[14])&&(OUT[24]>OUT[15])&&(OUT[24]>OUT[16])&&(OUT[24]>OUT[17])&&(OUT[24]>OUT[18])
&&(OUT[24]>OUT[19])&&(OUT[24]>OUT[20])&&(OUT[24]>OUT[21])&&(OUT[24]>OUT[22])&&(OUT[24]>OUT[23])&&(OUT[24]>OUT[25])&&(OUT[24]>OUT[26])&&(OUT[24]>OUT[27])&&(OUT[24]>OUT[28])
&&(OUT[24]>OUT[29])&&(OUT[24]>OUT[30])&&(OUT[24]>OUT[31])&&(OUT[24]>OUT[32])&&(OUT[24]>OUT[33])&&(OUT[24]>OUT[34])&&(OUT[24]>OUT[35])&&(OUT[24]>OUT[36])&&(OUT[24]>OUT[37])
&&(OUT[24]>OUT[38])&&(OUT[24]>OUT[39])&&(OUT[24]>OUT[40])&&(OUT[24]>OUT[41])&&(OUT[24]>OUT[42])&&(OUT[24]>OUT[43])&&(OUT[24]>OUT[44])&&(OUT[24]>OUT[45])&&(OUT[24]>OUT[46])
&&(OUT[24]>OUT[47])&&(OUT[24]>OUT[48]) ) 
{
MT_VCX=0;
MT_VCY=0;	
	
}

//26

else if((OUT[25]>OUT[0])&&(OUT[25]>OUT[1])&&(OUT[25]>OUT[2])&&(OUT[25]>OUT[3])&&(OUT[25]>OUT[4])&&(OUT[25]>OUT[5])&&(OUT[25]>OUT[6])&&(OUT[25]>OUT[7])&&(OUT[25]>OUT[8])&&(OUT[25]>OUT[9])
&&(OUT[25]>OUT[10])&&(OUT[25]>OUT[11])&&(OUT[25]>OUT[12])&&(OUT[25]>OUT[13])&&(OUT[25]>OUT[14])&&(OUT[25]>OUT[15])&&(OUT[25]>OUT[16])&&(OUT[25]>OUT[17])&&(OUT[25]>OUT[18])
&&(OUT[25]>OUT[19])&&(OUT[25]>OUT[20])&&(OUT[25]>OUT[21])&&(OUT[25]>OUT[22])&&(OUT[25]>OUT[23])&&(OUT[25]>OUT[24])&&(OUT[25]>OUT[26])&&(OUT[25]>OUT[27])&&(OUT[25]>OUT[28])
&&(OUT[25]>OUT[29])&&(OUT[25]>OUT[30])&&(OUT[25]>OUT[31])&&(OUT[25]>OUT[32])&&(OUT[25]>OUT[33])&&(OUT[25]>OUT[34])&&(OUT[25]>OUT[35])&&(OUT[25]>OUT[36])&&(OUT[25]>OUT[37])
&&(OUT[25]>OUT[38])&&(OUT[25]>OUT[39])&&(OUT[25]>OUT[40])&&(OUT[25]>OUT[41])&&(OUT[25]>OUT[42])&&(OUT[25]>OUT[43])&&(OUT[25]>OUT[44])&&(OUT[25]>OUT[45])&&(OUT[25]>OUT[46])
&&(OUT[25]>OUT[47])&&(OUT[25]>OUT[48]) ) 
{
MT_VCX=0.25;
MT_VCY=0;		
	
}

//27

else if((OUT[26]>OUT[0])&&(OUT[26]>OUT[1])&&(OUT[26]>OUT[2])&&(OUT[26]>OUT[3])&&(OUT[26]>OUT[4])&&(OUT[26]>OUT[5])&&(OUT[26]>OUT[6])&&(OUT[26]>OUT[7])&&(OUT[26]>OUT[8])&&(OUT[26]>OUT[9])
&&(OUT[26]>OUT[10])&&(OUT[26]>OUT[11])&&(OUT[26]>OUT[12])&&(OUT[26]>OUT[13])&&(OUT[26]>OUT[14])&&(OUT[26]>OUT[15])&&(OUT[26]>OUT[16])&&(OUT[26]>OUT[17])&&(OUT[26]>OUT[18])
&&(OUT[26]>OUT[19])&&(OUT[26]>OUT[20])&&(OUT[26]>OUT[21])&&(OUT[26]>OUT[22])&&(OUT[26]>OUT[23])&&(OUT[26]>OUT[24])&&(OUT[26]>OUT[25])&&(OUT[26]>OUT[27])&&(OUT[26]>OUT[28])
&&(OUT[26]>OUT[29])&&(OUT[26]>OUT[30])&&(OUT[26]>OUT[31])&&(OUT[26]>OUT[32])&&(OUT[26]>OUT[33])&&(OUT[26]>OUT[34])&&(OUT[26]>OUT[35])&&(OUT[26]>OUT[36])&&(OUT[26]>OUT[37])
&&(OUT[26]>OUT[38])&&(OUT[26]>OUT[39])&&(OUT[26]>OUT[40])&&(OUT[26]>OUT[41])&&(OUT[26]>OUT[42])&&(OUT[26]>OUT[43])&&(OUT[26]>OUT[44])&&(OUT[26]>OUT[45])&&(OUT[26]>OUT[46])
&&(OUT[26]>OUT[47])&&(OUT[26]>OUT[48]) ) 
{
MT_VCX=0.5;
MT_VCY=0;		
	
}


//28

else if((OUT[27]>OUT[0])&&(OUT[27]>OUT[1])&&(OUT[27]>OUT[2])&&(OUT[27]>OUT[3])&&(OUT[27]>OUT[4])&&(OUT[27]>OUT[5])&&(OUT[27]>OUT[6])&&(OUT[27]>OUT[7])&&(OUT[27]>OUT[8])&&(OUT[27]>OUT[9])
&&(OUT[27]>OUT[10])&&(OUT[27]>OUT[11])&&(OUT[27]>OUT[12])&&(OUT[27]>OUT[13])&&(OUT[27]>OUT[14])&&(OUT[27]>OUT[15])&&(OUT[27]>OUT[16])&&(OUT[27]>OUT[17])&&(OUT[27]>OUT[18])
&&(OUT[27]>OUT[19])&&(OUT[27]>OUT[20])&&(OUT[27]>OUT[21])&&(OUT[27]>OUT[22])&&(OUT[27]>OUT[23])&&(OUT[27]>OUT[24])&&(OUT[27]>OUT[25])&&(OUT[27]>OUT[26])&&(OUT[27]>OUT[28])
&&(OUT[27]>OUT[29])&&(OUT[27]>OUT[30])&&(OUT[27]>OUT[31])&&(OUT[27]>OUT[32])&&(OUT[27]>OUT[33])&&(OUT[27]>OUT[34])&&(OUT[27]>OUT[35])&&(OUT[27]>OUT[36])&&(OUT[27]>OUT[37])
&&(OUT[27]>OUT[38])&&(OUT[27]>OUT[39])&&(OUT[27]>OUT[40])&&(OUT[27]>OUT[41])&&(OUT[27]>OUT[42])&&(OUT[27]>OUT[43])&&(OUT[27]>OUT[44])&&(OUT[27]>OUT[45])&&(OUT[27]>OUT[46])
&&(OUT[27]>OUT[47])&&(OUT[27]>OUT[48]) ) 
{
MT_VCX=0.75;
MT_VCY=0;		
	
}

//29

else if((OUT[28]>OUT[0])&&(OUT[28]>OUT[1])&&(OUT[28]>OUT[2])&&(OUT[28]>OUT[3])&&(OUT[28]>OUT[4])&&(OUT[28]>OUT[5])&&(OUT[28]>OUT[6])&&(OUT[28]>OUT[7])&&(OUT[28]>OUT[8])&&(OUT[28]>OUT[9])
&&(OUT[28]>OUT[10])&&(OUT[28]>OUT[11])&&(OUT[28]>OUT[12])&&(OUT[28]>OUT[13])&&(OUT[28]>OUT[14])&&(OUT[28]>OUT[15])&&(OUT[28]>OUT[16])&&(OUT[28]>OUT[17])&&(OUT[28]>OUT[18])
&&(OUT[28]>OUT[19])&&(OUT[28]>OUT[20])&&(OUT[28]>OUT[21])&&(OUT[28]>OUT[22])&&(OUT[28]>OUT[23])&&(OUT[28]>OUT[24])&&(OUT[28]>OUT[25])&&(OUT[28]>OUT[26])&&(OUT[28]>OUT[27])
&&(OUT[28]>OUT[29])&&(OUT[28]>OUT[30])&&(OUT[28]>OUT[31])&&(OUT[28]>OUT[32])&&(OUT[28]>OUT[33])&&(OUT[28]>OUT[34])&&(OUT[28]>OUT[35])&&(OUT[28]>OUT[36])&&(OUT[28]>OUT[37])
&&(OUT[28]>OUT[38])&&(OUT[28]>OUT[39])&&(OUT[28]>OUT[40])&&(OUT[28]>OUT[41])&&(OUT[28]>OUT[42])&&(OUT[28]>OUT[43])&&(OUT[28]>OUT[44])&&(OUT[28]>OUT[45])&&(OUT[28]>OUT[46])
&&(OUT[28]>OUT[47])&&(OUT[28]>OUT[48]) ) 
{
MT_VCX=-0.75;
MT_VCY=0.25;		
	
}

//30

else if((OUT[29]>OUT[0])&&(OUT[29]>OUT[1])&&(OUT[29]>OUT[2])&&(OUT[29]>OUT[3])&&(OUT[29]>OUT[4])&&(OUT[29]>OUT[5])&&(OUT[29]>OUT[6])&&(OUT[29]>OUT[7])&&(OUT[29]>OUT[8])&&(OUT[29]>OUT[9])
&&(OUT[29]>OUT[10])&&(OUT[29]>OUT[11])&&(OUT[29]>OUT[12])&&(OUT[29]>OUT[13])&&(OUT[29]>OUT[14])&&(OUT[29]>OUT[15])&&(OUT[29]>OUT[16])&&(OUT[29]>OUT[17])&&(OUT[29]>OUT[18])
&&(OUT[29]>OUT[19])&&(OUT[29]>OUT[20])&&(OUT[29]>OUT[21])&&(OUT[29]>OUT[22])&&(OUT[29]>OUT[23])&&(OUT[29]>OUT[24])&&(OUT[29]>OUT[25])&&(OUT[29]>OUT[26])&&(OUT[29]>OUT[27])
&&(OUT[29]>OUT[28])&&(OUT[29]>OUT[30])&&(OUT[29]>OUT[31])&&(OUT[29]>OUT[32])&&(OUT[29]>OUT[33])&&(OUT[29]>OUT[34])&&(OUT[29]>OUT[35])&&(OUT[29]>OUT[36])&&(OUT[29]>OUT[37])
&&(OUT[29]>OUT[38])&&(OUT[29]>OUT[39])&&(OUT[29]>OUT[40])&&(OUT[29]>OUT[41])&&(OUT[29]>OUT[42])&&(OUT[29]>OUT[43])&&(OUT[29]>OUT[44])&&(OUT[29]>OUT[45])&&(OUT[29]>OUT[46])
&&(OUT[29]>OUT[47])&&(OUT[29]>OUT[48]) ) 
{
MT_VCX=-0.5;
MT_VCY=0.25;		
	
}

//31

else if((OUT[30]>OUT[0])&&(OUT[30]>OUT[1])&&(OUT[30]>OUT[2])&&(OUT[30]>OUT[3])&&(OUT[30]>OUT[4])&&(OUT[30]>OUT[5])&&(OUT[30]>OUT[6])&&(OUT[30]>OUT[7])&&(OUT[30]>OUT[8])&&(OUT[30]>OUT[9])
&&(OUT[30]>OUT[10])&&(OUT[30]>OUT[11])&&(OUT[30]>OUT[12])&&(OUT[30]>OUT[13])&&(OUT[30]>OUT[14])&&(OUT[30]>OUT[15])&&(OUT[30]>OUT[16])&&(OUT[30]>OUT[17])&&(OUT[30]>OUT[18])
&&(OUT[30]>OUT[19])&&(OUT[30]>OUT[20])&&(OUT[30]>OUT[21])&&(OUT[30]>OUT[22])&&(OUT[30]>OUT[23])&&(OUT[30]>OUT[24])&&(OUT[30]>OUT[25])&&(OUT[30]>OUT[26])&&(OUT[30]>OUT[27])
&&(OUT[30]>OUT[28])&&(OUT[30]>OUT[29])&&(OUT[30]>OUT[31])&&(OUT[30]>OUT[32])&&(OUT[30]>OUT[33])&&(OUT[30]>OUT[34])&&(OUT[30]>OUT[35])&&(OUT[30]>OUT[36])&&(OUT[30]>OUT[37])
&&(OUT[30]>OUT[38])&&(OUT[30]>OUT[39])&&(OUT[30]>OUT[40])&&(OUT[30]>OUT[41])&&(OUT[30]>OUT[42])&&(OUT[30]>OUT[43])&&(OUT[30]>OUT[44])&&(OUT[30]>OUT[45])&&(OUT[30]>OUT[46])
&&(OUT[30]>OUT[47])&&(OUT[30]>OUT[48]) ) 
{
MT_VCX=-0.25;
MT_VCY=0.25;		
	
}

//32

else if((OUT[31]>OUT[0])&&(OUT[31]>OUT[1])&&(OUT[31]>OUT[2])&&(OUT[31]>OUT[3])&&(OUT[31]>OUT[4])&&(OUT[31]>OUT[5])&&(OUT[31]>OUT[6])&&(OUT[31]>OUT[7])&&(OUT[31]>OUT[8])&&(OUT[31]>OUT[9])
&&(OUT[31]>OUT[10])&&(OUT[31]>OUT[11])&&(OUT[31]>OUT[12])&&(OUT[31]>OUT[13])&&(OUT[31]>OUT[14])&&(OUT[31]>OUT[15])&&(OUT[31]>OUT[16])&&(OUT[31]>OUT[17])&&(OUT[31]>OUT[18])
&&(OUT[31]>OUT[19])&&(OUT[31]>OUT[20])&&(OUT[31]>OUT[21])&&(OUT[31]>OUT[22])&&(OUT[31]>OUT[23])&&(OUT[31]>OUT[24])&&(OUT[31]>OUT[25])&&(OUT[31]>OUT[26])&&(OUT[31]>OUT[27])
&&(OUT[31]>OUT[28])&&(OUT[31]>OUT[29])&&(OUT[31]>OUT[30])&&(OUT[31]>OUT[32])&&(OUT[31]>OUT[33])&&(OUT[31]>OUT[34])&&(OUT[31]>OUT[35])&&(OUT[31]>OUT[36])&&(OUT[31]>OUT[37])
&&(OUT[31]>OUT[38])&&(OUT[31]>OUT[39])&&(OUT[31]>OUT[40])&&(OUT[31]>OUT[41])&&(OUT[31]>OUT[42])&&(OUT[31]>OUT[43])&&(OUT[31]>OUT[44])&&(OUT[31]>OUT[45])&&(OUT[31]>OUT[46])
&&(OUT[31]>OUT[47])&&(OUT[31]>OUT[48]) ) 
{
	
MT_VCX=0;
MT_VCY=0.25;		
}

//33

else if((OUT[32]>OUT[0])&&(OUT[32]>OUT[1])&&(OUT[32]>OUT[2])&&(OUT[32]>OUT[3])&&(OUT[32]>OUT[4])&&(OUT[32]>OUT[5])&&(OUT[32]>OUT[6])&&(OUT[32]>OUT[7])&&(OUT[32]>OUT[8])&&(OUT[32]>OUT[9])
&&(OUT[32]>OUT[10])&&(OUT[32]>OUT[11])&&(OUT[32]>OUT[12])&&(OUT[32]>OUT[13])&&(OUT[32]>OUT[14])&&(OUT[32]>OUT[15])&&(OUT[32]>OUT[16])&&(OUT[32]>OUT[17])&&(OUT[32]>OUT[18])
&&(OUT[32]>OUT[19])&&(OUT[32]>OUT[20])&&(OUT[32]>OUT[21])&&(OUT[32]>OUT[22])&&(OUT[32]>OUT[23])&&(OUT[32]>OUT[24])&&(OUT[32]>OUT[25])&&(OUT[32]>OUT[26])&&(OUT[32]>OUT[27])
&&(OUT[32]>OUT[28])&&(OUT[32]>OUT[29])&&(OUT[32]>OUT[30])&&(OUT[32]>OUT[31])&&(OUT[32]>OUT[33])&&(OUT[32]>OUT[34])&&(OUT[32]>OUT[35])&&(OUT[32]>OUT[36])&&(OUT[32]>OUT[37])
&&(OUT[32]>OUT[38])&&(OUT[32]>OUT[39])&&(OUT[32]>OUT[40])&&(OUT[32]>OUT[41])&&(OUT[32]>OUT[42])&&(OUT[32]>OUT[43])&&(OUT[32]>OUT[44])&&(OUT[32]>OUT[45])&&(OUT[32]>OUT[46])
&&(OUT[32]>OUT[47])&&(OUT[32]>OUT[48]) ) 
{
MT_VCX=0.25;
MT_VCY=0.25;		
	
}

//34

else if((OUT[33]>OUT[0])&&(OUT[33]>OUT[1])&&(OUT[33]>OUT[2])&&(OUT[33]>OUT[3])&&(OUT[33]>OUT[4])&&(OUT[33]>OUT[5])&&(OUT[33]>OUT[6])&&(OUT[33]>OUT[7])&&(OUT[33]>OUT[8])&&(OUT[33]>OUT[9])
&&(OUT[33]>OUT[10])&&(OUT[33]>OUT[11])&&(OUT[33]>OUT[12])&&(OUT[33]>OUT[13])&&(OUT[33]>OUT[14])&&(OUT[33]>OUT[15])&&(OUT[33]>OUT[16])&&(OUT[33]>OUT[17])&&(OUT[33]>OUT[18])
&&(OUT[33]>OUT[19])&&(OUT[33]>OUT[20])&&(OUT[33]>OUT[21])&&(OUT[33]>OUT[22])&&(OUT[33]>OUT[23])&&(OUT[33]>OUT[24])&&(OUT[33]>OUT[25])&&(OUT[33]>OUT[26])&&(OUT[33]>OUT[27])
&&(OUT[33]>OUT[28])&&(OUT[33]>OUT[29])&&(OUT[33]>OUT[30])&&(OUT[33]>OUT[31])&&(OUT[33]>OUT[32])&&(OUT[33]>OUT[34])&&(OUT[33]>OUT[35])&&(OUT[33]>OUT[36])&&(OUT[33]>OUT[37])
&&(OUT[33]>OUT[38])&&(OUT[33]>OUT[39])&&(OUT[33]>OUT[40])&&(OUT[33]>OUT[41])&&(OUT[33]>OUT[42])&&(OUT[33]>OUT[43])&&(OUT[33]>OUT[44])&&(OUT[33]>OUT[45])&&(OUT[33]>OUT[46])
&&(OUT[33]>OUT[47])&&(OUT[33]>OUT[48]) ) 
{
MT_VCX=0.5;
MT_VCY=0.25;		
	
}


//35

else if((OUT[34]>OUT[0])&&(OUT[34]>OUT[1])&&(OUT[34]>OUT[2])&&(OUT[34]>OUT[3])&&(OUT[34]>OUT[4])&&(OUT[34]>OUT[5])&&(OUT[34]>OUT[6])&&(OUT[34]>OUT[7])&&(OUT[34]>OUT[8])&&(OUT[34]>OUT[9])
&&(OUT[34]>OUT[10])&&(OUT[34]>OUT[11])&&(OUT[34]>OUT[12])&&(OUT[34]>OUT[13])&&(OUT[34]>OUT[14])&&(OUT[34]>OUT[15])&&(OUT[34]>OUT[16])&&(OUT[34]>OUT[17])&&(OUT[34]>OUT[18])
&&(OUT[34]>OUT[19])&&(OUT[34]>OUT[20])&&(OUT[34]>OUT[21])&&(OUT[34]>OUT[22])&&(OUT[34]>OUT[23])&&(OUT[34]>OUT[24])&&(OUT[34]>OUT[25])&&(OUT[34]>OUT[26])&&(OUT[34]>OUT[27])
&&(OUT[34]>OUT[28])&&(OUT[34]>OUT[29])&&(OUT[34]>OUT[30])&&(OUT[34]>OUT[31])&&(OUT[34]>OUT[32])&&(OUT[34]>OUT[33])&&(OUT[34]>OUT[35])&&(OUT[34]>OUT[36])&&(OUT[34]>OUT[37])
&&(OUT[34]>OUT[38])&&(OUT[34]>OUT[39])&&(OUT[34]>OUT[40])&&(OUT[34]>OUT[41])&&(OUT[34]>OUT[42])&&(OUT[34]>OUT[43])&&(OUT[34]>OUT[44])&&(OUT[34]>OUT[45])&&(OUT[34]>OUT[46])
&&(OUT[34]>OUT[47])&&(OUT[34]>OUT[48]) ) 
{
MT_VCX=0.75;
MT_VCY=0.25;		
	
}


//36

else if((OUT[35]>OUT[0])&&(OUT[35]>OUT[1])&&(OUT[35]>OUT[2])&&(OUT[35]>OUT[3])&&(OUT[35]>OUT[4])&&(OUT[35]>OUT[5])&&(OUT[35]>OUT[6])&&(OUT[35]>OUT[7])&&(OUT[35]>OUT[8])&&(OUT[35]>OUT[9])
&&(OUT[35]>OUT[10])&&(OUT[35]>OUT[11])&&(OUT[35]>OUT[12])&&(OUT[35]>OUT[13])&&(OUT[35]>OUT[14])&&(OUT[35]>OUT[15])&&(OUT[35]>OUT[16])&&(OUT[35]>OUT[17])&&(OUT[35]>OUT[18])
&&(OUT[35]>OUT[19])&&(OUT[35]>OUT[20])&&(OUT[35]>OUT[21])&&(OUT[35]>OUT[22])&&(OUT[35]>OUT[23])&&(OUT[35]>OUT[24])&&(OUT[35]>OUT[25])&&(OUT[35]>OUT[26])&&(OUT[35]>OUT[27])
&&(OUT[35]>OUT[28])&&(OUT[35]>OUT[29])&&(OUT[35]>OUT[30])&&(OUT[35]>OUT[31])&&(OUT[35]>OUT[32])&&(OUT[35]>OUT[33])&&(OUT[35]>OUT[34])&&(OUT[35]>OUT[36])&&(OUT[35]>OUT[37])
&&(OUT[35]>OUT[38])&&(OUT[35]>OUT[39])&&(OUT[35]>OUT[40])&&(OUT[35]>OUT[41])&&(OUT[35]>OUT[42])&&(OUT[35]>OUT[43])&&(OUT[35]>OUT[44])&&(OUT[35]>OUT[45])&&(OUT[35]>OUT[46])
&&(OUT[35]>OUT[47])&&(OUT[35]>OUT[48]) ) 
{
MT_VCX=-0.75;
MT_VCY=0.5;		
	
}

//37

else if((OUT[36]>OUT[0])&&(OUT[36]>OUT[1])&&(OUT[36]>OUT[2])&&(OUT[36]>OUT[3])&&(OUT[36]>OUT[4])&&(OUT[36]>OUT[5])&&(OUT[36]>OUT[6])&&(OUT[36]>OUT[7])&&(OUT[36]>OUT[8])&&(OUT[36]>OUT[9])
&&(OUT[36]>OUT[10])&&(OUT[36]>OUT[11])&&(OUT[36]>OUT[12])&&(OUT[36]>OUT[13])&&(OUT[36]>OUT[14])&&(OUT[36]>OUT[15])&&(OUT[36]>OUT[16])&&(OUT[36]>OUT[17])&&(OUT[36]>OUT[18])
&&(OUT[36]>OUT[19])&&(OUT[36]>OUT[20])&&(OUT[36]>OUT[21])&&(OUT[36]>OUT[22])&&(OUT[36]>OUT[23])&&(OUT[36]>OUT[24])&&(OUT[36]>OUT[25])&&(OUT[36]>OUT[26])&&(OUT[36]>OUT[27])
&&(OUT[36]>OUT[28])&&(OUT[36]>OUT[29])&&(OUT[36]>OUT[30])&&(OUT[36]>OUT[31])&&(OUT[36]>OUT[32])&&(OUT[36]>OUT[33])&&(OUT[36]>OUT[34])&&(OUT[36]>OUT[35])&&(OUT[36]>OUT[37])
&&(OUT[36]>OUT[38])&&(OUT[36]>OUT[39])&&(OUT[36]>OUT[40])&&(OUT[36]>OUT[41])&&(OUT[36]>OUT[42])&&(OUT[36]>OUT[43])&&(OUT[36]>OUT[44])&&(OUT[36]>OUT[45])&&(OUT[36]>OUT[46])
&&(OUT[36]>OUT[47])&&(OUT[36]>OUT[48]) ) 
{
MT_VCX=-0.5;
MT_VCY=0.5;		
	
}

//38

else if((OUT[37]>OUT[0])&&(OUT[37]>OUT[1])&&(OUT[37]>OUT[2])&&(OUT[37]>OUT[3])&&(OUT[37]>OUT[4])&&(OUT[37]>OUT[5])&&(OUT[37]>OUT[6])&&(OUT[37]>OUT[7])&&(OUT[37]>OUT[8])&&(OUT[37]>OUT[9])
&&(OUT[37]>OUT[10])&&(OUT[37]>OUT[11])&&(OUT[37]>OUT[12])&&(OUT[37]>OUT[13])&&(OUT[37]>OUT[14])&&(OUT[37]>OUT[15])&&(OUT[37]>OUT[16])&&(OUT[37]>OUT[17])&&(OUT[37]>OUT[18])
&&(OUT[37]>OUT[19])&&(OUT[37]>OUT[20])&&(OUT[37]>OUT[21])&&(OUT[37]>OUT[22])&&(OUT[37]>OUT[23])&&(OUT[37]>OUT[24])&&(OUT[37]>OUT[25])&&(OUT[37]>OUT[26])&&(OUT[37]>OUT[27])
&&(OUT[37]>OUT[28])&&(OUT[37]>OUT[29])&&(OUT[37]>OUT[30])&&(OUT[37]>OUT[31])&&(OUT[37]>OUT[32])&&(OUT[37]>OUT[33])&&(OUT[37]>OUT[34])&&(OUT[37]>OUT[35])&&(OUT[37]>OUT[36])
&&(OUT[37]>OUT[38])&&(OUT[37]>OUT[39])&&(OUT[37]>OUT[40])&&(OUT[37]>OUT[41])&&(OUT[37]>OUT[42])&&(OUT[37]>OUT[43])&&(OUT[37]>OUT[44])&&(OUT[37]>OUT[45])&&(OUT[37]>OUT[46])
&&(OUT[37]>OUT[47])&&(OUT[37]>OUT[48]) ) 
{
MT_VCX=-0.25;
MT_VCY=0.5;		
	
}
//39

else if((OUT[38]>OUT[0])&&(OUT[38]>OUT[1])&&(OUT[38]>OUT[2])&&(OUT[38]>OUT[3])&&(OUT[38]>OUT[4])&&(OUT[38]>OUT[5])&&(OUT[38]>OUT[6])&&(OUT[38]>OUT[7])&&(OUT[38]>OUT[8])&&(OUT[38]>OUT[9])
&&(OUT[38]>OUT[10])&&(OUT[38]>OUT[11])&&(OUT[38]>OUT[12])&&(OUT[38]>OUT[13])&&(OUT[38]>OUT[14])&&(OUT[38]>OUT[15])&&(OUT[38]>OUT[16])&&(OUT[38]>OUT[17])&&(OUT[38]>OUT[18])
&&(OUT[38]>OUT[19])&&(OUT[38]>OUT[20])&&(OUT[38]>OUT[21])&&(OUT[38]>OUT[22])&&(OUT[38]>OUT[23])&&(OUT[38]>OUT[24])&&(OUT[38]>OUT[25])&&(OUT[38]>OUT[26])&&(OUT[38]>OUT[27])
&&(OUT[38]>OUT[28])&&(OUT[38]>OUT[29])&&(OUT[38]>OUT[30])&&(OUT[38]>OUT[31])&&(OUT[38]>OUT[32])&&(OUT[38]>OUT[33])&&(OUT[38]>OUT[34])&&(OUT[38]>OUT[35])&&(OUT[38]>OUT[36])
&&(OUT[38]>OUT[37])&&(OUT[38]>OUT[39])&&(OUT[38]>OUT[40])&&(OUT[38]>OUT[41])&&(OUT[38]>OUT[42])&&(OUT[38]>OUT[43])&&(OUT[38]>OUT[44])&&(OUT[38]>OUT[45])&&(OUT[38]>OUT[46])
&&(OUT[38]>OUT[47])&&(OUT[38]>OUT[48]) ) 
{
MT_VCX=0;
MT_VCY=0.5;		
	
}

//40
else if((OUT[39]>OUT[0])&&(OUT[39]>OUT[1])&&(OUT[39]>OUT[2])&&(OUT[39]>OUT[3])&&(OUT[39]>OUT[4])&&(OUT[39]>OUT[5])&&(OUT[39]>OUT[6])&&(OUT[39]>OUT[7])&&(OUT[39]>OUT[8])&&(OUT[39]>OUT[9])
&&(OUT[39]>OUT[10])&&(OUT[39]>OUT[11])&&(OUT[39]>OUT[12])&&(OUT[39]>OUT[13])&&(OUT[39]>OUT[14])&&(OUT[39]>OUT[15])&&(OUT[39]>OUT[16])&&(OUT[39]>OUT[17])&&(OUT[39]>OUT[18])
&&(OUT[39]>OUT[19])&&(OUT[39]>OUT[20])&&(OUT[39]>OUT[21])&&(OUT[39]>OUT[22])&&(OUT[39]>OUT[23])&&(OUT[39]>OUT[24])&&(OUT[39]>OUT[25])&&(OUT[39]>OUT[26])&&(OUT[39]>OUT[27])
&&(OUT[39]>OUT[28])&&(OUT[39]>OUT[29])&&(OUT[39]>OUT[30])&&(OUT[39]>OUT[31])&&(OUT[39]>OUT[32])&&(OUT[39]>OUT[33])&&(OUT[39]>OUT[34])&&(OUT[39]>OUT[35])&&(OUT[39]>OUT[36])
&&(OUT[39]>OUT[37])&&(OUT[39]>OUT[38])&&(OUT[39]>OUT[40])&&(OUT[39]>OUT[41])&&(OUT[39]>OUT[42])&&(OUT[39]>OUT[43])&&(OUT[39]>OUT[44])&&(OUT[39]>OUT[45])&&(OUT[39]>OUT[46])
&&(OUT[39]>OUT[47])&&(OUT[39]>OUT[48]) ) 
{
MT_VCX=0.25;
MT_VCY=0.5;		
	
}

//41

else if((OUT[40]>OUT[0])&&(OUT[40]>OUT[1])&&(OUT[40]>OUT[2])&&(OUT[40]>OUT[3])&&(OUT[40]>OUT[4])&&(OUT[40]>OUT[5])&&(OUT[40]>OUT[6])&&(OUT[40]>OUT[7])&&(OUT[40]>OUT[8])&&(OUT[40]>OUT[9])
&&(OUT[40]>OUT[10])&&(OUT[40]>OUT[11])&&(OUT[40]>OUT[12])&&(OUT[40]>OUT[13])&&(OUT[40]>OUT[14])&&(OUT[40]>OUT[15])&&(OUT[40]>OUT[16])&&(OUT[40]>OUT[17])&&(OUT[40]>OUT[18])
&&(OUT[40]>OUT[19])&&(OUT[40]>OUT[20])&&(OUT[40]>OUT[21])&&(OUT[40]>OUT[22])&&(OUT[40]>OUT[23])&&(OUT[40]>OUT[24])&&(OUT[40]>OUT[25])&&(OUT[40]>OUT[26])&&(OUT[40]>OUT[27])
&&(OUT[40]>OUT[28])&&(OUT[40]>OUT[29])&&(OUT[40]>OUT[30])&&(OUT[40]>OUT[31])&&(OUT[40]>OUT[32])&&(OUT[40]>OUT[33])&&(OUT[40]>OUT[34])&&(OUT[40]>OUT[35])&&(OUT[40]>OUT[36])
&&(OUT[40]>OUT[37])&&(OUT[40]>OUT[38])&&(OUT[40]>OUT[39])&&(OUT[40]>OUT[41])&&(OUT[40]>OUT[42])&&(OUT[40]>OUT[43])&&(OUT[40]>OUT[44])&&(OUT[40]>OUT[45])&&(OUT[40]>OUT[46])
&&(OUT[40]>OUT[47])&&(OUT[40]>OUT[48]) ) 
{
MT_VCX=0.5;
MT_VCY=0.5;		
	
}

//42

else if((OUT[41]>OUT[0])&&(OUT[41]>OUT[1])&&(OUT[41]>OUT[2])&&(OUT[41]>OUT[3])&&(OUT[41]>OUT[4])&&(OUT[41]>OUT[5])&&(OUT[41]>OUT[6])&&(OUT[41]>OUT[7])&&(OUT[41]>OUT[8])&&(OUT[41]>OUT[9])
&&(OUT[41]>OUT[10])&&(OUT[41]>OUT[11])&&(OUT[41]>OUT[12])&&(OUT[41]>OUT[13])&&(OUT[41]>OUT[14])&&(OUT[41]>OUT[15])&&(OUT[41]>OUT[16])&&(OUT[41]>OUT[17])&&(OUT[41]>OUT[18])
&&(OUT[41]>OUT[19])&&(OUT[41]>OUT[20])&&(OUT[41]>OUT[21])&&(OUT[41]>OUT[22])&&(OUT[41]>OUT[23])&&(OUT[41]>OUT[24])&&(OUT[41]>OUT[25])&&(OUT[41]>OUT[26])&&(OUT[41]>OUT[27])
&&(OUT[41]>OUT[28])&&(OUT[41]>OUT[29])&&(OUT[41]>OUT[30])&&(OUT[41]>OUT[31])&&(OUT[41]>OUT[32])&&(OUT[41]>OUT[33])&&(OUT[41]>OUT[34])&&(OUT[41]>OUT[35])&&(OUT[41]>OUT[36])
&&(OUT[41]>OUT[37])&&(OUT[41]>OUT[38])&&(OUT[41]>OUT[39])&&(OUT[41]>OUT[40])&&(OUT[41]>OUT[42])&&(OUT[41]>OUT[43])&&(OUT[41]>OUT[44])&&(OUT[41]>OUT[45])&&(OUT[41]>OUT[46])
&&(OUT[41]>OUT[47])&&(OUT[41]>OUT[48]) ) 
{
MT_VCX=0.75;
MT_VCY=0.5;		
	
}
//43

else if((OUT[42]>OUT[0])&&(OUT[42]>OUT[1])&&(OUT[42]>OUT[2])&&(OUT[42]>OUT[3])&&(OUT[42]>OUT[4])&&(OUT[42]>OUT[5])&&(OUT[42]>OUT[6])&&(OUT[42]>OUT[7])&&(OUT[42]>OUT[8])&&(OUT[42]>OUT[9])
&&(OUT[42]>OUT[10])&&(OUT[42]>OUT[11])&&(OUT[42]>OUT[12])&&(OUT[42]>OUT[13])&&(OUT[42]>OUT[14])&&(OUT[42]>OUT[15])&&(OUT[42]>OUT[16])&&(OUT[42]>OUT[17])&&(OUT[42]>OUT[18])
&&(OUT[42]>OUT[19])&&(OUT[42]>OUT[20])&&(OUT[42]>OUT[21])&&(OUT[42]>OUT[22])&&(OUT[42]>OUT[23])&&(OUT[42]>OUT[24])&&(OUT[42]>OUT[25])&&(OUT[42]>OUT[26])&&(OUT[42]>OUT[27])
&&(OUT[42]>OUT[28])&&(OUT[42]>OUT[29])&&(OUT[42]>OUT[30])&&(OUT[42]>OUT[31])&&(OUT[42]>OUT[32])&&(OUT[42]>OUT[33])&&(OUT[42]>OUT[34])&&(OUT[42]>OUT[35])&&(OUT[42]>OUT[36])
&&(OUT[42]>OUT[37])&&(OUT[42]>OUT[38])&&(OUT[42]>OUT[39])&&(OUT[42]>OUT[40])&&(OUT[42]>OUT[41])&&(OUT[42]>OUT[43])&&(OUT[42]>OUT[44])&&(OUT[42]>OUT[45])&&(OUT[42]>OUT[46])
&&(OUT[42]>OUT[47])&&(OUT[42]>OUT[48]) ) 
{
MT_VCX=-0.75;
MT_VCY=0.75;		
	
}

//44

else if((OUT[43]>OUT[0])&&(OUT[43]>OUT[1])&&(OUT[43]>OUT[2])&&(OUT[43]>OUT[3])&&(OUT[43]>OUT[4])&&(OUT[43]>OUT[5])&&(OUT[43]>OUT[6])&&(OUT[43]>OUT[7])&&(OUT[43]>OUT[8])&&(OUT[43]>OUT[9])
&&(OUT[43]>OUT[10])&&(OUT[43]>OUT[11])&&(OUT[43]>OUT[12])&&(OUT[43]>OUT[13])&&(OUT[43]>OUT[14])&&(OUT[43]>OUT[15])&&(OUT[43]>OUT[16])&&(OUT[43]>OUT[17])&&(OUT[43]>OUT[18])
&&(OUT[43]>OUT[19])&&(OUT[43]>OUT[20])&&(OUT[43]>OUT[21])&&(OUT[43]>OUT[22])&&(OUT[43]>OUT[23])&&(OUT[43]>OUT[24])&&(OUT[43]>OUT[25])&&(OUT[43]>OUT[26])&&(OUT[43]>OUT[27])
&&(OUT[43]>OUT[28])&&(OUT[43]>OUT[29])&&(OUT[43]>OUT[30])&&(OUT[43]>OUT[31])&&(OUT[43]>OUT[32])&&(OUT[43]>OUT[33])&&(OUT[43]>OUT[34])&&(OUT[43]>OUT[35])&&(OUT[43]>OUT[36])
&&(OUT[43]>OUT[37])&&(OUT[43]>OUT[38])&&(OUT[43]>OUT[39])&&(OUT[43]>OUT[40])&&(OUT[43]>OUT[41])&&(OUT[43]>OUT[42])&&(OUT[43]>OUT[44])&&(OUT[43]>OUT[45])&&(OUT[43]>OUT[46])
&&(OUT[43]>OUT[47])&&(OUT[43]>OUT[48]) ) 
{
MT_VCX=-0.5;
MT_VCY=0.75;	
	
}

//45
else if((OUT[44]>OUT[0])&&(OUT[44]>OUT[1])&&(OUT[44]>OUT[2])&&(OUT[44]>OUT[3])&&(OUT[44]>OUT[4])&&(OUT[44]>OUT[5])&&(OUT[44]>OUT[6])&&(OUT[44]>OUT[7])&&(OUT[44]>OUT[8])&&(OUT[44]>OUT[9])
&&(OUT[44]>OUT[10])&&(OUT[44]>OUT[11])&&(OUT[44]>OUT[12])&&(OUT[44]>OUT[13])&&(OUT[44]>OUT[14])&&(OUT[44]>OUT[15])&&(OUT[44]>OUT[16])&&(OUT[44]>OUT[17])&&(OUT[44]>OUT[18])
&&(OUT[44]>OUT[19])&&(OUT[44]>OUT[20])&&(OUT[44]>OUT[21])&&(OUT[44]>OUT[22])&&(OUT[44]>OUT[23])&&(OUT[44]>OUT[24])&&(OUT[44]>OUT[25])&&(OUT[44]>OUT[26])&&(OUT[44]>OUT[27])
&&(OUT[44]>OUT[28])&&(OUT[44]>OUT[29])&&(OUT[44]>OUT[30])&&(OUT[44]>OUT[31])&&(OUT[44]>OUT[32])&&(OUT[44]>OUT[33])&&(OUT[44]>OUT[34])&&(OUT[44]>OUT[35])&&(OUT[44]>OUT[36])
&&(OUT[44]>OUT[37])&&(OUT[44]>OUT[38])&&(OUT[44]>OUT[39])&&(OUT[44]>OUT[40])&&(OUT[44]>OUT[41])&&(OUT[44]>OUT[42])&&(OUT[44]>OUT[43])&&(OUT[44]>OUT[45])&&(OUT[44]>OUT[46])
&&(OUT[44]>OUT[47])&&(OUT[44]>OUT[48]) ) 
{
MT_VCX=-0.25;
MT_VCY=0.75;	
	
}

//46
else if((OUT[45]>OUT[0])&&(OUT[45]>OUT[1])&&(OUT[45]>OUT[2])&&(OUT[45]>OUT[3])&&(OUT[45]>OUT[4])&&(OUT[45]>OUT[5])&&(OUT[45]>OUT[6])&&(OUT[45]>OUT[7])&&(OUT[45]>OUT[8])&&(OUT[45]>OUT[9])
&&(OUT[45]>OUT[10])&&(OUT[45]>OUT[11])&&(OUT[45]>OUT[12])&&(OUT[45]>OUT[13])&&(OUT[45]>OUT[14])&&(OUT[45]>OUT[15])&&(OUT[45]>OUT[16])&&(OUT[45]>OUT[17])&&(OUT[45]>OUT[18])
&&(OUT[45]>OUT[19])&&(OUT[45]>OUT[20])&&(OUT[45]>OUT[21])&&(OUT[45]>OUT[22])&&(OUT[45]>OUT[23])&&(OUT[45]>OUT[24])&&(OUT[45]>OUT[25])&&(OUT[45]>OUT[26])&&(OUT[45]>OUT[27])
&&(OUT[45]>OUT[28])&&(OUT[45]>OUT[29])&&(OUT[45]>OUT[30])&&(OUT[45]>OUT[31])&&(OUT[45]>OUT[32])&&(OUT[45]>OUT[33])&&(OUT[45]>OUT[34])&&(OUT[45]>OUT[35])&&(OUT[45]>OUT[36])
&&(OUT[45]>OUT[37])&&(OUT[45]>OUT[38])&&(OUT[45]>OUT[39])&&(OUT[45]>OUT[40])&&(OUT[45]>OUT[41])&&(OUT[45]>OUT[42])&&(OUT[45]>OUT[43])&&(OUT[45]>OUT[44])&&(OUT[45]>OUT[46])
&&(OUT[45]>OUT[47])&&(OUT[45]>OUT[48]) ) 
{
MT_VCX=0;
MT_VCY=0.75;
	
}
//47

else if((OUT[46]>OUT[0])&&(OUT[46]>OUT[1])&&(OUT[46]>OUT[2])&&(OUT[46]>OUT[3])&&(OUT[46]>OUT[4])&&(OUT[46]>OUT[5])&&(OUT[46]>OUT[6])&&(OUT[46]>OUT[7])&&(OUT[46]>OUT[8])&&(OUT[46]>OUT[9])
&&(OUT[46]>OUT[10])&&(OUT[46]>OUT[11])&&(OUT[46]>OUT[12])&&(OUT[46]>OUT[13])&&(OUT[46]>OUT[14])&&(OUT[46]>OUT[15])&&(OUT[46]>OUT[16])&&(OUT[46]>OUT[17])&&(OUT[46]>OUT[18])
&&(OUT[46]>OUT[19])&&(OUT[46]>OUT[20])&&(OUT[46]>OUT[21])&&(OUT[46]>OUT[22])&&(OUT[46]>OUT[23])&&(OUT[46]>OUT[24])&&(OUT[46]>OUT[25])&&(OUT[46]>OUT[26])&&(OUT[46]>OUT[27])
&&(OUT[46]>OUT[28])&&(OUT[46]>OUT[29])&&(OUT[46]>OUT[30])&&(OUT[46]>OUT[31])&&(OUT[46]>OUT[32])&&(OUT[46]>OUT[33])&&(OUT[46]>OUT[34])&&(OUT[46]>OUT[35])&&(OUT[46]>OUT[36])
&&(OUT[46]>OUT[37])&&(OUT[46]>OUT[38])&&(OUT[46]>OUT[39])&&(OUT[46]>OUT[40])&&(OUT[46]>OUT[41])&&(OUT[46]>OUT[42])&&(OUT[46]>OUT[43])&&(OUT[46]>OUT[44])&&(OUT[46]>OUT[45])
&&(OUT[46]>OUT[47])&&(OUT[46]>OUT[48]) ) 
{
MT_VCX=0.25;
MT_VCY=0.75;	
	
}

//48
else if((OUT[47]>OUT[0])&&(OUT[47]>OUT[1])&&(OUT[47]>OUT[2])&&(OUT[47]>OUT[3])&&(OUT[47]>OUT[4])&&(OUT[47]>OUT[5])&&(OUT[47]>OUT[6])&&(OUT[47]>OUT[7])&&(OUT[47]>OUT[8])&&(OUT[47]>OUT[9])
&&(OUT[47]>OUT[10])&&(OUT[47]>OUT[11])&&(OUT[47]>OUT[12])&&(OUT[47]>OUT[13])&&(OUT[47]>OUT[14])&&(OUT[47]>OUT[15])&&(OUT[47]>OUT[16])&&(OUT[47]>OUT[17])&&(OUT[47]>OUT[18])
&&(OUT[47]>OUT[19])&&(OUT[47]>OUT[20])&&(OUT[47]>OUT[21])&&(OUT[47]>OUT[22])&&(OUT[47]>OUT[23])&&(OUT[47]>OUT[24])&&(OUT[47]>OUT[25])&&(OUT[47]>OUT[26])&&(OUT[47]>OUT[27])
&&(OUT[47]>OUT[28])&&(OUT[47]>OUT[29])&&(OUT[47]>OUT[30])&&(OUT[47]>OUT[31])&&(OUT[47]>OUT[32])&&(OUT[47]>OUT[33])&&(OUT[47]>OUT[34])&&(OUT[47]>OUT[35])&&(OUT[47]>OUT[36])
&&(OUT[47]>OUT[37])&&(OUT[47]>OUT[38])&&(OUT[47]>OUT[39])&&(OUT[47]>OUT[40])&&(OUT[47]>OUT[41])&&(OUT[47]>OUT[42])&&(OUT[47]>OUT[43])&&(OUT[47]>OUT[44])&&(OUT[47]>OUT[45])
&&(OUT[47]>OUT[46])&&(OUT[47]>OUT[48]) ) 
{
MT_VCX=0.5;
MT_VCY=0.75;	
	
}

//49
else if((OUT[48]>OUT[0])&&(OUT[48]>OUT[1])&&(OUT[48]>OUT[2])&&(OUT[48]>OUT[3])&&(OUT[48]>OUT[4])&&(OUT[48]>OUT[5])&&(OUT[48]>OUT[6])&&(OUT[48]>OUT[7])&&(OUT[48]>OUT[8])&&(OUT[48]>OUT[9])
&&(OUT[48]>OUT[10])&&(OUT[48]>OUT[11])&&(OUT[48]>OUT[12])&&(OUT[48]>OUT[13])&&(OUT[48]>OUT[14])&&(OUT[48]>OUT[15])&&(OUT[48]>OUT[16])&&(OUT[48]>OUT[17])&&(OUT[48]>OUT[18])
&&(OUT[48]>OUT[19])&&(OUT[48]>OUT[20])&&(OUT[48]>OUT[21])&&(OUT[48]>OUT[22])&&(OUT[48]>OUT[23])&&(OUT[48]>OUT[24])&&(OUT[48]>OUT[25])&&(OUT[48]>OUT[26])&&(OUT[48]>OUT[27])
&&(OUT[48]>OUT[28])&&(OUT[48]>OUT[29])&&(OUT[48]>OUT[30])&&(OUT[48]>OUT[31])&&(OUT[48]>OUT[32])&&(OUT[48]>OUT[33])&&(OUT[48]>OUT[34])&&(OUT[48]>OUT[35])&&(OUT[48]>OUT[36])
&&(OUT[48]>OUT[37])&&(OUT[48]>OUT[38])&&(OUT[48]>OUT[39])&&(OUT[48]>OUT[40])&&(OUT[48]>OUT[41])&&(OUT[48]>OUT[42])&&(OUT[48]>OUT[43])&&(OUT[48]>OUT[44])&&(OUT[48]>OUT[45])
&&(OUT[48]>OUT[46])&&(OUT[48]>OUT[47]) ) 
{
MT_VCX=0.75;
MT_VCY=0.75;	
	
}









// final result 

if (MT_VCX == 0){
	MVX_HALF = 0;
	MVX_QRTER = 0;
}

else if (MT_VCX == 0.25){
	MVX_HALF = 0;
	MVX_QRTER = 1;
}

else if (MT_VCX == 0.5){
	MVX_HALF = 1;
	MVX_QRTER = 0;
}

else if (MT_VCX == 0.75){
	MVX_HALF = 1;
	MVX_QRTER = 1;
}

else if (MT_VCX == -0.5){
	MVX_HALF = -1;
	MVX_QRTER = 0;
}

else if (MT_VCX == -0.25){
	MVX_HALF = 0;
	MVX_QRTER = -1;
}

else if (MT_VCX == -0.75){
	MVX_HALF = -1;
	MVX_QRTER = -1;
}

//MVY

if (MT_VCY == 0){
	MVY_HALF = 0;
	MVY_QRTER = 0;
}


else if (MT_VCY == 0.25){
	MVY_HALF = 0;
	MVY_QRTER = 1;
}

else if (MT_VCY == 0.5){
	MVY_HALF = 1;
	MVY_QRTER = 0;
}

else if (MT_VCY == 0.75){
	MVY_HALF = 1;
	MVY_QRTER = 1;
}


else if (MT_VCY == -0.5){
	MVY_HALF = -1;
	MVY_QRTER = 0;
}

else if (MT_VCY == -0.25){
	MVY_HALF = 0;
	MVY_QRTER = -1;
}

else if (MT_VCY == -0.75){
	MVY_HALF = -1;
	MVY_QRTER = -1;
}








	  //end of neural network code


	  for (int k = 0; k <= counter_i; k++)
	  {
		  array[k] = 0;
	  }

	  counter_i = 0;
	  index_ref = 0;
	// myfile2 << flag_start << ',' << flag_2point << ',' << flag_star <<  endl;

	  flag_start = 0;
	  flag_2point = 0;
	  flag_star = 0;

      break;



    case MESEARCH_SELECTIVE:
      xTZSearchSelective( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred );
      break;

    case MESEARCH_DIAMOND_ENHANCED:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, true );
      break;

    case MESEARCH_FULL: // shouldn't get here.
    default:
      break;
  }
}


Void TEncSearch::xTZSearch( const TComDataCU* const pcCU,
                            const TComPattern* const pcPatternKey,
                            const Pel* const         piRefY,
                            const Int                iRefStride,
                            const TComMv* const      pcMvSrchRngLT,
                            const TComMv* const      pcMvSrchRngRB,
                            TComMv&                  rcMv,
                            Distortion&              ruiSAD,
                            const TComMv* const      pIntegerMv2Nx2NPred,
                            const Bool               bExtendedSettings)
{
  const Bool bUseAdaptiveRaster                      = bExtendedSettings;
  const Int  iRaster                                 = 5;
  const Bool bTestOtherPredictedMV                   = bExtendedSettings;
  const Bool bTestZeroVector                         = true;
  const Bool bTestZeroVectorStart                    = bExtendedSettings;
  const Bool bTestZeroVectorStop                     = false;
  const Bool bFirstSearchDiamond                     = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bFirstCornersForDiamondDist1            = bExtendedSettings;
  const Bool bFirstSearchStop                        = m_pcEncCfg->getFastMEAssumingSmootherMVEnabled();
  const UInt uiFirstSearchRounds                     = 3;     // first search stop X rounds after best match (must be >=1)
  const Bool bEnableRasterSearch                     = true;
  const Bool bAlwaysRasterSearch                     = bExtendedSettings;  // true: BETTER but factor 2 slower
  const Bool bRasterRefinementEnable                 = false; // enable either raster refinement or star refinement
  const Bool bRasterRefinementDiamond                = false; // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bRasterRefinementCornersForDiamondDist1 = bExtendedSettings;
  const Bool bStarRefinementEnable                   = true;  // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond                  = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementCornersForDiamondDist1   = bExtendedSettings;
  const Bool bStarRefinementStop                     = false;
  const UInt uiStarRefinementRounds                  = 2;  // star refinement stop X rounds after best match (must be >=1)
  const Bool bNewZeroNeighbourhoodTest               = bExtendedSettings;

  UInt uiSearchRange = m_iSearchRange;
  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;

  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      if (cMv != rcMv && (cMv.getHor() != cStruct.iBestX && cMv.getVer() != cStruct.iBestY))
      {
        // only test cMV if not obviously previously tested.
        xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
      }
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    if ((rcMv.getHor() != 0 || rcMv.getVer() != 0) &&
        (0 != cStruct.iBestX || 0 != cStruct.iBestY))
    {
      // only test 0-vector if not obviously previously tested.
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
    }
  }

  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  if (pIntegerMv2Nx2NPred != 0)
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    if ((rcMv != integerMv2Nx2NPred) &&
        (integerMv2Nx2NPred.getHor() != cStruct.iBestX || integerMv2Nx2NPred.getVer() != cStruct.iBestY))
    {
      // only test integerMv2Nx2NPred if not obviously previously tested.
      xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);
    }

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // start search
  Int  iDist = 0;
  Int  iStartX = cStruct.iBestX;
  Int  iStartY = cStruct.iBestY;

  const Bool bBestCandidateZero = (cStruct.iBestX == 0) && (cStruct.iBestY == 0);

  // first search around best position up to now.
  // The following works as a "subsampled/log" window search around the best candidate
  for (iDist = 1; iDist <= (Int)uiSearchRange; iDist *= 2)
	  
  {
	  flag_start = 1;
	  flag_2point = 0;
	  flag_star = 0;
    if ( bFirstSearchDiamond == 1 )
    {
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bFirstCornersForDiamondDist1 );
    }
    else
    {
      xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
    }

    if ( bFirstSearchStop && ( cStruct.uiBestRound >= uiFirstSearchRounds ) ) // stop criterion
    {
      break;
    }
  }

  if (!bNewZeroNeighbourhoodTest)
  {
    // test whether zero Mv is a better start point than Median predictor
    if ( bTestZeroVectorStart && ((cStruct.iBestX != 0) || (cStruct.iBestY != 0)) )
    {
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
      if ( (cStruct.iBestX == 0) && (cStruct.iBestY == 0) )
      {
        // test its neighborhood
        for ( iDist = 1; iDist <= (Int)uiSearchRange; iDist*=2 )
        {
          xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
          if ( bTestZeroVectorStop && (cStruct.uiBestRound > 0) ) // stop criterion
          {
            break;
          }
        }
      }
    }
  }
  else
  {
    // Test also zero neighbourhood but with half the range
    // It was reported that the original (above) search scheme using bTestZeroVectorStart did not
    // make sense since one would have already checked the zero candidate earlier
    // and thus the conditions for that test would have not been satisfied
    if (bTestZeroVectorStart == true && bBestCandidateZero != true)
    {
      for ( iDist = 1; iDist <= ((Int)uiSearchRange >> 1); iDist*=2 )
      {
        xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
        if ( bTestZeroVectorStop && (cStruct.uiBestRound > 2) ) // stop criterion
        {
          break;
        }
      }
    }
  }

  // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
  if ( cStruct.uiBestDistance == 1 )
  {
    cStruct.uiBestDistance = 0;
	flag_2point = 1;
    xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
  }

  // raster search if distance is too big
  if (bUseAdaptiveRaster)
  {
    int iWindowSize = iRaster;
    Int   iSrchRngRasterLeft   = iSrchRngHorLeft;
    Int   iSrchRngRasterRight  = iSrchRngHorRight;
    Int   iSrchRngRasterTop    = iSrchRngVerTop;
    Int   iSrchRngRasterBottom = iSrchRngVerBottom;

    if (!(bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster))))
    {
      iWindowSize ++;
      iSrchRngRasterLeft /= 2;
      iSrchRngRasterRight /= 2;
      iSrchRngRasterTop /= 2;
      iSrchRngRasterBottom /= 2;
    }
    cStruct.uiBestDistance = iWindowSize;
    for ( iStartY = iSrchRngRasterTop; iStartY <= iSrchRngRasterBottom; iStartY += iWindowSize )
    {
      for ( iStartX = iSrchRngRasterLeft; iStartX <= iSrchRngRasterRight; iStartX += iWindowSize )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iWindowSize );
      }
    }
  }
  else
  {
    if ( bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster) || bAlwaysRasterSearch ) )
    {
      cStruct.uiBestDistance = iRaster;
      for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += iRaster )
      {
        for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += iRaster )
        {
          xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iRaster );
        }
      }
    }
  }

  // raster refinement

  if ( bRasterRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      if ( cStruct.uiBestDistance > 1 )
      {
        iDist = cStruct.uiBestDistance >>= 1;
        if ( bRasterRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bRasterRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
      }

      // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // star refinement
  if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
	  flag_start = 0;
	  flag_2point = 0;
	  flag_star = 1;
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bStarRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
			flag_2point =1;
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // getting the 8 SAD points
  iDist = 1;
  iStartX = cStruct.iBestX;
  iStartY = cStruct.iBestY;
  index_ref = counter_i;
  SAD_Best=cStruct.uiBestSad;
  MVX_Best=cStruct.iBestX;
  MVY_Best=cStruct.iBestY;
  
  xTZ8PointSquareSearch(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  iDist = 2;
  xTZ8PointSquareSearch2(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);
  
  cStruct.iBestX=MVX_Best;
  cStruct.iBestY=MVY_Best;
  cStruct.uiBestSad=SAD_Best;

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );
}


Void TEncSearch::xTZSearchSelective( const TComDataCU* const   pcCU,
                                     const TComPattern* const  pcPatternKey,
                                     const Pel* const          piRefY,
                                     const Int                 iRefStride,
                                     const TComMv* const       pcMvSrchRngLT,
                                     const TComMv* const       pcMvSrchRngRB,
                                     TComMv                   &rcMv,
                                     Distortion               &ruiSAD,
                                     const TComMv* const       pIntegerMv2Nx2NPred )
{
  const Bool bTestOtherPredictedMV    = true;
  const Bool bTestZeroVector          = true;
  const Bool bEnableRasterSearch      = true;
  const Bool bAlwaysRasterSearch      = false;  // 1: BETTER but factor 15x slower
  const Bool bStarRefinementEnable    = true;   // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond   = true;   // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementStop      = false;
  const UInt uiStarRefinementRounds   = 2;  // star refinement stop X rounds after best match (must be >=1)
  const UInt uiSearchRange            = m_iSearchRange;
  const Int  uiSearchRangeInitial     = m_iSearchRange >> 2;
  const Int  uiSearchStep             = 4;
  const Int  iMVDistThresh            = 8;

  Int   iSrchRngHorLeft         = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight        = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop          = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom       = pcMvSrchRngRB->getVer();
  Int   iFirstSrchRngHorLeft    = 0;
  Int   iFirstSrchRngHorRight   = 0;
  Int   iFirstSrchRngVerTop     = 0;
  Int   iFirstSrchRngVerBottom  = 0;
  Int   iStartX                 = 0;
  Int   iStartY                 = 0;
  Int   iBestX                  = 0;
  Int   iBestY                  = 0;
  Int   iDist                   = 0;

  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;
  cStruct.iBestX = 0;
  cStruct.iBestY = 0;


  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
  }

  if ( pIntegerMv2Nx2NPred != 0 )
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // Initial search
  iBestX = cStruct.iBestX;
  iBestY = cStruct.iBestY; 
  iFirstSrchRngHorLeft    = ((iBestX - uiSearchRangeInitial) > iSrchRngHorLeft)   ? (iBestX - uiSearchRangeInitial) : iSrchRngHorLeft;
  iFirstSrchRngVerTop     = ((iBestY - uiSearchRangeInitial) > iSrchRngVerTop)    ? (iBestY - uiSearchRangeInitial) : iSrchRngVerTop;
  iFirstSrchRngHorRight   = ((iBestX + uiSearchRangeInitial) < iSrchRngHorRight)  ? (iBestX + uiSearchRangeInitial) : iSrchRngHorRight;  
  iFirstSrchRngVerBottom  = ((iBestY + uiSearchRangeInitial) < iSrchRngVerBottom) ? (iBestY + uiSearchRangeInitial) : iSrchRngVerBottom;    

  for ( iStartY = iFirstSrchRngVerTop; iStartY <= iFirstSrchRngVerBottom; iStartY += uiSearchStep )
  {
    for ( iStartX = iFirstSrchRngHorLeft; iStartX <= iFirstSrchRngHorRight; iStartX += uiSearchStep )
    {
      xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 0 );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 1, false );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 2, false );
    }
  }

  Int iMaxMVDistToPred = (abs(cStruct.iBestX - iBestX) > iMVDistThresh || abs(cStruct.iBestY - iBestY) > iMVDistThresh);

  //full search with early exit if MV is distant from predictors
  if ( bEnableRasterSearch && (iMaxMVDistToPred || bAlwaysRasterSearch) )
  {
    for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += 1 )
    {
      for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += 1 )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 1 );
      }
    }
  }
  //Smaller MV, refine around predictor
  else if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    // start refinement
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, false );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );

}


Void TEncSearch::xPatternSearchFracDIF(
                                       Bool         bIsLosslessCoded,
                                       TComPattern* pcPatternKey,
                                       Pel*         piRefY,
                                       Int          iRefStride,
                                       TComMv*      pcMvInt,
                                       TComMv&      rcMvHalf,
                                       TComMv&      rcMvQter,
                                       Distortion&  ruiCost
                                      )
{
  //  Reference pattern initialization (integer scale)
	
  TComPattern cPatternRoi;
  Int         iOffset    = pcMvInt->getHor() + pcMvInt->getVer() * iRefStride;
  cPatternRoi.initPattern(piRefY + iOffset,
                          pcPatternKey->getROIYWidth(),
                          pcPatternKey->getROIYHeight(),
                          iRefStride,
                          pcPatternKey->getBitDepthY());

  //  Half-pel refinement
  xExtDIFUpSamplingH ( &cPatternRoi );

  rcMvHalf = *pcMvInt;   rcMvHalf <<= 1;    // for mv-cost
  TComMv baseRefMv(0, 0);
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 2, rcMvHalf, !bIsLosslessCoded );

  m_pcRdCost->setCostScale( 0 );

  xExtDIFUpSamplingQ ( &cPatternRoi, rcMvHalf );
  baseRefMv = rcMvHalf;
  baseRefMv <<= 1;

  rcMvQter = *pcMvInt;   rcMvQter <<= 1;    // for mv-cost
  rcMvQter += rcMvHalf;  rcMvQter <<= 1;
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 1, rcMvQter, !bIsLosslessCoded );
}


//! encode residual and calculate rate-distortion for a CU block
Void TEncSearch::encodeResAndCalcRdInterCU( TComDataCU* pcCU, TComYuv* pcYuvOrg, TComYuv* pcYuvPred,
                                            TComYuv* pcYuvResi, TComYuv* pcYuvResiBest, TComYuv* pcYuvRec,
                                            Bool bSkipResidual DEBUG_STRING_FN_DECLARE(sDebug) )
{
  assert ( !pcCU->isIntra(0) );

  const UInt cuWidthPixels      = pcCU->getWidth ( 0 );
  const UInt cuHeightPixels     = pcCU->getHeight( 0 );
  const Int  numValidComponents = pcCU->getPic()->getNumberValidComponents();
  const TComSPS &sps=*(pcCU->getSlice()->getSPS());

  // The pcCU is not marked as skip-mode at this point, and its m_pcTrCoeff, m_pcArlCoeff, m_puhCbf, m_puhTrIdx will all be 0.
  // due to prior calls to TComDataCU::initEstData(  );

  if ( bSkipResidual ) //  No residual coding : SKIP mode
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    pcYuvResi->clear();

    pcYuvPred->copyToPartYuv( pcYuvRec, 0 );
    Distortion distortion = 0;

    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID compID=ComponentID(comp);
      const UInt csx=pcYuvOrg->getComponentScaleX(compID);
      const UInt csy=pcYuvOrg->getComponentScaleY(compID);
      distortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID), pcYuvRec->getStride(compID), pcYuvOrg->getAddr(compID),
                                               pcYuvOrg->getStride(compID), cuWidthPixels >> csx, cuHeightPixels >> csy, compID);
    }

    m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST]);
    m_pcEntropyCoder->resetBits();

    if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex( pcCU, 0, true );

    UInt uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    pcCU->getTotalBits()       = uiBits;
    pcCU->getTotalDistortion() = distortion;
    pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( uiBits, distortion );

    m_pcRDGoOnSbacCoder->store(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_TEMP_BEST]);

#if DEBUG_STRING
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif

    return;
  }

  //  Residual coding.

   pcYuvResi->subtract( pcYuvOrg, pcYuvPred, 0, cuWidthPixels );

  TComTURecurse tuLevel0(pcCU, 0);

  Double     nonZeroCost       = 0;
  UInt       nonZeroBits       = 0;
  Distortion nonZeroDistortion = 0;
  Distortion zeroDistortion    = 0;

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_CURR_BEST ] );

  xEstimateInterResidualQT( pcYuvResi,  nonZeroCost, nonZeroBits, nonZeroDistortion, &zeroDistortion, tuLevel0 DEBUG_STRING_PASS_INTO(sDebug) );

  // -------------------------------------------------------
  // set the coefficients in the pcCU, and also calculates the residual data.
  // If a block full of 0's is efficient, then just use 0's.
  // The costs at this point do not include header bits.

  m_pcEntropyCoder->resetBits();
  m_pcEntropyCoder->encodeQtRootCbfZero( );
  const UInt   zeroResiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  const Double zeroCost     = (pcCU->isLosslessCoded( 0 )) ? (nonZeroCost+1) : (m_pcRdCost->calcRdCost( zeroResiBits, zeroDistortion ));

  if ( zeroCost < nonZeroCost || !pcCU->getQtRootCbf(0) )
  {
    const UInt uiQPartNum = tuLevel0.GetAbsPartIdxNumParts();
    ::memset( pcCU->getTransformIdx()     , 0, uiQPartNum * sizeof(UChar) );
    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID component = ComponentID(comp);
      ::memset( pcCU->getCbf( component ) , 0, uiQPartNum * sizeof(UChar) );
      ::memset( pcCU->getCrossComponentPredictionAlpha(component), 0, ( uiQPartNum * sizeof(SChar) ) );
    }
    static const UInt useTS[MAX_NUM_COMPONENT]={0,0,0};
    pcCU->setTransformSkipSubParts ( useTS, 0, pcCU->getDepth(0) );
#if DEBUG_STRING
    sDebug.clear();
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif
  }
  else
  {
    xSetInterResidualQTData( NULL, false, tuLevel0); // Call first time to set coefficients.
  }

  // all decisions now made. Fully encode the CU, including the headers:
  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST] );

  UInt finalBits = 0;
  xAddSymbolBitsInter( pcCU, finalBits );
  // we've now encoded the pcCU, and so have a valid bit cost

  if ( !pcCU->getQtRootCbf( 0 ) )
  {
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
  }
  else
  {
    xSetInterResidualQTData( pcYuvResiBest, true, tuLevel0 ); // else set the residual image data pcYUVResiBest from the various temp images.
  }
  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_TEMP_BEST ] );

  pcYuvRec->addClip ( pcYuvPred, pcYuvResiBest, 0, cuWidthPixels, sps.getBitDepths() );

  // update with clipped distortion and cost (previously unclipped reconstruction values were used)

  Distortion finalDistortion = 0;
  for(Int comp=0; comp<numValidComponents; comp++)
  {
    const ComponentID compID=ComponentID(comp);
    finalDistortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID ), pcYuvRec->getStride(compID ), pcYuvOrg->getAddr(compID ), pcYuvOrg->getStride(compID), cuWidthPixels >> pcYuvOrg->getComponentScaleX(compID), cuHeightPixels >> pcYuvOrg->getComponentScaleY(compID), compID);
  }

  pcCU->getTotalBits()       = finalBits;
  pcCU->getTotalDistortion() = finalDistortion;
  pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( finalBits, finalDistortion );
}



Void TEncSearch::xEstimateInterResidualQT( TComYuv    *pcResi,
                                           Double     &rdCost,
                                           UInt       &ruiBits,
                                           Distortion &ruiDist,
                                           Distortion *puiZeroDist,
                                           TComTU     &rTu
                                           DEBUG_STRING_FN_DECLARE(sDebug) )
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiDepth      = rTu.GetTransformDepthTotal();
  const UInt uiTrMode     = rTu.GetTransformDepthRel();
  const UInt subTUDepth   = uiTrMode + 1;
  const UInt numValidComp = pcCU->getPic()->getNumberValidComponents();
  DEBUG_STRING_NEW(sSingleStringComp[MAX_NUM_COMPONENT])

  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  UInt SplitFlag = ((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && pcCU->isInter(uiAbsPartIdx) && ( pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N ));
#if DEBUG_STRING
  const Int debugPredModeMask = DebugStringGetPredModeMask(pcCU->getPredictionMode(uiAbsPartIdx));
#endif

  Bool bCheckFull;

  if ( SplitFlag && uiDepth == pcCU->getDepth(uiAbsPartIdx) && ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) ) )
  {
    bCheckFull = false;
  }
  else
  {
    bCheckFull =  ( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
  }

  const Bool bCheckSplit  = ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

  assert( bCheckFull || bCheckSplit );

  // code full block
  Double     dSingleCost = MAX_DOUBLE;
  UInt       uiSingleBits                                                                                                        = 0;
  Distortion uiSingleDistComp            [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  Distortion uiSingleDist                                                                                                        = 0;
  TCoeff     uiAbsSum                    [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  UInt       uiBestTransformMode         [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  //  Stores the best explicit RDPCM mode for a TU encoded without split
  UInt       bestExplicitRdpcmModeUnSplit[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{3,3}, {3,3}, {3,3}};
  SChar      bestCrossCPredictionAlpha   [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};

  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );

  if( bCheckFull )
  {
    Double minCost[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/];
    Bool checkTransformSkip[MAX_NUM_COMPONENT];
    pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

    m_pcEntropyCoder->resetBits();

    memset( m_pTempPel, 0, sizeof( Pel ) * rTu.getRect(COMPONENT_Y).width * rTu.getRect(COMPONENT_Y).height ); // not necessary needed for inside of recursion (only at the beginning)

    const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    TCoeff *pcCoeffCurr[MAX_NUM_COMPONENT];
#if ADAPTIVE_QP_SELECTION
    TCoeff *pcArlCoeffCurr[MAX_NUM_COMPONENT];
#endif

    for(UInt i=0; i<numValidComp; i++)
    {
      minCost[i][0] = MAX_DOUBLE;
      minCost[i][1] = MAX_DOUBLE;
    }

    Pel crossCPredictedResidualBuffer[ MAX_TU_SIZE * MAX_TU_SIZE ];

    for(UInt i=0; i<numValidComp; i++)
    {
      checkTransformSkip[i]=false;
      const ComponentID compID=ComponentID(i);
      const Int channelBitDepth=pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
      pcCoeffCurr[compID]    = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
#if ADAPTIVE_QP_SELECTION
      pcArlCoeffCurr[compID] = m_ppcQTTempArlCoeff[compID ][uiQTTempAccessLayer] +  rTu.getCoefficientOffset(compID);
#endif

      if(rTu.ProcessComponentSection(compID))
      {
        const QpParam cQP(*pcCU, compID);

        checkTransformSkip[compID] = pcCU->getSlice()->getPPS()->getUseTransformSkip() &&
                                     TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(compID), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize()) &&
                                     (!pcCU->isLosslessCoded(0));

        const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

        TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

        const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

        do
        {
          const UInt           subTUIndex             = TUIterator.GetSectionNumber();
          const UInt           subTUAbsPartIdx        = TUIterator.GetAbsPartIdxTU(compID);
          const TComRectangle &tuCompRect             = TUIterator.getRect(compID);
          const UInt           subTUBufferOffset      = tuCompRect.width * tuCompRect.height * subTUIndex;

                TCoeff        *currentCoefficients    = pcCoeffCurr[compID] + subTUBufferOffset;
#if ADAPTIVE_QP_SELECTION
                TCoeff        *currentARLCoefficients = pcArlCoeffCurr[compID] + subTUBufferOffset;
#endif
          const Bool isCrossCPredictionAvailable      =    isChroma(compID)
                                                         && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                         && (pcCU->getCbf(subTUAbsPartIdx, COMPONENT_Y, uiTrMode) != 0);

          SChar preCalcAlpha = 0;
          const Pel *pLumaResi = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( COMPONENT_Y, rTu.getRect( COMPONENT_Y ).x0, rTu.getRect( COMPONENT_Y ).y0 );

          if (isCrossCPredictionAvailable)
          {
            const Bool bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
            const Pel  *const lumaResidualForEstimate       = bUseReconstructedResidualForEstimate ? pLumaResi                                                     : pcResi->getAddrPix(COMPONENT_Y, tuCompRect.x0, tuCompRect.y0);
            const UInt        lumaResidualStrideForEstimate = bUseReconstructedResidualForEstimate ? m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y) : pcResi->getStride(COMPONENT_Y);

            preCalcAlpha = xCalcCrossComponentPredictionAlpha(TUIterator,
                                                              compID,
                                                              lumaResidualForEstimate,
                                                              pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                              tuCompRect.width,
                                                              tuCompRect.height,
                                                              lumaResidualStrideForEstimate,
                                                              pcResi->getStride(compID));
          }

          const Int transformSkipModesToTest    = checkTransformSkip[compID] ? 2 : 1;
          const Int crossCPredictionModesToTest = (preCalcAlpha != 0)        ? 2 : 1; // preCalcAlpha cannot be anything other than 0 if isCrossCPredictionAvailable is false

          const Bool isOneMode                  = (crossCPredictionModesToTest == 1) && (transformSkipModesToTest == 1);

          for (Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
          {
            pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);

            for (Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
            {
              const Bool isFirstMode          = (transformSkipModeId == 0) && (crossCPredictionModeId == 0);
              const Bool bUseCrossCPrediction = crossCPredictionModeId != 0;

              m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
              m_pcEntropyCoder->resetBits();

              pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);
              pcCU->setCrossComponentPredictionAlphaPartRange((bUseCrossCPrediction ? preCalcAlpha : 0), compID, subTUAbsPartIdx, partIdxesPerSubTU );

              if ((compID != COMPONENT_Cr) && ((transformSkipModeId == 1) ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ()))
              {
                m_pcEntropyCoder->estimateBit(m_pcTrQuant->m_pcEstBitsSbac, tuCompRect.width, tuCompRect.height, toChannelType(compID));
              }

#if RDOQ_CHROMA_LAMBDA
              m_pcTrQuant->selectLambda(compID);
#endif

              Pel *pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
              UInt resiStride     = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);

              TCoeff bestCoeffComp   [MAX_TU_SIZE*MAX_TU_SIZE];
              Pel    bestResiComp    [MAX_TU_SIZE*MAX_TU_SIZE];

#if ADAPTIVE_QP_SELECTION
              TCoeff bestArlCoeffComp[MAX_TU_SIZE*MAX_TU_SIZE];
#endif
              TCoeff     currAbsSum   = 0;
              UInt       currCompBits = 0;
              Distortion currCompDist = 0;
              Double     currCompCost = 0;
              UInt       nonCoeffBits = 0;
              Distortion nonCoeffDist = 0;
              Double     nonCoeffCost = 0;

              if(!isOneMode && !isFirstMode)
              {
                memcpy(bestCoeffComp,    currentCoefficients,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(bestArlCoeffComp, currentARLCoefficients, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for(Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy(&bestResiComp[y * tuCompRect.width], (pcResiCurrComp + (y * resiStride)), (sizeof(Pel) * tuCompRect.width));
                }
              }

              if (bUseCrossCPrediction)
              {
                TComTrQuant::crossComponentPrediction(TUIterator,
                                                      compID,
                                                      pLumaResi,
                                                      pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                      crossCPredictedResidualBuffer,
                                                      tuCompRect.width,
                                                      tuCompRect.height,
                                                      m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                      pcResi->getStride(compID),
                                                      tuCompRect.width,
                                                      false);

                m_pcTrQuant->transformNxN(TUIterator, compID, crossCPredictedResidualBuffer, tuCompRect.width, currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }
              else
              {
                m_pcTrQuant->transformNxN(TUIterator, compID, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ), pcResi->getStride(compID), currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }

              if(isFirstMode || (currAbsSum == 0))
              {
                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pTempPel,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        tuCompRect.width,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        true);

                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride( compID ), pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }
                else
                {
                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pTempPel, tuCompRect.width, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }

                m_pcEntropyCoder->encodeQtCbfZero( TUIterator, toChannelType(compID) );

                if ( isCrossCPredictionAvailable )
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                nonCoeffBits = m_pcEntropyCoder->getNumberOfWrittenBits();
                nonCoeffCost = m_pcRdCost->calcRdCost( nonCoeffBits, nonCoeffDist );
              }

              if((puiZeroDist != NULL) && isFirstMode)
              {
                *puiZeroDist += nonCoeffDist; // initialized with zero residual distortion
              }

              DEBUG_STRING_NEW(sSingleStringTest)

              if( currAbsSum > 0 ) //if non-zero coefficients are present, a residual needs to be derived for further prediction
              {
                if (isFirstMode)
                {
                  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
                  m_pcEntropyCoder->resetBits();
                }

                m_pcEntropyCoder->encodeQtCbf( TUIterator, compID, true );

                if (isCrossCPredictionAvailable)
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                m_pcEntropyCoder->encodeCoeffNxN( TUIterator, currentCoefficients, compID );
                currCompBits = m_pcEntropyCoder->getNumberOfWrittenBits();

                pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 );

                m_pcTrQuant->invTransformNxN( TUIterator, compID, pcResiCurrComp, m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID), currentCoefficients, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sSingleStringTest, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );

                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        true);
                }

                currCompDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        pcResi->getStride(compID),
                                                        tuCompRect.width, tuCompRect.height, compID);

                currCompCost = m_pcRdCost->calcRdCost(currCompBits, currCompDist);
                  
                if (pcCU->isLosslessCoded(0))
                {
                  nonCoeffCost = MAX_DOUBLE;
                }
              }
              else if ((transformSkipModeId == 1) && !bUseCrossCPrediction)
              {
                currCompCost = MAX_DOUBLE;
              }
              else
              {
                currCompBits = nonCoeffBits;
                currCompDist = nonCoeffDist;
                currCompCost = nonCoeffCost;
              }

              // evaluate
              if ((currCompCost < minCost[compID][subTUIndex]) || ((transformSkipModeId == 1) && (currCompCost == minCost[compID][subTUIndex])))
              {
                bestExplicitRdpcmModeUnSplit[compID][subTUIndex] = pcCU->getExplicitRdpcmMode(compID, subTUAbsPartIdx);

                if(isFirstMode) //check for forced null
                {
                  if((nonCoeffCost < currCompCost) || (currAbsSum == 0))
                  {
                    memset(currentCoefficients, 0, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));

                    currAbsSum   = 0;
                    currCompBits = nonCoeffBits;
                    currCompDist = nonCoeffDist;
                    currCompCost = nonCoeffCost;
                  }
                }

#if DEBUG_STRING
                if (currAbsSum > 0)
                {
                  DEBUG_STRING_SWAP(sSingleStringComp[compID], sSingleStringTest)
                }
                else
                {
                  sSingleStringComp[compID].clear();
                }
#endif

                uiAbsSum                 [compID][subTUIndex] = currAbsSum;
                uiSingleDistComp         [compID][subTUIndex] = currCompDist;
                minCost                  [compID][subTUIndex] = currCompCost;
                uiBestTransformMode      [compID][subTUIndex] = transformSkipModeId;
                bestCrossCPredictionAlpha[compID][subTUIndex] = (crossCPredictionModeId == 1) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;

                if (uiAbsSum[compID][subTUIndex] == 0)
                {
                  if (bUseCrossCPrediction)
                  {
                    TComTrQuant::crossComponentPrediction(TUIterator,
                                                          compID,
                                                          pLumaResi,
                                                          m_pTempPel,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                          tuCompRect.width,
                                                          tuCompRect.height,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                          tuCompRect.width,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                          true);
                  }
                  else
                  {
                    pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
                    const UInt uiStride = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);
                    for(UInt uiY = 0; uiY < tuCompRect.height; uiY++)
                    {
                      memset(pcResiCurrComp, 0, (sizeof(Pel) * tuCompRect.width));
                      pcResiCurrComp += uiStride;
                    }
                  }
                }
              }
              else
              {
                // reset
                memcpy(currentCoefficients,    bestCoeffComp,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(currentARLCoefficients, bestArlCoeffComp, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for (Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy((pcResiCurrComp + (y * resiStride)), &bestResiComp[y * tuCompRect.width], (sizeof(Pel) * tuCompRect.width));
                }
              }
            }
          }

          pcCU->setExplicitRdpcmModePartRange            (   bestExplicitRdpcmModeUnSplit[compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU);
          pcCU->setTransformSkipPartRange                (   uiBestTransformMode         [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCbfPartRange                          ((((uiAbsSum                    [compID][subTUIndex] > 0) ? 1 : 0) << uiTrMode), compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCrossComponentPredictionAlphaPartRange(   bestCrossCPredictionAlpha   [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
        } while (TUIterator.nextSection(rTu)); //end of sub-TU loop
      } // processing section
    } // component loop

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      if (rTu.ProcessComponentSection(compID) && (rTu.getRect(compID).width != rTu.getRect(compID).height))
      {
        offsetSubTUCBFs(rTu, compID); //the CBFs up to now have been defined for two sub-TUs - shift them down a level and replace with the parent level CBF
      }
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    if( uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( 0, 5 - uiLog2TrSize );
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const UInt chOrderChange = ((ch + 1) == numValidComp) ? 0 : (ch + 1);
      const ComponentID compID=ComponentID(chOrderChange);
      if( rTu.ProcessComponentSection(compID) )
      {
        m_pcEntropyCoder->encodeQtCbf( rTu, compID, true );
      }
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if (rTu.ProcessComponentSection(compID))
      {
        if(isChroma(compID) && (uiAbsSum[COMPONENT_Y][0] != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, compID );
        }

        m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr[compID], compID );
        for (UInt subTUIndex = 0; subTUIndex < 2; subTUIndex++)
        {
          uiSingleDist += uiSingleDistComp[compID][subTUIndex];
        }
      }
    }

    uiSingleBits = m_pcEntropyCoder->getNumberOfWrittenBits();

    dSingleCost = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDist );
  } // check full

  // code sub-blocks
  if( bCheckSplit )
  {
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    Distortion uiSubdivDist = 0;
    UInt       uiSubdivBits = 0;
    Double     dSubdivCost = 0.0;

    //save the non-split CBFs in case we need to restore them later

    UInt bestCBF     [MAX_NUM_COMPONENT];
    UInt bestsubTUCBF[MAX_NUM_COMPONENT][2];
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);

      if (rTu.ProcessComponentSection(compID))
      {
        bestCBF[compID] = pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode);

        const TComRectangle &tuCompRect = rTu.getRect(compID);
        if (tuCompRect.width != tuCompRect.height)
        {
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

          for (UInt subTU = 0; subTU < 2; subTU++)
          {
            bestsubTUCBF[compID][subTU] = pcCU->getCbf ((uiAbsPartIdx + (subTU * partIdxesPerSubTU)), compID, subTUDepth);
          }
        }
      }
    }


    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiQPartNumSubdiv = tuRecurseChild.GetAbsPartIdxNumParts();

    DEBUG_STRING_NEW(sSplitString[MAX_NUM_COMPONENT])

    do
    {
      DEBUG_STRING_NEW(childString)
      xEstimateInterResidualQT( pcResi, dSubdivCost, uiSubdivBits, uiSubdivDist, bCheckFull ? NULL : puiZeroDist,  tuRecurseChild DEBUG_STRING_PASS_INTO(childString));
#if DEBUG_STRING
      // split the string by component and append to the relevant output (because decoder decodes in channel order, whereas this search searches by TU-order)
      std::size_t lastPos=0;
      const std::size_t endStrng=childString.find(debug_reorder_data_inter_token[MAX_NUM_COMPONENT], lastPos);
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        if (lastPos!=std::string::npos && childString.find(debug_reorder_data_inter_token[ch], lastPos)==lastPos)
        {
          lastPos+=strlen(debug_reorder_data_inter_token[ch]); // skip leading string
        }
        std::size_t pos=childString.find(debug_reorder_data_inter_token[ch+1], lastPos);
        if (pos!=std::string::npos && pos>endStrng)
        {
          lastPos=endStrng;
        }
        sSplitString[ch]+=childString.substr(lastPos, (pos==std::string::npos)? std::string::npos : (pos-lastPos) );
        lastPos=pos;
      }
#endif
    } while ( tuRecurseChild.nextSection(rTu) ) ;

    UInt uiCbfAny=0;
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      UInt uiYUVCbf = 0;
      for( UInt ui = 0; ui < 4; ++ui )
      {
        uiYUVCbf |= pcCU->getCbf( uiAbsPartIdx + ui * uiQPartNumSubdiv, ComponentID(ch),  uiTrMode + 1 );
      }
      UChar *pBase=pcCU->getCbf( ComponentID(ch) );
      const UInt flags=uiYUVCbf << uiTrMode;
      for( UInt ui = 0; ui < 4 * uiQPartNumSubdiv; ++ui )
      {
        pBase[uiAbsPartIdx + ui] |= flags;
      }
      uiCbfAny|=uiYUVCbf;
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    // when compID isn't a channel, code Cbfs:
    xEncodeInterResidualQT( MAX_NUM_COMPONENT, rTu );
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      xEncodeInterResidualQT( ComponentID(ch), rTu );
    }

    uiSubdivBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    dSubdivCost  = m_pcRdCost->calcRdCost( uiSubdivBits, uiSubdivDist );

    if (!bCheckFull || (uiCbfAny && (dSubdivCost < dSingleCost)))
    {
      rdCost += dSubdivCost;
      ruiBits += uiSubdivBits;
      ruiDist += uiSubdivDist;
#if DEBUG_STRING
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        DEBUG_STRING_APPEND(sDebug, sSplitString[ch])
      }
#endif
    }
    else
    {
      rdCost  += dSingleCost;
      ruiBits += uiSingleBits;
      ruiDist += uiSingleDist;

      //restore state to unsplit

      pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        const ComponentID compID=ComponentID(ch);

        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        if (rTu.ProcessComponentSection(compID))
        {
          DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])

          const Bool splitIntoSubTUs   = rTu.getRect(compID).width != rTu.getRect(compID).height;
          const UInt numberOfSections  = splitIntoSubTUs ? 2 : 1;
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> (splitIntoSubTUs ? 1 : 0);

          for (UInt subTUIndex = 0; subTUIndex < numberOfSections; subTUIndex++)
          {
            const UInt  uisubTUPartIdx = uiAbsPartIdx + (subTUIndex * partIdxesPerSubTU);

            if (splitIntoSubTUs)
            {
              const UChar combinedCBF = (bestsubTUCBF[compID][subTUIndex] << subTUDepth) | (bestCBF[compID] << uiTrMode);
              pcCU->setCbfPartRange(combinedCBF, compID, uisubTUPartIdx, partIdxesPerSubTU);
            }
            else
            {
              pcCU->setCbfPartRange((bestCBF[compID] << uiTrMode), compID, uisubTUPartIdx, partIdxesPerSubTU);
            }

            pcCU->setCrossComponentPredictionAlphaPartRange(bestCrossCPredictionAlpha[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setTransformSkipPartRange(uiBestTransformMode[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setExplicitRdpcmModePartRange(bestExplicitRdpcmModeUnSplit[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
          }
        }
      }

      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
    }
  }
  else
  {
    rdCost  += dSingleCost;
    ruiBits += uiSingleBits;
    ruiDist += uiSingleDist;
#if DEBUG_STRING
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[compID])

      if (rTu.ProcessComponentSection(compID))
      {
        DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])
      }
    }
#endif
  }
  DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[MAX_NUM_COMPONENT])
}



Void TEncSearch::xEncodeInterResidualQT( const ComponentID compID, TComTU &rTu )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  const UInt uiCurrTrMode = rTu.GetTransformDepthRel();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );

  const Bool bSubdiv = uiCurrTrMode != uiTrMode;

  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  if (compID==MAX_NUM_COMPONENT)  // we are not processing a channel, instead we always recurse and code the CBFs
  {
    if( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() && uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      if((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && (pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N))
      {
        assert(bSubdiv); // Inferred splitting rule - see derivation and use of interSplitFlag in the specification.
      }
      else
      {
        m_pcEntropyCoder->encodeTransformSubdivFlag( bSubdiv, 5 - uiLog2TrSize );
      }
    }

    assert( !pcCU->isIntra(uiAbsPartIdx) );

    const Bool bFirstCbfOfCU = uiCurrTrMode == 0;

    for (UInt ch=COMPONENT_Cb; ch<pcCU->getPic()->getNumberValidComponents(); ch++)
    {
      const ComponentID compIdInner=ComponentID(ch);
      if( bFirstCbfOfCU || rTu.ProcessingAllQuadrants(compIdInner) )
      {
        if( bFirstCbfOfCU || pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) )
        {
          m_pcEntropyCoder->encodeQtCbf( rTu, compIdInner, !bSubdiv );
        }
      }
      else
      {
        assert( pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode ) == pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) );
      }
    }

    if (!bSubdiv)
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }

  if( !bSubdiv )
  {
    if (compID != MAX_NUM_COMPONENT) // we have already coded the CBFs, so now we code coefficients
    {
      if (rTu.ProcessComponentSection(compID))
      {
        if (isChroma(compID) && (pcCU->getCbf(uiAbsPartIdx, COMPONENT_Y, uiTrMode) != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction(rTu, compID);
        }

        if (pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode) != 0)
        {
          const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
          TCoeff *pcCoeffCurr = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
          m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr, compID );
        }
      }
    }
  }
  else
  {
    if( compID==MAX_NUM_COMPONENT || pcCU->getCbf( uiAbsPartIdx, compID, uiCurrTrMode ) )
    {
      TComTURecurse tuRecurseChild(rTu, false);
      do
      {
        xEncodeInterResidualQT( compID, tuRecurseChild );
      } while (tuRecurseChild.nextSection(rTu));
    }
  }
}




Void TEncSearch::xSetInterResidualQTData( TComYuv* pcResi, Bool bSpatial, TComTU &rTu ) // TODO: turn this into two functions for bSpatial=true and false.
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiCurrTrMode=rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );
  const TComSPS *sps=pcCU->getSlice()->getSPS();

  if( uiCurrTrMode == uiTrMode )
  {
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTTempAccessLayer = sps->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if( bSpatial )
    {
      // Data to be copied is in the spatial domain, i.e., inverse-transformed.

      for(UInt i=0; i<pcResi->getNumberValidComponents(); i++)
      {
        const ComponentID compID=ComponentID(i);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          m_pcQTTempTComYuv[uiQTTempAccessLayer].copyPartToPartComponentMxN    ( compID, pcResi, rectCompTU );
        }
      }
    }
    else
    {
      for (UInt ch=0; ch < getNumberValidComponents(sps->getChromaFormatIdc()); ch++)
      {
        const ComponentID compID   = ComponentID(ch);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          const UInt numCoeffInBlock    = rectCompTU.width * rectCompTU.height;
          const UInt offset             = rTu.getCoefficientOffset(compID);
          TCoeff* dest                  = pcCU->getCoeff(compID)                        + offset;
          const TCoeff* src             = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + offset;
          ::memcpy( dest, src, sizeof(TCoeff)*numCoeffInBlock );

#if ADAPTIVE_QP_SELECTION
          TCoeff* pcArlCoeffSrc            = m_ppcQTTempArlCoeff[compID][uiQTTempAccessLayer] + offset;
          TCoeff* pcArlCoeffDst            = pcCU->getArlCoeff(compID)                        + offset;
          ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * numCoeffInBlock );
#endif
        }
      }
    }
  }
  else
  {

    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetInterResidualQTData( pcResi, bSpatial, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}




UInt TEncSearch::xModeBitsIntra( TComDataCU* pcCU, UInt uiMode, UInt uiPartOffset, UInt uiDepth, const ChannelType chType )
{
  // Reload only contexts required for coding intra mode information
  m_pcRDGoOnSbacCoder->loadIntraDirMode( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST], chType );

  // Temporarily set the intra dir being tested, and only
  // for absPartIdx, since encodeIntraDirModeLuma/Chroma only use
  // the entry at absPartIdx.

  UChar &rIntraDirVal=pcCU->getIntraDir( chType )[uiPartOffset];
  UChar origVal=rIntraDirVal;
  rIntraDirVal = uiMode;
  //pcCU->setIntraDirSubParts ( chType, uiMode, uiPartOffset, uiDepth + uiInitTrDepth );

  m_pcEntropyCoder->resetBits();
  if (isLuma(chType))
  {
    m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiPartOffset);
  }
  else
  {
    m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiPartOffset);
  }

  rIntraDirVal = origVal; // restore

  return m_pcEntropyCoder->getNumberOfWrittenBits();
}




UInt TEncSearch::xUpdateCandList( UInt uiMode, Double uiCost, UInt uiFastCandNum, UInt * CandModeList, Double * CandCostList )
{
  UInt i;
  UInt shift=0;

  while ( shift<uiFastCandNum && uiCost<CandCostList[ uiFastCandNum-1-shift ] )
  {
    shift++;
  }

  if( shift!=0 )
  {
    for(i=1; i<shift; i++)
    {
      CandModeList[ uiFastCandNum-i ] = CandModeList[ uiFastCandNum-1-i ];
      CandCostList[ uiFastCandNum-i ] = CandCostList[ uiFastCandNum-1-i ];
    }
    CandModeList[ uiFastCandNum-shift ] = uiMode;
    CandCostList[ uiFastCandNum-shift ] = uiCost;
    return 1;
  }

  return 0;
}





/** add inter-prediction syntax elements for a CU block
 * \param pcCU
 * \param uiQp
 * \param uiTrMode
 * \param ruiBits
 * \returns Void
 */
Void  TEncSearch::xAddSymbolBitsInter( TComDataCU* pcCU, UInt& ruiBits )
{
  if(pcCU->getMergeFlag( 0 ) && pcCU->getPartitionSize( 0 ) == SIZE_2Nx2N && !pcCU->getQtRootCbf( 0 ))
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    m_pcEntropyCoder->resetBits();
    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }
    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex(pcCU, 0, true);

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
  else
  {
    m_pcEntropyCoder->resetBits();

    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag ( pcCU, 0, true );
    m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
    m_pcEntropyCoder->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );
    m_pcEntropyCoder->encodePredInfo( pcCU, 0 );

    Bool codeDeltaQp = false;
    Bool codeChromaQpAdj = false;
    m_pcEntropyCoder->encodeCoeff   ( pcCU, 0, pcCU->getDepth(0), codeDeltaQp, codeChromaQpAdj );

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
}





/**
 * \brief Generate half-sample interpolated block
 *
 * \param pattern Reference picture ROI
 * \param biPred    Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingH( TComPattern* pattern )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;
  Int halfFilterSize = (filterSize>>1);
  Pel *srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[0].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 0, false, chFmt, pattern->getBitDepthY());
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[2].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 2, false, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + halfFilterSize * intStride + 1;
  dstPtr = m_filteredBlock[0][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
  dstPtr = m_filteredBlock[2][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+1, 2, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
  dstPtr = m_filteredBlock[0][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[2][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+1, 2, false, true, chFmt, pattern->getBitDepthY());
}





/**
 * \brief Generate quarter-sample interpolated blocks
 *
 * \param pattern    Reference picture ROI
 * \param halfPelRef Half-pel mv
 * \param biPred     Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingQ( TComPattern* pattern, TComMv halfPelRef )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Pel *srcPtr;
  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;

  Int halfFilterSize = (filterSize>>1);

  Int extHeight = (halfPelRef.getVer() == 0) ? height + filterSize : height + filterSize-1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  // Horizontal filter 1/4
  srcPtr = pattern->getROIY() - halfFilterSize * srcStride - 1;
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() >= 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 1, false, chFmt, pattern->getBitDepthY());

  // Horizontal filter 3/4
  srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() > 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 3, false, chFmt, pattern->getBitDepthY());

  // Generate @ 1,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][1].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());

  if (halfPelRef.getVer() != 0)
  {
    // Generate @ 2,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][1].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 2,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][3].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 0,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][1].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 0,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][3].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());
  }

  if (halfPelRef.getHor() != 0)
  {
    // Generate @ 1,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[1][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[3][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 1,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[1][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[3][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }

  // Generate @ 1,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][3].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
}





//! set wp tables
Void  TEncSearch::setWpScalingDistParam( TComDataCU* pcCU, Int iRefIdx, RefPicList eRefPicListCur )
{
  if ( iRefIdx<0 )
  {
    m_cDistParam.bApplyWeight = false;
    return;
  }

  TComSlice       *pcSlice  = pcCU->getSlice();
  WPScalingParam  *wp0 , *wp1;

  m_cDistParam.bApplyWeight = ( pcSlice->getSliceType()==P_SLICE && pcSlice->testWeightPred() ) || ( pcSlice->getSliceType()==B_SLICE && pcSlice->testWeightBiPred() ) ;

  if ( !m_cDistParam.bApplyWeight )
  {
    return;
  }

  Int iRefIdx0 = ( eRefPicListCur == REF_PIC_LIST_0 ) ? iRefIdx : (-1);
  Int iRefIdx1 = ( eRefPicListCur == REF_PIC_LIST_1 ) ? iRefIdx : (-1);

  getWpScaling( pcCU, iRefIdx0, iRefIdx1, wp0 , wp1 );

  if ( iRefIdx0 < 0 )
  {
    wp0 = NULL;
  }
  if ( iRefIdx1 < 0 )
  {
    wp1 = NULL;
  }

  m_cDistParam.wpCur  = NULL;

  if ( eRefPicListCur == REF_PIC_LIST_0 )
  {
    m_cDistParam.wpCur = wp0;
  }
  else
  {
    m_cDistParam.wpCur = wp1;
  }
}



//! \}
