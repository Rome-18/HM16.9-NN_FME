/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2016, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     TEncSearch.cpp
 \brief    encoder search class
 */

#include "TLibCommon/CommonDef.h"
#include "TLibCommon/TComRom.h"
#include "TLibCommon/TComMotionInfo.h"
#include "TEncSearch.h"
#include "TLibCommon/TComTU.h"
#include "TLibCommon/Debug.h"
#include <math.h>
#include <limits>
#include <fstream>
#include <iostream>
#include <algorithm>


// EMI: Parameters declaration

signed short MVX_HALF, MVX_QRTER, MVY_HALF, MVY_QRTER = 0;
float  C, H1, H2, V1, V2, U1, U2, U3, U4;
long int array_e[100000];

float IN[17] = {};
float X1[22] = {};
float X2[20] = {};
float OUT[49] = {};
int N, NN_out, index_ref, counter_i, PUHeight, PUWidth, PIdx, PAddr, xP, yP, nPSW, nPSH;

/*
The next group of variables are all 1D and 2D arrays. The reason why I declared them as std::array is because that
way they can be assigned in a cleaner manner. These arrays are assigned values in TEncSearch::init() function depending
on the chosen Quantization Parameter
https://stackoverflow.com/questions/16059781/2d-array-value-assign-after-declaration-in-c for more info on 2D array assignment
*/
std::array<std::array<float,4>,8> embs0, embs1;
std::array<std::array<float,2>,3> embs2;
std::array<std::array<float,7>,14> embs3;
std::array<std::array<float,17>,22> in_h1;
std::array<std::array<float,22>,20> h1_h2;
std::array<std::array<float,20>,49> h2_out;
std::array<float ,22> b1, BN_gamma_1, BN_beta_1;
std::array<float ,20> b2, BN_gamma_2, BN_beta_2;
std::array<float ,49> bout;
std::array<float ,9> BN_gamma_in, mean, stdev;

// Helper Functions

float relu(float x){
	if (x>0)	{	return x; }
	else { return 0; }
}

float sigmoid(float x){
  return (1 / (1 + std::exp(-x)));
}

//end of modification


//! \ingroup TLibEncoder
//! \{

static const TComMv s_acMvRefineH[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static const TComMv s_acMvRefineQ[9] =
{
  TComMv(  0,  0 ), // 0
  TComMv(  0, -1 ), // 1
  TComMv(  0,  1 ), // 2
  TComMv( -1, -1 ), // 5
  TComMv(  1, -1 ), // 6
  TComMv( -1,  0 ), // 3
  TComMv(  1,  0 ), // 4
  TComMv( -1,  1 ), // 7
  TComMv(  1,  1 )  // 8
};

static Void offsetSubTUCBFs(TComTU &rTu, const ComponentID compID)
{
        TComDataCU *pcCU              = rTu.getCU();
  const UInt        uiTrDepth         = rTu.GetTransformDepthRel();
  const UInt        uiAbsPartIdx      = rTu.GetAbsPartIdxTU(compID);
  const UInt        partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

  //move the CBFs down a level and set the parent CBF

  UChar subTUCBF[2];
  UChar combinedSubTUCBF = 0;

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);

    subTUCBF[subTU]   = pcCU->getCbf(subTUAbsPartIdx, compID, uiTrDepth);
    combinedSubTUCBF |= subTUCBF[subTU];
  }

  for (UInt subTU = 0; subTU < 2; subTU++)
  {
    const UInt subTUAbsPartIdx = uiAbsPartIdx + (subTU * partIdxesPerSubTU);
    const UChar compositeCBF = (subTUCBF[subTU] << 1) | combinedSubTUCBF;

    pcCU->setCbfPartRange((compositeCBF << uiTrDepth), compID, subTUAbsPartIdx, partIdxesPerSubTU);
  }
}


TEncSearch::TEncSearch()
: m_puhQTTempTrIdx(NULL)
, m_pcQTTempTComYuv(NULL)
, m_pcEncCfg (NULL)
, m_pcTrQuant (NULL)
, m_pcRdCost (NULL)
, m_pcEntropyCoder (NULL)
, m_iSearchRange (0)
, m_bipredSearchRange (0)
, m_motionEstimationSearchMethod (MESEARCH_FULL)
, m_pppcRDSbacCoder (NULL)
, m_pcRDGoOnSbacCoder (NULL)
, m_pTempPel (NULL)
, m_isInitialized (false)
{
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    m_ppcQTTempCoeff[ch]                           = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]                        = NULL;
#endif
    m_puhQTTempCbf[ch]                             = NULL;
    m_phQTTempCrossComponentPredictionAlpha[ch]    = NULL;
    m_pSharedPredTransformSkip[ch]                 = NULL;
    m_pcQTTempTUCoeff[ch]                          = NULL;
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = NULL;
#endif
    m_puhQTTempTransformSkipFlag[ch]               = NULL;
  }

  for (Int i=0; i<MAX_NUM_REF_LIST_ADAPT_SR; i++)
  {
    memset (m_aaiAdaptSR[i], 0, MAX_IDX_ADAPT_SR * sizeof (Int));
  }
  for (Int i=0; i<AMVP_MAX_NUM_CANDS+1; i++)
  {
    memset (m_auiMVPIdxCost[i], 0, (AMVP_MAX_NUM_CANDS+1) * sizeof (UInt) );
  }

  setWpScalingDistParam( NULL, -1, REF_PIC_LIST_X );
}


Void TEncSearch::destroy()
{
  assert (m_isInitialized);
  if ( m_pTempPel )
  {
    delete [] m_pTempPel;
    m_pTempPel = NULL;
  }

  if ( m_pcEncCfg )
  {
    const UInt uiNumLayersAllocated = m_pcEncCfg->getQuadtreeTULog2MaxSize()-m_pcEncCfg->getQuadtreeTULog2MinSize()+1;

    for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
    {
      for (UInt layer = 0; layer < uiNumLayersAllocated; layer++)
      {
        delete[] m_ppcQTTempCoeff[ch][layer];
#if ADAPTIVE_QP_SELECTION
        delete[] m_ppcQTTempArlCoeff[ch][layer];
#endif
      }
      delete[] m_ppcQTTempCoeff[ch];
      delete[] m_puhQTTempCbf[ch];
#if ADAPTIVE_QP_SELECTION
      delete[] m_ppcQTTempArlCoeff[ch];
#endif
    }

    for( UInt layer = 0; layer < uiNumLayersAllocated; layer++ )
    {
      m_pcQTTempTComYuv[layer].destroy();
    }
  }

  delete[] m_puhQTTempTrIdx;
  delete[] m_pcQTTempTComYuv;

  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    delete[] m_pSharedPredTransformSkip[ch];
    delete[] m_pcQTTempTUCoeff[ch];
#if ADAPTIVE_QP_SELECTION
    delete[] m_ppcQTTempTUArlCoeff[ch];
#endif
    delete[] m_phQTTempCrossComponentPredictionAlpha[ch];
    delete[] m_puhQTTempTransformSkipFlag[ch];
  }
  m_pcQTTempTransformSkipTComYuv.destroy();

  m_tmpYuvPred.destroy();
  m_isInitialized = false;
}

TEncSearch::~TEncSearch()
{
  if (m_isInitialized)
  {
    destroy();
  }
}




Void TEncSearch::init(TEncCfg*       pcEncCfg,
                      TComTrQuant*   pcTrQuant,
                      Int            iSearchRange,
                      Int            bipredSearchRange,
                      MESearchMethod motionEstimationSearchMethod,
                      const UInt     maxCUWidth,
                      const UInt     maxCUHeight,
                      const UInt     maxTotalCUDepth,
                      TEncEntropy*   pcEntropyCoder,
                      TComRdCost*    pcRdCost,
                      TEncSbac***    pppcRDSbacCoder,
                      TEncSbac*      pcRDGoOnSbacCoder
                      )
{
  assert (!m_isInitialized);
  m_pcEncCfg                     = pcEncCfg;
  m_pcTrQuant                    = pcTrQuant;
  m_iSearchRange                 = iSearchRange;
  m_bipredSearchRange            = bipredSearchRange;
  m_motionEstimationSearchMethod = motionEstimationSearchMethod;
  m_pcEntropyCoder               = pcEntropyCoder;
  m_pcRdCost                     = pcRdCost;

  m_pppcRDSbacCoder              = pppcRDSbacCoder;
  m_pcRDGoOnSbacCoder            = pcRDGoOnSbacCoder;
  
  for (UInt iDir = 0; iDir < MAX_NUM_REF_LIST_ADAPT_SR; iDir++)
  {
    for (UInt iRefIdx = 0; iRefIdx < MAX_IDX_ADAPT_SR; iRefIdx++)
    {
      m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange;
    }
  }

  // initialize motion cost
  for( Int iNum = 0; iNum < AMVP_MAX_NUM_CANDS+1; iNum++)
  {
    for( Int iIdx = 0; iIdx < AMVP_MAX_NUM_CANDS; iIdx++)
    {
      if (iIdx < iNum)
      {
        m_auiMVPIdxCost[iIdx][iNum] = xGetMvpIdxBits(iIdx, iNum);
      }
      else
      {
        m_auiMVPIdxCost[iIdx][iNum] = MAX_INT;
      }
    }
  }

  const ChromaFormat cform=pcEncCfg->getChromaFormatIdc();
  initTempBuff(cform);

  m_pTempPel = new Pel[maxCUWidth*maxCUHeight];

  const UInt uiNumLayersToAllocate = pcEncCfg->getQuadtreeTULog2MaxSize()-pcEncCfg->getQuadtreeTULog2MinSize()+1;
  const UInt uiNumPartitions = 1<<(maxTotalCUDepth<<1);
  for (UInt ch=0; ch<MAX_NUM_COMPONENT; ch++)
  {
    const UInt csx=::getComponentScaleX(ComponentID(ch), cform);
    const UInt csy=::getComponentScaleY(ComponentID(ch), cform);
    m_ppcQTTempCoeff[ch] = new TCoeff* [uiNumLayersToAllocate];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempArlCoeff[ch]  = new TCoeff*[uiNumLayersToAllocate];
#endif
    m_puhQTTempCbf[ch] = new UChar  [uiNumPartitions];

    for (UInt layer = 0; layer < uiNumLayersToAllocate; layer++)
    {
      m_ppcQTTempCoeff[ch][layer] = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy)];
#if ADAPTIVE_QP_SELECTION
      m_ppcQTTempArlCoeff[ch][layer]  = new TCoeff[(maxCUWidth*maxCUHeight)>>(csx+csy) ];
#endif
    }

    m_phQTTempCrossComponentPredictionAlpha[ch]    = new SChar  [uiNumPartitions];
    m_pSharedPredTransformSkip[ch]                 = new Pel   [MAX_CU_SIZE*MAX_CU_SIZE];
    m_pcQTTempTUCoeff[ch]                          = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#if ADAPTIVE_QP_SELECTION
    m_ppcQTTempTUArlCoeff[ch]                      = new TCoeff[MAX_CU_SIZE*MAX_CU_SIZE];
#endif
    m_puhQTTempTransformSkipFlag[ch]               = new UChar [uiNumPartitions];
  }
  m_puhQTTempTrIdx   = new UChar  [uiNumPartitions];
  m_pcQTTempTComYuv  = new TComYuv[uiNumLayersToAllocate];
  for( UInt ui = 0; ui < uiNumLayersToAllocate; ++ui )
  {
    m_pcQTTempTComYuv[ui].create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  }
  m_pcQTTempTransformSkipTComYuv.create( maxCUWidth, maxCUHeight, pcEncCfg->getChromaFormatIdc() );
  m_tmpYuvPred.create(MAX_CU_SIZE, MAX_CU_SIZE, pcEncCfg->getChromaFormatIdc());
  m_isInitialized = true;

  // EMI: Weights and Bias Initialization based on QP

  if(m_pcEncCfg->getQP() == 27){
    
    embs0 = {{
      {{0.28226915,-0.3013882,0.2726443,0.09908676}},
      {{0.00022126742,-0.0042713634,0.013788432,0.00016589682}},
      {{0.0010037599,0.003740409,-0.0044264416,-0.00038688726}},
      {{-0.054586243,0.012640734,0.03842694,-0.06640733}},
      {{0.0008533101,-0.0068794484,-0.033910986,0.0005362762}},
      {{-0.060178135,-0.029313162,0.029440515,-0.10958095}},
      {{-0.07028606,0.012073138,-0.025192589,0.0067943917}},
      {{-0.13664949,-0.051337715,-0.027480468,0.034141697}}
    }};

    embs1 = {{
      {{-0.12863055,0.013502836,0.089277655,0.086814016}},
      {{-0.013142972,-0.002143063,-0.0007437665,0.0034178912}},
      {{0.004820742,0.0019660837,0.0037983481,-0.0031177648}},
      {{-0.04214557,-0.008129467,0.06945414,-0.0068204687}},
      {{0.03298121,0.002917829,0.0035158733,0.008332825}},
      {{-0.030023329,0.029603135,0.0642066,0.031445794}},
      {{0.058541935,-0.05254912,0.011047653,-0.009454259}},
      {{0.077901736,-0.13876036,0.009646339,0.020725114}}
    }};

    in_h1 = {{
      {{0.23720442,0.023522899,0.19724225,0.051848125,-0.18966103,0.15133342,-0.052141942,-0.0031572,-0.6588876,1.0215673,1.3051752,1.7918707,0.32819858,-3.1257224,-3.1658823,-0.08496778,2.5400388}},
      {{-0.007931642,0.010122783,-0.024115693,-0.014960281,0.03366466,0.001440467,0.026818462,-0.00856439,-0.1866711,1.3264632,-0.12548769,0.4153219,2.0133822,1.19668,-0.47690383,-2.8817375,-0.9536577}},
      {{0.005114516,0.0020660232,0.0015167459,0.0009045063,-0.0008187593,0.0016962212,0.0247495,0.00887137,-0.29282647,-0.11398509,0.61017996,0.33417192,-0.22047538,-0.08433203,1.7437308,0.43703407,-4.6453595}},
      {{0.000976779,0.009699465,-0.01453258,-0.010099582,0.0011433125,0.0051629315,0.018189281,-0.0034229218,-0.06886236,-6.318976,0.0506164,0.02456714,0.17993477,0.15742542,0.052364748,1.1011355,-0.2186689}},
      {{-0.15713893,0.12945807,-0.32165727,-0.06740415,0.3177715,0.021007301,0.035323806,-0.08436634,0.078667834,-0.5628731,0.28230944,0.5440949,-5.104387,1.1601133,-0.26779205,0.28947034,0.3368927}},
      {{0.02283751,-0.0048329267,-0.0540126,-0.0044612396,0.057108775,0.011071362,-0.012427872,0.005807339,-1.525515,-0.6237906,-1.2113509,-1.373642,-1.4696139,-0.9310276,-1.0166276,-0.21229298,-0.93364686}},
      {{-0.00065385713,0.009042579,-0.010882692,-0.003497508,0.006901105,0.009460624,0.032490402,-0.0010665702,-0.24304722,2.996799,-3.3376827,0.64728147,0.13125409,0.6132344,-0.43520942,0.37715563,0.5460783}},
      {{-0.019211255,0.014355245,-0.033841778,-0.013899747,0.040439997,0.0015478411,-0.0536859,-0.012631714,-0.20433858,0.48371604,0.14980812,0.57096887,1.0017391,-5.8496304,-1.0060886,0.41756135,-0.04687334}},
      {{-0.018979061,0.044319116,-0.07814774,-0.03879637,0.061992057,0.03298995,-0.013540687,-0.042746887,-0.2189551,1.4367061,-0.14360435,-3.4231937,2.186697,2.1650195,-0.2815019,0.23053764,-0.22742109}},
      {{-0.0021987867,-0.0009217518,-0.0059321327,0.0002605133,0.0057554,-0.0006013251,0.0012010644,0.0021900667,-0.73226315,1.4024848,-1.3982384,-0.38998345,2.9156609,-2.8647552,-1.9674066,-0.15640767,-2.311961}},
      {{-0.097479425,-0.0729206,-0.028319009,0.064808324,0.0257395,-0.09329763,-0.008181652,0.027199956,0.2254022,4.5920744,0.08536095,-0.8246281,-5.016751,3.043821,-1.438934,-1.1200621,0.50906074}},
      {{0.054161124,0.016006066,0.019673843,0.04361059,-0.014723103,0.022606283,-0.030964548,-0.021791454,-0.010367717,0.021667017,0.03869549,0.075950384,-5.553717,-0.010444025,0.013842317,0.0038505746,0.15617193}},
      {{-0.017878857,-0.009419586,-0.046093773,-0.01713693,0.07737308,0.01962058,-0.052372318,0.0067812353,0.099432744,-4.2573175,-1.947747,0.60119015,1.0702113,2.2730954,-1.7112485,-0.6121426,1.8162727}},
      {{-0.006835059,0.002855935,-0.010563094,-0.0072653973,0.018301785,-0.010417304,0.033668116,-0.0030164677,0.4467621,-1.4017375,0.16677445,-0.7980609,-0.37390205,4.8242116,-1.8627912,0.47746807,0.116871}},
      {{-0.077215016,0.07412322,-0.25014627,-0.22120187,-0.24030252,0.20793553,2.2288046,0.046785988,-0.7060805,2.9130044,0.17231004,-2.650716,1.5848074,-2.044808,-0.13386124,1.5032389,-0.31748626}},
      {{-0.1684965,0.099814504,-0.41473526,-0.25790286,0.40316835,0.03752054,-0.12270377,-0.13698184,-0.83148205,-5.8564277,-0.3947472,-0.48261088,3.1366267,0.9115832,3.3389878,-2.4959784,-1.11853}},
      {{-0.060280554,0.013189199,-0.079775676,-0.054577902,0.06414893,-0.03318865,-0.00493247,-0.012966446,2.7213986,-2.5083435,-0.03542431,1.2204767,-1.5210546,-1.9913036,-0.7754878,-0.10051322,0.60771376}},
      {{-0.008031677,0.002869096,-0.033904158,-0.019357303,0.0067341086,-0.0009625143,0.02268429,0.005214557,0.16631211,7.044424,-0.12851413,-0.099203005,-0.0044667562,-0.4859634,-0.052661132,-1.6363213,0.7790441}},
      {{-0.05120461,-0.16061656,0.11080006,0.09643523,0.0011718428,-0.15930763,-0.19796097,0.044887427,-0.23763783,-0.65930825,0.1550804,-1.1932822,-2.0270808,-0.24827628,2.9763453,2.8044028,0.16955984}},
      {{0.079403,0.01018962,0.013437157,-0.013008354,-0.038195696,0.103391975,0.03006673,0.007290962,2.4120457,-3.9764104,-0.512206,-1.201351,0.6443354,-0.64046633,2.0899312,-0.7650253,-1.2624494}},
      {{-0.10406923,0.034969553,-0.16947913,-0.094626985,0.141232,-0.008205534,-0.06025018,-0.034852978,-0.88228077,1.0308443,1.3625108,0.83885205,-1.532129,5.6815953,0.4356452,-0.47125587,-0.39821175}},
      {{-0.23010793,0.15172772,-0.5074094,-0.27257714,0.42124182,0.024747657,0.32578063,-0.11107159,-0.062991984,0.9978483,0.49428144,1.2900962,-1.826593,-5.9474845,-0.018516047,-0.13628383,1.5369316}}
    }};

    h1_h2 = {{
      {{0.15348276,1.3735784,0.2958113,0.30471593,3.4766088,-2.1146579,-0.13038021,0.61812586,0.9108676,6.3531585,0.21284619,4.017668,-1.4956278,-0.36320186,-0.85302675,0.4455098,-0.90160197,0.5382541,-0.32008466,0.047515154,-2.1393785,-1.1461748}},
      {{-1.9160762,0.07851796,0.3757962,-3.039597,0.38659352,0.91674155,-1.8772686,-1.3313162,-0.8697706,7.4451246,0.08843291,-0.06212106,-2.261535,-1.0318803,-0.37236908,1.1733278,-0.46787775,0.10880147,0.32828102,-0.5607003,1.4256957,0.2807987}},
      {{-1.9140997,-0.66190284,0.37751824,-0.59247106,0.022500262,-0.48849764,-0.52850807,3.939295,-0.9828863,-5.0880184,-0.038231153,-0.39317378,-0.119216144,-3.308286,-0.23210312,0.2391008,-0.4623724,0.5679628,-0.5056683,-0.7864365,-4.6760893,1.3529196}},
      {{-0.98187584,-1.4484869,-0.61045134,0.4495367,-0.018966407,-2.7039757,-0.10622565,0.6493505,-3.2351162,-3.262894,0.4703386,-0.2522438,-0.22988339,-0.4841898,-0.16502781,0.4366268,1.816454,-1.0060649,-0.5420715,-1.3993471,-0.72963387,0.8676828}},
      {{-0.8328583,-0.6341197,-1.5649406,-3.6148663,0.1491246,-1.1853582,-0.18067014,-1.1058569,-1.3728071,4.459879,-0.6222325,-0.5098414,0.97448313,-1.1542722,-0.3609881,1.4221258,1.160012,0.50261116,-0.9146049,-1.5928344,-0.25897887,1.0718087}},
      {{-1.5089022,-3.0087602,-0.027760927,-1.4672759,0.8598542,-0.5206525,-0.51380885,-0.709474,-0.34855676,-6.588205,-0.54846686,4.39452,-2.288357,1.3154463,-0.013584421,2.8823895,-0.09662703,-0.4393376,-0.03077488,-0.75236243,-0.7003584,1.9757441}},
      {{0.0053735133,0.23286127,0.40989938,-0.27555192,0.028906135,-4.741305,-0.9202164,-0.38613585,-4.24109,1.3125217,-2.259813,-0.724559,0.050224572,-8.218085,0.33977214,0.8841695,0.5841322,-0.037088778,-0.75311524,-0.7500083,-0.49806517,1.5098013}},
      {{-0.8190302,-0.3586672,0.050430123,-0.017751785,2.257862,-2.4802158,-0.6227679,-3.8016908,-1.5217022,-7.4687123,-0.079104334,5.0943155,-0.1364908,0.26491812,0.0026755887,0.41367915,-0.49587652,0.17070714,-0.7593142,-0.15481247,-0.58824325,0.8749379}},
      {{-1.0686055,0.65527207,1.273352,-0.70999694,0.13107276,-3.1910927,-2.2471304,-0.43473047,-0.67078733,-0.72045135,-1.442483,1.1266897,-0.7676236,1.2911853,-1.0741515,1.423653,0.40511492,0.6231206,-2.654861,-1.4056357,-1.182006,0.46488473}},
      {{-0.5294082,-2.4656343,-0.05665373,0.6754891,0.11193102,0.004552314,-4.3641663,0.57380533,-1.5734142,11.380287,-0.23447116,-1.0399948,-1.8872411,-0.40570608,-0.204329,1.9040773,0.033842087,-5.990855,-0.45095757,-1.1698426,0.60984755,2.2381527}},
      {{-1.0618976,-0.9586274,-0.48294613,0.7737645,0.43894225,-5.227489,-2.765173,-2.110887,-1.4109453,-2.952256,-1.6786814,0.69202924,-1.3819486,-0.30436662,0.2456742,0.6584109,-4.888731,-2.8267512,-0.770879,-7.0582614,0.7635327,1.6051195}},
      {{-0.016813798,0.04776739,0.026206668,-0.0077506695,0.023676284,-15.43851,0.009825209,0.075037874,-0.088134125,-16.05031,-0.004468927,-2.0600924,-0.6834753,9.3532726e-05,0.031444613,0.29720983,-0.035216253,-0.00022366097,-0.050605945,0.014925606,-0.0011377158,0.03261329}},
      {{-0.6309181,0.13994926,-10.92424,-1.616081,0.79273796,-5.9379115,-0.3979599,-0.3055321,-0.45085207,-1.4342066,-0.47662434,0.89003056,-0.32262874,1.5602063,0.77613693,1.9418318,0.5716117,0.54751235,-1.0709902,-1.4023232,-1.2546668,0.28616294}},
      {{-2.0392845,-0.512225,-0.050087925,-3.6300614,0.26390603,-1.6582297,-2.7381034,-3.198586,0.5226149,4.675773,-1.7904564,-0.73459727,-0.6524061,0.80037147,0.39565971,0.2756216,-0.53739595,0.76194066,-0.12116847,-1.2068979,-0.1401476,0.042736605}},
      {{-2.8018014,-2.6901643,-1.7860128,0.3663592,0.17558661,-4.2376313,-0.3547743,-2.524614,0.038501777,1.5587312,-0.5876519,-0.7668131,0.49103248,0.784339,0.19278216,1.1069891,1.4708883,-2.5831542,-0.83132315,-1.0594783,-0.72397107,0.35646856}},
      {{-1.7508475,0.6484532,-0.8484321,-0.032006554,0.29882392,-2.2764478,-1.6434679,-3.0829406,-1.7100955,-9.69125,-0.56980354,-0.9682039,0.20969272,0.8366717,0.09030318,0.4907158,-0.34661233,0.70830375,0.2605292,-0.50311536,0.9030334,-0.2138843}},
      {{-0.7566623,-3.007393,0.038855217,-2.5401962,0.58510226,-4.3659987,-0.36174336,-0.1586915,-0.23686863,-3.3158185,-0.0007668193,-0.5919425,-0.6661042,0.8344695,-1.4693837,1.7894675,0.9811267,-0.1689184,2.1571295,-1.1851039,-0.73766106,1.3492801}},
      {{-0.6738992,-1.6508086,-0.05526358,-10.549391,-0.031568583,-1.7800802,-0.6724291,0.7068311,-0.3369421,-3.6703954,-0.46930557,-0.93301713,-2.1326838,0.1656676,0.07065711,1.1423923,0.57962674,1.2805179,-0.49532613,-1.002052,0.12612227,1.4546365}},
      {{-1.04417,-0.18112746,-0.21428566,0.502736,-0.6914161,0.5312868,-0.15747853,-0.7861368,0.42419106,-5.520175,-0.47582427,-10.964157,-1.1396344,0.043860037,-0.2114929,1.9133542,0.18066813,0.49991277,-0.32745588,-0.36400038,0.20536444,0.23291074}},
      {{-1.3120236,0.7446476,-0.30917427,0.68494934,3.090556,-4.6032186,-0.95886564,-5.0423026,-3.7047102,-9.442905,-0.21433567,-1.7023779,0.07510149,-0.6272415,0.13079354,0.6226274,1.6906297,0.13303094,-0.7556714,-1.5916926,0.569758,-0.17380466}}
    }};

    h2_out = {{
      {{-1.9361204,0.07583711,-0.21869108,-3.8241727,-4.9559517,-2.2741084,-0.82874376,-0.2329723,0.1927154,-0.3374154,2.7678182,2.0473132,-3.1661057,0.1949921,-1.6129552,-1.255995,-2.179695,-3.0022879,-1.8608903,-5.347982}},
      {{-1.8922473,0.20808539,-1.5263704,-3.5602465,-4.463153,-3.5716472,-0.09275374,-2.036108,0.8174654,0.7821348,2.203972,1.5115542,-1.8077791,0.21131107,-1.1438947,1.0936133,-7.077546,-5.948678,-1.4807172,-1.6592021}},
      {{-1.6501964,-0.14678818,-1.4367,-1.1149006,-2.6979523,-4.632849,-0.47948042,-0.29458216,1.1604114,1.144057,1.2744013,1.7806568,-1.6094095,-0.0803688,-0.55532837,1.0149598,-8.381768,-9.49749,-2.124937,0.29965502}},
      {{-0.9781873,-0.45773843,-0.43894932,-0.1663607,-0.42015466,-1.8655351,-0.36098838,1.2017761,0.076288946,-0.45692855,0.06670727,0.59111273,-1.2755156,-1.0030348,0.26070932,0.4229183,-6.803957,-9.87026,-1.4106337,0.6204758}},
      {{-1.3803672,-5.1380415,-0.92435354,0.5025955,0.31680137,-4.5695815,0.6476429,-0.85673344,0.5860839,-0.79390836,-1.1555187,0.17346315,-0.25747856,-2.0341015,1.0851172,-0.005819946,-6.913978,-8.0809355,-1.3097132,0.44881403}},
      {{-1.5483891,-7.411447,-0.1307243,1.148637,0.82361454,-2.8811173,0.96205026,-3.627808,0.18408336,-3.0653534,-2.2555008,-0.41707373,0.3474997,-0.87289315,0.8240628,-0.4040653,-4.3963614,-6.1433287,-1.2648818,-1.6621137}},
      {{-1.6432184,-5.875678,1.3805286,0.4141601,0.4388207,-2.2572591,-0.6356292,-0.98439944,-1.2385484,-2.1982188,-2.6380165,0.9563483,1.164754,-1.9641789,0.18879837,-2.7623718,-1.9354279,-3.197279,-1.7433145,-4.51933}},
      {{-0.95339453,0.16188557,0.39083531,-5.3609867,-3.7362745,-1.1182715,-1.3662351,-2.2059677,-0.4979081,0.15891404,2.8270824,1.867096,-3.192117,0.21283609,-1.3812823,-1.5226235,0.19023769,-1.613487,0.9928732,-8.450262}},
      {{-0.4070734,0.26200807,-1.4399517,-4.0803704,-3.9979436,-2.7594364,-0.45377722,-1.5537249,-1.3818128,0.7332687,2.0679119,-0.6407966,-1.8830127,0.20057262,-0.46068892,1.0317415,-1.3848646,-3.0415485,0.78536826,-3.5015604}},
      {{-0.7432341,-0.22213756,-1.6293046,-1.553122,-3.175132,-3.5574238,-0.85020095,-1.6651194,-0.54137677,1.4157493,1.3435966,-0.15301247,-1.4181024,-1.1103871,0.3976109,0.8995216,-3.017105,-4.090146,0.633006,0.15771942}},
      {{0.028139796,-0.71501523,-1.1282929,-0.16587824,-1.1223044,-3.509918,-0.27924734,1.101042,0.073819175,1.1078112,0.08926312,-0.7615397,-0.90453553,-2.232232,0.89093256,0.14641045,-3.8452842,-6.629619,0.7290251,0.7232835}},
      {{-0.4198606,-2.7410069,-0.5906204,1.0323501,0.01445428,-2.7270072,0.39829674,-2.0162878,-1.0760336,0.39278165,-0.7982286,-0.39166516,-0.8371645,-2.947053,0.8561672,-1.0496576,-2.4178069,-4.2878227,0.74306905,0.123567045}},
      {{-0.53332615,-3.7467186,0.87339544,1.322767,0.8612457,-1.5349262,0.68190825,-2.5031571,-0.9283692,-1.3143734,-1.8865714,0.0562429,-0.09019638,-1.9100914,0.2987997,-3.2929127,-0.93385786,-4.1330967,0.51712114,-2.6774004}},
      {{-0.76238805,-4.8973775,2.5532508,0.8183991,0.75091743,-0.7463707,-1.1723242,-2.6000674,-0.8523448,-1.5898651,-2.8641171,1.5798566,0.28133893,-1.2904342,0.14014934,-5.9249396,0.007605117,-2.056416,0.4683039,-6.6777563}},
      {{-0.35561353,0.07756844,0.71739215,-5.740809,-3.884615,0.80010766,-3.3995283,-4.9805584,-0.77667993,0.5050925,1.0575324,2.2576518,-2.155773,1.9432034,-1.01463,-1.7665644,0.21589853,-1.8405589,0.48197263,-9.479026}},
      {{-0.714339,0.15397942,-0.7916277,-4.260237,-3.063702,0.19057828,-2.1573012,-4.21581,-1.1309427,0.12472181,1.2882943,0.06713349,-1.5071946,1.6050993,0.067624405,1.0986037,0.36608842,-2.6409523,0.7925497,-4.356496}},
      {{-0.4140321,0.09806016,-1.4161752,-2.2263613,-2.1459289,-0.1888247,-1.0801607,-1.0203574,-0.46979475,0.5873378,0.65252423,-0.22082748,-1.1540369,-0.02178394,0.6502954,1.0257502,0.46314675,-1.8458762,0.0971302,0.16389674}},
      {{-0.08966538,-0.29580268,-0.69733113,-0.34147027,-0.42350614,-0.56743765,-0.5652474,1.1157712,-0.2356191,0.7994985,-0.009060653,-0.61282796,-1.0088115,-1.5232527,0.46686903,0.087262936,0.49641737,-2.3213084,-0.40611666,0.73463017}},
      {{-0.23769745,-1.5962809,-0.259054,0.44648615,0.650681,0.015657214,0.46570843,-1.1509839,-0.6417831,0.7471598,-0.5963827,-0.3599812,-0.7933172,-2.5326385,-0.004153891,-1.4670279,0.39650106,-1.5891942,-0.2477465,0.2939751}},
      {{-0.3339482,-2.8562222,1.5823094,1.1548796,0.93936735,0.21025386,1.0816581,-4.343214,-1.0083731,0.20776573,-1.5007815,0.5460831,-0.8842514,-1.7704966,-0.61385596,-3.7902603,0.18520316,-1.2744484,-0.11290029,-3.4487875}},
      {{-0.5696328,-3.2039058,3.295856,0.6135193,0.5909705,0.36564544,-0.6439054,-4.837849,-0.8569591,-0.1005557,-2.4643269,1.2569125,-0.35401535,-1.8359097,-0.88336414,-5.5469923,0.37355173,-0.2909737,-0.41804782,-7.1790657}},
      {{0.3806385,-0.5814539,0.809649,-4.785136,-1.9255116,0.8382449,-4.1397495,-2.6367497,-1.4452354,-0.105999,-0.38349968,1.4798667,-0.14809178,1.1916746,-0.05380719,-0.7491559,0.49759892,0.2129916,-0.9430602,-7.363152}},
      {{0.7811413,-0.18702805,-1.3656274,-3.8877082,-2.675116,0.695756,-2.3684986,-4.2765875,-1.8201505,-0.5291465,-0.41085175,-0.31722367,0.06938838,1.950539,0.6869208,0.98925513,0.5137208,-0.35389632,-0.22144568,-4.4502196}},
      {{0.9977964,0.10276243,-1.5486745,-1.3950815,-1.2891539,0.67716825,-1.7604228,-1.2851266,-1.030592,-0.37305006,-0.2149561,0.48435822,-0.15675853,1.2868514,0.39336944,0.8799076,0.66528136,-0.10180063,-0.9330794,0.14957094}},
      {{2.1340215,0.10693526,-0.9402748,-0.28462607,0.3234007,0.7266851,-0.61208904,1.2188,-1.3042747,-0.007541274,-0.34901318,-2.0270436,-0.8144289,0.0018622222,-0.424844,-0.040298156,0.5788004,0.15025802,-1.7586378,0.5850138}},
      {{0.8177631,-0.33387136,0.20502,-0.07313905,0.7670095,0.58299774,0.72943664,-1.2183553,-0.7305005,0.4904314,-0.4216503,0.37315816,-0.7577868,-1.2519953,-1.2165948,-1.6420461,0.6931867,0.19875194,-1.2191231,0.22491573}},
      {{0.52419245,-0.8766574,2.097178,0.16295698,0.67442393,0.69484484,1.5303273,-4.2930474,-0.2883754,0.406715,-0.77563477,0.67935604,-0.97651196,-1.5342623,-2.466289,-5.4077635,0.584929,0.23997697,-1.1767495,-3.7628384}},
      {{-0.23092145,-0.8031454,3.1513767,-0.9796745,-0.20185772,0.78531367,0.1067454,-1.9054585,-0.9549887,-0.0014866946,-0.94492495,0.8123033,-0.84054196,-0.8871568,-2.3279145,-4.876115,0.538146,0.24567989,-1.156611,-5.889552}},
      {{-0.35265648,-2.0994937,0.056469295,-3.344081,-0.80279,0.55648816,-4.9030056,-5.616618,-0.4585869,-1.7007468,-1.2581273,1.5240915,1.2381953,1.4227215,0.58653134,-1.7913363,0.24730933,0.5452971,-0.18852426,-7.281416}},
      {{-0.7864842,-1.5244298,-1.2951105,-2.336804,-1.1482898,-0.095958546,-3.072341,-4.5259857,0.12846611,-1.6920817,-1.155145,-0.8340439,1.1607578,2.0033612,0.46446002,0.7944923,0.23550904,0.47258833,-0.028683005,-3.192165}},
      {{-0.4778732,-0.13626193,-1.2062687,-0.6965102,-0.15814759,-0.7776251,-1.6494415,-1.1445396,-0.35821494,-1.9679639,-0.6952973,-0.7532007,0.5930015,1.4072437,-0.39691734,0.75403327,0.20660807,0.61669433,-0.24027725,0.23122546}},
      {{-0.22784889,0.22950922,-0.2529655,-1.2955661,1.0382105,-1.0008798,-0.19078383,1.1188693,-0.42115396,-1.3036696,-0.15094112,-0.8208371,-0.5271821,0.4920554,-1.4028282,0.03983057,0.021302609,0.68971545,-0.29201964,0.6815755}},
      {{-0.65037465,0.1548421,0.57645035,-1.1371797,0.86895627,-0.66631055,1.2125032,-0.96841574,0.23157394,-0.45785284,-0.06601467,-0.48530346,-0.99338937,0.0469951,-2.9170763,-1.4361391,0.12175695,0.6893148,-0.09161344,0.26187545}},
      {{-0.77771276,-0.23073563,1.9637852,-0.9873199,0.39373,-0.41680896,1.845956,-4.1209307,1.3251704,0.067906685,-0.32026386,0.7206299,-2.3220575,-0.7116963,-3.69668,-4.483258,0.33702034,0.6597127,-0.25020635,-3.5817986}},
      {{-0.9614923,-0.17550501,3.53512,-2.5742888,-0.29373223,0.29316756,1.0378301,-4.3791323,0.5727138,0.17870927,0.3690363,1.8496107,-2.9823987,-0.59112245,-4.525158,-5.851133,0.34459364,0.53866136,0.047755595,-7.6229053}},
      {{-1.2430536,-4.0890727,0.22514321,-1.0181198,-0.70611936,-0.64393544,-4.625364,-3.4249947,1.5529841,-2.3441274,-2.7113936,1.0936053,1.9746695,1.622164,0.1966263,-2.070846,-0.7012077,0.6471998,-0.4225021,-5.269164}},
      {{-1.112755,-3.3521125,-1.207867,-0.6080027,-0.2635705,-1.9938236,-3.0107656,-3.1026373,1.6282591,-2.8527486,-1.8583913,-0.85758895,1.9422414,1.9452487,-0.09336137,0.45327818,-1.356989,0.59735733,-0.5972391,-2.650647}},
      {{-1.1176507,-1.1214428,-1.176614,-1.2550093,0.752858,-3.4453914,-1.148339,-2.1821272,1.1549461,-3.143828,-1.2401462,0.009418828,1.2728548,1.3923342,-1.4174237,0.6599773,-3.1855078,0.7605677,-0.11607645,0.42131922}},
      {{-0.16663626,0.20835103,-0.89796984,-1.9178624,1.2711746,-3.412198,0.13684233,1.1000077,0.9506473,-2.7822573,-0.41651624,-0.15462987,-0.27305543,0.40934804,-2.2608294,0.21468046,-4.917577,0.62469923,0.43130198,0.6989058}},
      {{-0.81748444,0.32159066,0.070320584,-2.3486528,0.7301634,-3.773644,1.336627,-1.9582659,1.5771464,-1.6265662,-0.23521312,0.7898207,-1.789905,0.399945,-3.8821692,-0.8343138,-2.7854714,0.75726026,0.3544972,0.35360348}},
      {{-1.167703,0.27623582,1.3917956,-2.4267128,-0.5330915,-2.5163476,1.7612665,-1.5449642,2.1380239,-0.467719,0.23601553,0.3120675,-2.817511,0.24643457,-4.5426674,-3.0405316,-1.2925341,0.6445094,-0.004546424,-2.6339705}},
      {{-1.486615,0.20243648,2.6448503,-3.0223773,-1.2875032,-1.0061347,0.7506782,-2.0524144,2.1338282,-0.24022643,0.99044204,1.8967882,-4.1052585,0.45797318,-4.791186,-5.4564195,-0.27857116,0.5902024,0.3159026,-6.525028}},
      {{-2.0672753,-5.202173,-0.3901068,-0.60020167,-0.11698152,-2.240296,-3.318845,-1.3973423,1.2577276,-3.5854425,-2.3491452,0.87591857,2.0723765,1.5270153,-0.21286863,-1.7203791,-1.9526399,-0.35268983,-2.0661206,-4.0591245}},
      {{-1.9155627,-6.1236753,-2.2862632,0.046869777,0.18098189,-3.7805219,-1.8096279,-3.0799103,2.1716635,-3.865416,-1.8469915,-0.30601987,2.4412248,2.0968108,-0.37381554,0.40820456,-5.1216435,-0.5503051,-2.264332,-1.3813362}},
      {{-1.6444955,-3.0563533,-2.1748807,-1.5069617,1.1195599,-4.925861,-0.6158871,-0.8552594,1.8310404,-3.7679248,-1.5016278,0.26289326,1.6749625,0.89513826,-1.158028,0.5419902,-8.604765,-0.33366328,-2.5359657,0.6649476}},
      {{-0.6342847,-0.13588555,-1.0069835,-1.523727,0.8600457,-2.4676604,-0.18137498,1.183678,0.853588,-2.5610793,-0.62918,0.7465493,-0.92871016,0.14285375,-1.5668454,0.27806914,-10.11193,-0.9811178,-0.86729026,0.6409905}},
      {{-0.8490292,0.3856568,-0.79744536,-2.3380342,-0.76949257,-5.554136,1.2856319,-0.71475786,1.9048779,-1.8240552,-0.10551486,1.8498098,-3.1215155,0.6738776,-3.251503,-0.16824974,-9.969151,-0.8072854,-1.3781303,0.5476442}},
      {{-1.7100494,0.41046154,0.43299386,-2.4442775,-2.5802772,-3.3919637,1.7099838,-2.3715906,2.617292,-1.0621325,0.50827944,1.3747741,-3.7008836,-0.14911963,-4.5616546,-0.37589753,-3.8536646,-1.3216095,-1.7039734,-1.140391}},
      {{-1.9755075,0.22951302,1.6078569,-2.1728926,-2.901307,-2.1776643,0.44596013,-0.38213548,2.083692,-0.7281417,1.0424219,2.251483,-4.575052,0.57287717,-4.680173,-3.6168606,-2.1805997,-0.7621243,-1.9205668,-4.0993066}}
    }};

    b1 = {
      0.07319873, -0.20031491, -0.004790352, -0.020491587, -0.03352872, -0.65990305, -0.11987655, -0.073981516, -0.20762354, -0.4132745, -0.23313262, -0.19546632, -0.14736226, 0.031754814, -0.294366, -0.15925473, 0.33371288, 0.0026858475, 0.40137824, 0.049070824, 0.31495643, 0.03207288
    };

    b2 = {
      0.43676847, 0.043547515, -0.074307166, 0.00023891385, -0.009579195, -0.11595506, 0.04197894, -0.19012171, -0.0061142454, 0.10519897, -0.055357255, 0.5855401, -0.0011687742, -0.032717813, -0.00823498, 0.062378984, 0.055830237, -0.008531158, -0.23256278, 0.005484897
    };

    bout = {
      -2.9870582, -2.3119547, -1.9210625, -0.99593765, -1.4624437, -1.7795087, -2.5713668, -2.845775, -0.44485402, -0.42981678, 0.6918684, -0.2308339, -0.5022115, -2.4500127, -2.638215, -0.769771, 0.8073428, 1.3326411, 0.9398483, -0.61835414, -1.8889372, -1.7530228, 0.3690265, 1.0462825, 3.2416968, 1.032465, 0.10379861, -1.1714137, -2.2122037, -0.3781356, 0.8734101, 1.3227068, 0.7830178, -0.87594616, -2.3846204, -2.3127909, -0.5274007, -0.75176924, 0.28096822, -0.9339821, -0.8889557, -2.8682797, -2.5524082, -1.852707, -1.7154696, -1.1424373, -2.1528172, -2.2416747, -3.0902367
    };

    BN_gamma_in = {
      0.88892555, 0.1943633, 0.5888427, 0.8945928, 0.9471859, 0.24438542, 0.3986997, 0.8995282, 0.27419937
    };

    BN_gamma_1 = {
      3.8042057, 7.882902, 8.483495, 7.5864606, 4.184419, 29.596327, 10.725661, 3.9494252, 5.886112, 22.76438, 11.239269, 9.826693, 4.6393247, 4.886238, 3.9207451, -1.8525798, 2.488183, 5.8625474, 1.8649724, 4.713248, 2.7539713, 2.980408
    };

    BN_gamma_2 = {
      1.4233361, 1.9910127, 4.323991, 1.6547074, 2.750698, 1.6519068, 1.5228505, 2.6477308, 2.8095348, 1.4169037, 2.97183, 1.7880703, 2.2604039, 2.9004543, 2.4753313, 1.3474885, 0.7244029, 1.0996294, 2.2110915, 0.74094975
    };

    BN_beta_1 = {
      -0.037575085, -0.04926505, -0.011404137, -0.022446731, -0.10042657, -0.0018300808, -0.014159438, -0.06613139, -0.07619548, -0.004026887, -0.0054530334, -0.017184239, -0.060125776, -0.010784406, -0.0025621539, 0.21367863, -0.16451122, -0.013791994, -0.3675548, -0.011890049, -0.3845421, -0.11870573
    };

    BN_beta_2 = {
      -0.6025847, -0.12267424, -0.24315499, -0.14002095, -0.10109505, -0.059697248, -0.18138345, -0.04476527, -0.2481347, -0.18995917, -0.2030869, -0.89279914, -0.211857, -0.10795695, -0.17093669, -0.14614123, -0.07215314, -0.08007496, -0.07467785, -0.09638905
    };
    
    mean = {
      91828.1382794219,60064.72142260708,90913.46118018722,62702.406380507295,18218.69972661811,63914.468002958456,90067.63227849842,60305.95601229378,92705.90091554137
    };

    stdev = {
      633352.4849876252,526958.9776215982,628632.4605299984,529621.8678264711,437113.6842881952,530647.6781594356,628939.1984349521,527752.956509009,634525.8883418391
    };
  }

  else if(m_pcEncCfg->getQP() == 32){
    
    embs0 = {{
      {{0.010544926,0.32418105,-0.054017544,-0.01357609}},
      {{0.0059918663,-0.012747943,0.0016099362,0.00069630716}},
      {{-0.0055781356,0.004107,-0.0027217327,-0.0004950705}},
      {{0.062178552,-0.003372373,-0.014757037,-0.10967231}},
      {{-0.00015695664,0.026187446,0.01328009,0.00028739902}},
      {{0.06546475,0.0036986456,-0.014078438,-0.1503436}},
      {{0.03352909,0.07189542,-0.009277624,0.025731418}},
      {{0.20335418,0.13860096,-0.07373799,-0.05592698}}
    }};

    embs1 = {{
      {{0.1821566,0.36134854,-0.05732885,0.25514057}},
      {{0.0103732115,0.00081630284,-0.0029329828,-0.01029888}},
      {{-0.0066281552,-0.0013268343,0.0020408675,0.003035347}},
      {{-0.0170021,-0.02308644,-0.16405569,-0.010237381}},
      {{-0.0015038498,0.006553697,0.003398106,0.03145231}},
      {{-0.011865768,0.062314257,-0.17273872,-0.008790586}},
      {{0.022023909,-0.0043568457,-0.0024962209,0.09087925}},
      {{0.07579615,-0.06874565,0.004317907,0.17758305}}
    }};

    in_h1 = {{
      {{0.194529,-0.44395933,0.14118434,0.24812958,0.48702952,0.17502266,-0.48631063,-0.3295757,0.38055864,-2.2354057,4.010767,0.7511519,-0.24367835,0.43256322,0.38810238,-2.354644,0.41873977}},
      {{-0.016563559,-0.24607131,0.06881783,0.00057208375,0.034908775,0.068272755,0.08755866,-0.19677776,4.491796,-0.4955355,-2.9826753,0.8019549,-1.3032181,0.48123845,-0.6697076,-1.3595556,6.176601}},
      {{-0.022638138,-0.1155018,-0.009675225,0.012654417,0.02886183,-0.034925,0.061815582,-0.11608713,-2.0839689,0.070910074,2.9727561,-0.7956399,-0.17385547,-0.39590973,2.1329231,1.4348602,-3.4803278}},
      {{-0.31376177,-0.49946657,0.14701962,-0.068793304,-0.098617665,-0.05149782,-0.02653077,-0.59261626,-0.4006515,0.26217216,0.062016416,0.34179363,5.3669558,-0.4105365,0.10184255,-0.081056856,0.0035147108}},
      {{-0.012437419,0.048759677,0.014388821,0.02790312,-0.017204588,0.0024317065,0.0003382031,0.0455156,0.11683971,-0.030697241,0.09660166,0.06113649,-6.6447535,0.06497378,0.03045827,-0.04170798,0.056668896}},
      {{-0.0012283755,-0.0030967197,0.00014301826,-0.0015110744,-0.0008524618,0.002244161,-0.00050721323,-0.0032048232,4.3214116,0.6645987,-0.49987358,0.96765256,-7.115939,0.8738991,1.140016,2.246098,1.8874749}},
      {{0.007106285,0.011184829,0.020073364,0.009349842,-0.011104126,0.02402469,0.027062628,0.027495142,-1.1896405,-0.20872799,0.06379168,0.36295795,2.1883843,0.59136456,0.27608943,-5.195732,-3.6279004}},
      {{-0.04468772,0.27520338,0.05628103,0.05564807,-0.17010076,0.093607716,-0.10930459,0.2414471,0.35973227,0.2837755,-0.15063176,0.076482095,-8.013078,0.19027832,0.29506415,-0.52226955,0.025889637}},
      {{0.018042587,-0.014139239,0.012900233,0.014465761,0.026710546,-0.012735679,-0.011204394,-0.0018487899,1.0701678,0.45647147,-0.5454036,0.9325302,1.168298,-0.21199226,-2.535596,-3.493762,4.430775}},
      {{0.3585157,-0.3661543,0.24947502,0.14466515,0.80479616,0.3105534,0.77466464,-0.3598533,2.3150728,-0.7311112,0.05518434,1.1708729,1.4066141,1.3725685,0.26006705,-1.6731759,0.2372455}},
      {{-0.009545688,0.19528666,0.059799988,-0.03420409,-0.063926965,0.054725923,-0.09184841,0.16774543,-0.89267266,-2.3972461,2.9033012,0.82718396,-1.9130467,0.20558582,-0.67859524,4.9350715,-1.914427}},
      {{-0.028840145,0.11003756,-0.01552879,-0.0069679134,-0.049420673,0.013914154,0.03342866,0.08799405,0.48711583,0.41834182,-0.6681328,-2.5928166,3.7207463,-0.39106447,-1.0959642,1.7503008,1.06276}},
      {{0.51389277,1.3264012,0.36394104,0.09772931,0.042169675,0.017792644,-0.48589998,1.296556,-0.03182263,0.031720825,0.5090339,0.46993583,4.9174013,-0.14998129,0.49057522,0.83196294,0.93737864}},
      {{-0.0008652635,0.018248176,0.01987166,-0.0036836057,-0.010982116,0.020992937,-0.013648826,0.011231455,-0.31218645,0.28319004,-0.42101786,2.5066018,1.0154077,-3.1432989,0.034074694,0.12292501,-0.2922746}},
      {{-0.07633746,0.14078173,-0.032903038,-0.039771866,-0.16045834,0.013875716,-0.24802673,0.09933268,0.5559678,-0.6824585,1.1999745,1.0324074,-0.36277434,0.4428609,1.0716505,-6.1629896,-0.34582552}},
      {{0.4483878,-0.57462376,0.0070533943,0.34279528,0.5581162,0.15975961,-0.113467164,-0.4706961,-1.9892844,2.431248,-2.8217242,1.2934726,-4.0982857,1.1449466,-0.8987246,3.1517065,-1.3874229}},
      {{-0.01948792,0.032068737,0.011065782,-0.011716247,-0.020679053,0.005844518,0.014819385,0.00484479,3.046456,-1.6974682,-3.3021846,-0.37860924,1.5798581,0.5892553,0.11987446,0.45945936,0.9600822}},
      {{-0.0008308681,-0.0039468603,-0.005030169,0.00338726,-0.020001976,-0.016195325,-0.07108545,0.006318681,-3.7255487,-1.6297063,-0.48024285,0.45980957,-0.36874256,0.16631679,0.42549238,5.111385,0.43704173}},
      {{-0.01692854,0.044523735,-0.018993251,0.0036042393,-0.14251412,0.006172738,-0.290922,0.10356873,-0.32359302,0.6535371,-0.593696,3.64762,-0.8929642,-2.434466,-0.50500226,-0.051067777,2.0454407}},
      {{-0.07052842,-0.07563496,0.0016207099,-0.0051400242,-0.23770212,0.11176227,-0.49616808,0.015748251,2.2070198,0.30128518,-0.46214324,-2.0254002,0.7999839,1.2374176,-0.3727137,0.62198883,-0.5686395}},
      {{0.003377252,0.045773946,0.021453764,-0.009933644,-0.0053228,0.0028135085,-0.010473957,0.02901124,0.25211367,3.39779,0.04206702,-0.05833142,-2.3969862,0.12445765,0.04163618,-4.17573,-0.82956946}},
      {{0.10387459,-0.15798865,-0.021717386,0.10581671,0.15945947,0.038209002,-0.036127944,-0.052975826,6.271982,-0.92230976,2.42837,-1.7915677,0.6596289,-0.6009844,1.3781526,-0.45105085,-2.8585818}}
    }};

    h1_h2 = {{
      {{-0.3406377,0.064547695,0.38271374,0.29420194,0.3237212,0.8188653,0.20385207,-0.5561016,-0.11238258,-0.35920152,-0.6829031,0.21465677,-0.4490183,-0.14476708,-0.49679166,-0.33439943,-0.3475628,-0.15404305,0.31848514,-0.12446071,-0.62965417,-0.03689105}},
      {{-0.23817596,-1.068955,-1.1013027,0.5875591,0.30556536,20.886757,0.150949,-0.29076752,-0.17634706,-0.086900674,0.18222176,0.020965997,-0.13477229,0.9236276,-0.20860781,0.028320964,0.5153952,-0.09801192,0.19052893,0.17995238,-0.118057124,-0.07501097}},
      {{0.27412793,0.11594515,1.9675996,-2.477502,3.4468596,0.6035114,-0.8838087,1.0053769,-1.0260023,-8.579349,-0.6676723,-1.189099,-0.062260564,-0.80239004,-1.0731642,0.5142693,-0.11684836,0.0009279025,-0.31644836,-0.7101848,0.50283295,-0.30224895}},
      {{-0.05403604,-2.2386155,-3.1873186,-0.28513294,-0.76191556,-1.8054912,-1.8683556,1.5009259,-0.4684041,-0.09651406,-0.8739274,-0.09568878,-0.32205415,-0.24923876,-1.5714308,-1.4465907,0.5220749,-1.2204539,-0.7736565,0.4808414,-0.20793857,-1.8059978}},
      {{-0.45353022,-0.47170648,1.5054615,-1.4033982,-0.34696415,-1.8918811,-1.1933022,2.16807,0.7070739,-0.423933,0.38592955,0.31867325,0.5002208,0.14556487,-2.6940167,-1.9509788,-1.9766034,-3.2674541,-0.41780624,0.847946,-0.80003095,-1.8192141}},
      {{-1.1634669,-0.89995795,-0.6182944,-0.67456067,11.073114,-0.79717845,0.1923719,5.608754,0.15868744,0.45574084,1.1092744,-9.512792,-0.2454653,-0.78088,0.5642616,-1.0550385,-0.2624872,-0.24735308,-0.13428214,-0.91701937,0.36714515,-0.8692725}},
      {{-0.69710386,-0.35680225,0.22325107,-0.92459774,9.662852,0.010833558,-0.8265165,0.8706545,0.03938525,0.13419487,-0.50522935,0.5295034,-1.641097,0.028204951,-0.2006442,-0.056528874,-0.11310583,0.22015782,-0.26697487,-0.19217965,-0.06903034,-0.29578048}},
      {{-0.940156,-0.58892196,-0.051997386,-0.3020029,-6.3688846,-0.40837812,0.18144119,0.43431222,0.3817597,-0.24779657,2.1808019,-1.0579283,-0.24836554,-1.365546,0.21810234,-1.4201792,-0.8846914,-0.6629103,-2.7792623,-1.5116564,0.43925744,-0.6415145}},
      {{-0.21304205,0.11414138,0.668397,-0.69270456,-2.4175713,-0.9227871,-4.749908,0.7558259,2.5464406,-0.27032825,1.3861969,-0.7691757,0.26316682,0.12645943,-1.9529972,-1.4512755,0.303381,-1.0518479,-0.2959529,0.5716291,-1.6637416,-1.7220516}},
      {{0.24564941,1.5789884,-5.0129323,2.1522741,-2.6928403,13.266014,5.7670293,-0.7408017,-3.500189,-8.512102,-2.129048,2.0301728,-0.61542165,4.844662,-0.16030101,-1.2086668,0.5687295,3.4361718,2.2449877,-3.1970623,-2.025044,0.26705375}},
      {{-2.0412889,-0.2642946,-0.14379343,0.6069427,8.699491,1.0280488,0.60129565,2.78058,-0.90342736,0.046768386,5.130697,4.005143,-0.26937073,0.008926862,-2.2346363,0.2346254,1.279218,-4.492163,0.57536215,-0.00014420818,-1.2604362,1.6209898}},
      {{-0.4990193,-0.7330153,-0.973682,-10.176304,-0.1843778,-1.2405972,-3.3806415,6.1220775,1.0085399,-0.6042025,0.66590154,-0.13118957,-1.8725599,1.1020998,-1.0134807,-1.7836219,-1.4462442,0.4665921,-0.4680806,0.3429301,1.2378452,-1.7150816}},
      {{-0.6854613,-0.736237,1.8405443,-0.6314675,1.8359957,-0.28601158,-0.8154368,2.9532714,8.607073,0.071804225,1.572245,-2.6444588,-0.06386045,0.13902615,-0.12932423,-0.39826226,-5.8184533,-1.0577273,-0.11664912,-0.23418185,0.5239467,-1.8022218}},
      {{-1.0632387,-0.2929117,0.47862685,-0.22694497,-5.9335713,-0.8570152,0.7474237,-1.854158,-0.61951923,0.25126785,1.5328095,0.2565842,-0.16868024,-1.2326187,-0.043230146,-1.4015234,-1.9421641,-0.5129812,1.0320368,1.2308594,1.018072,-2.3208208}},
      {{-0.719778,-0.15887114,0.20977922,0.26907453,-2.660035,-0.020132208,-0.33670646,1.4819133,0.62177855,-0.12057312,2.8659377,-3.2279992,-0.1139249,-0.17831138,0.76061285,-1.1582367,1.8664986,-0.40827057,-0.17131355,-0.38366562,-12.302706,-1.2537317}},
      {{-0.5395805,-0.9203766,-0.82570255,0.05666592,-2.200953,0.0056948876,0.4741706,1.1612064,-1.4522799,-0.38407063,-1.2206804,-3.2631247,0.025347074,-0.09957076,3.1490185,-0.9397646,-0.8747465,-6.328976,0.12750351,0.3305285,0.77201617,-0.88776684}},
      {{-0.43483067,0.16975616,0.5344408,-1.098117,-6.908342,-0.26365778,-0.49314043,0.98101616,1.3615265,-0.03298024,-0.07961801,0.33866686,0.120668255,-8.442268,0.28180945,-0.7466373,0.045877807,-0.31202152,1.6790364,1.6131923,0.3392343,-1.238469}},
      {{-0.55939806,-1.7966897,-2.8294618,0.17855427,-0.77004445,-1.4812025,-0.07320645,1.3574754,-0.050382964,-0.38406312,1.092627,-3.3258994,0.2551672,-5.2378736,-0.3917529,-1.0796337,1.3099645,-0.9470073,1.2471191,0.5633561,-0.2020835,-0.46204352}},
      {{-0.6328888,0.008212672,0.34946072,-0.14209655,-12.569103,0.018750722,-0.6701961,-1.0611601,-0.14002758,0.11215602,0.84440494,0.36272153,-0.15145417,1.6262454,-0.8386817,-0.60081995,-0.46974564,-0.8159464,0.6053536,1.9213146,0.016196257,-0.5002923}},
      {{0.032288603,-0.3100435,0.17452358,-0.9341317,-3.8379674,-0.64225584,-3.9269786,0.91929,0.6843521,-0.16959016,-1.8756517,-0.42927006,0.27215546,0.4038726,0.05923058,-2.2621212,-4.107717,-3.4062839,-0.34028825,0.49370003,2.387721,-2.4250076}}
    }};

    h2_out = {{
      {{0.030977985,-5.961079,-2.4089422,-7.362662,-5.3336616,-2.4603453,-5.9636683,-0.8630446,-1.1003906,-2.6854773,-0.5726974,-0.7267918,1.1871284,-0.71003,0.55069953,-1.7261221,0.99969226,-2.7579956,0.83172226,-4.0926538}},
      {{0.03671133,-4.152407,-3.7084038,-6.5992365,-9.641322,-2.2267826,-3.6495388,-0.28963995,-1.2001494,-2.1851609,-0.84834373,-1.3482755,0.8438874,0.59080017,-1.2584075,-1.0364565,1.466495,-1.042927,-0.2249999,-6.71363}},
      {{0.014456272,-4.8021145,-4.777348,-4.8863373,-6.479745,-0.3283308,-4.3534226,-0.33222118,-1.3398534,-2.1084125,-0.6510879,-1.2024411,0.24909051,0.10351689,-2.4451675,-0.7449168,0.6835245,0.15523091,-0.72067004,-6.473035}},
      {{0.005148174,-5.6201296,-6.501752,-1.199838,-0.986673,0.42856097,-0.44612655,-0.18738541,-1.0752043,-2.2814305,0.13680227,-0.7089239,-0.3461367,-0.43948716,-1.606273,-0.34731528,-0.5875332,0.56927705,-0.1418471,-10.005318}},
      {{0.044942055,-4.5640607,-5.3887405,0.34318912,-6.1219263,-0.88746876,-5.8401694,0.18307832,-0.2611853,-2.3735712,-0.5502086,-3.184957,-2.8245885,-1.6536883,-2.8492904,-0.3485992,-0.733757,0.09315033,-0.4392478,-5.5133185}},
      {{0.013525045,-4.1708136,-4.3209615,1.3339664,-7.825249,-3.6253688,-5.28181,0.19009724,0.25095218,-2.4375343,-0.84837717,-3.4498768,-3.7275934,-2.6756866,-1.9774824,0.10843911,-1.6096199,-0.36356702,0.2447735,-4.563042}},
      {{0.05824517,-6.3452196,-4.5777807,0.93059343,-3.1114326,-3.1517236,-7.1412597,-1.442352,-0.015331556,-2.9504764,-0.4497012,-1.8546798,-3.9948583,-3.9365494,-0.31770846,-0.5761799,-1.5240821,-0.66635084,1.3237394,-2.8574946}},
      {{0.039616335,-4.746551,-2.0783713,-6.1053433,-2.3560126,-4.1135774,-5.286647,-1.8931811,0.7672191,-2.2562053,-0.46144724,-2.3752909,1.0981492,-0.27061105,0.86417985,-1.9692024,1.2851774,-4.5704546,0.34581882,-1.9953002}},
      {{0.009304139,2.339137,-2.7047694,-4.8698926,-3.245974,-2.7859561,0.47803712,-1.3790033,0.6152204,-1.4378783,-0.5484069,-3.1656597,0.9610872,0.59610146,-0.34178627,-1.2665193,1.3963675,-1.4716568,-0.16118227,-4.077961}},
      {{0.0040743006,1.1722383,-4.4039407,-3.1521177,-3.1916938,-0.57453436,-0.11138352,-0.5324691,0.67109156,-1.9177958,-0.67229545,-3.4390535,0.2832967,0.5383791,-1.6155794,-1.349255,0.5306087,0.119002275,-0.6920624,-3.6185546}},
      {{0.007412071,1.7037108,-4.3323407,-0.7818997,-2.702519,0.40767777,-0.22398558,0.11385079,0.70308626,-1.6981167,0.12681139,-2.432342,-0.31271112,-0.24102809,-1.8261842,-0.9736592,-0.5403027,0.6921047,-0.7253057,-5.617452}},
      {{0.0146199,1.2648422,-6.4265785,0.50631094,-2.7416146,-0.7766379,-0.7939048,0.5750858,1.2180092,-2.0478573,-0.84946024,-3.9401598,-1.6283598,-1.7741132,-1.5228248,-1.0012841,-1.116548,0.13782816,-0.37226793,-3.223728}},
      {{0.018580033,-1.6712823,-5.546985,1.2963892,-2.5070577,-4.728944,-3.1431289,0.1959831,1.4314613,-1.713872,-0.86662555,-3.0145662,-2.3162646,-3.9890435,-0.7448696,-0.22181316,-1.831846,-0.8755993,0.59047014,-3.1318326}},
      {{0.014901829,-4.769029,-5.779445,1.1836386,-1.4544227,-5.91915,-5.3364954,-1.7917308,1.3475451,-2.5197065,-0.6701217,-1.9895554,-2.9171743,-3.611352,0.3563498,-1.0748373,-1.7173958,-1.6696844,1.1573118,-1.1941609}},
      {{-0.014749426,-5.1271715,-1.8843105,-4.35919,-0.06748247,-7.6984844,-4.693524,-3.6877956,0.5201817,-2.1000314,-0.3395488,-1.2389107,0.6777107,-0.5762628,1.355713,-1.4144653,1.413369,-3.7564566,0.98312026,-1.5559702}},
      {{0.01981678,1.3359827,-2.4957864,-2.8998754,-0.18350418,-4.371501,0.5871901,-2.7157488,0.47168788,-1.6636763,-0.63226676,-2.048532,0.62855816,0.5874038,0.62896806,-1.1721488,1.4572192,-0.43418464,0.42419183,-1.9531534}},
      {{0.019723976,0.63827586,-2.042473,-1.0190487,-0.19182354,-0.27160645,-1.7930878,-0.5757241,0.4397082,-1.4241657,-0.7507604,-1.6797999,0.44722888,0.5013748,-0.11394368,-1.2177404,0.59391695,0.8107934,-0.47386816,-2.5702043}},
      {{0.011459272,0.42263064,-3.523768,-0.072218776,-0.03412086,0.40952927,-1.1136932,0.1919454,0.5546236,-1.6810329,-0.09808705,-0.6404886,0.19945364,-0.12965533,-0.7597391,-0.9024224,-0.5354362,0.74284655,-0.6749572,-2.6041644}},
      {{0.004060332,0.6289113,-4.13722,0.6417375,-0.066380985,-0.7546858,-2.9550185,0.81667906,0.75557256,-1.5689048,-0.9545955,-1.0101175,-0.34676787,-1.12524,-0.49721572,-0.55074567,-1.4019289,-0.23072778,-0.1251087,-1.832142}},
      {{-0.014578907,-2.0791252,-4.6863985,0.82938874,-0.067674525,-5.6958084,-2.7221055,0.6247608,0.9439532,-1.7800162,-1.2640505,-1.6716084,-0.989545,-3.7831776,-0.004534949,-0.46754065,-2.0877023,-1.9798789,1.1173925,-1.0434244}},
      {{0.031909216,-3.8972619,-5.826686,0.7277088,-0.00978169,-5.17458,-5.3516455,-1.1966801,0.9937444,-2.2591898,-0.7746614,-0.6895923,-1.4025352,-3.3223608,0.75818497,-0.81268823,-1.9639915,-4.9435196,1.5907387,-0.5116956}},
      {{0.03892116,-6.3438177,-1.858048,-1.3014326,0.6750471,-2.9674757,-1.5346265,-4.235018,-0.21993446,-2.185353,0.7681648,0.38945782,-0.42370647,-0.24036525,1.0061886,-1.0016023,1.0539842,-2.9363008,0.7731131,-0.8374073}},
      {{0.00875706,2.2781634,-1.7385997,-0.9471631,0.59870774,-5.0671954,1.6630679,-4.6618576,-0.26698807,-1.7139692,0.6576374,-0.38599864,-0.05586757,0.5626495,0.5923356,-0.5939146,1.4809976,0.2127321,0.5805174,-0.7725485}},
      {{-0.010576419,-0.5821721,-1.8212445,-0.094257295,0.6398978,-0.408877,-1.9922223,-1.3392504,-0.39812177,-1.6163095,-0.10478516,0.051684726,0.13860506,0.45317808,0.28785953,-0.5903435,0.8405394,0.6643724,-0.7753317,-0.6220532}},
      {{0.018079814,2.2199621,-1.8519313,0.016734183,0.67481285,0.43946847,1.4762568,0.00865331,-0.48832512,-1.3627717,0.98209363,0.93685937,0.21873608,-0.108182706,0.26314402,-0.5052906,-0.5773784,0.48343712,-2.1503284,-0.6114615}},
      {{0.019029103,-0.8499456,-1.8767159,0.3997426,0.6001197,-0.7859651,-2.9638476,0.88330257,-0.17376862,-1.7378219,-0.4608598,0.12994263,0.24973246,-0.792675,-0.116370186,-0.14703609,-1.5987515,-1.1764624,-0.32032788,-0.21955714}},
      {{0.030910533,-2.486963,-1.785453,0.22445643,0.56820697,-5.655808,-2.4266524,0.8939246,-0.165511,-1.5218287,-0.61814815,-0.2574794,0.118027665,-3.7365549,-0.167306,-0.17014804,-2.2457416,-4.2941356,1.194171,0.04199298}},
      {{-0.026647361,-3.793521,-1.8412906,-0.5426539,0.6522713,-3.5583763,-2.0639887,-0.64416975,-0.06188394,-2.242578,0.27675933,0.28522083,-0.25508696,-2.2877872,0.13685177,-0.2965643,-1.6678487,-7.802881,1.2429476,-0.3284973}},
      {{-0.009260245,-5.492302,-4.1962743,0.03097679,0.11235079,-4.1557107,-3.1428928,-4.573323,-1.0100368,-2.3543918,0.39573783,-0.6751179,-1.6475649,-0.17907453,2.1154933,-1.9744664,1.2215297,-1.9360434,1.4318805,0.20438345}},
      {{0.018334104,2.0415273,-3.9673142,0.0012666684,-0.29429203,-6.201598,1.1443725,-3.6754298,-1.1929746,-1.7302241,0.022132743,-1.5489277,-1.14485,0.6317965,1.1983674,-0.4763977,1.0052652,0.8040568,0.71643144,0.4196414}},
      {{0.011086576,1.0601543,-3.108125,0.25837973,-0.06993632,-0.49035713,-2.9345357,-1.2548302,-1.5733005,-1.5212615,-0.78542256,-0.68368363,-0.45978126,0.58833516,0.40099367,0.02281867,0.5696725,0.5770725,-0.83370775,0.55624133}},
      {{0.00068628346,0.22921468,-3.1183548,0.019298024,-0.01141233,0.42819992,-1.0196757,0.008169596,-2.0112224,-1.8345467,-0.23444013,-0.46780837,0.13179626,0.14406855,0.52916706,0.23905347,-0.30787253,0.04826296,-1.1767576,0.632094}},
      {{0.025600256,0.8492736,-2.1147666,-0.13506168,-0.15866427,-0.6455553,-2.3956118,0.96035945,-1.7089576,-1.6664002,-1.1982183,-1.6692398,0.5249271,-0.5709431,0.25747445,0.22582337,-0.7981597,-1.9108881,-0.25121215,0.6659633}},
      {{0.027321838,-1.6666893,-2.5101125,-1.1063274,-0.2260073,-4.6156235,-2.8794684,1.1151376,-1.3676054,-1.6626629,-1.519329,-2.1688402,0.8676974,-2.7416463,0.41765672,-0.038312748,-1.6288346,-4.5661397,1.0988421,0.71499044}},
      {{0.055000633,-4.4860673,-2.0467942,-3.6425807,-0.012453865,-5.973493,-6.286934,-0.43254593,-0.5976613,-2.1902122,-0.8138221,-1.2610195,0.93441635,-3.4679823,0.7171889,-0.58989984,-1.5061425,-8.51213,1.6158824,0.85675824}},
      {{0.0007893652,-5.4055986,-5.603472,0.85626537,-2.0506256,-6.4074206,-3.5243351,-3.5147235,-1.1846752,-2.4782455,0.53211945,-2.0298326,-3.2112112,0.35608906,2.1722958,-1.0327257,-0.20624484,-0.41343582,1.1696594,0.67652464}},
      {{0.016607359,-1.755467,-5.3156815,0.7005378,-2.6872382,-4.810926,-1.7987406,-3.460384,-2.0955772,-1.685597,0.044125028,-2.640535,-2.2521968,0.73917097,0.5781175,0.7041323,0.06720363,0.486144,0.48685205,0.58506316}},
      {{0.033712503,-2.6023004,-4.438473,0.057536278,-3.2408328,-0.80254495,-2.5659761,-1.1144556,-2.2945511,-1.8239923,-0.848061,-3.5360224,-1.6149472,0.6449306,0.88505054,1.1319628,0.29642615,0.22402574,-0.7948272,0.66918707}},
      {{0.008399792,-2.7255292,-4.703087,-0.5966691,-4.0482397,0.4351529,-0.774484,-0.13089435,-3.3308675,-1.4956243,-0.51444805,-2.513712,-0.14637549,-0.0077392585,0.6989296,1.2608868,-0.30607346,-0.22663115,-1.0812701,0.7556875}},
      {{0.044285588,-2.6431065,-3.7999713,-1.7117745,-2.473005,-0.7554874,-3.7944067,0.8708459,-3.0872622,-1.790095,-1.2692964,-4.942803,0.50166273,-0.40166858,0.84384614,1.2565066,-0.7049919,-2.1719065,-0.59836835,0.8371818}},
      {{0.012227295,-1.7665095,-2.7124581,-3.3216417,-1.8398135,-3.0129998,-2.9603994,1.1281158,-3.056515,-1.5759099,-1.2702916,-4.165337,1.2439579,-1.7421002,0.49436575,0.6682051,-0.94720066,-4.9312387,0.55223024,0.74876076}},
      {{-0.021351164,-4.5311956,-2.379314,-5.7768745,-1.5459813,-3.2705603,-5.496931,-0.02055391,-1.1803468,-2.3246055,-0.90013635,-3.046526,1.2916174,-2.2337224,1.3847294,-0.2728287,-0.7490512,-8.35686,1.0859252,0.82466465}},
      {{-0.04282825,-6.8335037,-3.9270284,0.7313905,-4.0174065,-3.8561308,-6.500565,-2.3437567,-1.8499539,-2.8641512,0.11010754,-1.6736056,-4.4037347,-0.23368357,1.5544791,-0.12534977,-0.1739095,-0.3372083,0.8357152,-1.3504393}},
      {{0.03917394,-4.2650013,-2.4893777,0.6378617,-7.5966578,-4.089638,-4.3666983,-1.8333223,-2.6888087,-2.4281604,-0.26206875,-2.613684,-4.2138867,0.7278805,-0.06592078,1.528434,0.13225482,0.43667,0.03449306,-1.4961754}},
      {{0.033449598,-4.795223,-2.7816384,-0.35478896,-7.8705244,-0.5973432,-5.9003773,-0.7379891,-3.1519856,-2.1555412,-0.6858072,-2.2611036,-2.9060147,0.33737314,0.36116847,2.0125675,0.13083863,0.36516044,-0.748003,-1.4368566}},
      {{0.016103387,-5.507445,-5.7036414,-1.1826941,-3.6418512,0.4298769,-0.40811032,-0.02629964,-5.0277276,-2.1616738,-0.23689286,-1.4285028,-0.3721985,-0.16736862,0.19880791,0.944372,-0.6403679,0.38697982,-0.19327222,-1.3406373}},
      {{-0.009657043,-4.9108763,-5.7483196,-3.7105396,-4.569297,-0.6066927,-5.3459907,0.6417396,-3.5819278,-2.156445,-1.2897168,-3.6348784,0.39033225,-0.5006541,0.20985247,1.8821769,-0.3878272,-1.8150983,-0.522808,-1.7308176}},
      {{0.031486377,-4.155102,-4.111661,-5.3377295,-3.5304532,-2.394995,-5.1483727,1.1370293,-4.20868,-2.2891145,-1.4211107,-3.1982954,1.051538,-0.7836346,0.20307069,1.3779522,-0.66157293,-3.3376231,0.3409004,-1.6006303}},
      {{-0.037350398,-5.3119645,-2.5942628,-7.214516,-2.9479876,-2.4429793,-6.8616753,0.09590293,-2.6558187,-2.7670777,-0.8546078,-2.2715337,1.2376467,-1.634901,0.6158084,0.0970656,-0.27604738,-6.0151634,0.9372759,-1.2591068}}
    }};

    b1 = {
      -0.0049955565, 0.10717612, 0.15114632, 0.10126317, -0.10553105, 0.39605942, -0.109165646, -0.025799735, -0.07216266, 0.23460741, 0.057850275, -0.19342746, 0.25126573, -0.061093632, 0.2043045, 0.052504558, -0.063302234, -0.011591376, 0.11921273, 0.011104563, 0.073517516, 0.066035405
    };

    b2 = {
      -0.41103315, -0.20223027, -0.37175557, -0.013068864, -0.20652032, -0.22951521, -0.06365492, 0.021193005, -0.081393346, -0.5340913, 1.8972214, -0.20313433, 0.1977613, 0.008707272, 0.18421975, 0.1432961, 0.0124573205, -0.013009959, 0.09757736, -0.1365599
    };

    bout = {
      -2.438158, -1.881084, -1.1758672, -0.5054431, -1.431543, -2.0051668, -2.4874482, -2.2333572, -0.36673674, -0.41133633, 0.5375187, -0.58888465, -0.95757663, -2.3547454, -1.8331339, -0.55587435, 0.6023997, 0.9480412, 0.5023698, -1.0291535, -1.827768, -0.88421863, 0.32450244, 0.96511483, 2.910525, 0.68699986, -0.22868581, -0.90516293, -2.0007129, -0.6790832, 0.6343906, 0.9355449, 0.37817848, -1.0069504, -2.1195629, -2.5741065, -0.83942294, -0.70036554, 0.25611362, -0.8848292, -0.94383115, -2.4823787, -2.5888357, -1.883544, -1.2985414, -0.6629248, -1.2679373, -1.8575569, -2.462722
    };

    BN_gamma_in = {
      0.22436851, 0.6119331, 0.31924367, 0.7875305, 0.46081686, 0.8254344, 0.5858978, 0.24713367, 0.16195321
    };

    BN_gamma_1 = {
      4.2801304, 3.8742063, 3.333941, 2.7943194, 8.076668, -5.7275276, 6.578163, 2.0909302, -6.6178937, 4.843705, 3.0946987, 6.451957, 2.3460631, 5.127021, 3.2064857, 4.930928, 6.014237, 6.438127, -3.0380588, 3.2222378, 4.531242, 4.72637
    };

    BN_gamma_2 = {
      0.5444534, 9.590407, 3.3743725, 1.3998222, 0.49318665, 0.72520787, 3.3065383, 1.3539441, 1.2718676, 7.6243067, 0.5435205, 1.1727779, 1.5160342, 0.8426641, -1.1726903, 1.494846, 2.019272, 0.9765218, 1.5951302, 0.8723333
    };

    BN_beta_1 = {
      -0.0010760338, -0.004676914, -0.20424844, -0.0087894285, -0.01820674, 0.010627744, -0.070086196, -0.13610502, 0.016813433, -0.039659586, -0.08994487, -0.056893412, -0.047869284, -0.029157525, -0.47002998, -0.007725403, -0.039821785, -0.025608486, 0.10121787, -0.066335045, -0.01819922, -0.015381996
    };

    BN_beta_2 = {
      -0.0006379157, -0.044468317, -0.018976137, -0.16233516, -0.046708833, -0.04897804, -0.041026738, -0.13733093, -0.122636706, -0.41131982, -0.8614173, -0.041784212, -0.26152495, -0.16413134, 0.33587226, -0.3433272, -0.2791657, -0.06189704, -0.31524986, -0.054362312
    };
    
    mean = {
      91525.89776170258,60026.008483516256,90584.58660025275,62728.46208860909,18971.969148367567,63809.69485925258,89757.81417461201,60172.19357001993,92291.03546524212
    };

    stdev = {
      642251.52754976,536440.1965550308,637294.4283578823,539774.5885682282,448249.567058352,540416.0303173843,637593.8898577997,536915.8923481405,642858.7671954081
    };
  }
  
  else if(m_pcEncCfg->getQP() == 37){
    
    embs0 = {{
      {{0.1534634,-0.06853023,-0.33204302,0.13530788}},
      {{-0.017689241,4.126809e-05,-0.004316614,-0.0035948069}},
      {{0.003967548,0.0007605454,0.0050881645,0.00309997}},
      {{-0.008502378,-0.022122828,-0.03594148,-0.05440886}},
      {{0.02536732,-0.0072591417,-0.012759627,0.0014096769}},
      {{-0.014002474,0.034495838,-0.0923408,-0.070347816}},
      {{0.04854123,0.023466162,-0.0013493096,-0.03209936}},
      {{0.121522486,-0.07095332,0.059349183,-0.112310775}}
    }};

    embs1 = {{
      {{-0.10107693,-0.028543472,0.099395186,0.017731845}},
      {{-0.004656397,-0.000969016,-0.001383911,0.017308507}},
      {{0.0051293653,0.0010528784,0.0013771973,-0.0050150426}},
      {{0.02035755,-0.10776665,-0.0031524806,0.03568019}},
      {{-0.006186371,-0.0012843903,-0.007841812,-0.027588865}},
      {{0.025248341,-0.086771026,-0.033787936,0.047956668}},
      {{-0.022598276,-0.030891106,0.02238393,-0.045807242}},
      {{-0.007113242,-0.064540654,0.08554972,-0.09048981}}
    }};

    in_h1 = {{
      {{0.0567354,-0.006428689,0.00057670195,-0.0054904004,-0.017448388,0.05663937,0.13400128,-0.004453628,-0.044184238,-2.1288168,5.378041,-0.17421101,-1.4513229,3.0039015,0.61729455,0.7487755,2.1668901}},
      {{0.24189942,0.092658445,-0.107332766,0.06654899,-0.14234254,-0.05418316,-0.2394898,-0.2702803,1.9702573,-2.5699997,2.7477963,-0.56594926,4.4784617,-0.3068309,2.2914815,-1.1226311,-0.2701477}},
      {{0.011800056,-0.006735384,-0.012010577,0.007565686,0.008598352,-0.008152962,-0.018359363,0.005267193,-0.74045306,-1.3121495,-1.0537858,-1.3277295,-2.4542594,-0.9789674,-1.5097381,-1.4005247,-0.42542467}},
      {{0.21815197,0.025785832,-0.055458453,0.30169296,0.02927199,0.22829708,-0.1560852,-0.26983148,0.23074636,0.40700957,0.029634371,0.024661176,-9.773264,0.47755617,-0.26948377,0.087107785,0.52757716}},
      {{0.4465631,-0.032919187,0.012852641,-0.014584547,0.04489085,-0.13518327,-0.028850388,-0.44643798,-0.8508307,-0.5039718,-1.0992751,-1.5580823,-3.530534,-1.9017115,2.3551123,-1.7033147,-1.1921201}},
      {{0.029023217,-0.008133964,-0.0039184988,-0.016950615,0.038055204,-0.051184323,0.0005298646,-0.00094442925,-0.54892063,-3.4219797,-1.800858,0.10666191,0.20620039,0.79820704,0.36382145,1.9839625,0.7970145}},
      {{0.26978108,0.09535516,0.060293227,0.124749646,-0.02949255,0.32743374,0.18854554,-0.23752542,-2.598827,1.2804245,-0.0042424514,-0.8998796,2.0701551,-2.1065638,1.1352909,0.10477556,-2.4946396}},
      {{0.0109757045,-0.04042029,0.010409167,0.07555424,-0.032508418,0.31033152,0.19284675,0.030986587,3.3098428,0.6180262,0.21883936,1.6974671,-2.906309,-0.85656613,0.24224535,-0.80388236,-0.23412825}},
      {{0.13956383,0.011344369,-0.026796458,0.036147647,-0.045296717,-0.0019752553,-0.052772738,-0.20288847,2.3311114,0.04458839,-1.2944429,-0.545126,-3.0520694,-1.5692482,0.37199467,1.2078958,2.7178268}},
      {{0.08302444,0.03569621,-0.0339131,-0.00086120557,-0.020267207,0.014022382,-0.011152395,-0.06595791,-0.6163702,0.24306436,0.7364457,-2.4437566,3.8883262,3.057095,-0.8677536,0.20407432,-0.03144822}},
      {{-0.3082616,-0.13346699,0.026157783,0.054244522,0.1459068,0.03300675,-0.03695535,0.28025946,-2.084527,2.705042,2.4479773,-0.32308227,-0.5597026,-0.03650812,2.7462955,-0.87342536,0.8912582}},
      {{0.0034120244,-0.0022691758,0.0028138605,-0.010734934,0.0003919008,-0.013612266,0.009985412,0.0020669186,1.0071492,0.9558634,-1.9357864,0.48265183,0.0011389153,-3.3783572,-4.022296,-0.5662267,3.7181227}},
      {{0.17590299,0.010055761,-0.021961333,0.0643267,-0.05365336,0.120867155,0.05767039,-0.20321935,-1.566341,-2.7063634,-1.32521,0.6049211,5.686032,1.8541753,-1.1645777,-1.2727972,-0.08819816}},
      {{0.067257494,0.0023034897,-0.023751082,-0.010556827,-0.0319553,-0.04712473,-0.04919266,-0.09828602,-4.458706,-0.42217875,2.3871555,0.8577052,-2.1982152,-0.70154667,-0.17031264,1.2465935,-0.50126487}},
      {{-0.25311223,-0.088922925,-0.031111768,0.11697734,0.21529897,0.06438991,0.25437725,0.13189477,0.025719156,0.107777104,-0.23781079,-0.4099916,-0.32374606,0.25591192,0.34886467,-0.26392668,-0.08737362}},
      {{0.06644751,-0.008173447,-0.021071525,0.016030185,-0.028363835,0.02278638,0.031052874,-0.07036962,-0.384059,0.7344067,-5.0555243,0.21031508,1.1517404,-5.181081,-1.748868,0.5460304,-0.40766025}},
      {{0.2608632,0.08041059,-0.049913414,-0.035444994,-0.05758563,-0.060026072,0.010079798,-0.21770757,-1.0045887,0.01755877,2.7866247,1.0031483,-1.5010911,-8.503779,0.131638,0.026498064,1.1718764}},
      {{-0.066684894,-0.017819451,0.07868211,-0.04835206,0.023585519,0.016627226,0.07625635,0.06700037,0.03851453,-0.014001937,0.10993939,0.053658597,-8.082174,0.20245525,0.14586791,-0.043289732,0.108356036}},
      {{0.10134861,0.04883007,-0.019989014,-0.03375129,-0.008192757,-0.09485469,-0.033298343,-0.0792573,1.2391448,-0.2920291,1.8872045,-0.38839743,-0.01799175,3.2484143,-5.993614,0.29719839,1.0991074}},
      {{0.040150322,-0.01731417,-0.0040070037,-0.008271042,-0.0163426,0.008112485,0.0032953254,-0.040636573,-0.0036788217,0.12573303,0.1809458,-2.651669,-4.264982,-2.5535948,-0.14979416,0.14385991,-0.23674333}},
      {{0.6637098,0.15070471,-0.10307241,-0.10283866,-0.16143474,-0.21344605,0.050014563,-0.6099566,0.14247869,0.6718116,3.7166061,-0.08479388,-4.3994117,5.084953,1.1506631,-0.28107357,-0.69152755}},
      {{-0.0018943532,0.0076557947,-0.0062596393,-0.029253073,-0.018749502,-0.05332481,-0.014639802,-0.0045530605,1.2829462,-0.37770113,2.1781454,0.61330146,0.7458531,-9.575831,-0.014503236,0.00647683,-1.8130622}}
    }};

    h1_h2 = {{
      {{0.1345991,-0.2843643,-1.6208855,1.1366081,-0.5173231,0.28462034,-1.7430623,0.51337206,-0.13290416,-3.6027365,-1.4379207,0.22460926,0.28373775,-0.82457507,-0.0055604605,-3.393348,1.8502145,1.4541202,-1.2826167,0.1307732,1.8334744,-1.8994665}},
      {{0.7799963,-0.9222544,1.2092673,-0.2428411,-0.38602254,-0.6441626,-0.9809061,-0.8113633,-1.7915919,-1.0243354,-0.99402404,1.929683,-0.07560947,1.0496104,0.005461319,-2.3996687,1.2528632,-1.0886673,0.2838008,-1.8117974,-0.13856937,-0.32256627}},
      {{-0.10756025,-2.0242653,-2.5339031,-1.1692758,0.51159865,0.18488649,-1.7208847,0.09921063,0.16754234,-3.7432635,-0.07727801,0.15904681,-3.4436553,-0.35714874,0.008265697,-1.8198081,1.5286956,-2.3971906,-0.17188121,-12.0549345,0.9663913,-0.29151013}},
      {{0.20522843,-0.511877,-7.821321,-0.7586001,-0.5256673,0.206966,-1.325856,-0.61877424,-0.19545537,-0.03491445,0.3190564,0.25087133,0.02110864,-0.17120667,0.008341026,-2.026326,-1.2164174,-0.6927323,-0.09282482,-7.9680786,1.8475726,-2.2461112}},
      {{-0.3002051,-2.2809591,3.6074429,0.10832369,0.072783835,-0.17705938,-0.8587234,1.0618279,1.5601217,-0.8070113,-3.9852934,-1.2440536,-0.6566002,-2.0209966,-0.0029227505,-1.3838981,-2.6257048,0.010799304,1.4669698,0.36589402,0.6297904,-1.6147618}},
      {{0.64276886,-2.0661414,-0.15744722,1.0323553,-1.7126143,-2.5005572,-0.15003388,-0.9970267,1.8057615,-0.6023443,-1.1746923,-1.006375,-2.1613052,0.06585688,0.0001977719,-0.11351785,2.023182,-0.9773449,-0.36867824,4.8287287,0.3943829,0.251674}},
      {{-0.33322704,-2.263115,0.31616378,0.12832972,0.19682711,-0.69387794,0.33747512,-0.79124695,-0.812231,-0.83557117,0.6795977,-0.56545484,-0.6993212,0.46899617,0.008697336,-3.244947,-0.019641515,1.8844653,-4.2196875,-0.8171387,2.5502882,1.2560353}},
      {{-1.0449314,-0.9893782,-5.155994,0.18919276,0.39296845,0.2819968,-0.84243584,0.5152512,0.7472688,-0.9995878,-2.1308973,-0.3121155,-0.018038224,-1.0917192,0.0043348325,-0.02409246,1.9582142,1.9174757,-0.53216565,-3.6676662,-0.6394038,-1.3996017}},
      {{1.3789215,-1.6426723,-2.6859462,-0.6735227,-0.19993258,-1.1456238,-0.10955213,-1.1142004,0.05938038,-0.047535732,-1.7086396,-1.4385628,-0.28922328,0.25687662,0.00043854152,-1.3881598,1.8040093,-0.27861205,-0.7651022,-6.6719165,-0.3541271,0.058284853}},
      {{-0.2361227,-2.6561694,-5.6916447,7.413404,0.6530119,0.9825636,-1.0451201,-0.23907667,-0.9213229,-0.84234625,0.19538112,-0.89894867,-2.0460706,-0.51303077,-0.00022552424,-1.0681534,0.13092767,3.1281276,0.5240837,-0.46268085,-0.24763657,0.34839576}},
      {{-0.44926548,-0.6019773,-4.983229,1.611696,-0.31117454,0.18082274,-2.802552,-0.6991732,-0.23768061,1.1272796,-1.4047236,-0.03844805,0.1750529,-0.24563365,-0.005628807,-3.8455508,0.90121925,4.0505757,-0.40623015,-2.6189353,2.0412838,0.04732692}},
      {{-3.7196238,-0.56200665,-0.19310918,-0.08144232,-0.012492829,-0.24445654,1.2547596,-1.3914027,-4.0541515,-0.2905875,-0.044774517,-0.25775963,-0.54361343,1.3913188,-0.00033319215,7.1841936,0.06485394,-0.0051461263,0.05740558,0.115089595,0.12759152,-0.40264234}},
      {{-0.31582952,-0.76603127,-1.4739165,-0.6891932,-0.32528514,-4.8008504,-0.19162355,-0.031943243,-1.0677046,-0.3155506,0.12931077,0.3020215,-0.2603417,-2.2025962,-0.0047945245,-0.9937897,0.54108286,-0.8873023,0.16403247,-3.457272,1.1240369,-0.2601511}},
      {{0.025673863,0.01098321,-4.345004,-0.3821133,-0.97488695,0.044283394,-0.50924534,-0.07895175,0.002976737,-0.5611096,0.050858732,0.027394895,0.6412413,-0.093203865,-0.0009031692,-0.086767405,-0.033388328,-1.5015023,0.11884098,-11.895199,-0.031592403,0.20026691}},
      {{-0.2885577,-0.96562517,-2.1948762,-0.47204927,-0.3132196,-0.24623506,-1.3925308,-0.7130011,0.076106764,-2.7474616,-0.9731472,0.1432799,0.20274489,-1.085094,-5.7189212e-05,-0.92847574,4.008976,-1.787284,-3.0869818,0.3140819,0.20081556,-0.6892776}},
      {{0.097561024,-0.56756437,0.17987369,-0.35088092,-0.052081678,-0.35484505,-1.1194814,-1.4820952,0.11727283,-1.4235522,-0.36308154,-0.811188,0.31351343,-1.0976741,-0.004050418,-3.7763839,-0.9723056,0.2738309,-0.6985257,-2.5704799,1.8142775,-7.536729}},
      {{-0.42364874,1.0101587,0.2938647,-0.6097341,-0.05375458,0.33901063,-0.30655074,-4.1183596,-3.9821646,0.5537073,-0.44782263,0.41342455,5.532584,-0.97220147,-4.331942e-05,0.40655327,-0.40960655,-0.21833166,0.2772291,0.4764204,-0.9735009,-0.5029044}},
      {{-0.45997062,-2.993493,-0.42198884,-0.61040604,0.816276,0.0904,0.2362622,-2.032463,0.21564063,0.8174657,0.5237037,-0.08404491,-3.6583252,-1.2702883,0.0049246363,-1.622094,0.052065045,-6.8616214,0.9520761,-0.9424459,0.4050477,0.12875701}},
      {{-0.44664258,-1.7381164,-4.397646,0.60204303,0.250606,-1.5049684,-0.28927803,-0.054840524,-1.4980472,-1.3349515,-0.6326593,-10.76486,-0.7789056,0.22875677,-0.0019619833,-0.7322345,0.53613627,0.64351577,0.7946898,-5.436228,1.3062932,0.27507234}},
      {{-0.27550226,-2.6609716,-1.1765906,0.37210244,0.30347833,-2.031823,-0.041872516,-0.29290804,0.33315185,-0.25387433,0.027110836,0.37056407,-1.03434,-2.0805528,0.0020194699,0.81889117,2.5055025,0.55647266,1.4220364,-3.188525,0.9155351,-1.1691136}}
    }};

    h2_out = {{
      {{-3.79084,-0.27408394,-3.189597,-0.35742465,-5.87903,-2.7332094,0.6294749,-4.209083,0.92204446,-1.9547417,-3.9913604,-4.945286,-1.2245082,0.08347902,-1.4744695,0.35457796,-5.123049,-0.5114998,1.4544,-2.1924891}},
      {{-1.4857115,0.79415506,-2.333123,0.5704064,-3.1558127,-5.278161,0.06366119,-1.7799634,1.0771527,-1.3114797,-4.428288,-3.6988719,-1.0842831,0.16003919,-1.2859408,0.71158427,-3.3808324,-1.1723145,1.2886236,-3.438135}},
      {{0.8326815,0.9148179,-2.418736,0.051567215,-2.2452765,-7.487401,-0.7089777,-1.4143443,1.1297483,-2.3010857,-1.2724978,-2.3938293,-1.5625747,0.4513198,-0.9288244,0.46817747,-3.9992595,-1.1717336,0.60560924,-3.1268559}},
      {{0.86779916,-0.054485396,-1.8448498,-0.030460907,0.25742218,-5.84859,-0.976733,-0.3301048,0.40222842,-2.220868,0.88878024,-0.71296877,-0.9206697,-1.0555454,0.1570899,-0.46352556,-8.991869,-2.0289078,-0.8757961,-2.0663857}},
      {{1.0170318,0.23084803,-1.0475802,-0.8337315,0.62957865,-9.389729,-2.5653539,1.3580736,-0.5156135,-2.4814928,-0.75670445,-2.775996,-1.181898,0.8639646,0.61881834,-0.6748372,-4.973547,-0.41882768,-2.4921923,-1.9038095}},
      {{-0.46965784,0.4586696,-0.723227,-0.67951113,0.34876317,-6.7122273,-2.938054,2.4066534,-1.1332097,-2.146081,-3.3227286,-3.830296,-0.7711353,1.4338446,0.9129004,-1.2336209,-3.7626405,-0.47352296,-3.2675037,-0.9687111}},
      {{-2.1041074,0.27219662,-2.0400171,-0.92408097,0.21625148,-3.274894,-4.9285955,1.9903901,-0.8768423,-1.5964358,-2.7919612,-6.1255054,-0.53884625,1.3149983,0.3901789,-2.573391,-5.3499866,-0.35784352,-3.9592533,-0.024589015}},
      {{-5.340954,-1.9227296,-2.0424345,-0.102374665,-5.0090656,-1.6019543,0.6631732,-2.9803085,1.6088688,-2.6014695,-0.57614887,-4.060399,-1.105148,-0.47312692,-2.6645606,-0.25431275,-3.6206214,0.71073014,1.0580217,-2.190369}},
      {{-2.492809,-0.72933376,-1.0059054,0.92331636,-1.6946024,-2.1761522,0.19257757,-1.4729885,1.4257301,-2.7051797,-4.087224,1.1731548,-1.1808041,-0.6903093,-2.1596842,0.80151266,3.51821,-0.40918428,0.85750884,-3.071126}},
      {{0.023954995,-0.3953996,-0.30848,0.6175298,0.118374236,-3.0436473,-0.4533891,-0.9441353,1.4980235,-3.4845037,-1.8761336,-0.46294728,-1.2939194,-0.25680387,-1.2182832,0.13382171,1.079201,-0.7837834,0.27954295,-3.163765}},
      {{0.81225294,-0.22841388,-0.04946831,-0.2944954,0.7637736,-3.815752,-1.277072,0.38411596,1.3154222,-2.3890228,1.062627,1.0197961,-1.2868842,-0.9050922,-0.5571875,-0.61941546,1.1597748,-1.0031757,-0.40783015,-2.2265294}},
      {{0.5851084,-0.43330458,0.9075445,-1.0706291,0.61723435,-3.8385048,-2.8722167,1.5073278,0.95785475,-2.8754716,-1.2974743,-0.5855056,-0.92148197,0.312522,0.45106712,-1.0128703,1.5278807,-0.1419854,-1.4062581,-1.3613555}},
      {{-1.6434312,0.1329718,0.6142655,-1.4291192,0.24897231,-3.1772323,-3.2693295,2.55974,0.24170563,-2.5443978,-3.8998444,-1.4305415,-0.70906526,0.35549796,0.8514729,-2.3639448,-0.04156944,-0.20121354,-2.0251832,-0.5618681}},
      {{-4.833062,-0.10742058,-0.84617114,-1.95124,-0.22168042,-1.4302198,-4.6447716,2.7410102,0.22590882,-2.7738602,-1.7647394,-5.2934947,-0.447717,0.7322863,0.270669,-4.2054644,-2.8275225,0.99580044,-3.3394203,0.032883912}},
      {{-6.85972,-2.848225,-3.403983,-0.11904758,-2.7581232,0.021054829,0.46356663,-2.2447803,0.88934386,-1.6108018,-1.6999496,-3.229507,-0.87306535,0.258162,-3.0137491,0.21415284,-2.962449,1.5720204,0.3253599,-1.5258119}},
      {{-3.4047198,-2.2757628,-1.1981326,1.25064,-0.2499907,-0.14846107,0.0032133355,-1.8980559,0.7794415,-1.9918299,-5.033426,0.319168,-0.98127145,-0.6732654,-2.1361992,1.3593034,1.7230468,0.5092378,0.6051237,-2.1220357}},
      {{0.067504324,-1.1970823,-0.036173996,0.77015704,0.46924216,0.14785907,-0.03565924,-0.38789353,0.7431062,-1.6635497,-1.2816081,1.2757211,-0.9259752,0.37047675,-1.6969378,0.37848872,2.1334405,-0.01821801,0.5054064,-1.7327616}},
      {{0.7361076,-0.26226166,0.51084137,-0.16421647,0.59547865,0.24142249,-0.7227888,0.28046295,0.639242,-1.4692355,1.032591,0.49430498,-0.9850953,-0.7808436,-0.46663636,-0.5150455,-0.31636053,-0.7059711,-0.3629503,-1.1080654}},
      {{0.5268215,0.041642085,1.0490237,-1.5966932,0.25367326,0.23508488,-1.3342905,0.9719381,0.6639677,-1.5861989,-0.8878188,-0.09061186,-0.778375,0.26245612,0.29995027,-1.2736902,1.9538968,-0.47190893,-1.2617062,-0.36894676}},
      {{-2.4897768,0.18583417,0.9457945,-2.3800092,-0.86608154,0.36834255,-1.9356707,1.8666133,0.537266,-2.3311133,-5.4620867,-1.9194838,-0.5828756,0.43810433,1.0451081,-2.3443248,-0.8714369,-0.10318221,-1.7251219,-0.128733}},
      {{-6.23021,-0.15416025,-0.7899199,-3.2517564,-1.043924,0.6344513,-3.1535258,1.5662118,0.5518072,-1.366873,-1.4526768,-4.7608275,-0.39216506,0.91268903,0.9400008,-3.8330414,-1.7186658,1.2352114,-2.379429,0.4500256}},
      {{-7.7426944,-2.716945,-3.233396,-0.12697831,-0.043719288,0.76519054,-0.5040063,-0.25165692,0.28536966,-0.13474649,-0.6745187,-4.043364,-0.2533327,0.26536408,-2.712312,0.28360114,-2.6688135,0.40644842,-0.31916827,0.28211537}},
      {{-2.5409987,-2.2120063,-2.5722005,1.0506396,0.49771345,0.75273424,-0.28269148,-0.091497615,-0.33032307,-0.42818698,-4.8778186,0.90391666,-0.45897824,-0.012033714,-2.8360274,1.7471061,3.0615911,0.5731647,-0.19064431,-0.116894715}},
      {{0.34249473,-1.7816874,-0.4427825,0.5578567,0.4300094,0.7647499,-0.00038401727,0.27418062,-0.26204672,-0.1324233,-2.1711454,-0.26526368,-0.47883654,0.30326444,-2.1356921,1.1907989,1.095132,-0.21392734,0.116601884,0.16979982}},
      {{0.7183751,-0.5314305,-0.1010496,-0.07712576,0.022848655,0.7564737,-0.13821855,0.3875864,-0.19251882,0.7052435,0.88395303,2.1501448,-0.38283458,-2.0970306,-0.4288725,-0.25450867,1.3101803,-1.4863348,-0.28936568,0.52965605}},
      {{0.43572566,-0.23408447,0.43645206,-1.4789686,-0.67211115,0.7638364,-0.041086696,0.67964697,0.29210228,0.06800023,-1.1739695,-1.3220015,-0.2207144,0.2555926,0.28853437,-1.5680196,1.179032,-0.6928284,-0.53086686,0.55414224}},
      {{-3.0675368,-0.1471093,0.21602172,-3.390807,-1.5202669,0.75874513,-0.30262893,0.73325557,0.37713465,-0.1793724,-4.936724,-0.5939764,-0.1901627,0.6131286,1.3106741,-2.7202642,-0.5058211,-0.16919535,-0.7305068,0.5220331}},
      {{-4.948725,-1.7164645,-1.1683022,-2.123304,-1.2617267,0.76396316,-0.5656339,0.31721348,0.24542214,-0.0002981799,-1.3809621,-6.8076005,-0.27332315,0.36553854,0.6624176,-4.5784407,1.2210603,-0.050142433,-0.63078284,0.5358278}},
      {{-5.939312,-2.14646,-1.9326196,-0.24968949,0.28030756,0.30781987,-1.2546062,-0.39163673,-1.1296519,-0.8847648,-1.9541328,-3.3645236,0.13098383,0.942035,-3.3371725,-0.44738105,-3.7603185,1.5680219,-1.8215283,0.59417397}},
      {{-2.7468994,-1.2740148,-0.57421696,0.9523588,0.38345534,-0.2196248,-1.1225303,-0.4581311,-1.5736685,-1.4180177,-4.936636,0.53951496,0.28189433,0.16752827,-2.317615,1.2079539,2.8325453,0.86271524,-1.1966031,0.5716258}},
      {{0.4047738,-0.55257875,0.16005194,0.5709008,0.04739921,0.015212694,-0.13596597,0.4373214,-1.5903995,-1.426334,-1.3990923,0.36408398,0.5405664,0.2825057,-1.826258,0.92072815,2.411305,-0.06430958,-0.67107856,0.6767604}},
      {{0.68599343,-0.0074999155,0.32202196,0.008762874,-0.994279,0.122946076,0.20696902,0.32964364,-1.4925401,-1.5210704,0.8069836,0.32274467,0.5983619,-0.90428996,-0.50698817,0.012681037,-0.06974187,-0.63236815,-0.26486915,0.67285943}},
      {{0.3496629,0.077899404,1.1443666,-1.0660663,-2.0042841,-0.07636695,0.6371082,-0.42541692,-0.8412643,-1.4233783,-0.92958,-0.04746502,0.36534023,0.09013753,0.23387828,-1.3318917,1.5236535,-0.32199728,-0.03126645,0.34796524}},
      {{-3.2325015,-0.1415614,0.87864566,-3.2186627,-3.256905,-0.0936,0.86800253,-0.5422472,-0.31713834,-1.8708761,-3.5601144,-1.6837566,0.3231444,0.653349,1.0887002,-2.083986,-0.3351049,0.15667371,-0.10313666,0.032152}},
      {{-5.8546624,-0.8721594,-0.552581,-3.7637475,-4.551777,0.2512885,0.7181649,-1.5592476,0.26147407,-1.544776,-1.2112072,-5.2453423,0.1158852,1.148863,0.03672781,-3.5904307,-0.9742504,1.0279688,-0.10432036,-0.09829077}},
      {{-3.7720168,-0.45620093,-1.0664699,-0.4489988,0.12176769,-1.8578204,-2.3806977,0.62428933,-1.5239084,-2.227518,-1.696218,-4.006168,0.6652209,1.0264599,-3.1633685,-0.99366724,-3.254878,1.6027848,-3.1247814,0.9615083}},
      {{-1.8209605,0.048677947,-0.6186193,0.6226513,0.115347646,-2.975862,-1.8807333,0.7979179,-2.192413,-2.1168094,-4.1831274,-0.7138426,0.9560957,0.33423576,-2.436034,0.5870032,-0.099758334,0.63128155,-1.6817524,0.77705634}},
      {{0.27036345,0.26818225,0.22099306,0.5136106,-0.7687572,-3.3696716,-0.5273032,0.63315076,-2.4304016,-3.4815319,-1.2917346,-1.6185414,1.4923244,0.28751084,-1.6083295,0.5470238,-1.1501478,-0.17435503,-1.5848731,0.2639256}},
      {{0.66716,0.29480535,0.05826946,-0.160165,-2.072353,-4.0751185,0.2388867,0.42529035,-2.2437325,-2.3430502,0.8923889,0.44880307,1.5800203,-0.6531633,-0.7794857,0.05126753,-2.3170874,-0.71222955,-0.34226018,0.14809784}},
      {{0.24483474,-0.22067861,0.96610725,-0.966021,-2.6628473,-2.9770846,0.88295585,-1.138603,-1.5498984,-4.1044164,-1.1595508,-1.4579875,1.6480289,0.048203703,0.054874048,-1.0980614,-1.2000519,-0.3782853,0.41821358,-0.7033018}},
      {{-2.6233256,-0.09066766,0.74681985,-2.0962722,-3.9988008,-2.3080988,1.5451663,-1.3485798,-0.92592204,-3.109405,-2.392627,-1.2640305,1.0620683,0.16937791,0.57242316,-1.9924635,0.22300504,-0.24917015,0.6842023,-1.0711887}},
      {{-5.1153517,-0.9804985,-0.32927042,-2.9344585,-6.8207345,-1.7061942,1.6021892,-2.588118,0.012130635,-3.6642056,-1.771127,-5.242413,0.45507744,0.3714898,-0.5651356,-2.9320562,-1.8013448,0.73433846,0.72493815,-0.6851276}},
      {{-2.498124,0.470118,-2.3129277,-0.55768543,0.1791298,-2.9718773,-3.9720623,1.2039342,-1.7642012,-2.1863058,-2.1458693,-5.641713,1.08704,1.0729008,-2.3222463,-0.43654525,-6.5174813,0.36032814,-4.1821156,0.28341976}},
      {{-1.2306958,1.0037384,-1.5899255,0.544885,0.08145177,-5.8815775,-2.6034505,1.4288691,-2.5866377,-1.6310697,-3.6522205,-4.022237,1.5512781,0.81542236,-1.4796076,0.57652867,-3.65756,-0.44456312,-3.2618053,-0.31507614}},
      {{0.6889341,1.2641408,-1.7939171,0.25092658,-0.78871953,-5.292466,-1.2642014,0.6998021,-2.7430847,-2.6552618,-0.84094054,-3.032455,2.0751066,0.582152,-1.297808,0.32550293,-4.4531293,-1.2196308,-2.484948,-0.8720957}},
      {{0.74331874,0.33500355,-1.7273695,-0.12538242,-1.5051763,-4.883207,-0.33311456,-0.40521878,-1.9011911,-1.9896075,0.9466992,-1.7351352,1.9743212,-1.1219636,-0.2617265,-0.16917485,-7.8154125,-1.4930067,-0.64020073,-1.2291567}},
      {{0.56697303,0.15584034,-0.6962735,-0.5600917,-2.6090696,-6.1918545,0.37112916,-1.7213689,-1.6783863,-3.5163698,-0.8552942,-3.4905338,2.3918548,0.22040017,0.040622283,-1.0964103,-3.2356782,-0.6277086,1.2656531,-2.8526478}},
      {{-1.2625091,0.3289483,0.13895334,-1.26025,-4.4890513,-5.497037,0.88397354,-1.8095859,-0.7997254,-3.3473234,-2.8853846,-4.189787,1.6809872,0.638551,0.09879297,-1.4114746,-2.4721892,-0.730439,1.7689198,-3.0482845}},
      {{-3.1132739,-0.26718724,-1.4513032,-1.8292713,-6.35572,-3.106349,1.2624732,-4.1408844,-0.22132768,-2.7061942,-2.8522718,-6.386335,0.68125284,0.38427934,-0.38616484,-1.8726023,-4.3178973,-0.35947245,1.382914,-1.8339115}}
    }};

    b1 = {
      0.12841143, 0.027267512, -0.5752973, -0.03060086, -0.5042013, -0.0041859397, -0.055937875, 0.30224955, 0.16656455, -0.14257039, 0.19191845, 0.00010271561, -0.22641727, 0.028802058, -0.2804178, -0.07584756, 0.105454504, -0.11678563, -0.030078467, -0.37664086, 0.16718218, -0.018994538
    };

    b2 = {
      -0.08229959, -0.11617129, -0.4219205, 0.15530168, -0.022043139, 0.028713733, 0.22553833, 0.049688406, 0.07634744, -0.30670586, -0.46652034, -0.12063626, 0.170148, 0.36352733, 0.011189314, -0.037468076, -0.3072728, -0.10997649, 0.017808285, 0.69065845
    };

    bout = {
      -2.0932746, -1.7281371, -1.5663319, -0.30336627, -1.70251, -2.0915399, -2.3424277, -1.9825616, -0.47312674, -0.80270684, 0.47170085, -0.77058065, -0.8707162, -2.2736857, -1.7096754, -0.61306864, 0.3587981, 1.0104866, 0.40393415, -0.7968485, -1.6388718, -0.73997957, 0.46075186, 0.95466304, 3.2166753, 0.9206431, 0.2779176, -0.54284173, -1.6435367, -0.5193649, 0.40204918, 1.0605416, 0.4500131, -0.810381, -1.7662615, -2.1081953, -0.77709264, -0.8951463, 0.35970178, -0.7927564, -0.78061265, -2.2689064, -2.2678483, -1.8459193, -1.3911519, -0.16162421, -1.3543484, -1.8169917, -2.1468234
    };

    BN_gamma_in = {
      0.25599247, 0.593217, 0.15077364, 0.9047042, 0.3593856, 0.1032027, 0.19478422, 0.9665782, 0.1915536
    };

    BN_gamma_1 = {
      4.0671334, 2.5293684, 29.787909, 3.3518093, 20.626656, 4.40677, 3.3583822, 2.0698519, 3.926327, 5.108628, 2.5921028, 7.405247, 4.3297896, 4.446688, 0.0009942056, 4.448321, 3.228769, 8.130528, 4.621719, 28.456524, 3.1407359, 6.0162606
    };

    BN_gamma_2 = {
      0.7697466, 1.2833815, 0.499721, 1.0000252, 1.2129672, 0.60955906, 0.88899124, 1.70377, 1.6983159, 0.9831476, 1.1832514, 8.217565, 1.5381502, 2.1790109, 1.5167311, 1.4096103, 8.318063, 0.94352734, 2.0258076, 0.80043
    };

    BN_beta_1 = {
      -0.0112576755, -0.33400193, 0.0009396916, -0.19612122, -0.006370715, -0.05254791, -0.22348052, -0.1998903, -0.08642023, -0.052281428, -0.22451155, -0.012548706, -0.13982059, -0.013830932, -0.00010087536, -0.08554087, -0.21925825, -0.019511083, -0.041701224, -0.005240558, -0.24380943, -0.026923055
    };

    BN_beta_2 = {
      -0.060880806, -0.08502615, -0.1274184, -0.25011104, -0.12003592, -0.06448313, -0.22580524, -0.1773738, -0.3115398, -0.073510975, -0.017014254, -0.08144358, -0.37289006, -0.6793206, -0.111850835, -0.078858204, -0.032879822, -0.13099694, -0.17198478, -0.5081416
    };
    
    mean = {
      89181.28384408768,58457.84402066208,88045.67881255377,61350.47309520807,19275.932043466157,62041.67506548536,87577.27392690617,58610.16610608882,89781.83517569612
    };

    stdev = {
      612332.4946726247,500942.7793910199,605819.3348647763,505140.49803198315,405659.3641763986,504379.0747126609,607802.0932639176,501437.74141163327,611806.2317041238
    };
  }

  else { // QP=22 and Default
    
    embs0 = {{
      {{0.3733845,-0.3955783,0.07744011,-0.04307303}},
      {{-0.0042048795,-2.6874498e-06,2.0371448e-05,0.011494284}},
      {{0.003232961,-0.0006760608,0.00013007366,-0.003584122}},
      {{-0.0075287274,0.036592837,-0.042221125,0.012873099}},
      {{0.00067959866,0.0033404862,-0.00074650906,-0.01971964}},
      {{-0.03144007,0.072797485,-0.07439423,0.011875049}},
      {{-0.031092443,-0.0053221015,0.01395625,-0.054928824}},
      {{-0.046231944,-0.07600457,-0.08442417,-0.064925104}}
    }};

    embs1 = {{
      {{-0.3296824,0.16756245,0.31641313,0.26641658}},
      {{-0.0049882843,-1.868626e-06,0.0031466566,0.010046641}},
      {{0.0009981405,0.00020256553,-0.0029553438,-0.004276571}},
      {{0.033103377,-0.02075392,0.002531248,0.025623647}},
      {{0.0054921927,0.004964581,0.0022904095,-0.019248046}},
      {{0.07195673,0.047087893,0.008440574,0.06479084}},
      {{0.0021697378,-0.0068458896,0.029914293,-0.056096025}},
      {{0.028263576,0.016895277,0.110997014,-0.06382125}}
    }};

    in_h1 = {{
      {{0.057050616,0.06855201,-0.017443892,-0.15447481,0.07538818,0.09677833,-0.02042298,-0.13432838,0.054282084,0.93268055,-0.14276381,1.3953099,-5.8364077,1.5105208,0.29851422,-0.27822313,-0.12269779}},
      {{0.012728278,-0.014872517,-0.0012589413,-0.008302922,0.011553641,-0.018846424,-0.010829608,-0.008665479,0.13402916,0.26899412,-0.047460802,-0.19940458,-6.654499,0.018570153,0.020071937,0.09912613,0.085503355}},
      {{-0.027031004,-0.03998885,0.122665495,0.21127217,-0.3414903,0.052848108,-0.023314286,0.15296647,0.06602587,2.776284,-6.8083787,-0.5248961,1.8841953,-0.018325595,-0.083072774,0.6160252,-0.15541749}},
      {{0.14657423,0.056241635,0.08110978,0.14180641,-0.0010235836,-0.062000602,-0.110626005,0.16995908,-0.85792696,-7.3822837,0.1369948,1.9664847,0.35489994,2.497576,0.25454,-0.041920416,-0.6833186}},
      {{-0.08392918,-0.02735688,-0.021202205,-0.05495517,0.01027054,-0.057401124,0.09710667,-0.045766886,0.03729351,2.0004926,3.7448688,-0.102923684,-4.8391485,-2.163518,0.71390724,-0.02909232,-0.7763726}},
      {{-0.25226483,-0.17276599,0.15690748,0.406457,-0.25046894,-0.015308232,0.07325021,0.20310797,3.756846,2.8357959,1.8672935,-5.444311,-2.2058775,1.2708818,-0.3161241,1.478432,-1.0772191}},
      {{0.022039648,-0.015314712,0.0045147664,0.032485113,-0.020106161,-0.0015731354,-0.03138318,0.027192196,-1.2231278,-1.1417211,-1.1083041,-0.9330061,-1.4955891,-0.8497526,-1.7162641,-1.2343669,-0.94257265}},
      {{0.050771873,0.014254911,-0.024296733,-0.05081756,0.15569848,-0.03391795,-0.019241473,-0.030955272,0.26403892,0.29749277,-2.9288533,-2.3650334,0.5329439,-4.5000978,-0.6974548,1.0295471,0.0049914313}},
      {{0.0077312943,0.006705391,0.0023315593,-0.009817684,0.0050122966,-0.003104088,-0.0067061903,-0.008930252,-1.0425847,-8.840298,0.52396977,-3.1033056,0.23220792,0.90011317,0.14374496,1.0058776,1.1481088}},
      {{0.0035793565,-0.0028511349,-0.0045714118,0.005861853,0.08602707,-0.046973314,-0.013686983,-0.0047652554,-0.6665907,3.9855692,0.64324254,-0.25181746,-1.8046904,3.8003218,-0.80689144,0.23280556,0.48429358}},
      {{0.0001978224,-0.0034015202,-0.0041588163,0.00091899745,0.012035328,-0.011002193,0.0032443264,0.003810142,0.31612772,11.086474,2.0842788,-1.826035,-1.6806641,-0.5993142,0.23182327,-0.24369699,0.09643237}},
      {{0.07249187,0.03374509,0.0074901534,-0.03744666,0.15309526,-0.017760372,-0.04140162,-0.023654297,-2.8634362,-0.6758711,1.0081978,-0.104594775,1.0292581,0.27862856,0.073339485,-0.076874815,-1.2261417}},
      {{0.036819678,0.015787903,0.021875797,0.021311106,0.00018288198,0.014271819,-0.040390223,0.011992362,-0.27928498,-1.6651977,-8.806841,-0.27489978,-0.1771623,-1.4721745,-0.09510949,-0.19309041,2.0720327}},
      {{0.024042845,0.043956224,-0.011577562,-0.084966674,0.04149123,0.030524382,-0.012428696,-0.076841675,-0.4331509,5.7092013,0.35348836,-5.4220114,1.9068352,-0.051366616,-0.71586245,0.5925905,0.041998856}},
      {{0.0041042394,-0.015006409,-0.009326402,-0.01013237,0.02446176,-0.008822017,-0.00038391602,-0.011086035,0.4364459,-7.615895,-2.2534082,-1.7802687,1.6913401,1.4180043,0.1782173,-0.7709802,-0.27052477}},
      {{0.008584797,0.015830508,-0.00027014592,-0.023893153,0.024854383,-0.009613886,0.0010472022,-0.014495565,0.5863806,8.943821,1.710683,3.169423,0.76186806,-1.1491064,-0.6482134,-2.741316,0.1579861}},
      {{-0.079161495,0.025107013,-0.060153343,-0.13907643,-0.0852589,0.06229602,0.093904085,-0.114618756,0.5629781,-4.864559,-1.0355686,4.9173803,-1.2032555,-1.2740922,0.35165,-1.5811297,1.405614}},
      {{-0.017708922,-0.017740007,-0.014548779,-0.009375289,-0.01699673,0.010499651,0.016498165,-0.012182215,-0.06576759,5.5527773,-0.385713,-4.4827805,0.21217015,0.86194855,1.1267047,-1.2835853,-0.14838287}},
      {{-0.00395669,-0.0047800196,-0.0042034583,0.0035550883,0.008738205,-0.014047844,0.013553514,0.010654173,1.3666008,-2.1284971,-4.1911883,-4.021476,-1.7214179,1.2728922,0.011577944,0.8269684,0.51593584}},
      {{0.008810847,0.0015253337,-0.0007419918,-0.0020201628,0.012554304,-0.0033248847,-0.008140443,-0.002872699,0.18276627,-1.4899291,-1.1332129,4.580202,0.24450715,-3.0116549,0.091031455,0.13224165,0.006803785}},
      {{0.0018362622,-0.0021412184,0.0009579793,0.0023724379,0.0063624913,-0.008243871,-0.00061847526,0.0004604199,-0.22419353,-6.6580997,3.777099,-1.1011275,-1.7943287,-0.0030645458,0.98975146,2.6963558,-0.5909706}},
      {{-0.022593845,-0.017831868,0.030059779,-0.1454817,-0.0035982204,-0.01020175,0.019159472,-0.15425463,-1.4452808,-0.63522863,-1.282902,-2.0539281,-1.3610346,-1.8707799,-1.5939791,-1.2904797,-1.9712447}}
    }};

    h1_h2 = {{
      {{0.7554163,-1.3022556,-0.9612269,-0.2627089,-0.255777,0.103316,-0.45604455,1.1219162,-14.981949,-0.80014974,-0.47460973,0.69412696,-0.21907093,-0.7058185,-0.058277994,-0.1873796,0.05167255,0.1965401,-1.0003427,0.041628096,-0.063469276,-2.8486114}},
      {{0.12653857,0.35472775,-0.2380115,-0.5961112,-2.192483,-0.3884077,6.3742337,0.51233906,-0.27703473,0.42883185,0.1493798,1.1793038,-0.099336155,-0.13761772,-0.29622942,0.55055195,-0.72205955,0.57331145,0.90264326,-0.31309012,-16.095829,1.2547908}},
      {{0.9945252,-1.1436526,-1.6755255,-0.9257329,-0.37016675,-1.3113837,-1.3990961,-2.730878,-1.0585417,0.3901338,-0.61484635,2.5484383,-0.6850726,-1.4219462,-2.403859,-0.17285797,-0.66894823,-2.7379375,1.7640618,-1.8942379,-1.1537029,-0.43631485}},
      {{3.2515807,0.0816401,-1.4357821,-0.6852204,-0.24076955,-0.90857965,1.6794988,-1.7721336,1.0000271,-0.42804974,-2.5114272,2.5667543,-1.0728191,-3.3925514,-6.714174,-0.7392857,-0.99543965,1.3389217,-2.2479618,-0.31471282,0.0993357,0.807666}},
      {{0.54497993,0.2946543,-0.6853568,-3.1620302,-1.3818439,-1.7540332,-0.47112617,0.33131042,-0.35720617,-0.84790206,-2.5957787,2.0044436,-0.31705534,-3.0363123,-2.5049303,0.19553299,1.7636857,1.6010492,-1.5630541,0.21437177,-0.908653,-1.7820778}},
      {{0.1479296,-0.5049125,-1.0626428,-0.027286591,-0.811701,-0.48351288,-2.1930788,2.4344099,0.06252009,-0.034618426,-0.032645825,0.6188358,-0.62336886,-0.13789566,0.0973203,-0.1735957,-0.45395964,-0.15937719,1.8669689,-13.258511,-0.39660275,-2.8320093}},
      {{4.492561,0.41040227,-1.520283,-0.50651085,-0.6960688,-0.32136527,6.636803,2.1676672,0.060820933,-0.2627734,-0.4197467,-1.9468426,-0.589558,-3.6534722,-1.3150678,0.2408752,1.3488808,1.0219834,0.22859181,-1.0730982,0.17252392,0.35872614}},
      {{0.57912755,-0.25311357,-1.4603397,-0.12463425,-0.38379273,-0.39065498,9.904365,-0.71325034,0.73055696,-0.5198067,-0.34957084,2.971267,-0.8469692,-0.4280893,-1.2341846,-11.203491,-0.3492627,0.20003787,0.97141516,-2.5631912,-0.07178439,1.1701448}},
      {{1.4045416,-0.39673924,-1.9295537,-0.7092752,-0.08965599,-2.3568954,-1.5522438,0.8727476,0.28772417,-1.2189358,6.093582,0.25929335,-1.3209646,-2.4024022,-1.2814279,-3.4163017,0.49908128,2.9816313,2.1042569,0.025083758,-0.57254034,-1.751599}},
      {{1.5644755,0.06092344,-0.8752619,-2.3184369,-1.3768808,-1.3580093,2.7341337,-1.022151,-0.98161036,-0.31208253,0.44900006,0.09601501,-0.06627203,-4.735663,-0.97157556,-0.9063478,-0.4098105,5.251039,3.6054611,0.87027043,-0.32449886,1.0799302}},
      {{6.45778,4.3892226,0.08491518,-5.255923,0.061065104,-0.75951093,2.9950013,5.200704,0.39529228,-1.7685473,-0.30829948,1.4100127,0.6476868,0.85932434,2.0768993,-0.3092719,-3.4271562,0.7982151,-0.47777766,-0.32120365,-0.71884775,-1.5241696}},
      {{1.0330032,7.8388395,-4.0322666,1.6718191,-0.039620757,-0.039026752,-2.57136,-2.883659,-0.010719947,-0.19296448,0.877634,-0.22960788,-0.64577895,-3.783678,0.0032760536,-0.74312234,0.31372276,0.01605502,-0.99083793,-0.20062368,-0.39790505,-3.2006776}},
      {{-0.53278816,-0.73172563,-1.4899474,-4.1913953,-0.06827268,-0.7350783,1.7298745,0.73786277,-0.21828055,-6.496943,-0.7727528,0.83222806,1.7602971,-0.71836454,-1.5462036,-0.51186144,-2.969491,1.2433028,-1.6080977,0.69810414,-0.6386562,0.13202986}},
      {{0.8421685,3.6315343,-0.41153246,-4.037508,0.33109018,-1.057563,-1.4187298,3.0879557,-0.8254747,0.5522904,-2.2857952,-0.87076426,-0.55209976,-1.7463218,-3.3718617,-1.1529938,-0.39401874,0.6055842,2.279259,0.65024275,-0.22906724,-0.7296097}},
      {{0.5945484,-0.9175764,-3.0222318,-1.5095512,0.20238662,-0.5220323,-3.187229,-2.2424257,0.19560651,-1.428166,-0.9398323,2.8886056,-0.8687827,-4.5390587,-1.9915539,-1.337602,1.6911471,3.7082224,-0.9910946,-0.26062715,0.6409624,-2.654559}},
      {{-1.8299226,-0.15802115,-1.0444163,-0.994199,0.116865024,-0.6776138,-3.6519625,1.8813323,0.3266009,-0.3572318,-0.56653357,0.40572178,-0.23996001,-1.0928743,-5.273275,-0.15709725,-2.1772046,0.0984866,1.3794644,1.2540492,-0.44890833,-6.001696}},
      {{1.72965,-0.5538613,-0.92373586,-2.185433,0.32638037,-1.6892717,-1.2643733,0.8079729,-0.30361134,-0.34799132,-2.3685458,-0.31163582,-1.3052127,-1.1091819,-3.5453796,-1.5441597,-0.31652468,1.1984578,2.8408434,0.39156955,-1.4259497,-1.6319553}},
      {{-0.09239311,7.861889,-0.047929212,-0.22732362,-0.019742412,-0.17643175,-1.0632308,-0.118229516,0.01762647,0.05542535,0.9719156,-0.7337599,-0.29312983,-0.31857294,-2.0551066,0.24317862,-0.78104573,-0.25349244,-1.505984,0.08867297,-0.25133672,-0.8063653}},
      {{0.8912786,0.057176393,-1.6075531,0.1219341,-0.8889251,-1.3274693,-0.791946,-0.7536349,-0.51146567,-1.0454465,1.5849984,1.1233307,-0.018467361,-3.432102,-0.24234007,2.0634177,-0.7585289,-1.999617,0.64069206,-0.64004564,-1.8149351,-1.3892003}},
      {{0.16232619,0.090991214,-0.45298147,-1.3007445,-0.961945,-1.2795779,-0.40959015,-0.15537642,0.062223267,-0.75241643,0.47843808,-0.0026103607,-1.6414963,-0.4912146,-0.098185815,-0.9432038,-0.03134608,1.0043424,4.7849994,-0.15303369,-0.313824,-0.5366371}}
    }};

    h2_out = {{
      {{-1.238327,-2.4781287,-0.07277412,1.4092864,-1.1565784,0.39188737,4.1781435,1.5260519,0.7700602,-5.4236665,-0.5494375,-1.4935813,0.40426734,-7.946559,-0.97857535,1.9892577,-6.6384068,-4.546085,-1.218953,5.606371}},
      {{-0.5423884,-2.3342874,-0.34847978,1.1517874,-0.7117098,1.2442166,0.7496826,1.6861641,2.1224413,-2.9071443,-1.6935183,-0.3449631,-1.0035982,-10.829698,-0.235759,0.44214433,-10.214342,-5.3736043,-0.18497707,5.9762216}},
      {{-1.1084182,-2.5428321,-1.824848,0.3911756,-1.8544183,0.75435126,-0.38328332,0.91339993,2.954737,-1.6174952,-1.6271768,1.3768159,-0.58256114,-9.066122,0.6188959,-0.3584821,-12.031467,-6.25265,0.542921,2.7890668}},
      {{-1.156576,-1.3808104,-2.8951826,-2.0047255,-1.2875066,-0.40356246,-0.41402838,-0.2097627,1.7028614,-0.2500598,-0.63443995,1.6599838,-0.9526331,-3.8675563,0.40049234,-1.2416533,-8.221544,-0.85489285,0.44224882,-0.51449114}},
      {{-0.7220892,-0.22476003,-6.4161334,-8.121563,-0.8278756,-0.7964911,0.20685154,-0.61626345,2.5891685,1.6217846,-0.59840834,-0.273377,-1.6368268,-5.5598745,-0.19526772,-1.2491884,-4.261137,-4.813237,0.12365271,-0.9369634}},
      {{-0.44256654,0.52949417,-7.579666,-9.167833,0.053160936,-1.4351593,1.4630437,-1.3637987,2.250968,1.6840285,-1.2370784,-3.9124472,-0.73664254,-3.0730503,-1.0569236,-0.38185626,-2.2002938,-2.3149805,0.28242067,-0.52983224}},
      {{-1.3919595,0.8002521,-7.420829,-10.002622,-0.72123903,-1.414979,3.7987213,-1.9393184,1.6026337,0.9209154,-0.8318801,-5.219205,1.0236864,-1.4050896,-2.311681,0.45724043,-1.1044652,-1.4384642,-0.88618565,-0.0643177}},
      {{-1.2203536,-2.4439886,-0.091454536,1.463736,-1.732639,0.2979172,4.2407684,2.2140386,-0.44545954,-7.9549727,-0.3402429,-4.7746544,0.73425335,-3.1723769,-0.8110022,3.0267174,-4.2344456,-4.549877,-3.0584662,2.5140915}},
      {{-1.6111989,-1.3540605,0.09146401,1.4373952,-2.7468894,1.1363075,1.981103,2.2340364,0.17257729,-3.4859467,-1.022956,-2.4198391,0.39399958,-5.599713,-0.20834295,0.82724774,-6.03905,-4.6686416,-1.6959453,0.27682513}},
      {{-1.6751261,-2.108256,-1.5359447,0.57247645,-1.7892026,0.6382037,-0.33679497,1.4698408,1.5615978,-1.1262611,-1.9275132,-0.50493544,-0.50903165,-5.6750536,0.75748426,0.20306298,-6.220707,-6.007293,-0.9435353,-0.7169809}},
      {{-1.1892928,-0.7230385,-3.2229722,-0.17447045,-2.6346889,-0.44803727,-0.41511217,0.4589528,1.816863,0.54185414,-0.71924084,1.651418,-0.46473944,-4.226076,1.0102104,-0.87033767,-5.2020226,-0.8667109,-0.57458806,-1.1708974}},
      {{-1.2413332,-1.0317123,-5.5435715,-3.9761155,-0.713632,-1.5579755,0.4177899,0.060497563,1.8557823,1.5170213,-0.91325146,-1.4353323,-0.45866644,-3.2470129,0.876784,-0.023068085,-2.233169,-5.087739,-0.95837134,-1.0976571}},
      {{-1.2729759,0.045918107,-7.393521,-6.8290925,0.07027289,-1.7402194,2.279388,-0.875081,1.5269132,1.5093551,-1.099047,-4.3483853,1.5354044,-1.5113386,-0.25246388,1.0483732,-1.1516932,-2.704793,-0.5829404,-0.39445373}},
      {{-1.272547,0.1954707,-7.5905967,-8.488177,-0.775156,-1.0882683,4.315242,-1.3981789,1.1403342,0.77222097,-0.83250636,-5.5976477,2.717065,-0.16145787,-2.2103913,1.8451254,-0.17962544,-2.5908995,-3.4637675,-0.32597077}},
      {{-1.2354851,-1.9118727,0.29436544,0.9522212,-3.9443345,0.63534516,5.10739,1.9618329,-1.470506,-7.8344784,0.12782149,-5.664831,0.8223732,-0.7849332,-2.146461,2.7152836,-1.3641932,-3.4338708,-1.5629685,1.4877259}},
      {{-1.603004,-1.7843262,0.39632675,0.9051671,-3.3356862,1.6702334,2.3293374,2.1003518,-1.0831616,-4.2447863,-0.94847786,-4.4082456,-0.3572199,-0.8044891,-1.9960394,1.2946049,-2.3005164,-4.4283924,-1.3643757,-0.19143315}},
      {{-0.74803805,-2.1025379,-0.33533752,0.7242121,-2.7608283,0.8222601,-0.40080836,1.1238579,-0.24322744,-0.8732455,-1.026589,-0.2326518,-1.100188,-0.38453743,-0.039096627,-0.49135688,-1.2670732,-4.3228283,-0.9111507,-0.8043376}},
      {{-0.9620068,-1.2127383,-1.901988,0.40094665,-1.2700937,-0.45035112,-0.5031402,0.42354447,0.41909033,0.068371855,-0.62979996,1.5176963,-1.2179626,-0.09044534,0.7369214,-1.1382856,-0.60330427,-1.3260831,-0.5557839,-0.75392836}},
      {{-0.6546032,-1.0485766,-4.119225,-0.022609225,-0.13511606,-1.4817314,-0.08322042,-0.7412327,0.49490297,0.60316664,-0.97852975,-0.6763389,-0.22301668,0.1208434,0.8493381,0.15909354,-0.24979024,-3.3093827,-0.6503668,-0.15138076}},
      {{-0.6478492,-0.92980033,-6.347924,-2.028504,0.56203455,-2.1240964,2.8339705,-1.4848018,0.53511304,0.7350967,-0.98847234,-5.7669654,2.5748484,0.26952314,0.37077755,1.6273429,-0.16847426,-3.2898307,-0.73266095,0.75440776}},
      {{-1.0551529,-0.32656348,-6.80789,-3.9475718,0.04521603,-1.7091978,4.4374375,-2.0050538,-0.051829338,0.07919981,-0.36854973,-5.504098,3.253842,0.39631876,-1.8392888,2.1435575,0.40277728,-2.880817,-2.3169827,0.8404161}},
      {{-1.1601518,-1.1674422,-0.7762939,-0.059401587,-3.5568223,1.1890361,3.1122642,0.18040237,-1.4844029,-3.609155,0.19447307,-4.384516,0.8953194,0.48453254,-4.99852,0.8627077,0.35720956,-1.2734114,-1.5387819,0.3945554}},
      {{-0.9849769,-0.6515655,0.48989138,0.32757786,-5.4113417,2.056835,2.844787,1.0508797,-1.9518207,-1.5718989,0.31785807,-4.725327,-0.05280455,0.4337291,-4.6191134,0.38310465,0.18528123,-1.3603122,-1.6489997,-0.37487087}},
      {{-0.46664828,-1.5020769,0.20901683,0.4752166,-1.9869576,1.111493,-0.35710835,0.4117361,-1.6051552,-0.55870295,0.34065193,-0.73368305,-2.2096875,0.4841782,-1.4097538,-0.81362265,0.5007743,-1.2815951,-1.1835998,-0.3916062}},
      {{-0.773659,-0.2929885,-0.32464793,0.3791608,-0.2433143,-0.8431218,-0.4802862,0.079120696,-1.573589,-0.18684459,1.6040394,1.5752164,-0.06918673,0.49383554,0.13819346,-2.509128,0.5844117,2.3485296,-0.7478015,0.18613228}},
      {{0.2367593,-1.4714109,-1.7097781,0.43147284,0.7509038,-1.9079447,-0.11156469,-0.83275473,-1.0472811,0.11438545,0.35893315,-0.26539776,0.1292078,0.47995123,0.6874976,0.15347674,0.56229377,-1.4869012,-1.1255058,1.3393466}},
      {{0.4496252,-1.1094891,-3.9606993,0.3124613,0.87749445,-2.327994,3.1770482,-1.08969,-0.86985254,0.017359406,0.12798986,-4.641305,2.6466408,0.4696144,0.54381996,1.6707044,0.45993075,-1.4428794,-1.3762239,3.337862}},
      {{-0.14159463,-1.1843402,-3.1890068,0.18566678,-0.012497328,-1.8239578,3.9488258,-0.98517215,-1.0134299,-1.2448262,0.04841852,-3.931225,2.9696562,0.4815945,-0.8989997,1.0267032,0.53113145,-0.68532115,-1.8672214,2.230287}},
      {{0.47149813,0.09588603,-0.9173192,-3.2990088,-1.611163,2.0972557,5.7451673,-0.7265628,-0.91101986,-1.1812564,0.11983069,-5.457726,-0.37331924,0.20610262,-9.494576,1.5596477,0.7206782,-3.4683716,-5.028988,-0.329539}},
      {{-0.31636003,0.93824154,0.46308917,-1.9419962,-1.970993,2.4010592,2.8440058,-0.23390469,-1.57174,-0.8565662,-1.3126819,-5.3435245,-1.0602348,0.18679924,-5.834102,0.5889937,0.6498272,-3.4298313,-2.3010714,-0.100740775}},
      {{-0.040105686,0.22537582,0.6429694,-0.15957303,-0.38209754,1.124357,-0.35974154,-0.89450186,-1.7856946,-0.21881042,-1.0003434,-0.80167866,-2.300352,0.3911653,-2.9378648,-0.51173663,0.6250292,-2.8501792,0.10243741,0.4206771}},
      {{0.43243888,-0.20429628,0.4271505,0.21497673,0.63347715,-0.44982365,-0.5221693,-0.5304587,-1.9594094,-0.39159954,-0.43743902,1.497987,-1.327628,0.22840215,-1.3018163,-1.299697,0.6878756,-1.2093495,1.2524803,2.1531625}},
      {{1.561228,-1.2480354,-0.43985566,0.5467603,1.1071808,-1.5233486,-0.20526135,-0.31756508,-1.6663842,-0.6801573,-1.1063652,0.1081711,0.2546967,0.007983713,-0.24714044,0.063543096,0.48681688,-4.734435,0.94224924,4.0391364}},
      {{2.1835465,-1.8132675,-1.8785999,0.5853147,0.8771605,-1.9991196,3.570708,-0.3624444,-0.9572011,-1.0056226,-1.4428741,-3.0546603,2.7117395,-0.3033956,0.18051949,1.3797348,0.39322498,-5.119358,-0.26077706,6.066649}},
      {{1.0960753,-2.30192,-1.9903293,0.67933273,-0.8331768,-1.4221879,6.0410013,-0.14963737,-0.93257535,-2.6165338,-0.8611555,-4.160141,4.1376166,-0.080827855,-0.19386052,1.797762,0.3517677,-3.3864625,-1.7168748,6.5846963}},
      {{0.6886182,2.6412444,-1.1806282,-5.59887,-0.9440339,1.4736531,5.541026,-2.0186703,-0.6691068,-0.22610301,-0.43175247,-6.9155416,-0.8703403,0.21274245,-7.6549416,1.5073909,0.47183603,-2.5760553,-5.3002954,0.2858386}},
      {{-0.007900984,2.9537416,0.32727185,-4.3320246,-0.52152675,1.5724742,2.3732736,-1.5634096,-1.2632596,-0.31169012,-1.3755506,-4.1245747,-1.8417956,-0.074330546,-5.4378257,0.27695763,-0.3106108,-2.7499745,-1.0661426,0.33692932}},
      {{0.2477469,1.8759428,0.8829754,-2.2691545,0.54966635,0.77846444,-0.25891635,-1.8699151,-2.1190042,-1.0116583,-1.8250264,-1.2656991,-2.2623286,-0.7916517,-3.9006393,-0.096869275,-0.65979314,-4.0526257,2.1643362,1.8905209}},
      {{0.85141504,0.48240423,0.9142266,-0.35111797,1.0758204,-0.43965644,-0.4931653,-1.2417327,-1.915187,-0.82496727,-0.9814468,1.5426644,-1.0290517,-1.2043488,-3.085826,-0.9650442,-1.4715197,-0.8550357,3.16221,4.349895}},
      {{2.4561758,-1.1074051,0.7014756,0.047022454,1.086765,-1.277341,-0.29457286,-0.8584533,-2.0956092,-1.9219863,-1.5954437,-0.99970514,-0.09015392,-1.698533,-1.4544846,-0.008433768,-2.0628386,-6.5435667,3.1625564,6.4782963}},
      {{3.148371,-1.7502271,-0.29438472,0.81625366,0.77002335,-1.4911063,2.4527035,-0.07355991,-1.6093991,-2.116567,-1.50088,-1.1248101,2.2868466,-2.0657713,-0.6473738,0.9363298,-2.923581,-6.5887365,1.2958633,7.7449665}},
      {{2.7501724,-2.8728516,-0.64556843,0.90799946,-0.6858942,-0.7491737,5.244162,0.39961946,-1.8285754,-3.5800378,-0.901071,-2.384956,4.1074715,-1.5288957,-1.0523527,1.7118901,-2.375311,-5.47734,-1.6071343,7.1250715}},
      {{-0.3235274,2.5874004,-2.0195677,-6.269873,-1.784469,0.677417,4.3134956,-2.6084244,-0.5304579,0.42529207,-0.43010673,-4.390657,-1.9495107,-0.9468037,-5.19517,0.5214057,-0.86294943,-2.024588,-2.0545774,0.6930588}},
      {{-0.1906036,3.5938506,-1.2381212,-4.3496275,-0.5259681,1.3330657,1.6812019,-2.4027727,-0.38645738,0.43690047,-1.7972785,-3.0596387,-3.2419574,-2.733564,-3.758243,-0.435744,-1.6776179,-2.6621091,0.7281153,0.9560936}},
      {{-0.25207356,2.288368,-0.6819514,-3.9018235,0.51380694,0.56815404,-0.2926033,-2.4759493,-1.3302492,-0.23963939,-1.5054108,-0.255716,-2.6075177,-3.6786106,-3.968076,-0.6946718,-2.0479975,-3.7700999,3.126568,2.233614}},
      {{0.39259845,0.05484157,0.20544963,-1.4995444,0.510504,-0.4963922,-0.43216527,-1.420884,-1.4655148,-1.0243108,-1.0206858,1.6377453,-0.76186913,-3.1405456,-2.2596421,-0.81866735,-4.517536,-0.22449109,2.9918237,2.7762039}},
      {{2.4719496,-1.6282611,1.0059828,-0.22711356,0.513195,-0.7764537,-0.34891248,-0.9048245,-1.1642575,-1.715782,-1.0175136,0.94545096,-0.73069227,-6.2678804,-1.7441968,-0.67119014,-6.2986345,-6.9817433,3.382278,7.88128}},
      {{3.5474725,-2.5320592,0.15021814,0.49677607,0.12416033,-0.9026246,1.2123303,0.38020727,-0.39974508,-1.9853585,-1.7644424,-0.26797605,0.6417688,-7.0821986,-1.0469686,0.21556956,-6.40004,-6.7696743,2.4002833,9.950011}},
      {{2.3137817,-3.0863216,-0.090906695,0.93379974,-0.55581814,-0.86197037,4.62913,0.06853164,-1.019699,-2.512331,-0.824085,-0.52213234,2.7626688,-5.2391553,-1.0952313,1.0962396,-5.284039,-5.8029404,0.09028628,7.3576126}}
    }};

    b1 = {
      -0.016583161, -0.096573554, -0.0025740832, 0.086574815, -0.12610064, 0.15763375, -0.592417, -0.20685633, 0.035859305, 0.063171014, 0.08832273, -0.36545905, 0.04799708, -0.08655666, -0.0660817, -0.013356912, 0.24614985, 0.025203114, 0.18712485, 0.0005765692, 0.0946083, -0.78814775
    };

    b2 = {
      0.056685444, 0.12616673, -0.00020053257, -0.00025246502, 0.15335001, 0.028658161, 0.4475837, 0.1297091, 0.0033283953, 0.08408493, 0.763354, -0.06643723, -0.009628464, 0.26448366, -0.0051665693, 0.11316934, 0.012592981, -0.11271672, 0.004697036, 0.0028787327
    };

    bout = {
      -3.3131504, -2.4629805, -2.037252, -1.0327406, -1.4157845, -1.7684613, -2.725984, -2.8829994, -0.9643416, -0.8849854, 0.41426018, -0.63114333, -0.8694352, -2.4499555, -2.3565216, -0.92668915, 0.7353992, 1.079801, 0.63720113, -0.9683525, -1.9810324, -1.6668017, 0.14017141, 1.13362, 2.7705, 0.9497318, -0.095423594, -1.5799197, -2.1906607, -0.7154884, 0.76260936, 1.2724051, 0.6939598, -0.95049363, -2.2231054, -2.5306032, -0.7568879, -0.4965481, 0.6007382, -0.5334058, -0.84932417, -2.491522, -2.6422727, -1.7688118, -1.2677174, -0.7936714, -1.4443916, -1.9690944, -2.8440943
    };

    BN_gamma_in = {
      0.66414315, 0.087717295, 0.09027445, 0.18313819, 0.5336265, 0.31388438, 0.8485791, 0.5515298, 0.98288023
    };

    BN_gamma_1 = {
      3.5787385, 9.070073, 3.5187979, 1.4837271, 8.590108, 3.0723014, 22.098326, 6.6215467, 5.8599186, 4.3705406, -5.467495, 5.293933, 4.2537994, 4.6933136, 8.914585, 6.587312, 2.3396723, -5.020007, 3.136769, 10.567596, 5.5392127, 23.91258
    };

    BN_gamma_2 = {
      3.0147715, 3.1359296, 2.8814158, 2.3162198, 1.4241488, 4.525791, -1.1059378, 2.6940444, 7.2297626, 2.1813066, 1.0799968, 1.9830679, 4.8048987, 0.75247777, 1.8303784, 2.1325297, 2.991797, 5.866069, 4.5636625, -4.1626396
    };

    BN_beta_1 = {
      -0.02324522, -0.02654433, -0.061089195, -0.23854026, -0.010023108, -0.0043023583, -0.010376182, -0.041079883, -0.008734352, -0.020780468, 0.005439666, -0.03399022, -0.0076004476, -0.02694591, -0.021450635, -0.02012959, -0.22669512, 0.03046497, -0.27948585, -0.012470238, -0.00784889, -0.005809354
    };

    BN_beta_2 = {
      -0.2630594, -0.32949853, -0.102005385, -0.07609386, -0.19329932, -0.29237872, 0.42327935, -0.38829783, -0.23904246, -0.1760325, -0.7746258, -0.0323519, -0.21930622, -0.19888891, -0.100393936, -0.34020358, -0.08057859, -0.03910762, -0.1481675, 0.08375966
    };
    
    mean = {
      93058.161507703,61482.497728084745,92226.50527981958,63921.83768267968,19462.104317431003,65292.65234582706,91289.64724973585,61746.44742855567,94028.54672479484
    };

    stdev = {
      697478.1427514413,603266.34924219,693247.8345642344,605341.8136028602,526842.1535146936,606487.0708992897,693607.965629,604117.883277759,698683.9402648382
    };
  }
  
}


__inline Void TEncSearch::xTZSearchHelp( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const Int iSearchX, const Int iSearchY, const UChar ucPointNr, const UInt uiDistance )
{
  Distortion  uiSad = 0;

  const Pel* const  piRefSrch = rcStruct.piRefY + iSearchY * rcStruct.iYStride + iSearchX;

  //-- jclee for using the SAD function pointer
  m_pcRdCost->setDistParam( pcPatternKey, piRefSrch, rcStruct.iYStride,  m_cDistParam );

  setDistParamComp(COMPONENT_Y);

  // distortion
  m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
  m_cDistParam.m_maximumDistortionForEarlyExit = rcStruct.uiBestSad;

  if((m_pcEncCfg->getRestrictMESampling() == false) && m_pcEncCfg->getMotionEstimationSearchMethod() == MESEARCH_SELECTIVE)
  {
    Int isubShift = 0;
    // motion cost
    Distortion uiBitCost = m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

    // Skip search if bit cost is already larger than best SAD
    if (uiBitCost < rcStruct.uiBestSad)
    {
      if ( m_cDistParam.iRows > 32 )
      {
        m_cDistParam.iSubShift = 4;
      }
      else if ( m_cDistParam.iRows > 16 )
      {
        m_cDistParam.iSubShift = 3;
      }
      else if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 2;
      }
      else
      {
        m_cDistParam.iSubShift = 1;
      }

      Distortion uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
      if((uiTempSad + uiBitCost) < rcStruct.uiBestSad)
      {
        uiSad += uiTempSad >>  m_cDistParam.iSubShift;
        while(m_cDistParam.iSubShift > 0)
        {
          isubShift         = m_cDistParam.iSubShift -1;
          m_cDistParam.pOrg = pcPatternKey->getROIY() + (pcPatternKey->getPatternLStride() << isubShift);
          m_cDistParam.pCur = piRefSrch + (rcStruct.iYStride << isubShift);
          uiTempSad = m_cDistParam.DistFunc( &m_cDistParam );
          uiSad += uiTempSad >>  m_cDistParam.iSubShift;
          if(((uiSad << isubShift) + uiBitCost) > rcStruct.uiBestSad)
          {
            break;
          }

          m_cDistParam.iSubShift--;
        }

        if(m_cDistParam.iSubShift == 0)
        {
          uiSad += uiBitCost;
          if( uiSad < rcStruct.uiBestSad )
          {
            rcStruct.uiBestSad      = uiSad;
            rcStruct.iBestX         = iSearchX;
            rcStruct.iBestY         = iSearchY;
            rcStruct.uiBestDistance = uiDistance;
            rcStruct.uiBestRound    = 0;
            rcStruct.ucPointNr      = ucPointNr;
            m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
          }
        }
      }
    }
  }
  else
  {
    // fast encoder decision: use subsampled SAD when rows > 8 for integer ME
    if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE3 )
    {
      if ( m_cDistParam.iRows > 8 )
      {
        m_cDistParam.iSubShift = 1;
      }
    }

    uiSad = m_cDistParam.DistFunc( &m_cDistParam );

    // EMI: Modification "array_e & counter_i"
    array_e[counter_i] = uiSad;
    
    // only add motion cost if uiSad is smaller than best. Otherwise pointless
    // to add motion cost.
    if( uiSad < rcStruct.uiBestSad )
    {
      // motion cost
      uiSad += m_pcRdCost->getCostOfVectorWithPredictor( iSearchX, iSearchY );

      if( uiSad < rcStruct.uiBestSad )
      {
        rcStruct.uiBestSad      = uiSad;
        rcStruct.iBestX         = iSearchX;
        rcStruct.iBestY         = iSearchY;
        rcStruct.uiBestDistance = uiDistance;
        rcStruct.uiBestRound    = 0;
        rcStruct.ucPointNr      = ucPointNr;
        m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
      }
    }
  }
  counter_i = counter_i + 1;
}

__inline Void TEncSearch::xTZ2PointSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB )
{
  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 2 point search,                   //   1 2 3
  // check only the 2 untested points  //   4 0 5
  // around the start point            //   6 7 8
  Int iStartX = rcStruct.iBestX;
  Int iStartY = rcStruct.iBestY;
  switch( rcStruct.ucPointNr )
  {
    case 1:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY, 0, 2 );
      }
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
    }
      break;
    case 2:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 3:
    {
      if ( (iStartY - 1) >= iSrchRngVerTop )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY - 1, 0, 2 );
      }
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
    }
      break;
    case 4:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY - 1, 0, 2 );
        }
      }
    }
      break;
    case 5:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        if ( (iStartY - 1) >= iSrchRngVerTop )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY - 1, 0, 2 );
        }
        if ( (iStartY + 1) <= iSrchRngVerBottom )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 6:
    {
      if ( (iStartX - 1) >= iSrchRngHorLeft )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY , 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    case 7:
    {
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        if ( (iStartX - 1) >= iSrchRngHorLeft )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iStartY + 1, 0, 2 );
        }
        if ( (iStartX + 1) <= iSrchRngHorRight )
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY + 1, 0, 2 );
        }
      }
    }
      break;
    case 8:
    {
      if ( (iStartX + 1) <= iSrchRngHorRight )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iStartY, 0, 2 );
      }
      if ( (iStartY + 1) <= iSrchRngVerBottom )
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iStartY + 1, 0, 2 );
      }
    }
      break;
    default:
    {
      assert( false );
    }
      break;
  } // switch( rcStruct.ucPointNr )
}




__inline Void TEncSearch::xTZ8PointSquareSearch( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iTop >= iSrchRngVerTop ) // check top
  {
    if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
    }
    // top middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );

    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
    }
  } // check top
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
  }
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
  }
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
    if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
    }
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );

    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
    }
  } // check bottom
}


//additing other square search

__inline Void TEncSearch::xTZ8PointSquareSearch2( const TComPattern* const pcPatternKey, IntTZSearchStruct& rcStruct, const TComMv* const pcMvSrchRngLT, const TComMv* const pcMvSrchRngRB, const Int iStartX, const Int iStartY, const Int iDist )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;
// check top
  if ( iTop >= iSrchRngVerTop ) // check top
  {
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iLeft, iTop, 9, iDist);
    }
	  
	 if ( iLeft >= iSrchRngHorLeft ) // check top left
    {
		xTZSearchHelp(pcPatternKey, rcStruct, iStartX - 1, iTop, 10, iDist);
    }
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 11, iDist );
	
	if (iRight <= iSrchRngHorRight) // check top left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX +1, iTop, 12, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check top right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 13, iDist );
    }
  }

  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY-1, 14, iDist );
  }

  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY-1, 15, iDist );
  }
  
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 16, iDist );
  }
  
  
  if ( iRight <= iSrchRngHorRight ) // check middle right
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 17, iDist );
  }
  
  if ( iLeft >= iSrchRngHorLeft ) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY+1, 18, iDist );
  }
  
  if (iRight <= iSrchRngHorRight) // check middle left
  {
    xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY+1, 19, iDist );
  }
  
  
  
  if ( iBottom <= iSrchRngVerBottom ) // check bottom
  {
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 20, iDist );
    }  
	  
	if ( iLeft >= iSrchRngHorLeft ) // check bottom left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX - 1, iBottom, 21, iDist );
    }   
	  
	  
    
    // check bottom middle
    xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 22, iDist );

	if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iStartX + 1, iBottom, 23, iDist );
    }
	
    if ( iRight <= iSrchRngHorRight ) // check bottom right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 24, iDist );
    }
  } 
  
  // check bottom
}











__inline Void TEncSearch::xTZ8PointDiamondSearch( const TComPattern*const  pcPatternKey,
                                                  IntTZSearchStruct& rcStruct,
                                                  const TComMv*const  pcMvSrchRngLT,
                                                  const TComMv*const  pcMvSrchRngRB,
                                                  const Int iStartX,
                                                  const Int iStartY,
                                                  const Int iDist,
                                                  const Bool bCheckCornersAtDist1 )
{
  const Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  const Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  const Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  const Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  // 8 point search,                   //   1 2 3
  // search around the start point     //   4 0 5
  // with the required  distance       //   6 7 8
  assert ( iDist != 0 );
  const Int iTop        = iStartY - iDist;
  const Int iBottom     = iStartY + iDist;
  const Int iLeft       = iStartX - iDist;
  const Int iRight      = iStartX + iDist;
  rcStruct.uiBestRound += 1;

  if ( iDist == 1 )
  {
    if ( iTop >= iSrchRngVerTop ) // check top
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iTop, 1, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iTop, 3, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
      }
    }
    if ( iLeft >= iSrchRngHorLeft ) // check middle left
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
    }
    if ( iRight <= iSrchRngHorRight ) // check middle right
    {
      xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
    }
    if ( iBottom <= iSrchRngVerBottom ) // check bottom
    {
      if (bCheckCornersAtDist1)
      {
        if ( iLeft >= iSrchRngHorLeft) // check top-left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iBottom, 6, iDist );
        }
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        if ( iRight <= iSrchRngHorRight ) // check middle right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iBottom, 8, iDist );
        }
      }
      else
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
      }
    }
  }
  else
  {
    if ( iDist <= 8 )
    {
      const Int iTop_2      = iStartY - (iDist>>1);
      const Int iBottom_2   = iStartY + (iDist>>1);
      const Int iLeft_2     = iStartX - (iDist>>1);
      const Int iRight_2    = iStartX + (iDist>>1);

      if (  iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iTop,      2, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iTop_2,    1, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2,    3, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,    iStartY,   4, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,   iStartY,   5, iDist    );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2,  iBottom_2, 6, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, iDist>>1 );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX,  iBottom,   7, iDist    );
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 2, iDist );
        }
        if ( iTop_2 >= iSrchRngVerTop ) // check half top
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iTop_2, 1, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iTop_2, 3, (iDist>>1) );
          }
        } // check half top
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 4, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 5, iDist );
        }
        if ( iBottom_2 <= iSrchRngVerBottom ) // check half bottom
        {
          if ( iLeft_2 >= iSrchRngHorLeft ) // check half left
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iLeft_2, iBottom_2, 6, (iDist>>1) );
          }
          if ( iRight_2 <= iSrchRngHorRight ) // check half right
          {
            xTZSearchHelp( pcPatternKey, rcStruct, iRight_2, iBottom_2, 8, (iDist>>1) );
          }
        } // check half bottom
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 7, iDist );
        }
      } // check border
    }
    else // iDist > 8
    {
      if ( iTop >= iSrchRngVerTop && iLeft >= iSrchRngHorLeft &&
          iRight <= iSrchRngHorRight && iBottom <= iSrchRngVerBottom ) // check border
      {
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop,    0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iLeft,   iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iRight,  iStartY, 0, iDist );
        xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
          xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
        }
      }
      else // check border
      {
        if ( iTop >= iSrchRngVerTop ) // check top
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iTop, 0, iDist );
        }
        if ( iLeft >= iSrchRngHorLeft ) // check left
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iLeft, iStartY, 0, iDist );
        }
        if ( iRight <= iSrchRngHorRight ) // check right
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iRight, iStartY, 0, iDist );
        }
        if ( iBottom <= iSrchRngVerBottom ) // check bottom
        {
          xTZSearchHelp( pcPatternKey, rcStruct, iStartX, iBottom, 0, iDist );
        }
        for ( Int index = 1; index < 4; index++ )
        {
          const Int iPosYT = iTop    + ((iDist>>2) * index);
          const Int iPosYB = iBottom - ((iDist>>2) * index);
          const Int iPosXL = iStartX - ((iDist>>2) * index);
          const Int iPosXR = iStartX + ((iDist>>2) * index);

          if ( iPosYT >= iSrchRngVerTop ) // check top
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYT, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYT, 0, iDist );
            }
          } // check top
          if ( iPosYB <= iSrchRngVerBottom ) // check bottom
          {
            if ( iPosXL >= iSrchRngHorLeft ) // check left
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXL, iPosYB, 0, iDist );
            }
            if ( iPosXR <= iSrchRngHorRight ) // check right
            {
              xTZSearchHelp( pcPatternKey, rcStruct, iPosXR, iPosYB, 0, iDist );
            }
          } // check bottom
        } // for ...
      } // check border
    } // iDist <= 8
  } // iDist == 1
}

Distortion TEncSearch::xPatternRefinement( TComPattern* pcPatternKey,
                                           TComMv baseRefMv,
                                           Int iFrac, TComMv& rcMvFrac,
                                           Bool bAllowUseOfHadamard
                                         )
{
  Distortion  uiDist;
  Distortion  uiDistBest  = std::numeric_limits<Distortion>::max();
  UInt        uiDirecBest = 0;

  Pel*  piRefPos;
  Int iRefStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);

  m_pcRdCost->setDistParam( pcPatternKey, m_filteredBlock[0][0].getAddr(COMPONENT_Y), iRefStride, 1, m_cDistParam, m_pcEncCfg->getUseHADME() && bAllowUseOfHadamard );

  const TComMv* pcMvRefine = (iFrac == 2 ? s_acMvRefineH : s_acMvRefineQ);

  for (UInt i = 0; i < 9; i++)
  {
    TComMv cMvTest = pcMvRefine[i];
    cMvTest += baseRefMv;

    Int horVal = cMvTest.getHor() * iFrac;
    Int verVal = cMvTest.getVer() * iFrac;
    piRefPos = m_filteredBlock[ verVal & 3 ][ horVal & 3 ].getAddr(COMPONENT_Y);
    if ( horVal == 2 && ( verVal & 1 ) == 0 )
    {
      piRefPos += 1;
    }
    if ( ( horVal & 1 ) == 0 && verVal == 2 )
    {
      piRefPos += iRefStride;
    }
    cMvTest = pcMvRefine[i];
    cMvTest += rcMvFrac;

    setDistParamComp(COMPONENT_Y);

    m_cDistParam.pCur = piRefPos;
    m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
    uiDist = m_cDistParam.DistFunc( &m_cDistParam );
    uiDist += m_pcRdCost->getCostOfVectorWithPredictor( cMvTest.getHor(), cMvTest.getVer() );

    if ( uiDist < uiDistBest )
    {
      uiDistBest  = uiDist;
      uiDirecBest = i;
      m_cDistParam.m_maximumDistortionForEarlyExit = uiDist;
    }
  }

  rcMvFrac = pcMvRefine[uiDirecBest];

  return uiDistBest;
}



Void
TEncSearch::xEncSubdivCbfQT(TComTU      &rTu,
                            Bool         bLuma,
                            Bool         bChroma )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx         = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth            = rTu.GetTransformDepthRel();
  const UInt uiTrMode             = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt uiSubdiv             = ( uiTrMode > uiTrDepth ? 1 : 0 );
  const UInt uiLog2LumaTrafoSize  = rTu.GetLog2LumaTrSize();

  if( pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_NxN && uiTrDepth == 0 )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize > pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() )
  {
    assert( uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getSlice()->getSPS()->getQuadtreeTULog2MinSize() )
  {
    assert( !uiSubdiv );
  }
  else if( uiLog2LumaTrafoSize == pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
  {
    assert( !uiSubdiv );
  }
  else
  {
    assert( uiLog2LumaTrafoSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );
    if( bLuma )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( uiSubdiv, 5 - uiLog2LumaTrafoSize );
    }
  }

  if ( bChroma )
  {
    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if( rTu.ProcessingAllQuadrants(compID) && (uiTrDepth==0 || pcCU->getCbf( uiAbsPartIdx, compID, uiTrDepth-1 ) ))
      {
        m_pcEntropyCoder->encodeQtCbf(rTu, compID, (uiSubdiv == 0));
      }
    }
  }

  if( uiSubdiv )
  {
    TComTURecurse tuRecurse(rTu, false);
    do
    {
      xEncSubdivCbfQT( tuRecurse, bLuma, bChroma );
    } while (tuRecurse.nextSection(rTu));
  }
  else
  {
    //===== Cbfs =====
    if( bLuma )
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }
}




Void
TEncSearch::xEncCoeffQT(TComTU &rTu,
                        const ComponentID  component,
                        Bool         bRealCoeff )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();

  const UInt  uiTrMode        = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt  uiSubdiv        = ( uiTrMode > uiTrDepth ? 1 : 0 );

  if( uiSubdiv )
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xEncCoeffQT( tuRecurseChild, component, bRealCoeff );
    } while (tuRecurseChild.nextSection(rTu) );
  }
  else if (rTu.ProcessComponentSection(component))
  {
    //===== coefficients =====
    const UInt  uiLog2TrafoSize = rTu.GetLog2LumaTrSize();
    UInt    uiCoeffOffset   = rTu.getCoefficientOffset(component);
    UInt    uiQTLayer       = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrafoSize;
    TCoeff* pcCoeff         = bRealCoeff ? pcCU->getCoeff(component) : m_ppcQTTempCoeff[component][uiQTLayer];

    if (isChroma(component) && (pcCU->getCbf( rTu.GetAbsPartIdxTU(), COMPONENT_Y, uiTrMode ) != 0) && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag() )
    {
      m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, component );
    }

    m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeff+uiCoeffOffset, component );
  }
}




Void
TEncSearch::xEncIntraHeader( TComDataCU*  pcCU,
                            UInt         uiTrDepth,
                            UInt         uiAbsPartIdx,
                            Bool         bLuma,
                            Bool         bChroma )
{
  if( bLuma )
  {
    // CU header
    if( uiAbsPartIdx == 0 )
    {
      if( !pcCU->getSlice()->isIntra() )
      {
        if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
        {
          m_pcEntropyCoder->encodeCUTransquantBypassFlag( pcCU, 0, true );
        }
        m_pcEntropyCoder->encodeSkipFlag( pcCU, 0, true );
        m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
      }
      m_pcEntropyCoder  ->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );

      if (pcCU->isIntra(0) && pcCU->getPartitionSize(0) == SIZE_2Nx2N )
      {
        m_pcEntropyCoder->encodeIPCMInfo( pcCU, 0, true );

        if ( pcCU->getIPCMFlag (0))
        {
          return;
        }
      }
    }
    // luma prediction mode
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N )
    {
      if (uiAbsPartIdx==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, 0 );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      if (uiTrDepth>0 && (uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiAbsPartIdx );
      }
    }
  }

  if( bChroma )
  {
    if( pcCU->getPartitionSize(0) == SIZE_2Nx2N || !enable4ChromaPUsInIntraNxNCU(pcCU->getPic()->getChromaFormat()))
    {
      if(uiAbsPartIdx==0)
      {
         m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
    else
    {
      UInt uiQNumParts = pcCU->getTotalNumPart() >> 2;
      assert(uiTrDepth>0);
      if ((uiAbsPartIdx%uiQNumParts)==0)
      {
        m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiAbsPartIdx );
      }
    }
  }
}




UInt
TEncSearch::xGetIntraBitsQT(TComTU &rTu,
                            Bool         bLuma,
                            Bool         bChroma,
                            Bool         bRealCoeff /* just for test */ )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth=rTu.GetTransformDepthRel();
  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiTrDepth, uiAbsPartIdx, bLuma, bChroma );
  xEncSubdivCbfQT ( rTu, bLuma, bChroma );

  if( bLuma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Y,      bRealCoeff );
  }
  if( bChroma )
  {
    xEncCoeffQT   ( rTu, COMPONENT_Cb,  bRealCoeff );
    xEncCoeffQT   ( rTu, COMPONENT_Cr,  bRealCoeff );
  }
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  return uiBits;
}

UInt TEncSearch::xGetIntraBitsQTChroma(TComTU &rTu,
                                       ComponentID compID,
                                       Bool         bRealCoeff /* just for test */ )
{
  m_pcEntropyCoder->resetBits();
  xEncCoeffQT   ( rTu, compID,  bRealCoeff );
  UInt   uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  return uiBits;
}

Void TEncSearch::xIntraCodingTUBlock(       TComYuv*    pcOrgYuv,
                                            TComYuv*    pcPredYuv,
                                            TComYuv*    pcResiYuv,
                                            Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      const Bool        checkCrossCPrediction,
                                            Distortion& ruiDist,
                                      const ComponentID compID,
                                            TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug)
                                           ,Int         default0Save1Load2
                                     )
{
  if (!rTu.ProcessComponentSection(compID))
  {
    return;
  }
  const Bool           bIsLuma          = isLuma(compID);
  const TComRectangle &rect             = rTu.getRect(compID);
        TComDataCU    *pcCU             = rTu.getCU();
  const UInt           uiAbsPartIdx     = rTu.GetAbsPartIdxTU();
  const TComSPS       &sps              = *(pcCU->getSlice()->getSPS());

  const UInt           uiTrDepth        = rTu.GetTransformDepthRelAdj(compID);
  const UInt           uiFullDepth      = rTu.GetTransformDepthTotal();
  const UInt           uiLog2TrSize     = rTu.GetLog2LumaTrSize();
  const ChromaFormat   chFmt            = pcOrgYuv->getChromaFormat();
  const ChannelType    chType           = toChannelType(compID);
  const Int            bitDepth         = sps.getBitDepth(chType);

  const UInt           uiWidth          = rect.width;
  const UInt           uiHeight         = rect.height;
  const UInt           uiStride         = pcOrgYuv ->getStride (compID);
        Pel           *piOrg            = pcOrgYuv ->getAddr( compID, uiAbsPartIdx );
        Pel           *piPred           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piResi           = pcResiYuv->getAddr( compID, uiAbsPartIdx );
        Pel           *piReco           = pcPredYuv->getAddr( compID, uiAbsPartIdx );
  const UInt           uiQTLayer        = sps.getQuadtreeTULog2MaxSize() - uiLog2TrSize;
        Pel           *piRecQt          = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
  const UInt           uiRecQtStride    = m_pcQTTempTComYuv[ uiQTLayer ].getStride(compID);
  const UInt           uiZOrder         = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
        Pel           *piRecIPred       = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
        UInt           uiRecIPredStride = pcCU->getPic()->getPicYuvRec()->getStride  ( compID );
        TCoeff        *pcCoeff          = m_ppcQTTempCoeff[compID][uiQTLayer] + rTu.getCoefficientOffset(compID);
        Bool           useTransformSkip = pcCU->getTransformSkip(uiAbsPartIdx, compID);

#if ADAPTIVE_QP_SELECTION
        TCoeff        *pcArlCoeff       = m_ppcQTTempArlCoeff[compID][ uiQTLayer ] + rTu.getCoefficientOffset(compID);
#endif

  const UInt           uiChPredMode     = pcCU->getIntraDir( chType, uiAbsPartIdx );
  const UInt           partsPerMinCU    = 1<<(2*(sps.getMaxTotalCUDepth() - sps.getLog2DiffMaxMinCodingBlockSize()));
  const UInt           uiChCodedMode    = (uiChPredMode==DM_CHROMA_IDX && !bIsLuma) ? pcCU->getIntraDir(CHANNEL_TYPE_LUMA, getChromasCorrespondingPULumaIdx(uiAbsPartIdx, chFmt, partsPerMinCU)) : uiChPredMode;
  const UInt           uiChFinalMode    = ((chFmt == CHROMA_422)       && !bIsLuma) ? g_chroma422IntraAngleMappingTable[uiChCodedMode] : uiChCodedMode;

  const Int            blkX                                 = g_auiRasterToPelX[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            blkY                                 = g_auiRasterToPelY[ g_auiZscanToRaster[ uiAbsPartIdx ] ];
  const Int            bufferOffset                         = blkX + (blkY * MAX_CU_SIZE);
        Pel  *const    encoderLumaResidual                  = resiLuma[RESIDUAL_ENCODER_SIDE ] + bufferOffset;
        Pel  *const    reconstructedLumaResidual            = resiLuma[RESIDUAL_RECONSTRUCTED] + bufferOffset;
  const Bool           bUseCrossCPrediction                 = isChroma(compID) && (uiChPredMode == DM_CHROMA_IDX) && checkCrossCPrediction;
  const Bool           bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
        Pel *const     lumaResidualForEstimate              = bUseReconstructedResidualForEstimate ? reconstructedLumaResidual : encoderLumaResidual;

#if DEBUG_STRING
  const Int debugPredModeMask=DebugStringGetPredModeMask(MODE_INTRA);
#endif

  //===== init availability pattern =====
  DEBUG_STRING_NEW(sTemp)

#if !DEBUG_STRING
  if( default0Save1Load2 != 2 )
#endif
  {
    const Bool bUseFilteredPredictions=TComPrediction::filteringIntraReferenceSamples(compID, uiChFinalMode, uiWidth, uiHeight, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

    initIntraPatternChType( rTu, compID, bUseFilteredPredictions DEBUG_STRING_PASS_INTO(sDebug) );

    //===== get prediction signal =====
    predIntraAng( compID, uiChFinalMode, piOrg, uiStride, piPred, uiStride, rTu, bUseFilteredPredictions );

    // save prediction
    if( default0Save1Load2 == 1 )
    {
      Pel*  pPred   = piPred;
      Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
      Int k = 0;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pPredBuf[ k ++ ] = pPred[ uiX ];
        }
        pPred += uiStride;
      }
    }
  }
#if !DEBUG_STRING
  else
  {
    // load prediction
    Pel*  pPred   = piPred;
    Pel*  pPredBuf = m_pSharedPredTransformSkip[compID];
    Int k = 0;
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pPred[ uiX ] = pPredBuf[ k ++ ];
      }
      pPred += uiStride;
    }
  }
#endif

  //===== get residual signal =====
  {
    // get residual
    Pel*  pOrg    = piOrg;
    Pel*  pPred   = piPred;
    Pel*  pResi   = piResi;

    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        pResi[ uiX ] = pOrg[ uiX ] - pPred[ uiX ];
      }

      pOrg  += uiStride;
      pResi += uiStride;
      pPred += uiStride;
    }
  }

  if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
  {
    if (bUseCrossCPrediction)
    {
      if (xCalcCrossComponentPredictionAlpha( rTu, compID, lumaResidualForEstimate, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride ) == 0)
      {
        return;
      }
      TComTrQuant::crossComponentPrediction ( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, false );
    }
    else if (isLuma(compID) && !bUseReconstructedResidualForEstimate)
    {
      xStoreCrossComponentPredictionResult( encoderLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
    }
  }

  //===== transform and quantization =====
  //--- init rate estimation arrays for RDOQ ---
  if( useTransformSkip ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ() )
  {
    m_pcEntropyCoder->estimateBit( m_pcTrQuant->m_pcEstBitsSbac, uiWidth, uiHeight, chType );
  }

  //--- transform and quantization ---
  TCoeff uiAbsSum = 0;
  if (bIsLuma)
  {
    pcCU       ->setTrIdxSubParts ( uiTrDepth, uiAbsPartIdx, uiFullDepth );
  }

  const QpParam cQP(*pcCU, compID);

#if RDOQ_CHROMA_LAMBDA
  m_pcTrQuant->selectLambda     (compID);
#endif

  m_pcTrQuant->transformNxN     ( rTu, compID, piResi, uiStride, pcCoeff,
#if ADAPTIVE_QP_SELECTION
    pcArlCoeff,
#endif
    uiAbsSum, cQP
    );

  //--- inverse transform ---

#if DEBUG_STRING
  if ( (uiAbsSum > 0) || (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask) )
#else
  if ( uiAbsSum > 0 )
#endif
  {
    m_pcTrQuant->invTransformNxN ( rTu, compID, piResi, uiStride, pcCoeff, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sDebug, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );
  }
  else
  {
    Pel* pResi = piResi;
    memset( pcCoeff, 0, sizeof( TCoeff ) * uiWidth * uiHeight );
    for( UInt uiY = 0; uiY < uiHeight; uiY++ )
    {
      memset( pResi, 0, sizeof( Pel ) * uiWidth );
      pResi += uiStride;
    }
  }


  //===== reconstruction =====
  {
    Pel* pPred      = piPred;
    Pel* pResi      = piResi;
    Pel* pReco      = piReco;
    Pel* pRecQt     = piRecQt;
    Pel* pRecIPred  = piRecIPred;

    if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
    {
      if (bUseCrossCPrediction)
      {
        TComTrQuant::crossComponentPrediction( rTu, compID, reconstructedLumaResidual, piResi, piResi, uiWidth, uiHeight, MAX_CU_SIZE, uiStride, uiStride, true );
      }
      else if (isLuma(compID))
      {
        xStoreCrossComponentPredictionResult( reconstructedLumaResidual, piResi, rTu, 0, 0, MAX_CU_SIZE, uiStride );
      }
    }

 #if DEBUG_STRING
    std::stringstream ss(stringstream::out);
    const Bool bDebugPred=((DebugOptionList::DebugString_Pred.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugResi=((DebugOptionList::DebugString_Resi.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));
    const Bool bDebugReco=((DebugOptionList::DebugString_Reco.getInt()&debugPredModeMask) && DEBUG_STRING_CHANNEL_CONDITION(compID));

    if (bDebugPred || bDebugResi || bDebugReco)
    {
      ss << "###: " << "CompID: " << compID << " pred mode (ch/fin): " << uiChPredMode << "/" << uiChFinalMode << " absPartIdx: " << rTu.GetAbsPartIdxTU() << "\n";
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        ss << "###: ";
        if (bDebugPred)
        {
          ss << " - pred: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pPred[ uiX ] << ", ";
          }
        }
        if (bDebugResi)
        {
          ss << " - resi: ";
        }
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          if (bDebugResi)
          {
            ss << pResi[ uiX ] << ", ";
          }
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        if (bDebugReco)
        {
          ss << " - reco: ";
          for( UInt uiX = 0; uiX < uiWidth; uiX++ )
          {
            ss << pReco[ uiX ] << ", ";
          }
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
        ss << "\n";
      }
      DEBUG_STRING_APPEND(sDebug, ss.str())
    }
    else
#endif
    {

      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pReco    [ uiX ] = Pel(ClipBD<Int>( Int(pPred[uiX]) + Int(pResi[uiX]), bitDepth ));
          pRecQt   [ uiX ] = pReco[ uiX ];
          pRecIPred[ uiX ] = pReco[ uiX ];
        }
        pPred     += uiStride;
        pResi     += uiStride;
        pReco     += uiStride;
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }

  //===== update distortion =====
  ruiDist += m_pcRdCost->getDistPart( bitDepth, piReco, uiStride, piOrg, uiStride, uiWidth, uiHeight, compID );
}




Void
TEncSearch::xRecurIntraCodingLumaQT(TComYuv*    pcOrgYuv,
                                    TComYuv*    pcPredYuv,
                                    TComYuv*    pcResiYuv,
                                    Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                    Distortion& ruiDistY,
#if HHI_RQT_INTRA_SPEEDUP
                                    Bool        bCheckFirst,
#endif
                                    Double&     dRDCost,
                                    TComTU&     rTu
                                    DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU   *pcCU          = rTu.getCU();
  const UInt    uiAbsPartIdx  = rTu.GetAbsPartIdxTU();
  const UInt    uiFullDepth   = rTu.GetTransformDepthTotal();
  const UInt    uiTrDepth     = rTu.GetTransformDepthRel();
  const UInt    uiLog2TrSize  = rTu.GetLog2LumaTrSize();
        Bool    bCheckFull    = ( uiLog2TrSize  <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
        Bool    bCheckSplit   = ( uiLog2TrSize  >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

        Pel     resiLumaSplit [NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];
        Pel     resiLumaSingle[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

#if HHI_RQT_INTRA_SPEEDUP
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // don't check split if TU size is less or equal to max TU size
  Bool noSplitIntraMaxTuSize = bCheckFull;
  if(m_pcEncCfg->getRDpenalty() && ! isIntraSlice)
  {
    // in addition don't check split if TU size is less or equal to 16x16 TU size for non-intra slice
    noSplitIntraMaxTuSize = ( uiLog2TrSize  <= min(maxTuSize,4) );

    // if maximum RD-penalty don't check TU size 32x32
    if(m_pcEncCfg->getRDpenalty()==2)
    {
      bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
    }
  }
  if( bCheckFirst && noSplitIntraMaxTuSize )

  {
    bCheckSplit = false;
  }
#else
  Int maxTuSize = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize();
  Int isIntraSlice = (pcCU->getSlice()->getSliceType() == I_SLICE);
  // if maximum RD-penalty don't check TU size 32x32
  if((m_pcEncCfg->getRDpenalty()==2)  && !isIntraSlice)
  {
    bCheckFull    = ( uiLog2TrSize  <= min(maxTuSize,4));
  }
#endif
  Double     dSingleCost                        = MAX_DOUBLE;
  Distortion uiSingleDistLuma                   = 0;
  UInt       uiSingleCbfLuma                    = 0;
  Bool       checkTransformSkip  = pcCU->getSlice()->getPPS()->getUseTransformSkip();
  Int        bestModeId[MAX_NUM_COMPONENT] = { 0, 0, 0};
  checkTransformSkip           &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());
  checkTransformSkip           &= (!pcCU->getCUTransquantBypass(0));

  assert (rTu.ProcessComponentSection(COMPONENT_Y));
  const UInt totalAdjustedDepthChan   = rTu.GetTransformDepthTotalAdj(COMPONENT_Y);

  if ( m_pcEncCfg->getUseTransformSkipFast() )
  {
    checkTransformSkip       &= (pcCU->getPartitionSize(uiAbsPartIdx)==SIZE_NxN);
  }

  if( bCheckFull )
  {
    if(checkTransformSkip == true)
    {
      //----- store original entropy coding status -----
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );

      Distortion singleDistTmpLuma                    = 0;
      UInt       singleCbfTmpLuma                     = 0;
      Double     singleCostTmp                        = 0;
      Int        firstCheckId                         = 0;

      for(Int modeId = firstCheckId; modeId < 2; modeId ++)
      {
        DEBUG_STRING_NEW(sModeString)
        Int  default0Save1Load2 = 0;
        singleDistTmpLuma=0;
        if(modeId == firstCheckId)
        {
          default0Save1Load2 = 1;
        }
        else
        {
          default0Save1Load2 = 2;
        }


        pcCU->setTransformSkipSubParts ( modeId, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
        xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, singleDistTmpLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sModeString), default0Save1Load2 );

        singleCbfTmpLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );

        //----- determine rate and r-d cost -----
        if(modeId == 1 && singleCbfTmpLuma == 0)
        {
          //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
          singleCostTmp = MAX_DOUBLE;
        }
        else
        {
          UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );
          singleCostTmp     = m_pcRdCost->calcRdCost( uiSingleBits, singleDistTmpLuma );
        }
        if(singleCostTmp < dSingleCost)
        {
          DEBUG_STRING_SWAP(sDebug, sModeString)
          dSingleCost   = singleCostTmp;
          uiSingleDistLuma = singleDistTmpLuma;
          uiSingleCbfLuma = singleCbfTmpLuma;

          bestModeId[COMPONENT_Y] = modeId;
          if(bestModeId[COMPONENT_Y] == firstCheckId)
          {
            xStoreIntraResultQT(COMPONENT_Y, rTu );
            m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
          }

          if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
          {
            const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
            const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
            for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
            {
              if (bMaintainResidual[storedResidualIndex])
              {
                xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
              }
            }
          }
        }
        if (modeId == firstCheckId)
        {
          m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
        }
      }

      pcCU ->setTransformSkipSubParts ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

      if(bestModeId[COMPONENT_Y] == firstCheckId)
      {
        xLoadIntraResultQT(COMPONENT_Y, rTu );
        pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, rTu.GetTransformDepthTotalAdj(COMPONENT_Y) );

        m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
      }
    }
    else
    {
      //----- store original entropy coding status -----
      if( bCheckSplit )
      {
        m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
      }
      //----- code luma/chroma block with given intra prediction mode and store Cbf-----
      dSingleCost   = 0.0;

      pcCU ->setTransformSkipSubParts ( 0, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
      xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSingle, false, uiSingleDistLuma, COMPONENT_Y, rTu DEBUG_STRING_PASS_INTO(sDebug));

      if( bCheckSplit )
      {
        uiSingleCbfLuma = pcCU->getCbf( uiAbsPartIdx, COMPONENT_Y, uiTrDepth );
      }
      //----- determine rate and r-d cost -----
      UInt uiSingleBits = xGetIntraBitsQT( rTu, true, false, false );

      if(m_pcEncCfg->getRDpenalty() && (uiLog2TrSize==5) && !isIntraSlice)
      {
        uiSingleBits=uiSingleBits*4;
      }

      dSingleCost       = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDistLuma );

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSingle[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }
    }
  }

  if( bCheckSplit )
  {
    //----- store full entropy coding status, load original entropy coding status -----
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    else
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    //----- code splitted block -----
    Double     dSplitCost      = 0.0;
    Distortion uiSplitDistLuma = 0;
    UInt       uiSplitCbfLuma  = 0;

    TComTURecurse tuRecurseChild(rTu, false);
    DEBUG_STRING_NEW(sSplit)
    do
    {
      DEBUG_STRING_NEW(sChild)
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, bCheckFirst, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaSplit, uiSplitDistLuma, dSplitCost, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );
#endif
      DEBUG_STRING_APPEND(sSplit, sChild)
      uiSplitCbfLuma |= pcCU->getCbf( tuRecurseChild.GetAbsPartIdxTU(), COMPONENT_Y, tuRecurseChild.GetTransformDepthRel() );
    } while (tuRecurseChild.nextSection(rTu) );

    UInt    uiPartsDiv     = rTu.GetAbsPartIdxNumParts();
    {
      if (uiSplitCbfLuma)
      {
        const UInt flag=1<<uiTrDepth;
        UChar *pBase=pcCU->getCbf( COMPONENT_Y );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
    //----- restore context states -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
    
    //----- determine rate and r-d cost -----
    UInt uiSplitBits = xGetIntraBitsQT( rTu, true, false, false );
    dSplitCost       = m_pcRdCost->calcRdCost( uiSplitBits, uiSplitDistLuma );

    //===== compare and set best =====
    if( dSplitCost < dSingleCost )
    {
      //--- update cost ---
      DEBUG_STRING_SWAP(sSplit, sDebug)
      ruiDistY += uiSplitDistLuma;
      dRDCost  += dSplitCost;

      if (pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
      {
        const Int xOffset = rTu.getRect( COMPONENT_Y ).x0;
        const Int yOffset = rTu.getRect( COMPONENT_Y ).y0;
        for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
        {
          if (bMaintainResidual[storedResidualIndex])
          {
            xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaSplit[storedResidualIndex], rTu, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE);
          }
        }
      }

      return;
    }

    //----- set entropy coding status -----
    m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_TEST ] );

    //--- set transform index and Cbf values ---
    pcCU->setTrIdxSubParts( uiTrDepth, uiAbsPartIdx, uiFullDepth );
    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    pcCU->setCbfSubParts  ( uiSingleCbfLuma << uiTrDepth, COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );
    pcCU ->setTransformSkipSubParts  ( bestModeId[COMPONENT_Y], COMPONENT_Y, uiAbsPartIdx, totalAdjustedDepthChan );

    //--- set reconstruction for next intra prediction blocks ---
    const UInt  uiQTLayer   = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt  uiZOrder    = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;
    const UInt  uiWidth     = tuRect.width;
    const UInt  uiHeight    = tuRect.height;
    Pel*  piSrc       = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( COMPONENT_Y, uiAbsPartIdx );
    UInt  uiSrcStride = m_pcQTTempTComYuv[ uiQTLayer ].getStride  ( COMPONENT_Y );
    Pel*  piDes       = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
    UInt  uiDesStride = pcCU->getPic()->getPicYuvRec()->getStride  ( COMPONENT_Y );

    for( UInt uiY = 0; uiY < uiHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
    {
      for( UInt uiX = 0; uiX < uiWidth; uiX++ )
      {
        piDes[ uiX ] = piSrc[ uiX ];
      }
    }
  }
  ruiDistY += uiSingleDistLuma;
  dRDCost  += dSingleCost;
}


Void
TEncSearch::xSetIntraResultLumaQT(TComYuv* pcRecoYuv, TComTU &rTu)
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiTrDepth    = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====

    const TComRectangle &tuRect=rTu.getRect(COMPONENT_Y);
    const UInt coeffOffset = rTu.getCoefficientOffset(COMPONENT_Y);
    const UInt numCoeffInBlock = tuRect.width * tuRect.height;

    if (numCoeffInBlock!=0)
    {
      const TCoeff* srcCoeff = m_ppcQTTempCoeff[COMPONENT_Y][uiQTLayer] + coeffOffset;
      TCoeff* destCoeff      = pcCU->getCoeff(COMPONENT_Y) + coeffOffset;
      ::memcpy( destCoeff, srcCoeff, sizeof(TCoeff)*numCoeffInBlock );
#if ADAPTIVE_QP_SELECTION
      const TCoeff* srcArlCoeff = m_ppcQTTempArlCoeff[COMPONENT_Y][ uiQTLayer ] + coeffOffset;
      TCoeff* destArlCoeff      = pcCU->getArlCoeff (COMPONENT_Y)               + coeffOffset;
      ::memcpy( destArlCoeff, srcArlCoeff, sizeof( TCoeff ) * numCoeffInBlock );
#endif
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Y, pcRecoYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }

  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultLumaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}


Void
TEncSearch::xStoreIntraResultQT(const ComponentID compID, TComTU &rTu )
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff    = tuRect.width * tuRect.height;
      TCoeff* pcCoeffSrc = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffDst = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffDst = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( compID, &m_pcQTTempTransformSkipTComYuv, uiAbsPartIdx, tuRect.width, tuRect.height );
    }
  }
}


Void
TEncSearch::xLoadIntraResultQT(const ComponentID compID, TComTU &rTu)
{
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiTrDepth = rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if ( compID==COMPONENT_Y || uiTrMode == uiTrDepth )
  {
    assert(uiTrMode == uiTrDepth);
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    const UInt uiZOrder     = pcCU->getZorderIdxInCtu() + uiAbsPartIdx;

    if (rTu.ProcessComponentSection(compID))
    {
      const TComRectangle &tuRect=rTu.getRect(compID);

      //===== copy transform coefficients =====
      const UInt uiNumCoeff = tuRect.width * tuRect.height;
      TCoeff* pcCoeffDst = m_ppcQTTempCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcCoeffSrc = m_pcQTTempTUCoeff[compID];

      ::memcpy( pcCoeffDst, pcCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffDst = m_ppcQTTempArlCoeff[compID] [ uiQTLayer ] + rTu.getCoefficientOffset(compID);
      TCoeff* pcArlCoeffSrc = m_ppcQTTempTUArlCoeff[compID];
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeff );
#endif
      //===== copy reconstruction =====
      m_pcQTTempTransformSkipTComYuv.copyPartToPartComponent( compID, &m_pcQTTempTComYuv[ uiQTLayer ], uiAbsPartIdx, tuRect.width, tuRect.height );

      Pel*    piRecIPred        = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
      UInt    uiRecIPredStride  = pcCU->getPic()->getPicYuvRec()->getStride (compID);
      Pel*    piRecQt           = m_pcQTTempTComYuv[ uiQTLayer ].getAddr( compID, uiAbsPartIdx );
      UInt    uiRecQtStride     = m_pcQTTempTComYuv[ uiQTLayer ].getStride  (compID);
      UInt    uiWidth           = tuRect.width;
      UInt    uiHeight          = tuRect.height;
      Pel* pRecQt               = piRecQt;
      Pel* pRecIPred            = piRecIPred;
      for( UInt uiY = 0; uiY < uiHeight; uiY++ )
      {
        for( UInt uiX = 0; uiX < uiWidth; uiX++ )
        {
          pRecIPred[ uiX ] = pRecQt   [ uiX ];
        }
        pRecQt    += uiRecQtStride;
        pRecIPred += uiRecIPredStride;
      }
    }
  }
}

Void
TEncSearch::xStoreCrossComponentPredictionResult(       Pel    *pResiDst,
                                                  const Pel    *pResiSrc,
                                                        TComTU &rTu,
                                                  const Int     xOffset,
                                                  const Int     yOffset,
                                                  const Int     strideDst,
                                                  const Int     strideSrc )
{
  const Pel *pSrc = pResiSrc + yOffset * strideSrc + xOffset;
        Pel *pDst = pResiDst + yOffset * strideDst + xOffset;

  for( Int y = 0; y < rTu.getRect( COMPONENT_Y ).height; y++ )
  {
    ::memcpy( pDst, pSrc, sizeof(Pel) * rTu.getRect( COMPONENT_Y ).width );
    pDst += strideDst;
    pSrc += strideSrc;
  }
}

SChar
TEncSearch::xCalcCrossComponentPredictionAlpha(       TComTU &rTu,
                                                const ComponentID compID,
                                                const Pel*        piResiL,
                                                const Pel*        piResiC,
                                                const Int         width,
                                                const Int         height,
                                                const Int         strideL,
                                                const Int         strideC )
{
  const Pel *pResiL = piResiL;
  const Pel *pResiC = piResiC;

        TComDataCU *pCU = rTu.getCU();
  const Int  absPartIdx = rTu.GetAbsPartIdxTU( compID );
  const Int diffBitDepth = pCU->getSlice()->getSPS()->getDifferentialLumaChromaBitDepth();

  SChar alpha = 0;
  Int SSxy  = 0;
  Int SSxx  = 0;

  for( UInt uiY = 0; uiY < height; uiY++ )
  {
    for( UInt uiX = 0; uiX < width; uiX++ )
    {
      const Pel scaledResiL = rightShift( pResiL[ uiX ], diffBitDepth );
      SSxy += ( scaledResiL * pResiC[ uiX ] );
      SSxx += ( scaledResiL * scaledResiL   );
    }

    pResiL += strideL;
    pResiC += strideC;
  }

  if( SSxx != 0 )
  {
    Double dAlpha = SSxy / Double( SSxx );
    alpha = SChar(Clip3<Int>(-16, 16, (Int)(dAlpha * 16)));

    static const SChar alphaQuant[17] = {0, 1, 1, 2, 2, 2, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8};

    alpha = (alpha < 0) ? -alphaQuant[Int(-alpha)] : alphaQuant[Int(alpha)];
  }
  pCU->setCrossComponentPredictionAlphaPartRange( alpha, compID, absPartIdx, rTu.GetAbsPartIdxNumParts( compID ) );

  return alpha;
}

Void
TEncSearch::xRecurIntraChromaCodingQT(TComYuv*    pcOrgYuv,
                                      TComYuv*    pcPredYuv,
                                      TComYuv*    pcResiYuv,
                                      Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE],
                                      Distortion& ruiDist,
                                      TComTU&     rTu
                                      DEBUG_STRING_FN_DECLARE(sDebug))
{
  TComDataCU         *pcCU                  = rTu.getCU();
  const UInt          uiTrDepth             = rTu.GetTransformDepthRel();
  const UInt          uiAbsPartIdx          = rTu.GetAbsPartIdxTU();
  const ChromaFormat  format                = rTu.GetChromaFormat();
  UInt                uiTrMode              = pcCU->getTransformIdx( uiAbsPartIdx );
  const UInt          numberValidComponents = getNumberValidComponents(format);

  if(  uiTrMode == uiTrDepth )
  {
    if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      return;
    }

    const UInt uiFullDepth = rTu.GetTransformDepthTotal();

    Bool checkTransformSkip = pcCU->getSlice()->getPPS()->getUseTransformSkip();
    checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Cb), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

    if ( m_pcEncCfg->getUseTransformSkipFast() )
    {
      checkTransformSkip &= TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(COMPONENT_Y), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize());

      if (checkTransformSkip)
      {
        Int nbLumaSkip = 0;
        const UInt maxAbsPartIdxSub=uiAbsPartIdx + (rTu.ProcessingAllQuadrants(COMPONENT_Cb)?1:4);
        for(UInt absPartIdxSub = uiAbsPartIdx; absPartIdxSub < maxAbsPartIdxSub; absPartIdxSub ++)
        {
          nbLumaSkip += pcCU->getTransformSkip(absPartIdxSub, COMPONENT_Y);
        }
        checkTransformSkip &= (nbLumaSkip > 0);
      }
    }


    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      DEBUG_STRING_NEW(sDebugBestMode)

      //use RDO to decide whether Cr/Cb takes TS
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[uiFullDepth][CI_QT_TRAFO_ROOT] );

      const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

      TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

      const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

      do
      {
        const UInt subTUAbsPartIdx   = TUIterator.GetAbsPartIdxTU(compID);

        Double     dSingleCost               = MAX_DOUBLE;
        Int        bestModeId                = 0;
        Distortion singleDistC               = 0;
        UInt       singleCbfC                = 0;
        Distortion singleDistCTmp            = 0;
        Double     singleCostTmp             = 0;
        UInt       singleCbfCTmp             = 0;
        SChar      bestCrossCPredictionAlpha = 0;
        Int        bestTransformSkipMode     = 0;

        const Bool checkCrossComponentPrediction =    (pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, subTUAbsPartIdx) == DM_CHROMA_IDX)
                                                   &&  pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                   && (pcCU->getCbf(subTUAbsPartIdx,  COMPONENT_Y, uiTrDepth) != 0);

        const Int  crossCPredictionModesToTest = checkCrossComponentPrediction ? 2 : 1;
        const Int  transformSkipModesToTest    = checkTransformSkip            ? 2 : 1;
        const Int  totalModesToTest            = crossCPredictionModesToTest * transformSkipModesToTest;
              Int  currModeId                  = 0;
              Int  default0Save1Load2          = 0;

        for(Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
        {
          for(Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
          {
            pcCU->setCrossComponentPredictionAlphaPartRange(0, compID, subTUAbsPartIdx, partIdxesPerSubTU);
            DEBUG_STRING_NEW(sDebugMode)
            pcCU->setTransformSkipPartRange( transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU );
            currModeId++;

            const Bool isOneMode  = (totalModesToTest == 1);
            const Bool isLastMode = (currModeId == totalModesToTest); // currModeId is indexed from 1

            if (isOneMode)
            {
              default0Save1Load2 = 0;
            }
            else if (!isOneMode && (transformSkipModeId == 0) && (crossCPredictionModeId == 0))
            {
              default0Save1Load2 = 1; //save prediction on first mode
            }
            else
            {
              default0Save1Load2 = 2; //load it on subsequent modes
            }

            singleDistCTmp = 0;

            xIntraCodingTUBlock( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, (crossCPredictionModeId != 0), singleDistCTmp, compID, TUIterator DEBUG_STRING_PASS_INTO(sDebugMode), default0Save1Load2);
            singleCbfCTmp = pcCU->getCbf( subTUAbsPartIdx, compID, uiTrDepth);

            if (  ((crossCPredictionModeId == 1) && (pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) == 0))
               || ((transformSkipModeId    == 1) && (singleCbfCTmp == 0))) //In order not to code TS flag when cbf is zero, the case for TS with cbf being zero is forbidden.
            {
              singleCostTmp = MAX_DOUBLE;
            }
            else if (!isOneMode)
            {
              UInt bitsTmp = xGetIntraBitsQTChroma( TUIterator, compID, false );
              singleCostTmp  = m_pcRdCost->calcRdCost( bitsTmp, singleDistCTmp);
            }

            if(singleCostTmp < dSingleCost)
            {
              DEBUG_STRING_SWAP(sDebugBestMode, sDebugMode)
              dSingleCost               = singleCostTmp;
              singleDistC               = singleDistCTmp;
              bestCrossCPredictionAlpha = (crossCPredictionModeId != 0) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;
              bestTransformSkipMode     = transformSkipModeId;
              bestModeId                = currModeId;
              singleCbfC                = singleCbfCTmp;

              if (!isOneMode && !isLastMode)
              {
                xStoreIntraResultQT(compID, TUIterator);
                m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
              }
            }

            if (!isOneMode && !isLastMode)
            {
              m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiFullDepth ][ CI_QT_TRAFO_ROOT ] );
            }
          }
        }

        if(bestModeId < totalModesToTest)
        {
          xLoadIntraResultQT(compID, TUIterator);
          pcCU->setCbfPartRange( singleCbfC << uiTrDepth, compID, subTUAbsPartIdx, partIdxesPerSubTU );

          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiFullDepth ][ CI_TEMP_BEST ] );
        }

        DEBUG_STRING_APPEND(sDebug, sDebugBestMode)
        pcCU ->setTransformSkipPartRange                ( bestTransformSkipMode,     compID, subTUAbsPartIdx, partIdxesPerSubTU );
        pcCU ->setCrossComponentPredictionAlphaPartRange( bestCrossCPredictionAlpha, compID, subTUAbsPartIdx, partIdxesPerSubTU );
        ruiDist += singleDistC;
      } while (TUIterator.nextSection(rTu));

      if (splitIntoSubTUs)
      {
        offsetSubTUCBFs(rTu, compID);
      }
    }
  }
  else
  {
    UInt    uiSplitCbf[MAX_NUM_COMPONENT] = {0,0,0};

    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiTrDepthChild   = tuRecurseChild.GetTransformDepthRel();
    do
    {
      DEBUG_STRING_NEW(sChild)

      xRecurIntraChromaCodingQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, ruiDist, tuRecurseChild DEBUG_STRING_PASS_INTO(sChild) );

      DEBUG_STRING_APPEND(sDebug, sChild)
      const UInt uiAbsPartIdxSub=tuRecurseChild.GetAbsPartIdxTU();

      for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
      {
        uiSplitCbf[ch] |= pcCU->getCbf( uiAbsPartIdxSub, ComponentID(ch), uiTrDepthChild );
      }
    } while ( tuRecurseChild.nextSection(rTu) );


    UInt uiPartsDiv = rTu.GetAbsPartIdxNumParts();
    for(UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      if (uiSplitCbf[ch])
      {
        const UInt flag=1<<uiTrDepth;
        ComponentID compID=ComponentID(ch);
        UChar *pBase=pcCU->getCbf( compID );
        for( UInt uiOffs = 0; uiOffs < uiPartsDiv; uiOffs++ )
        {
          pBase[ uiAbsPartIdx + uiOffs ] |= flag;
        }
      }
    }
  }
}




Void
TEncSearch::xSetIntraResultChromaQT(TComYuv*    pcRecoYuv, TComTU &rTu)
{
  if (!rTu.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
  {
    return;
  }
  TComDataCU *pcCU=rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiTrDepth   = rTu.GetTransformDepthRel();
  UInt uiTrMode     = pcCU->getTransformIdx( uiAbsPartIdx );
  if(  uiTrMode == uiTrDepth )
  {
    UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    UInt uiQTLayer    = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    //===== copy transform coefficients =====
    const TComRectangle &tuRectCb=rTu.getRect(COMPONENT_Cb);
    UInt uiNumCoeffC    = tuRectCb.width*tuRectCb.height;//( pcCU->getSlice()->getSPS()->getMaxCUWidth() * pcCU->getSlice()->getSPS()->getMaxCUHeight() ) >> ( uiFullDepth << 1 );
    const UInt offset = rTu.getCoefficientOffset(COMPONENT_Cb);

    const UInt numberValidComponents = getNumberValidComponents(rTu.GetChromaFormat());
    for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
    {
      const ComponentID component = ComponentID(ch);
      const TCoeff* src           = m_ppcQTTempCoeff[component][uiQTLayer] + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      TCoeff* dest                = pcCU->getCoeff(component) + offset;//(uiNumCoeffIncC*uiAbsPartIdx);
      ::memcpy( dest, src, sizeof(TCoeff)*uiNumCoeffC );
#if ADAPTIVE_QP_SELECTION
      TCoeff* pcArlCoeffSrc = m_ppcQTTempArlCoeff[component][ uiQTLayer ] + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      TCoeff* pcArlCoeffDst = pcCU->getArlCoeff(component)                + offset;//( uiNumCoeffIncC * uiAbsPartIdx );
      ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * uiNumCoeffC );
#endif
    }

    //===== copy reconstruction =====

    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cb, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
    m_pcQTTempTComYuv[ uiQTLayer ].copyPartToPartComponent( COMPONENT_Cr, pcRecoYuv, uiAbsPartIdx, tuRectCb.width, tuRectCb.height );
  }
  else
  {
    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetIntraResultChromaQT( pcRecoYuv, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}



Void
TEncSearch::estIntraPredLumaQT(TComDataCU* pcCU,
                               TComYuv*    pcOrgYuv,
                               TComYuv*    pcPredYuv,
                               TComYuv*    pcResiYuv,
                               TComYuv*    pcRecoYuv,
                               Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                               DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt         uiDepth               = pcCU->getDepth(0);
  const UInt         uiInitTrDepth         = pcCU->getPartitionSize(0) == SIZE_2Nx2N ? 0 : 1;
  const UInt         uiNumPU               = 1<<(2*uiInitTrDepth);
  const UInt         uiQNumParts           = pcCU->getTotalNumPart() >> 2;
  const UInt         uiWidthBit            = pcCU->getIntraSizeIdx(0);
  const ChromaFormat chFmt                 = pcCU->getPic()->getChromaFormat();
  const UInt         numberValidComponents = getNumberValidComponents(chFmt);
  const TComSPS     &sps                   = *(pcCU->getSlice()->getSPS());
  const TComPPS     &pps                   = *(pcCU->getSlice()->getPPS());
        Distortion   uiOverallDistY        = 0;
        UInt         CandNum;
        Double       CandCostList[ FAST_UDI_MAX_RDMODE_NUM ];
        Pel          resiLumaPU[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE];

        Bool    bMaintainResidual[NUMBER_OF_STORED_RESIDUAL_TYPES];
        for (UInt residualTypeIndex = 0; residualTypeIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; residualTypeIndex++)
        {
          bMaintainResidual[residualTypeIndex] = true; //assume true unless specified otherwise
        }

        bMaintainResidual[RESIDUAL_ENCODER_SIDE] = !(m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate());

  // Lambda calculation at equivalent Qp of 4 is recommended because at that Qp, the quantisation divisor is 1.
#if FULL_NBIT
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#else
  const Double sqrtLambdaForFirstPass= (m_pcEncCfg->getCostMode()==COST_MIXED_LOSSLESS_LOSSY_CODING && pcCU->getCUTransquantBypass(0)) ?
                sqrt(0.57 * pow(2.0, ((LOSSLESS_AND_MIXED_LOSSLESS_RD_COST_TEST_QP_PRIME - 12 - 6 * (sps.getBitDepth(CHANNEL_TYPE_LUMA) - 8)) / 3.0)))
              : m_pcRdCost->getSqrtLambda();
#endif

  //===== set QP and clear Cbf =====
  if ( pps.getUseDQP() == true)
  {
    pcCU->setQPSubParts( pcCU->getQP(0), 0, uiDepth );
  }
  else
  {
    pcCU->setQPSubParts( pcCU->getSlice()->getSliceQp(), 0, uiDepth );
  }

  //===== loop over partitions =====
  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);

  do
  {
    const UInt uiPartOffset=tuRecurseWithPU.GetAbsPartIdxTU();
//  for( UInt uiPU = 0, uiPartOffset=0; uiPU < uiNumPU; uiPU++, uiPartOffset += uiQNumParts )
  //{
    //===== init pattern for luma prediction =====
    DEBUG_STRING_NEW(sTemp2)

    //===== determine set of modes to be tested (using prediction signal only) =====
    Int numModesAvailable     = 35; //total number of Intra modes
    UInt uiRdModeList[FAST_UDI_MAX_RDMODE_NUM];
    Int numModesForFullRD = m_pcEncCfg->getFastUDIUseMPMEnabled()?g_aucIntraModeNumFast_UseMPM[ uiWidthBit ] : g_aucIntraModeNumFast_NotUseMPM[ uiWidthBit ];

    // this should always be true
    assert (tuRecurseWithPU.ProcessComponentSection(COMPONENT_Y));
    initIntraPatternChType( tuRecurseWithPU, COMPONENT_Y, true DEBUG_STRING_PASS_INTO(sTemp2) );

    Bool doFastSearch = (numModesForFullRD != numModesAvailable);
    if (doFastSearch)
    {
      assert(numModesForFullRD < numModesAvailable);

      for( Int i=0; i < numModesForFullRD; i++ )
      {
        CandCostList[ i ] = MAX_DOUBLE;
      }
      CandNum = 0;

      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt uiAbsPartIdx=tuRecurseWithPU.GetAbsPartIdxTU();

      Pel* piOrg         = pcOrgYuv ->getAddr( COMPONENT_Y, uiAbsPartIdx );
      Pel* piPred        = pcPredYuv->getAddr( COMPONENT_Y, uiAbsPartIdx );
      UInt uiStride      = pcPredYuv->getStride( COMPONENT_Y );
      DistParam distParam;
      const Bool bUseHadamard=pcCU->getCUTransquantBypass(0) == 0;
      m_pcRdCost->setDistParam(distParam, sps.getBitDepth(CHANNEL_TYPE_LUMA), piOrg, uiStride, piPred, uiStride, puRect.width, puRect.height, bUseHadamard);
      distParam.bApplyWeight = false;
      for( Int modeIdx = 0; modeIdx < numModesAvailable; modeIdx++ )
      {
        UInt       uiMode = modeIdx;
        Distortion uiSad  = 0;

        const Bool bUseFilter=TComPrediction::filteringIntraReferenceSamples(COMPONENT_Y, uiMode, puRect.width, puRect.height, chFmt, sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag());

        predIntraAng( COMPONENT_Y, uiMode, piOrg, uiStride, piPred, uiStride, tuRecurseWithPU, bUseFilter, TComPrediction::UseDPCMForFirstPassIntraEstimation(tuRecurseWithPU, uiMode) );

        // use hadamard transform here
        uiSad+=distParam.DistFunc(&distParam);

        UInt   iModeBits = 0;

        // NB xModeBitsIntra will not affect the mode for chroma that may have already been pre-estimated.
        iModeBits+=xModeBitsIntra( pcCU, uiMode, uiPartOffset, uiDepth, CHANNEL_TYPE_LUMA );

        Double cost      = (Double)uiSad + (Double)iModeBits * sqrtLambdaForFirstPass;

#if DEBUG_INTRA_SEARCH_COSTS
        std::cout << "1st pass mode " << uiMode << " SAD = " << uiSad << ", mode bits = " << iModeBits << ", cost = " << cost << "\n";
#endif

        CandNum += xUpdateCandList( uiMode, cost, numModesForFullRD, uiRdModeList, CandCostList );
      }

      if (m_pcEncCfg->getFastUDIUseMPMEnabled())
      {
        Int uiPreds[NUM_MOST_PROBABLE_MODES] = {-1, -1, -1};

        Int iMode = -1;
        pcCU->getIntraDirPredictor( uiPartOffset, uiPreds, COMPONENT_Y, &iMode );

        const Int numCand = ( iMode >= 0 ) ? iMode : Int(NUM_MOST_PROBABLE_MODES);

        for( Int j=0; j < numCand; j++)
        {
          Bool mostProbableModeIncluded = false;
          Int mostProbableMode = uiPreds[j];

          for( Int i=0; i < numModesForFullRD; i++)
          {
            mostProbableModeIncluded |= (mostProbableMode == uiRdModeList[i]);
          }
          if (!mostProbableModeIncluded)
          {
            uiRdModeList[numModesForFullRD++] = mostProbableMode;
          }
        }
      }
    }
    else
    {
      for( Int i=0; i < numModesForFullRD; i++)
      {
        uiRdModeList[i] = i;
      }
    }

    //===== check modes (using r-d costs) =====
#if HHI_RQT_INTRA_SPEEDUP_MOD
    UInt   uiSecondBestMode  = MAX_UINT;
    Double dSecondBestPUCost = MAX_DOUBLE;
#endif
    DEBUG_STRING_NEW(sPU)
    UInt       uiBestPUMode  = 0;
    Distortion uiBestPUDistY = 0;
    Double     dBestPUCost   = MAX_DOUBLE;

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
    UInt max=numModesForFullRD;

    if (DebugOptionList::ForceLumaMode.isSet())
    {
      max=0;  // we are forcing a direction, so don't bother with mode check
    }
    for ( UInt uiMode = 0; uiMode < max; uiMode++)
#else
    for( UInt uiMode = 0; uiMode < numModesForFullRD; uiMode++ )
#endif
    {
      // set luma prediction mode
      UInt uiOrgMode = uiRdModeList[uiMode];

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );

      DEBUG_STRING_NEW(sMode)
      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;
#if HHI_RQT_INTRA_SPEEDUP
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, true, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#else
      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );
#endif

#if DEBUG_INTRA_SEARCH_COSTS
      std::cout << "2nd pass [luma,chroma] mode [" << Int(pcCU->getIntraDir(CHANNEL_TYPE_LUMA, uiPartOffset)) << "," << Int(pcCU->getIntraDir(CHANNEL_TYPE_CHROMA, uiPartOffset)) << "] cost = " << dPUCost << "\n";
#endif

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sMode)
#if HHI_RQT_INTRA_SPEEDUP_MOD
        uiSecondBestMode  = uiBestPUMode;
        dSecondBestPUCost = dBestPUCost;
#endif
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();

        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
#if HHI_RQT_INTRA_SPEEDUP_MOD
      else if( dPUCost < dSecondBestPUCost )
      {
        uiSecondBestMode  = uiOrgMode;
        dSecondBestPUCost = dPUCost;
      }
#endif
    } // Mode loop

#if HHI_RQT_INTRA_SPEEDUP
#if HHI_RQT_INTRA_SPEEDUP_MOD
    for( UInt ui =0; ui < 2; ++ui )
#endif
    {
#if HHI_RQT_INTRA_SPEEDUP_MOD
      UInt uiOrgMode   = ui ? uiSecondBestMode  : uiBestPUMode;
      if( uiOrgMode == MAX_UINT )
      {
        break;
      }
#else
      UInt uiOrgMode = uiBestPUMode;
#endif

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
      if (DebugOptionList::ForceLumaMode.isSet())
      {
        uiOrgMode = DebugOptionList::ForceLumaMode.getInt();
      }
#endif

      pcCU->setIntraDirSubParts ( CHANNEL_TYPE_LUMA, uiOrgMode, uiPartOffset, uiDepth + uiInitTrDepth );
      DEBUG_STRING_NEW(sModeTree)

      // set context models
      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST] );

      // determine residual for partition
      Distortion uiPUDistY = 0;
      Double     dPUCost   = 0.0;

      xRecurIntraCodingLumaQT( pcOrgYuv, pcPredYuv, pcResiYuv, resiLumaPU, uiPUDistY, false, dPUCost, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sModeTree));

      // check r-d cost
      if( dPUCost < dBestPUCost )
      {
        DEBUG_STRING_SWAP(sPU, sModeTree)
        uiBestPUMode  = uiOrgMode;
        uiBestPUDistY = uiPUDistY;
        dBestPUCost   = dPUCost;

        xSetIntraResultLumaQT( pcRecoYuv, tuRecurseWithPU );

        if (pps.getPpsRangeExtension().getCrossComponentPredictionEnabledFlag())
        {
          const Int xOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).x0;
          const Int yOffset = tuRecurseWithPU.getRect( COMPONENT_Y ).y0;
          for (UInt storedResidualIndex = 0; storedResidualIndex < NUMBER_OF_STORED_RESIDUAL_TYPES; storedResidualIndex++)
          {
            if (bMaintainResidual[storedResidualIndex])
            {
              xStoreCrossComponentPredictionResult(resiLuma[storedResidualIndex], resiLumaPU[storedResidualIndex], tuRecurseWithPU, xOffset, yOffset, MAX_CU_SIZE, MAX_CU_SIZE );
            }
          }
        }

        const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
        ::memcpy( m_puhQTTempTrIdx,  pcCU->getTransformIdx()       + uiPartOffset, uiQPartNum * sizeof( UChar ) );

        for (UInt component = 0; component < numberValidComponents; component++)
        {
          const ComponentID compID = ComponentID(component);
          ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID  ) + uiPartOffset, uiQPartNum * sizeof( UChar ) );
          ::memcpy( m_puhQTTempTransformSkipFlag[compID],  pcCU->getTransformSkip(compID)  + uiPartOffset, uiQPartNum * sizeof( UChar ) );
        }
      }
    } // Mode loop
#endif

    DEBUG_STRING_APPEND(sDebug, sPU)

    //--- update overall distortion ---
    uiOverallDistY += uiBestPUDistY;

    //--- update transform index and cbf ---
    const UInt uiQPartNum = tuRecurseWithPU.GetAbsPartIdxNumParts();
    ::memcpy( pcCU->getTransformIdx()       + uiPartOffset, m_puhQTTempTrIdx,  uiQPartNum * sizeof( UChar ) );
    for (UInt component = 0; component < numberValidComponents; component++)
    {
      const ComponentID compID = ComponentID(component);
      ::memcpy( pcCU->getCbf( compID  ) + uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
      ::memcpy( pcCU->getTransformSkip( compID  ) + uiPartOffset, m_puhQTTempTransformSkipFlag[compID ], uiQPartNum * sizeof( UChar ) );
    }

    //--- set reconstruction for next intra prediction blocks ---
    if( !tuRecurseWithPU.IsLastSection() )
    {
      const TComRectangle &puRect=tuRecurseWithPU.getRect(COMPONENT_Y);
      const UInt  uiCompWidth   = puRect.width;
      const UInt  uiCompHeight  = puRect.height;

      const UInt  uiZOrder      = pcCU->getZorderIdxInCtu() + uiPartOffset;
            Pel*  piDes         = pcCU->getPic()->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), uiZOrder );
      const UInt  uiDesStride   = pcCU->getPic()->getPicYuvRec()->getStride( COMPONENT_Y);
      const Pel*  piSrc         = pcRecoYuv->getAddr( COMPONENT_Y, uiPartOffset );
      const UInt  uiSrcStride   = pcRecoYuv->getStride( COMPONENT_Y);

      for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
      {
        for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
        {
          piDes[ uiX ] = piSrc[ uiX ];
        }
      }
    }

    //=== update PU data ====
    pcCU->setIntraDirSubParts     ( CHANNEL_TYPE_LUMA, uiBestPUMode, uiPartOffset, uiDepth + uiInitTrDepth );
	
  } while (tuRecurseWithPU.nextSection(tuRecurseCU));


  if( uiNumPU > 1 )
  { // set Cbf for all blocks
    UInt uiCombCbfY = 0;
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfY |= pcCU->getCbf( uiPartIdx, COMPONENT_Y,  1 );
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Y  )[ uiOffs ] |= uiCombCbfY;
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  //===== reset context models =====
  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  //===== set distortion (rate and r-d costs are determined later) =====
  pcCU->getTotalDistortion() = uiOverallDistY;
}




Void
TEncSearch::estIntraPredChromaQT(TComDataCU* pcCU,
                                 TComYuv*    pcOrgYuv,
                                 TComYuv*    pcPredYuv,
                                 TComYuv*    pcResiYuv,
                                 TComYuv*    pcRecoYuv,
                                 Pel         resiLuma[NUMBER_OF_STORED_RESIDUAL_TYPES][MAX_CU_SIZE * MAX_CU_SIZE]
                                 DEBUG_STRING_FN_DECLARE(sDebug))
{
  const UInt    uiInitTrDepth  = pcCU->getPartitionSize(0) != SIZE_2Nx2N && enable4ChromaPUsInIntraNxNCU(pcOrgYuv->getChromaFormat()) ? 1 : 0;

  TComTURecurse tuRecurseCU(pcCU, 0);
  TComTURecurse tuRecurseWithPU(tuRecurseCU, false, (uiInitTrDepth==0)?TComTU::DONT_SPLIT : TComTU::QUAD_SPLIT);
  const UInt    uiQNumParts    = tuRecurseWithPU.GetAbsPartIdxNumParts();
  const UInt    uiDepthCU=tuRecurseWithPU.getCUDepth();
  const UInt    numberValidComponents = pcCU->getPic()->getNumberValidComponents();

  do
  {
    UInt       uiBestMode  = 0;
    Distortion uiBestDist  = 0;
    Double     dBestCost   = MAX_DOUBLE;

    //----- init mode list -----
    if (tuRecurseWithPU.ProcessChannelSection(CHANNEL_TYPE_CHROMA))
    {
      UInt uiModeList[FAST_UDI_MAX_RDMODE_NUM];
      const UInt  uiQPartNum     = uiQNumParts;
      const UInt  uiPartOffset   = tuRecurseWithPU.GetAbsPartIdxTU();
      {
        UInt  uiMinMode = 0;
        UInt  uiMaxMode = NUM_CHROMA_MODE;

        //----- check chroma modes -----
        pcCU->getAllowedChromaDir( uiPartOffset, uiModeList );

#if ENVIRONMENT_VARIABLE_DEBUG_AND_TEST
        if (DebugOptionList::ForceChromaMode.isSet())
        {
          uiMinMode=DebugOptionList::ForceChromaMode.getInt();
          if (uiModeList[uiMinMode]==34)
          {
            uiMinMode=4; // if the fixed mode has been renumbered because DM_CHROMA covers it, use DM_CHROMA.
          }
          uiMaxMode=uiMinMode+1;
        }
#endif

        DEBUG_STRING_NEW(sPU)

        for( UInt uiMode = uiMinMode; uiMode < uiMaxMode; uiMode++ )
        {
          //----- restore context models -----
          m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          
          DEBUG_STRING_NEW(sMode)
          //----- chroma coding -----
          Distortion uiDist = 0;
          pcCU->setIntraDirSubParts  ( CHANNEL_TYPE_CHROMA, uiModeList[uiMode], uiPartOffset, uiDepthCU+uiInitTrDepth );
          xRecurIntraChromaCodingQT       ( pcOrgYuv, pcPredYuv, pcResiYuv, resiLuma, uiDist, tuRecurseWithPU DEBUG_STRING_PASS_INTO(sMode) );

          if( pcCU->getSlice()->getPPS()->getUseTransformSkip() )
          {
            m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
          }

          UInt    uiBits = xGetIntraBitsQT( tuRecurseWithPU, false, true, false );
          Double  dCost  = m_pcRdCost->calcRdCost( uiBits, uiDist );

          //----- compare -----
          if( dCost < dBestCost )
          {
            DEBUG_STRING_SWAP(sPU, sMode);
            dBestCost   = dCost;
            uiBestDist  = uiDist;
            uiBestMode  = uiModeList[uiMode];

            xSetIntraResultChromaQT( pcRecoYuv, tuRecurseWithPU );
            for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
            {
              const ComponentID compID = ComponentID(componentIndex);
              ::memcpy( m_puhQTTempCbf[compID], pcCU->getCbf( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_puhQTTempTransformSkipFlag[compID], pcCU->getTransformSkip( compID )+uiPartOffset, uiQPartNum * sizeof( UChar ) );
              ::memcpy( m_phQTTempCrossComponentPredictionAlpha[compID], pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, uiQPartNum * sizeof( SChar ) );
            }
          }
        }

        DEBUG_STRING_APPEND(sDebug, sPU)

        //----- set data -----
        for (UInt componentIndex = COMPONENT_Cb; componentIndex < numberValidComponents; componentIndex++)
        {
          const ComponentID compID = ComponentID(componentIndex);
          ::memcpy( pcCU->getCbf( compID )+uiPartOffset, m_puhQTTempCbf[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getTransformSkip( compID )+uiPartOffset, m_puhQTTempTransformSkipFlag[compID], uiQPartNum * sizeof( UChar ) );
          ::memcpy( pcCU->getCrossComponentPredictionAlpha(compID)+uiPartOffset, m_phQTTempCrossComponentPredictionAlpha[compID], uiQPartNum * sizeof( SChar ) );
        }
      }

      if( ! tuRecurseWithPU.IsLastSection() )
      {
        for (UInt ch=COMPONENT_Cb; ch<numberValidComponents; ch++)
        {
          const ComponentID compID    = ComponentID(ch);
          const TComRectangle &tuRect = tuRecurseWithPU.getRect(compID);
          const UInt  uiCompWidth     = tuRect.width;
          const UInt  uiCompHeight    = tuRect.height;
          const UInt  uiZOrder        = pcCU->getZorderIdxInCtu() + tuRecurseWithPU.GetAbsPartIdxTU();
                Pel*  piDes           = pcCU->getPic()->getPicYuvRec()->getAddr( compID, pcCU->getCtuRsAddr(), uiZOrder );
          const UInt  uiDesStride     = pcCU->getPic()->getPicYuvRec()->getStride( compID);
          const Pel*  piSrc           = pcRecoYuv->getAddr( compID, uiPartOffset );
          const UInt  uiSrcStride     = pcRecoYuv->getStride( compID);

          for( UInt uiY = 0; uiY < uiCompHeight; uiY++, piSrc += uiSrcStride, piDes += uiDesStride )
          {
            for( UInt uiX = 0; uiX < uiCompWidth; uiX++ )
            {
              piDes[ uiX ] = piSrc[ uiX ];
            }
          }
        }
      }

      pcCU->setIntraDirSubParts( CHANNEL_TYPE_CHROMA, uiBestMode, uiPartOffset, uiDepthCU+uiInitTrDepth );
      pcCU->getTotalDistortion      () += uiBestDist;
    }

  } while (tuRecurseWithPU.nextSection(tuRecurseCU));

  //----- restore context models -----

  if( uiInitTrDepth != 0 )
  { // set Cbf for all blocks
    UInt uiCombCbfU = 0;
    UInt uiCombCbfV = 0;
    UInt uiPartIdx  = 0;
    for( UInt uiPart = 0; uiPart < 4; uiPart++, uiPartIdx += uiQNumParts )
    {
      uiCombCbfU |= pcCU->getCbf( uiPartIdx, COMPONENT_Cb, 1 );
      uiCombCbfV |= pcCU->getCbf( uiPartIdx, COMPONENT_Cr, 1 );
    }
    for( UInt uiOffs = 0; uiOffs < 4 * uiQNumParts; uiOffs++ )
    {
      pcCU->getCbf( COMPONENT_Cb )[ uiOffs ] |= uiCombCbfU;
      pcCU->getCbf( COMPONENT_Cr )[ uiOffs ] |= uiCombCbfV;
    }
  }

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[uiDepthCU][CI_CURR_BEST] );
}




/** Function for encoding and reconstructing luma/chroma samples of a PCM mode CU.
 * \param pcCU pointer to current CU
 * \param uiAbsPartIdx part index
 * \param pOrg pointer to original sample arrays
 * \param pPCM pointer to PCM code arrays
 * \param pPred pointer to prediction signal arrays
 * \param pResi pointer to residual signal arrays
 * \param pReco pointer to reconstructed sample arrays
 * \param uiStride stride of the original/prediction/residual sample arrays
 * \param uiWidth block width
 * \param uiHeight block height
 * \param compID texture component type
 */
Void TEncSearch::xEncPCM (TComDataCU* pcCU, UInt uiAbsPartIdx, Pel* pOrg, Pel* pPCM, Pel* pPred, Pel* pResi, Pel* pReco, UInt uiStride, UInt uiWidth, UInt uiHeight, const ComponentID compID )
{
  const UInt uiReconStride   = pcCU->getPic()->getPicYuvRec()->getStride(compID);
  const UInt uiPCMBitDepth   = pcCU->getSlice()->getSPS()->getPCMBitDepth(toChannelType(compID));
  const Int  channelBitDepth = pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
  Pel* pRecoPic = pcCU->getPic()->getPicYuvRec()->getAddr(compID, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu()+uiAbsPartIdx);

  const Int pcmShiftRight=(channelBitDepth - Int(uiPCMBitDepth));

  assert(pcmShiftRight >= 0);

  for( UInt uiY = 0; uiY < uiHeight; uiY++ )
  {
    for( UInt uiX = 0; uiX < uiWidth; uiX++ )
    {
      // Reset pred and residual
      pPred[uiX] = 0;
      pResi[uiX] = 0;
      // Encode
      pPCM[uiX] = (pOrg[uiX]>>pcmShiftRight);
      // Reconstruction
      pReco   [uiX] = (pPCM[uiX]<<(pcmShiftRight));
      pRecoPic[uiX] = pReco[uiX];
    }
    pPred += uiStride;
    pResi += uiStride;
    pPCM += uiWidth;
    pOrg += uiStride;
    pReco += uiStride;
    pRecoPic += uiReconStride;
  }
}


//!  Function for PCM mode estimation.
Void TEncSearch::IPCMSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv )
{
  UInt              uiDepth      = pcCU->getDepth(0);
  const Distortion  uiDistortion = 0;
  UInt              uiBits;

  Double dCost;

  for (UInt ch=0; ch < pcCU->getPic()->getNumberValidComponents(); ch++)
  {
    const ComponentID compID  = ComponentID(ch);
    const UInt width  = pcCU->getWidth(0)  >> pcCU->getPic()->getComponentScaleX(compID);
    const UInt height = pcCU->getHeight(0) >> pcCU->getPic()->getComponentScaleY(compID);
    const UInt stride = pcPredYuv->getStride(compID);

    Pel * pOrig    = pcOrgYuv->getAddr  (compID, 0, width);
    Pel * pResi    = pcResiYuv->getAddr(compID, 0, width);
    Pel * pPred    = pcPredYuv->getAddr(compID, 0, width);
    Pel * pReco    = pcRecoYuv->getAddr(compID, 0, width);
    Pel * pPCM     = pcCU->getPCMSample (compID);

    xEncPCM ( pcCU, 0, pOrig, pPCM, pPred, pResi, pReco, stride, width, height, compID );

  }

  m_pcEntropyCoder->resetBits();
  xEncIntraHeader ( pcCU, uiDepth, 0, true, false);
  uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();

  dCost = m_pcRdCost->calcRdCost( uiBits, uiDistortion );

  m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST]);

  pcCU->getTotalBits()       = uiBits;
  pcCU->getTotalCost()       = dCost;
  pcCU->getTotalDistortion() = uiDistortion;

  pcCU->copyToPic(uiDepth);
}




Void TEncSearch::xGetInterPredictionError( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, Distortion& ruiErr, Bool /*bHadamard*/ )
{
  motionCompensation( pcCU, &m_tmpYuvPred, REF_PIC_LIST_X, iPartIdx );

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;
  pcCU->getPartIndexAndSize( iPartIdx, uiAbsPartIdx, iWidth, iHeight );

  DistParam cDistParam;

  cDistParam.bApplyWeight = false;


  m_pcRdCost->setDistParam( cDistParam, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA),
                            pcYuvOrg->getAddr( COMPONENT_Y, uiAbsPartIdx ), pcYuvOrg->getStride(COMPONENT_Y),
                            m_tmpYuvPred .getAddr( COMPONENT_Y, uiAbsPartIdx ), m_tmpYuvPred.getStride(COMPONENT_Y),
                            iWidth, iHeight, m_pcEncCfg->getUseHADME() && (pcCU->getCUTransquantBypass(iPartIdx) == 0) );

  ruiErr = cDistParam.DistFunc( &cDistParam );
}

//! estimation of best merge coding
Void TEncSearch::xMergeEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPUIdx, UInt& uiInterDir, TComMvField* pacMvField, UInt& uiMergeIndex, Distortion& ruiCost, TComMvField* cMvFieldNeighbours, UChar* uhInterDirNeighbours, Int& numValidMergeCand )
{

  UInt uiAbsPartIdx = 0;
  Int iWidth = 0;
  Int iHeight = 0;

 
  pcCU->getPartIndexAndSize( iPUIdx, uiAbsPartIdx, iWidth, iHeight );
  UInt uiDepth = pcCU->getDepth( uiAbsPartIdx );

  PartSize partSize = pcCU->getPartitionSize( 0 );
  if ( pcCU->getSlice()->getPPS()->getLog2ParallelMergeLevelMinus2() && partSize != SIZE_2Nx2N && pcCU->getWidth( 0 ) <= 8 )
  {
    if ( iPUIdx == 0 )
    {
      pcCU->setPartSizeSubParts( SIZE_2Nx2N, 0, uiDepth ); // temporarily set
      pcCU->getInterMergeCandidates( 0, 0, cMvFieldNeighbours,uhInterDirNeighbours, numValidMergeCand );
      pcCU->setPartSizeSubParts( partSize, 0, uiDepth ); // restore
    }
  }
  else
  {
    pcCU->getInterMergeCandidates( uiAbsPartIdx, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );
  }

  xRestrictBipredMergeCand( pcCU, iPUIdx, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand );

  ruiCost = std::numeric_limits<Distortion>::max();
  for( UInt uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )
  {
    Distortion uiCostCand = std::numeric_limits<Distortion>::max();
    UInt       uiBitsCand = 0;

    PartSize ePartSize = pcCU->getPartitionSize( 0 );

    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( cMvFieldNeighbours[0 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( cMvFieldNeighbours[1 + 2*uiMergeCand], ePartSize, uiAbsPartIdx, 0, iPUIdx );

    xGetInterPredictionError( pcCU, pcYuvOrg, iPUIdx, uiCostCand, m_pcEncCfg->getUseHADME() );
    uiBitsCand = uiMergeCand + 1;
    if (uiMergeCand == m_pcEncCfg->getMaxNumMergeCand() -1)
    {
        uiBitsCand--;
    }
    uiCostCand = uiCostCand + m_pcRdCost->getCost( uiBitsCand );
    if ( uiCostCand < ruiCost )
    {
      ruiCost = uiCostCand;
      pacMvField[0] = cMvFieldNeighbours[0 + 2*uiMergeCand];
      pacMvField[1] = cMvFieldNeighbours[1 + 2*uiMergeCand];
      uiInterDir = uhInterDirNeighbours[uiMergeCand];
      uiMergeIndex = uiMergeCand;
    }
  }
 
}

/** convert bi-pred merge candidates to uni-pred
 * \param pcCU
 * \param puIdx
 * \param mvFieldNeighbours
 * \param interDirNeighbours
 * \param numValidMergeCand
 * \returns Void
 */
Void TEncSearch::xRestrictBipredMergeCand( TComDataCU* pcCU, UInt puIdx, TComMvField* mvFieldNeighbours, UChar* interDirNeighbours, Int numValidMergeCand )
{
	
  if ( pcCU->isBipredRestriction(puIdx) )
  {
    for( UInt mergeCand = 0; mergeCand < numValidMergeCand; ++mergeCand )
    {
      if ( interDirNeighbours[mergeCand] == 3 )
      {
        interDirNeighbours[mergeCand] = 1;
        mvFieldNeighbours[(mergeCand << 1) + 1].setMvField(TComMv(0,0), -1);
      }
    }
  }
}

//! search of the best candidate for inter prediction
#if AMP_MRG
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv DEBUG_STRING_FN_DECLARE(sDebug), Bool bUseRes, Bool bUseMRG )
#else
Void TEncSearch::predInterSearch( TComDataCU* pcCU, TComYuv* pcOrgYuv, TComYuv* pcPredYuv, TComYuv* pcResiYuv, TComYuv* pcRecoYuv, Bool bUseRes )
#endif
{
  for(UInt i=0; i<NUM_REF_PIC_LIST_01; i++)
  {
    m_acYuvPred[i].clear();
  }
  m_cYuvPredTemp.clear();
  pcPredYuv->clear();

  if ( !bUseRes )
  {
    pcResiYuv->clear();
  }

  pcRecoYuv->clear();
  
  TComMv       cMvSrchRngLT;
  TComMv       cMvSrchRngRB;

  TComMv       cMvZero;
  TComMv       TempMv; //kolya

  TComMv       cMv[2];
  TComMv       cMvBi[2];
  TComMv       cMvTemp[2][33];

  Int          iNumPart    = pcCU->getNumPartitions();
  Int          iNumPredDir = pcCU->getSlice()->isInterP() ? 1 : 2;

  TComMv       cMvPred[2][33];

  TComMv       cMvPredBi[2][33];
  Int          aaiMvpIdxBi[2][33];

  Int          aaiMvpIdx[2][33];
  Int          aaiMvpNum[2][33];

  AMVPInfo     aacAMVPInfo[2][33];

  Int          iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
  Int          iRefIdxBi[2];

  UInt         uiPartAddr;
  Int          iRoiWidth, iRoiHeight;

  UInt         uiMbBits[3] = {1, 1, 0};

  UInt         uiLastMode = 0;
  Int          iRefStart, iRefEnd;

  PartSize     ePartSize = pcCU->getPartitionSize( 0 );

  Int          bestBiPRefIdxL1 = 0;
  Int          bestBiPMvpL1 = 0;
  Distortion   biPDistTemp = std::numeric_limits<Distortion>::max();

  TComMvField cMvFieldNeighbours[MRG_MAX_NUM_CANDS << 1]; // double length for mv of both lists
  UChar uhInterDirNeighbours[MRG_MAX_NUM_CANDS];
  Int numValidMergeCand = 0 ;

  for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
  {
    Distortion   uiCost[2] = { std::numeric_limits<Distortion>::max(), std::numeric_limits<Distortion>::max() };
    Distortion   uiCostBi  =   std::numeric_limits<Distortion>::max();
    Distortion   uiCostTemp;

    UInt         uiBits[3];
    UInt         uiBitsTemp;
    Distortion   bestBiPDist = std::numeric_limits<Distortion>::max();

    Distortion   uiCostTempL0[MAX_NUM_REF];
    for (Int iNumRef=0; iNumRef < MAX_NUM_REF; iNumRef++)
    {
      uiCostTempL0[iNumRef] = std::numeric_limits<Distortion>::max();
    }
    UInt         uiBitsTempL0[MAX_NUM_REF];

    TComMv       mvValidList1;
    Int          refIdxValidList1 = 0;
    UInt         bitsValidList1 = MAX_UINT;
    Distortion   costValidList1 = std::numeric_limits<Distortion>::max();

    xGetBlkBits( ePartSize, pcCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);

    pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
	
	
#if AMP_MRG
    Bool bTestNormalMC = true;

    if ( bUseMRG && pcCU->getWidth( 0 ) > 8 && iNumPart == 2 )
    {
      bTestNormalMC = false;
    }

    if (bTestNormalMC)
    {
#endif

    //  Uni-directional prediction
    for ( Int iRefList = 0; iRefList < iNumPredDir; iRefList++ )
    {
      RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

      for ( Int iRefIdxTemp = 0; iRefIdxTemp < pcCU->getSlice()->getNumRefIdx(eRefPicList); iRefIdxTemp++ )
      {
        uiBitsTemp = uiMbBits[iRefList];
        if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
        {
          uiBitsTemp += iRefIdxTemp+1;
          if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
          {
            uiBitsTemp--;
          }
        }
        xEstimateMvPredAMVP( pcCU, pcOrgYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
        aaiMvpIdx[iRefList][iRefIdxTemp] = pcCU->getMVPIdx(eRefPicList, uiPartAddr);
        aaiMvpNum[iRefList][iRefIdxTemp] = pcCU->getMVPNum(eRefPicList, uiPartAddr);

        if(pcCU->getSlice()->getMvdL1ZeroFlag() && iRefList==1 && biPDistTemp < bestBiPDist)
        {
          bestBiPDist = biPDistTemp;
          bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
          bestBiPRefIdxL1 = iRefIdxTemp;
        }

        uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];

        if ( m_pcEncCfg->getFastMEForGenBLowDelayEnabled() && iRefList == 1 )    // list 1
        {
          if ( pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) >= 0 )
          {
            cMvTemp[1][iRefIdxTemp] = cMvTemp[0][pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            uiCostTemp = uiCostTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )];
            /*first subtract the bit-rate part of the cost of the other list*/
            uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp )] );
            /*correct the bit-rate part of the current ref*/
            m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
            uiBitsTemp += m_pcRdCost->getBitsOfVectorWithPredictor( cMvTemp[1][iRefIdxTemp].getHor(), cMvTemp[1][iRefIdxTemp].getVer() );
            /*calculate the correct cost*/
            uiCostTemp += m_pcRdCost->getCost( uiBitsTemp );
          }
          else
          {
            xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
          }
        }
        else
        {
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
        }
        xCopyAMVPInfo(pcCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
        xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

        if ( iRefList == 0 )
        {
          uiCostTempL0[iRefIdxTemp] = uiCostTemp;
          uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
        }
        if ( uiCostTemp < uiCost[iRefList] )
        {
          uiCost[iRefList] = uiCostTemp;
          uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

          // set motion
          cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
          iRefIdx[iRefList] = iRefIdxTemp;
        }

        if ( iRefList == 1 && uiCostTemp < costValidList1 && pcCU->getSlice()->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
        {
          costValidList1 = uiCostTemp;
          bitsValidList1 = uiBitsTemp;

          // set motion
          mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
          refIdxValidList1 = iRefIdxTemp;
        }
      }
    }

    //  Bi-predictive Motion estimation
    if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )
    {

      cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
      iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];

      ::memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
      ::memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));

      UInt uiMotBits[2];

      if(pcCU->getSlice()->getMvdL1ZeroFlag())
      {
        xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
        pcCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
        cMvPredBi[1][bestBiPRefIdxL1]   = pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo()->m_acMvCand[bestBiPMvpL1];

        cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
        iRefIdxBi[1] = bestBiPRefIdxL1;
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
        TComYuv* pcYuvPred = &m_acYuvPred[REF_PIC_LIST_1];
        motionCompensation( pcCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );

        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiMbBits[1];

        if ( pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1) > 1 )
        {
          uiMotBits[1] += bestBiPRefIdxL1+1;
          if ( bestBiPRefIdxL1 == pcCU->getSlice()->getNumRefIdx(REF_PIC_LIST_1)-1 )
          {
            uiMotBits[1]--;
          }
        }

        uiMotBits[1] += m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][AMVP_MAX_NUM_CANDS];

        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

        cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
      }
      else
      {
        uiMotBits[0] = uiBits[0] - uiMbBits[0];
        uiMotBits[1] = uiBits[1] - uiMbBits[1];
        uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
      }

      // 4-times iteration (default)
      Int iNumIter = 4;

      // fast encoder setting: only one iteration
      if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 || pcCU->getSlice()->getMvdL1ZeroFlag() )
      {
        iNumIter = 1;
      }

      for ( Int iIter = 0; iIter < iNumIter; iIter++ )
      {
        Int         iRefList    = iIter % 2;

        if ( m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode()==FASTINTERSEARCH_MODE2 )
        {
          if( uiCost[0] <= uiCost[1] )
          {
            iRefList = 1;
          }
          else
          {
            iRefList = 0;
          }
        }
        else if ( iIter == 0 )
        {
          iRefList = 0;
        }
        if ( iIter == 0 && !pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllMv( cMv[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          pcCU->getCUMvField(RefPicList(1-iRefList))->setAllRefIdx( iRefIdx[1-iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
          TComYuv*  pcYuvPred = &m_acYuvPred[1-iRefList];
          motionCompensation ( pcCU, pcYuvPred, RefPicList(1-iRefList), iPartIdx );
        }

        RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );

        if(pcCU->getSlice()->getMvdL1ZeroFlag())
        {
          iRefList = 0;
          eRefPicList = REF_PIC_LIST_0;
        }

        Bool bChanged = false;

        iRefStart = 0;
        iRefEnd   = pcCU->getSlice()->getNumRefIdx(eRefPicList)-1;

        for ( Int iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
        {
          uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
          if ( pcCU->getSlice()->getNumRefIdx(eRefPicList) > 1 )
          {
            uiBitsTemp += iRefIdxTemp+1;
            if ( iRefIdxTemp == pcCU->getSlice()->getNumRefIdx(eRefPicList)-1 )
            {
              uiBitsTemp--;
            }
          }
          uiBitsTemp += m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][AMVP_MAX_NUM_CANDS];
          // call ME
          xMotionEstimation ( pcCU, pcOrgYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );

          xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], pcCU->getCUMvField(eRefPicList)->getAMVPInfo());
          xCheckBestMVP(pcCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

          if ( uiCostTemp < uiCostBi )
          {
            bChanged = true;

            cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
            iRefIdxBi[iRefList] = iRefIdxTemp;

            uiCostBi            = uiCostTemp;
            uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
            uiBits[2]           = uiBitsTemp;

            if(iNumIter!=1)
            {
              //  Set motion
              pcCU->getCUMvField( eRefPicList )->setAllMv( cMvBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );
              pcCU->getCUMvField( eRefPicList )->setAllRefIdx( iRefIdxBi[iRefList], ePartSize, uiPartAddr, 0, iPartIdx );

              TComYuv* pcYuvPred = &m_acYuvPred[iRefList];
              motionCompensation( pcCU, pcYuvPred, eRefPicList, iPartIdx );
            }
          }
        } // for loop-iRefIdxTemp

        if ( !bChanged )
        {
          if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
          {
            xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
            xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
            if(!pcCU->getSlice()->getMvdL1ZeroFlag())
            {
              xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
              xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
            }
          }
          break;
        }
      } // for loop-iter
    } // if (B_SLICE)

#if AMP_MRG
    } //end if bTestNormalMC
#endif
    //  Clear Motion Field
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
    pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );

    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

    UInt uiMEBits = 0;
    // Set Motion Field_
    cMv[1] = mvValidList1;
	
    iRefIdx[1] = refIdxValidList1;
    uiBits[1] = bitsValidList1;
    uiCost[1] = costValidList1;

#if AMP_MRG
    if (bTestNormalMC)
    {
#endif
    if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
    {
      uiLastMode = 2;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMvBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdxBi[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 3, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPIdxSubParts( aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[2];
    }
    else if ( uiCost[0] <= uiCost[1] )
    {
      uiLastMode = 0;
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
      pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[0];
    }
    else
    {
      uiLastMode = 1;
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMv( cMv[1], ePartSize, uiPartAddr, 0, iPartIdx );
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllRefIdx( iRefIdx[1], ePartSize, uiPartAddr, 0, iPartIdx );

      TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
      pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );

      pcCU->setInterDirSubParts( 2, uiPartAddr, iPartIdx, pcCU->getDepth(0) );

      pcCU->setMVPIdxSubParts( aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      pcCU->setMVPNumSubParts( aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));

      uiMEBits = uiBits[1];
    }
#if AMP_MRG
    } // end if bTestNormalMC
#endif

    if ( pcCU->getPartitionSize( uiPartAddr ) != SIZE_2Nx2N )
    {
      UInt uiMRGInterDir = 0;
      TComMvField cMRGMvField[2];
      UInt uiMRGIndex = 0;

      UInt uiMEInterDir = 0;
      TComMvField cMEMvField[2];

      m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

#if AMP_MRG
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      Distortion uiMECost  = std::numeric_limits<Distortion>::max();

      if (bTestNormalMC)
      {
        xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
        uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
      }
#else
      // calculate ME cost
      Distortion uiMEError = std::numeric_limits<Distortion>::max();
      xGetInterPredictionError( pcCU, pcOrgYuv, iPartIdx, uiMEError, m_pcEncCfg->getUseHADME() );
      Distortion uiMECost = uiMEError + m_pcRdCost->getCost( uiMEBits );
#endif
      // save ME result.
      uiMEInterDir = pcCU->getInterDir( uiPartAddr );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
      TComDataCU::getMvField( pcCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

      // find Merge result
      Distortion uiMRGCost = std::numeric_limits<Distortion>::max();

      xMergeEstimation( pcCU, pcOrgYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);

      if ( uiMRGCost < uiMECost )
      {
        // set Merge result
        pcCU->setMergeFlagSubParts ( true,          uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setMergeIndexSubParts( uiMRGIndex,    uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts  ( uiMRGInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMRGMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMRGMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,            ePartSize, uiPartAddr, 0, iPartIdx );

        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
        pcCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, pcCU->getDepth(uiPartAddr));
      }
      else
      {
        // set ME result
        pcCU->setMergeFlagSubParts( false,        uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->setInterDirSubParts ( uiMEInterDir, uiPartAddr, iPartIdx, pcCU->getDepth( uiPartAddr ) );
        pcCU->getCUMvField( REF_PIC_LIST_0 )->setAllMvField( cMEMvField[0], ePartSize, uiPartAddr, 0, iPartIdx );
        pcCU->getCUMvField( REF_PIC_LIST_1 )->setAllMvField( cMEMvField[1], ePartSize, uiPartAddr, 0, iPartIdx );
      }
    }

    //  MC
    motionCompensation ( pcCU, pcPredYuv, REF_PIC_LIST_X, iPartIdx );

  } //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )

  setWpScalingDistParam( pcCU, -1, REF_PIC_LIST_X );
 // CTUW = iRoiWidth;
 // CTUH = iRoiHeight;
 // myfile << CTUH << ',' << CTUW << endl;
  return;
}


// AMVP
Void TEncSearch::xEstimateMvPredAMVP( TComDataCU* pcCU, TComYuv* pcOrgYuv, UInt uiPartIdx, RefPicList eRefPicList, Int iRefIdx, TComMv& rcMvPred, Bool bFilled, Distortion* puiDistBiP )
{

  AMVPInfo*  pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();

  TComMv     cBestMv;
  Int        iBestIdx   = 0;
  TComMv     cZeroMv;
  TComMv     cMvPred;
  Distortion uiBestCost = std::numeric_limits<Distortion>::max();
  UInt       uiPartAddr = 0;
  Int        iRoiWidth, iRoiHeight;
  Int        i;
 
  pcCU->getPartIndexAndSize( uiPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
 

  // Fill the MV Candidates
  if (!bFilled)
  {
    pcCU->fillMvpCand( uiPartIdx, uiPartAddr, eRefPicList, iRefIdx, pcAMVPInfo );
  }

  // initialize Mvp index & Mvp
  iBestIdx = 0;
  cBestMv  = pcAMVPInfo->m_acMvCand[0];
  if (pcAMVPInfo->iN <= 1)
  {
    rcMvPred = cBestMv;

    pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
    pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));

    if(pcCU->getSlice()->getMvdL1ZeroFlag() && eRefPicList==REF_PIC_LIST_1)
    {
      (*puiDistBiP) = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, rcMvPred, 0, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    }
    return;
  }

  if (bFilled)
  {
    assert(pcCU->getMVPIdx(eRefPicList,uiPartAddr) >= 0);
    rcMvPred = pcAMVPInfo->m_acMvCand[pcCU->getMVPIdx(eRefPicList,uiPartAddr)];
    return;
  }

  m_cYuvPredTemp.clear();
  //-- Check Minimum Cost.
  for ( i = 0 ; i < pcAMVPInfo->iN; i++)
  {
    Distortion uiTmpCost;
    uiTmpCost = xGetTemplateCost( pcCU, uiPartAddr, pcOrgYuv, &m_cYuvPredTemp, pcAMVPInfo->m_acMvCand[i], i, AMVP_MAX_NUM_CANDS, eRefPicList, iRefIdx, iRoiWidth, iRoiHeight);
    if ( uiBestCost > uiTmpCost )
    {
      uiBestCost = uiTmpCost;
      cBestMv   = pcAMVPInfo->m_acMvCand[i];
      iBestIdx  = i;
      (*puiDistBiP) = uiTmpCost;
    }
  }

  m_cYuvPredTemp.clear();

  // Setting Best MVP
  rcMvPred = cBestMv;
  pcCU->setMVPIdxSubParts( iBestIdx, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  pcCU->setMVPNumSubParts( pcAMVPInfo->iN, eRefPicList, uiPartAddr, uiPartIdx, pcCU->getDepth(uiPartAddr));
  return;
  
}

UInt TEncSearch::xGetMvpIdxBits(Int iIdx, Int iNum)
{
  assert(iIdx >= 0 && iNum >= 0 && iIdx < iNum);

  if (iNum == 1)
  {
    return 0;
  }

  UInt uiLength = 1;
  Int iTemp = iIdx;
  if ( iTemp == 0 )
  {
    return uiLength;
  }

  Bool bCodeLast = ( iNum-1 > iTemp );

  uiLength += (iTemp-1);

  if( bCodeLast )
  {
    uiLength++;
  }

  return uiLength;
}

Void TEncSearch::xGetBlkBits( PartSize eCUMode, Bool bPSlice, Int iPartIdx, UInt uiLastMode, UInt uiBlkBit[3])
{
  if ( eCUMode == SIZE_2Nx2N )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else if ( (eCUMode == SIZE_2NxN || eCUMode == SIZE_2NxnU) || eCUMode == SIZE_2NxnD )
  {
    UInt aauiMbBits[2][3][3] = { { {0,0,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7,5,7}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( (eCUMode == SIZE_Nx2N || eCUMode == SIZE_nLx2N) || eCUMode == SIZE_nRx2N )
  {
    UInt aauiMbBits[2][3][3] = { { {0,2,3}, {0,0,0}, {0,0,0} } , { {5,7,7}, {7-2,7-2,9-2}, {9-3,9-3,9-3} } };
    if ( bPSlice )
    {
      uiBlkBit[0] = 3;
      uiBlkBit[1] = 0;
      uiBlkBit[2] = 0;
    }
    else
    {
      ::memcpy( uiBlkBit, aauiMbBits[iPartIdx][uiLastMode], 3*sizeof(UInt) );
    }
  }
  else if ( eCUMode == SIZE_NxN )
  {
    uiBlkBit[0] = (! bPSlice) ? 3 : 1;
    uiBlkBit[1] = 3;
    uiBlkBit[2] = 5;
  }
  else
  {
    printf("Wrong!\n");
    assert( 0 );
  }
}

Void TEncSearch::xCopyAMVPInfo (AMVPInfo* pSrc, AMVPInfo* pDst)
{
  pDst->iN = pSrc->iN;
  for (Int i = 0; i < pSrc->iN; i++)
  {
    pDst->m_acMvCand[i] = pSrc->m_acMvCand[i];
  }
}

Void TEncSearch::xCheckBestMVP ( TComDataCU* pcCU, RefPicList eRefPicList, TComMv cMv, TComMv& rcMvPred, Int& riMVPIdx, UInt& ruiBits, Distortion& ruiCost )
{
  AMVPInfo* pcAMVPInfo = pcCU->getCUMvField(eRefPicList)->getAMVPInfo();
  
  assert(pcAMVPInfo->m_acMvCand[riMVPIdx] == rcMvPred);

  if (pcAMVPInfo->iN < 2)
  {
    return;
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(0) );
  m_pcRdCost->setCostScale ( 0    );

  Int iBestMVPIdx = riMVPIdx;

  m_pcRdCost->setPredictor( rcMvPred );
  Int iOrgMvBits  = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
  iOrgMvBits += m_auiMVPIdxCost[riMVPIdx][AMVP_MAX_NUM_CANDS];
  Int iBestMvBits = iOrgMvBits;

  for (Int iMVPIdx = 0; iMVPIdx < pcAMVPInfo->iN; iMVPIdx++)
  {
    if (iMVPIdx == riMVPIdx)
    {
      continue;
    }

    m_pcRdCost->setPredictor( pcAMVPInfo->m_acMvCand[iMVPIdx] );

    Int iMvBits = m_pcRdCost->getBitsOfVectorWithPredictor(cMv.getHor(), cMv.getVer());
    iMvBits += m_auiMVPIdxCost[iMVPIdx][AMVP_MAX_NUM_CANDS];

    if (iMvBits < iBestMvBits)
    {
      iBestMvBits = iMvBits;
      iBestMVPIdx = iMVPIdx;
    }
  }

  if (iBestMVPIdx != riMVPIdx)  //if changed
  {
    rcMvPred = pcAMVPInfo->m_acMvCand[iBestMVPIdx];

    riMVPIdx = iBestMVPIdx;
    UInt uiOrgBits = ruiBits;
    ruiBits = uiOrgBits - iOrgMvBits + iBestMvBits;
    ruiCost = (ruiCost - m_pcRdCost->getCost( uiOrgBits ))  + m_pcRdCost->getCost( ruiBits );
  }
  
}


Distortion TEncSearch::xGetTemplateCost( TComDataCU* pcCU,
                                         UInt        uiPartAddr,
                                         TComYuv*    pcOrgYuv,
                                         TComYuv*    pcTemplateCand,
                                         TComMv      cMvCand,
                                         Int         iMVPIdx,
                                         Int         iMVPNum,
                                         RefPicList  eRefPicList,
                                         Int         iRefIdx,
                                         Int         iSizeX,
                                         Int         iSizeY
                                         )
{
  Distortion uiCost = std::numeric_limits<Distortion>::max();

  TComPicYuv* pcPicYuvRef = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdx )->getPicYuvRec();

  pcCU->clipMv( cMvCand );

  // prediction pattern
  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, true, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }
  else
  {
    xPredInterBlk( COMPONENT_Y, pcCU, pcPicYuvRef, uiPartAddr, &cMvCand, iSizeX, iSizeY, pcTemplateCand, false, pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
  }

  if ( pcCU->getSlice()->testWeightPred() && pcCU->getSlice()->getSliceType()==P_SLICE )
  {
    xWeightedPredictionUni( pcCU, pcTemplateCand, uiPartAddr, iSizeX, iSizeY, eRefPicList, pcTemplateCand, iRefIdx );
  }

  // calc distortion

  uiCost = m_pcRdCost->getDistPart( pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA), pcTemplateCand->getAddr(COMPONENT_Y, uiPartAddr), pcTemplateCand->getStride(COMPONENT_Y), pcOrgYuv->getAddr(COMPONENT_Y, uiPartAddr), pcOrgYuv->getStride(COMPONENT_Y), iSizeX, iSizeY, COMPONENT_Y, DF_SAD );
  uiCost = (UInt) m_pcRdCost->calcRdCost( m_auiMVPIdxCost[iMVPIdx][iMVPNum], uiCost, DF_SAD );
  return uiCost;
}


Void TEncSearch::xMotionEstimation( TComDataCU* pcCU, TComYuv* pcYuvOrg, Int iPartIdx, RefPicList eRefPicList, TComMv* pcMvPred, Int iRefIdxPred, TComMv& rcMv, UInt& ruiBits, Distortion& ruiCost, Bool bBi  )
{
  UInt          uiPartAddr;
  Int           iRoiWidth;
  Int           iRoiHeight;

  TComMv        cMvHalf, cMvQter;
  TComMv        cMvSrchRngLT;
  TComMv        cMvSrchRngRB;
  // Distortion   INTCOST=0;
  TComYuv*      pcYuv = pcYuvOrg;
   
  assert(eRefPicList < MAX_NUM_REF_LIST_ADAPT_SR && iRefIdxPred<Int(MAX_IDX_ADAPT_SR));
  m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];

  Int           iSrchRng      = ( bBi ? m_bipredSearchRange : m_iSearchRange );
  TComPattern   tmpPattern;
  TComPattern*  pcPatternKey  = &tmpPattern;

  Double        fWeight       = 1.0;

  pcCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );

  if ( bBi ) // Bipredictive ME
  {
    TComYuv*  pcYuvOther = &m_acYuvPred[1-(Int)eRefPicList];
    pcYuv                = &m_cYuvPredTemp;

    pcYuvOrg->copyPartToPartYuv( pcYuv, uiPartAddr, iRoiWidth, iRoiHeight );

    pcYuv->removeHighFreq( pcYuvOther, uiPartAddr, iRoiWidth, iRoiHeight, pcCU->getSlice()->getSPS()->getBitDepths().recon, m_pcEncCfg->getClipForBiPredMeEnabled() );

    fWeight = 0.5;
  }
  m_cDistParam.bIsBiPred = bBi;

  //  Search key pattern initialization
  pcPatternKey->initPattern( pcYuv->getAddr  ( COMPONENT_Y, uiPartAddr ),
                             iRoiWidth,
                             iRoiHeight,
                             pcYuv->getStride(COMPONENT_Y),
                             pcCU->getSlice()->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );

  Pel*        piRefY      = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getAddr( COMPONENT_Y, pcCU->getCtuRsAddr(), pcCU->getZorderIdxInCtu() + uiPartAddr );
  Int         iRefStride  = pcCU->getSlice()->getRefPic( eRefPicList, iRefIdxPred )->getPicYuvRec()->getStride(COMPONENT_Y);

  TComMv      cMvPred = *pcMvPred;

  if ( bBi )
  {
	  
    xSetSearchRange   ( pcCU, rcMv   , iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }
  else
  {
	  
    xSetSearchRange   ( pcCU, cMvPred, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
  }

  m_pcRdCost->selectMotionLambda(true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setPredictor  ( *pcMvPred );
  m_pcRdCost->setCostScale  ( 2 );

  setWpScalingDistParam( pcCU, iRefIdxPred, eRefPicList );
  //  Do integer search
  if ( (m_motionEstimationSearchMethod==MESEARCH_FULL) || bBi )
  {
    xPatternSearch      ( pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost );
  }
  else
  {
    rcMv = *pcMvPred;
    const TComMv *pIntegerMv2Nx2NPred=0;
    if (pcCU->getPartitionSize(0) != SIZE_2Nx2N || pcCU->getDepth(0) != 0)
    {
      pIntegerMv2Nx2NPred = &(m_integerMv2Nx2N[eRefPicList][iRefIdxPred]);
    }
    
    // EMI: Save Block width and height in global variables, to use in our NN
    // TODO: Code Cleaning
    PUHeight = iRoiHeight;
    PUWidth = iRoiWidth;
    PIdx = iPartIdx;
    PAddr = uiPartAddr;
    pcCU->getPartPosition(PIdx, xP, yP, nPSW, nPSH);


    xPatternSearchFast  ( pcCU, pcPatternKey, piRefY, iRefStride, &cMvSrchRngLT, &cMvSrchRngRB, rcMv, ruiCost, pIntegerMv2Nx2NPred );
    if (pcCU->getPartitionSize(0) == SIZE_2Nx2N)
    {
      m_integerMv2Nx2N[eRefPicList][iRefIdxPred] = rcMv;
    }
  }

  m_pcRdCost->selectMotionLambda( true, 0, pcCU->getCUTransquantBypass(uiPartAddr) );

  m_pcRdCost->setCostScale ( 1 );
    
  const Bool bIsLosslessCoded = pcCU->getCUTransquantBypass(uiPartAddr) != 0;
  xPatternSearchFracDIF( bIsLosslessCoded, pcPatternKey, piRefY, iRefStride, &rcMv, cMvHalf, cMvQter, ruiCost );

  m_pcRdCost->setCostScale( 0 );

  // EMI: Modification
  
  /* 
  Fractional Motion Estimation values computed by standard are stored in TComMv variables cMvHalf & cMvQter
  We create other TComMv variables, and replace the standard values with our NN predicted values
  Our NN modifies global variables MVX_HALF & MVX_QRTER, which in return are set used to set our new Mv
  */
  TComMv MV_HALF, MV_QRTER;
  MV_HALF.setHor(MVX_HALF);
  MV_HALF.setVer(MVY_HALF);
  MV_QRTER.setHor(MVX_QRTER);
  MV_QRTER.setVer(MVY_QRTER);

  // For finding Integer Motion Estimation, Set Horizontal and Vertical values to zero:

  // MV_HALF.setHor(0);
  // MV_HALF.setVer(0);
  // MV_QRTER.setHor(0);
  // MV_QRTER.setVer(0);

  /* 
  EMI: To Write the errors and output MV in a CSV file:
  Real values for errors: U,V,H           - NN values for errors: IN[]
  Real values for MV: cMvHalf, cMvQter    - NN values for MV: MV_HALF, MV_QRTER
  Block Width and Height: iRoiWidth, iRoiHeight
  */
  
  ofstream mv_nn;
  ofstream errors;
  errors.open("/home/emi/git-repos/data/HM16.9/extract_data/SSE_errors.csv", ios::app);
  mv_nn.open("/home/emi/git-repos/data/HM16.9/extract_data/mv_nn.csv", ios::app);
  errors << U1 << ',' << V1 << ',' << U2 << ',' << H1 << ',' << C << ',' << H2 << ',' << U3 << ',' << V2 << ',' << U4 << ',' << iRoiHeight << ',' << iRoiWidth;
  errors << ',' << xP << ',' << yP << ',' << PIdx  << ',' << PAddr << endl;
  // errors << ',' << uiPartAddr << ',' << iPartIdx << endl;
  
  /*
  Write the values of the output class directly instead of coordinates:
  Half * 0.5 + Quarter * 0.25:  results in range from -0.75->0.75
  Add both X & Y + 0.75:        range is now 0->1.5
  Multiply X by 4:              X values are now [0, 1, 2, 3, 4, 5, 6]
  Multiply Y by 4*7=28:         Y values are now [0, 7, 14, 21, 28, 35, 42]
  Adding X+Y results in the desired output class, given that the mapping starts from 
  0 for top left corner, 24 center, and 48 for bottom right corner
  */
  
  int MV_X = (((cMvHalf.getHor() * 0.5) + (cMvQter.getHor() * 0.25)) + 0.75) * 4;
  int MV_Y = (((cMvHalf.getVer() * 0.5) + (cMvQter.getVer() * 0.25)) + 0.75) * 28;
  int OUT_CLASS = MV_Y + MV_X;
  mv_nn << OUT_CLASS << endl;

  // Replace Motion Vector with values computed by our NN

  rcMv <<= 2;
  // rcMv += (cMvHalf <<= 1);
  // rcMv += cMvQter;
  rcMv += (MV_HALF <<= 1);
  rcMv += MV_QRTER;
  
  // End of modification

  UInt uiMvBits = m_pcRdCost->getBitsOfVectorWithPredictor( rcMv.getHor(), rcMv.getVer() );

  ruiBits      += uiMvBits;
  ruiCost       = (Distortion)( floor( fWeight * ( (Double)ruiCost - (Double)m_pcRdCost->getCost( uiMvBits ) ) ) + (Double)m_pcRdCost->getCost( ruiBits ) );
}


Void TEncSearch::xSetSearchRange ( const TComDataCU* const pcCU, const TComMv& cMvPred, const Int iSrchRng,
                                   TComMv& rcMvSrchRngLT, TComMv& rcMvSrchRngRB )
{
  Int  iMvShift = 2;
  TComMv cTmpMvPred = cMvPred;
  pcCU->clipMv( cTmpMvPred );

  rcMvSrchRngLT.setHor( cTmpMvPred.getHor() - (iSrchRng << iMvShift) );
  rcMvSrchRngLT.setVer( cTmpMvPred.getVer() - (iSrchRng << iMvShift) );

  rcMvSrchRngRB.setHor( cTmpMvPred.getHor() + (iSrchRng << iMvShift) );
  rcMvSrchRngRB.setVer( cTmpMvPred.getVer() + (iSrchRng << iMvShift) );
  pcCU->clipMv        ( rcMvSrchRngLT );
  pcCU->clipMv        ( rcMvSrchRngRB );

#if ME_ENABLE_ROUNDING_OF_MVS
  rcMvSrchRngLT.divideByPowerOf2(iMvShift);
  rcMvSrchRngRB.divideByPowerOf2(iMvShift);
#else
  rcMvSrchRngLT >>= iMvShift;
  rcMvSrchRngRB >>= iMvShift;
#endif
}


Void TEncSearch::xPatternSearch(const TComPattern* const pcPatternKey,
	const Pel*               piRefY,
	const Int                iRefStride,
	const TComMv* const      pcMvSrchRngLT,
	const TComMv* const      pcMvSrchRngRB,
	TComMv&      rcMv,
	Distortion&  ruiSAD)
{
	Int   iSrchRngHorLeft = pcMvSrchRngLT->getHor();
	Int   iSrchRngHorRight = pcMvSrchRngRB->getHor();
	Int   iSrchRngVerTop = pcMvSrchRngLT->getVer();
	Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

	Distortion  uiSad;
	Distortion  uiSadBest = std::numeric_limits<Distortion>::max();
	Int         iBestX = 0;
	Int         iBestY = 0;


	m_pcRdCost->setDistParam(pcPatternKey, piRefY, iRefStride, m_cDistParam);

	// fast encoder decision: use subsampled SAD for integer ME
	if (m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE1 || m_pcEncCfg->getFastInterSearchMode() == FASTINTERSEARCH_MODE3)
	{
		if (m_cDistParam.iRows > 8)
		{
			m_cDistParam.iSubShift = 1;
		}
	}

	piRefY += (iSrchRngVerTop * iRefStride);

	for (Int y = iSrchRngVerTop; y <= iSrchRngVerBottom; y++)
	{
		for (Int x = iSrchRngHorLeft; x <= iSrchRngHorRight; x++)
		{
			//  find min. distortion position
			m_cDistParam.pCur = piRefY + x;

			setDistParamComp(COMPONENT_Y);

			m_cDistParam.bitDepth = pcPatternKey->getBitDepthY();
			uiSad = m_cDistParam.DistFunc(&m_cDistParam);

			// motion cost
			uiSad += m_pcRdCost->getCostOfVectorWithPredictor(x, y);

			if (uiSad < uiSadBest)
			{
				uiSadBest = uiSad;
				iBestX = x;
				iBestY = y;
				m_cDistParam.m_maximumDistortionForEarlyExit = uiSad;
			}
		}
		piRefY += iRefStride;
	}




		rcMv.set(iBestX, iBestY);


		ruiSAD = uiSadBest - m_pcRdCost->getCostOfVectorWithPredictor(iBestX, iBestY);

		//getchar();
		return;
	}


Void TEncSearch::xPatternSearchFast( const TComDataCU* const  pcCU,
                                     const TComPattern* const pcPatternKey,
                                     const Pel* const         piRefY,
                                     const Int                iRefStride,
                                     const TComMv* const      pcMvSrchRngLT,
                                     const TComMv* const      pcMvSrchRngRB,
                                     TComMv&                  rcMv,
                                     Distortion&              ruiSAD,
                                     const TComMv* const      pIntegerMv2Nx2NPred )
{
  assert (MD_LEFT < NUM_MV_PREDICTORS);
  pcCU->getMvPredLeft       ( m_acMvPredictors[MD_LEFT] );
  assert (MD_ABOVE < NUM_MV_PREDICTORS);
  pcCU->getMvPredAbove      ( m_acMvPredictors[MD_ABOVE] );
  assert (MD_ABOVE_RIGHT < NUM_MV_PREDICTORS);
  pcCU->getMvPredAboveRight ( m_acMvPredictors[MD_ABOVE_RIGHT] );

  switch ( m_motionEstimationSearchMethod )
  {
    case MESEARCH_DIAMOND:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, false );
	  
      C = array_e[0];
      for (int i = 1; i <=index_ref - 1; i++)
      {
        if (array_e[i] < C)
          C = array_e[i];

      }
	 
      // index_ref = index_ref + 1;
      U1 = array_e[index_ref];
      V1 = array_e[index_ref + 1];
      U2 = array_e[index_ref + 2];
      H1 = array_e[index_ref + 3];	  
      H2 = array_e[index_ref + 4];
      U3 = array_e[index_ref + 5];
      V2 = array_e[index_ref + 6];
      U4 = array_e[index_ref + 7];
      	  
      // EMI: neural network implementation
      
      // Reset all values of arrays

      memset(IN, 0, sizeof(IN));
      memset(X1, 0, sizeof(X1));
      memset(X2, 0, sizeof(X2));
      memset(OUT, 0, sizeof(OUT));
      memset(array_e, 0, sizeof(array_e));
      N = 0; NN_out = 0; counter_i = 0; index_ref = 0;


      // Normalize input values using the computed mean and standard deviations

      IN[8] = (U1 - mean[0]) / stdev[0];
      IN[9] = (V1 - mean[1]) / stdev[1];
      IN[10] = (U2 - mean[2]) / stdev[2];
      IN[11] = (H1 - mean[3]) / stdev[3];
      IN[12] = (C - mean[4]) / stdev[4];
      IN[13] = (H2 - mean[5]) / stdev[5];
      IN[14] = (U3 - mean[6]) / stdev[6];
      IN[15] = (V2 - mean[7]) / stdev[7];
      IN[16] = (U4 - mean[8]) / stdev[8];

      // Input layer also consists of categorical variables, in which we will use embedding matrices depending on block Height and Width

      switch (PUHeight) {
        case 4:   IN[0] = embs0[1][0];  IN[1] = embs0[1][1];   IN[2] = embs0[1][2];   IN[3] = embs0[1][3];		break;
        case 8:   IN[0] = embs0[2][0];  IN[1] = embs0[2][1];   IN[2] = embs0[2][2];   IN[3] = embs0[2][3];		break;
        case 12:  IN[0] = embs0[3][0];  IN[1] = embs0[3][1];   IN[2] = embs0[3][2];   IN[3] = embs0[3][3];	  break;
        case 16:  IN[0] = embs0[4][0];  IN[1] = embs0[4][1];   IN[2] = embs0[4][2];   IN[3] = embs0[4][3];		break;
        case 24:  IN[0] = embs0[5][0];  IN[1] = embs0[5][1];   IN[2] = embs0[5][2];   IN[3] = embs0[5][3];	  break;
        case 32:  IN[0] = embs0[6][0];  IN[1] = embs0[6][1];   IN[2] = embs0[6][2];   IN[3] = embs0[6][3];		break;
        case 64:  IN[0] = embs0[7][0];  IN[1] = embs0[7][1];   IN[2] = embs0[7][2];   IN[3] = embs0[7][3];		break;
        default:  IN[0] = embs0[0][0];  IN[1] = embs0[0][1];   IN[2] = embs0[0][2];   IN[3] = embs0[0][3];		break;
      }

      switch (PUWidth) {
        case 4:   IN[4] = embs1[1][0];  IN[5] = embs1[1][1];   IN[6] = embs1[1][2];   IN[7] = embs1[1][3];		break;
        case 8:   IN[4] = embs1[2][0];  IN[5] = embs1[2][1];   IN[6] = embs1[2][2];   IN[7] = embs1[2][3];		break;
        case 12:  IN[4] = embs1[3][0];  IN[5] = embs1[3][1];   IN[6] = embs1[3][2];   IN[7] = embs1[3][3];	  break;
        case 16:  IN[4] = embs1[4][0];  IN[5] = embs1[4][1];   IN[6] = embs1[4][2];   IN[7] = embs1[4][3];		break;
        case 24:  IN[4] = embs1[5][0];  IN[5] = embs1[5][1];   IN[6] = embs1[5][2];   IN[7] = embs1[5][3];	  break;
        case 32:  IN[4] = embs1[6][0];  IN[5] = embs1[6][1];   IN[6] = embs1[6][2];   IN[7] = embs1[6][3];		break;
        case 64:  IN[4] = embs1[7][0];  IN[5] = embs1[7][1];   IN[6] = embs1[7][2];   IN[7] = embs1[7][3];		break;
        default:  IN[4] = embs1[0][0];  IN[5] = embs1[0][1];   IN[6] = embs1[0][2];   IN[7] = embs1[0][3];		break;
      }

      // Input Layer
      for(int i=0;i<9;i++){
        IN[i+8] = (IN[i+8] * BN_gamma_in[i]);	  
      }

      
      // First Hidden Layer
      for (int i = 0; i < 22; i++) {
        for (int j = 0; j < 17; j++) {
          X1[i] += (in_h1[i][j] * IN[j]);
        }
        X1[i] += b1[i];
        X1[i] = (relu(X1[i]) * BN_gamma_1[i]) + BN_beta_1[i];
      }

      // Second Hidden Layer
      for (int i = 0; i < 20; i++) {
        for (int j = 0; j < 22; j++) {
          X2[i] += (h1_h2[i][j] * X1[j]);
        }
        X2[i] += b2[i];
        X2[i] = (relu(X2[i]) * BN_gamma_2[i]) + BN_beta_2[i];
      }

      // OUTPUT LAYER
      for (int i = 0; i < 49; i++) {
        for (int j = 0; j < 20; j++) {
          OUT[i] += (h2_out[i][j] * X2[j]);
        }
        OUT[i] += bout[i];
      }
      
      // Decision: NN_out holds the index of the maximum element

      N = sizeof(OUT) / sizeof(float); // Size of OUT[] array, used in next step
      NN_out = std::distance(OUT, std::max_element(OUT, OUT + N));
      
      switch (NN_out) {
        case 0: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 1: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 2: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 3: MVX_HALF = 0;   MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 4: MVX_HALF = 0;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;
        case 5: MVX_HALF = 1;   MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = -1;	  break;
        case 6: MVX_HALF = 1;   MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = -1;		break;

        case 7: MVX_HALF = -1;  MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 8: MVX_HALF = -1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 9: MVX_HALF = 0;   MVX_QRTER = -1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 10: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 11: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 12: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = -1;  MVY_QRTER = 0;		break;
        case 13: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = -1;  MVY_QRTER = 0;		break;

        case 14: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 15: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 16: MVX_HALF = 0;  MVX_QRTER = -1;   MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 17: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 18: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 19: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = -1;		break;
        case 20: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = -1;		break;

        case 21: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 22: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 23: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 24: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 25: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 26: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
        case 27: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 0;		break;

        case 28: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 29: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 30: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 31: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 32: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 33: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 1;		break;
        case 34: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 0;   MVY_QRTER = 1;		break;

        case 35: MVX_HALF = -1; MVX_QRTER = -1;   MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 36: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 37: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 38: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 0;		break;
        case 39: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 40: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;
        case 41: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 0;	  break;

        case 42: MVX_HALF = -1; MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 43: MVX_HALF = -1; MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 44: MVX_HALF = 0;  MVX_QRTER = -1;	  MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 45: MVX_HALF = 0;  MVX_QRTER = 0;	  MVY_HALF = 1;   MVY_QRTER = 1;	  break;
        case 46: MVX_HALF = 0;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 47: MVX_HALF = 1;  MVX_QRTER = 0;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        case 48: MVX_HALF = 1;  MVX_QRTER = 1;		MVY_HALF = 1;   MVY_QRTER = 1;		break;
        default: MVX_HALF = 0;  MVX_QRTER = 0;		MVY_HALF = 0;   MVY_QRTER = 0;		break;
      }


      //end of neural network code

      break;



    case MESEARCH_SELECTIVE:
      xTZSearchSelective( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred );
      break;

    case MESEARCH_DIAMOND_ENHANCED:
      xTZSearch( pcCU, pcPatternKey, piRefY, iRefStride, pcMvSrchRngLT, pcMvSrchRngRB, rcMv, ruiSAD, pIntegerMv2Nx2NPred, true );
      break;

    case MESEARCH_FULL: // shouldn't get here.
    default:
      break;
  }
}


Void TEncSearch::xTZSearch( const TComDataCU* const pcCU,
                            const TComPattern* const pcPatternKey,
                            const Pel* const         piRefY,
                            const Int                iRefStride,
                            const TComMv* const      pcMvSrchRngLT,
                            const TComMv* const      pcMvSrchRngRB,
                            TComMv&                  rcMv,
                            Distortion&              ruiSAD,
                            const TComMv* const      pIntegerMv2Nx2NPred,
                            const Bool               bExtendedSettings)
{
  const Bool bUseAdaptiveRaster                      = bExtendedSettings;
  const Int  iRaster                                 = 5;
  const Bool bTestOtherPredictedMV                   = bExtendedSettings;
  const Bool bTestZeroVector                         = true;
  const Bool bTestZeroVectorStart                    = bExtendedSettings;
  const Bool bTestZeroVectorStop                     = false;
  const Bool bFirstSearchDiamond                     = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bFirstCornersForDiamondDist1            = bExtendedSettings;
  const Bool bFirstSearchStop                        = m_pcEncCfg->getFastMEAssumingSmootherMVEnabled();
  const UInt uiFirstSearchRounds                     = 3;     // first search stop X rounds after best match (must be >=1)
  const Bool bEnableRasterSearch                     = true;
  const Bool bAlwaysRasterSearch                     = bExtendedSettings;  // true: BETTER but factor 2 slower
  const Bool bRasterRefinementEnable                 = false; // enable either raster refinement or star refinement
  const Bool bRasterRefinementDiamond                = false; // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bRasterRefinementCornersForDiamondDist1 = bExtendedSettings;
  const Bool bStarRefinementEnable                   = true;  // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond                  = true;  // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementCornersForDiamondDist1   = bExtendedSettings;
  const Bool bStarRefinementStop                     = false;
  const UInt uiStarRefinementRounds                  = 2;  // star refinement stop X rounds after best match (must be >=1)
  const Bool bNewZeroNeighbourhoodTest               = bExtendedSettings;

  UInt uiSearchRange = m_iSearchRange;
  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;

  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      if (cMv != rcMv && (cMv.getHor() != cStruct.iBestX && cMv.getVer() != cStruct.iBestY))
      {
        // only test cMV if not obviously previously tested.
        xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
      }
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    if ((rcMv.getHor() != 0 || rcMv.getVer() != 0) &&
        (0 != cStruct.iBestX || 0 != cStruct.iBestY))
    {
      // only test 0-vector if not obviously previously tested.
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
    }
  }

  Int   iSrchRngHorLeft   = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight  = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop    = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom = pcMvSrchRngRB->getVer();

  if (pIntegerMv2Nx2NPred != 0)
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    if ((rcMv != integerMv2Nx2NPred) &&
        (integerMv2Nx2NPred.getHor() != cStruct.iBestX || integerMv2Nx2NPred.getVer() != cStruct.iBestY))
    {
      // only test integerMv2Nx2NPred if not obviously previously tested.
      xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);
    }

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // start search
  Int  iDist = 0;
  Int  iStartX = cStruct.iBestX;
  Int  iStartY = cStruct.iBestY;

  const Bool bBestCandidateZero = (cStruct.iBestX == 0) && (cStruct.iBestY == 0);

  // first search around best position up to now.
  // The following works as a "subsampled/log" window search around the best candidate
  for (iDist = 1; iDist <= (Int)uiSearchRange; iDist *= 2)
	  
  {
    if ( bFirstSearchDiamond == 1 )
    {
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bFirstCornersForDiamondDist1 );
    }
    else
    {
      xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
    }

    if ( bFirstSearchStop && ( cStruct.uiBestRound >= uiFirstSearchRounds ) ) // stop criterion
    {
      break;
    }
  }

  if (!bNewZeroNeighbourhoodTest)
  {
    // test whether zero Mv is a better start point than Median predictor
    if ( bTestZeroVectorStart && ((cStruct.iBestX != 0) || (cStruct.iBestY != 0)) )
    {
      xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
      if ( (cStruct.iBestX == 0) && (cStruct.iBestY == 0) )
      {
        // test its neighborhood
        for ( iDist = 1; iDist <= (Int)uiSearchRange; iDist*=2 )
        {
          xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
          if ( bTestZeroVectorStop && (cStruct.uiBestRound > 0) ) // stop criterion
          {
            break;
          }
        }
      }
    }
  }
  else
  {
    // Test also zero neighbourhood but with half the range
    // It was reported that the original (above) search scheme using bTestZeroVectorStart did not
    // make sense since one would have already checked the zero candidate earlier
    // and thus the conditions for that test would have not been satisfied
    if (bTestZeroVectorStart == true && bBestCandidateZero != true)
    {
      for ( iDist = 1; iDist <= ((Int)uiSearchRange >> 1); iDist*=2 )
      {
        xTZ8PointDiamondSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, 0, 0, iDist, false );
        if ( bTestZeroVectorStop && (cStruct.uiBestRound > 2) ) // stop criterion
        {
          break;
        }
      }
    }
  }

  // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
  if ( cStruct.uiBestDistance == 1 )
  {
    cStruct.uiBestDistance = 0;
    xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
  }

  // raster search if distance is too big
  if (bUseAdaptiveRaster)
  {
    int iWindowSize = iRaster;
    Int   iSrchRngRasterLeft   = iSrchRngHorLeft;
    Int   iSrchRngRasterRight  = iSrchRngHorRight;
    Int   iSrchRngRasterTop    = iSrchRngVerTop;
    Int   iSrchRngRasterBottom = iSrchRngVerBottom;

    if (!(bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster))))
    {
      iWindowSize ++;
      iSrchRngRasterLeft /= 2;
      iSrchRngRasterRight /= 2;
      iSrchRngRasterTop /= 2;
      iSrchRngRasterBottom /= 2;
    }
    cStruct.uiBestDistance = iWindowSize;
    for ( iStartY = iSrchRngRasterTop; iStartY <= iSrchRngRasterBottom; iStartY += iWindowSize )
    {
      for ( iStartX = iSrchRngRasterLeft; iStartX <= iSrchRngRasterRight; iStartX += iWindowSize )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iWindowSize );
      }
    }
  }
  else
  {
    if ( bEnableRasterSearch && ( ((Int)(cStruct.uiBestDistance) > iRaster) || bAlwaysRasterSearch ) )
    {
      cStruct.uiBestDistance = iRaster;
      for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += iRaster )
      {
        for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += iRaster )
        {
          xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, iRaster );
        }
      }
    }
  }

  // raster refinement

  if ( bRasterRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      if ( cStruct.uiBestDistance > 1 )
      {
        iDist = cStruct.uiBestDistance >>= 1;
        if ( bRasterRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bRasterRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
      }

      // calculate only 2 missing points instead 8 points if cStruct.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // star refinement
  if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, bStarRefinementCornersForDiamondDist1 );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }


  // EMI: BIG DIFFERENCE!
  // getting the 8 SAD points
  iDist = 1;
  iStartX = cStruct.iBestX;
  iStartY = cStruct.iBestY;
  index_ref = counter_i;
  
  xTZ8PointSquareSearch(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  iDist = 2;
  xTZ8PointSquareSearch2(pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist);

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );
}


Void TEncSearch::xTZSearchSelective( const TComDataCU* const   pcCU,
                                     const TComPattern* const  pcPatternKey,
                                     const Pel* const          piRefY,
                                     const Int                 iRefStride,
                                     const TComMv* const       pcMvSrchRngLT,
                                     const TComMv* const       pcMvSrchRngRB,
                                     TComMv                   &rcMv,
                                     Distortion               &ruiSAD,
                                     const TComMv* const       pIntegerMv2Nx2NPred )
{
  const Bool bTestOtherPredictedMV    = true;
  const Bool bTestZeroVector          = true;
  const Bool bEnableRasterSearch      = true;
  const Bool bAlwaysRasterSearch      = false;  // 1: BETTER but factor 15x slower
  const Bool bStarRefinementEnable    = true;   // enable either star refinement or raster refinement
  const Bool bStarRefinementDiamond   = true;   // 1 = xTZ8PointDiamondSearch   0 = xTZ8PointSquareSearch
  const Bool bStarRefinementStop      = false;
  const UInt uiStarRefinementRounds   = 2;  // star refinement stop X rounds after best match (must be >=1)
  const UInt uiSearchRange            = m_iSearchRange;
  const Int  uiSearchRangeInitial     = m_iSearchRange >> 2;
  const Int  uiSearchStep             = 4;
  const Int  iMVDistThresh            = 8;

  Int   iSrchRngHorLeft         = pcMvSrchRngLT->getHor();
  Int   iSrchRngHorRight        = pcMvSrchRngRB->getHor();
  Int   iSrchRngVerTop          = pcMvSrchRngLT->getVer();
  Int   iSrchRngVerBottom       = pcMvSrchRngRB->getVer();
  Int   iFirstSrchRngHorLeft    = 0;
  Int   iFirstSrchRngHorRight   = 0;
  Int   iFirstSrchRngVerTop     = 0;
  Int   iFirstSrchRngVerBottom  = 0;
  Int   iStartX                 = 0;
  Int   iStartY                 = 0;
  Int   iBestX                  = 0;
  Int   iBestY                  = 0;
  Int   iDist                   = 0;

  pcCU->clipMv( rcMv );
#if ME_ENABLE_ROUNDING_OF_MVS
  rcMv.divideByPowerOf2(2);
#else
  rcMv >>= 2;
#endif
  // init TZSearchStruct
  IntTZSearchStruct cStruct;
  cStruct.iYStride    = iRefStride;
  cStruct.piRefY      = piRefY;
  cStruct.uiBestSad   = MAX_UINT;
  cStruct.iBestX = 0;
  cStruct.iBestY = 0;


  // set rcMv (Median predictor) as start point and as best point
  xTZSearchHelp( pcPatternKey, cStruct, rcMv.getHor(), rcMv.getVer(), 0, 0 );

  // test whether one of PRED_A, PRED_B, PRED_C MV is better start point than Median predictor
  if ( bTestOtherPredictedMV )
  {
    for ( UInt index = 0; index < NUM_MV_PREDICTORS; index++ )
    {
      TComMv cMv = m_acMvPredictors[index];
      pcCU->clipMv( cMv );
#if ME_ENABLE_ROUNDING_OF_MVS
      cMv.divideByPowerOf2(2);
#else
      cMv >>= 2;
#endif
      xTZSearchHelp( pcPatternKey, cStruct, cMv.getHor(), cMv.getVer(), 0, 0 );
    }
  }

  // test whether zero Mv is better start point than Median predictor
  if ( bTestZeroVector )
  {
    xTZSearchHelp( pcPatternKey, cStruct, 0, 0, 0, 0 );
  }

  if ( pIntegerMv2Nx2NPred != 0 )
  {
    TComMv integerMv2Nx2NPred = *pIntegerMv2Nx2NPred;
    integerMv2Nx2NPred <<= 2;
    pcCU->clipMv( integerMv2Nx2NPred );
#if ME_ENABLE_ROUNDING_OF_MVS
    integerMv2Nx2NPred.divideByPowerOf2(2);
#else
    integerMv2Nx2NPred >>= 2;
#endif
    xTZSearchHelp(pcPatternKey, cStruct, integerMv2Nx2NPred.getHor(), integerMv2Nx2NPred.getVer(), 0, 0);

    // reset search range
    TComMv cMvSrchRngLT;
    TComMv cMvSrchRngRB;
    Int iSrchRng = m_iSearchRange;
    TComMv currBestMv(cStruct.iBestX, cStruct.iBestY );
    currBestMv <<= 2;
    xSetSearchRange( pcCU, currBestMv, iSrchRng, cMvSrchRngLT, cMvSrchRngRB );
    iSrchRngHorLeft   = cMvSrchRngLT.getHor();
    iSrchRngHorRight  = cMvSrchRngRB.getHor();
    iSrchRngVerTop    = cMvSrchRngLT.getVer();
    iSrchRngVerBottom = cMvSrchRngRB.getVer();
  }

  // Initial search
  iBestX = cStruct.iBestX;
  iBestY = cStruct.iBestY; 
  iFirstSrchRngHorLeft    = ((iBestX - uiSearchRangeInitial) > iSrchRngHorLeft)   ? (iBestX - uiSearchRangeInitial) : iSrchRngHorLeft;
  iFirstSrchRngVerTop     = ((iBestY - uiSearchRangeInitial) > iSrchRngVerTop)    ? (iBestY - uiSearchRangeInitial) : iSrchRngVerTop;
  iFirstSrchRngHorRight   = ((iBestX + uiSearchRangeInitial) < iSrchRngHorRight)  ? (iBestX + uiSearchRangeInitial) : iSrchRngHorRight;  
  iFirstSrchRngVerBottom  = ((iBestY + uiSearchRangeInitial) < iSrchRngVerBottom) ? (iBestY + uiSearchRangeInitial) : iSrchRngVerBottom;    

  for ( iStartY = iFirstSrchRngVerTop; iStartY <= iFirstSrchRngVerBottom; iStartY += uiSearchStep )
  {
    for ( iStartX = iFirstSrchRngHorLeft; iStartX <= iFirstSrchRngHorRight; iStartX += uiSearchStep )
    {
      xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 0 );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 1, false );
      xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, 2, false );
    }
  }

  Int iMaxMVDistToPred = (abs(cStruct.iBestX - iBestX) > iMVDistThresh || abs(cStruct.iBestY - iBestY) > iMVDistThresh);

  //full search with early exit if MV is distant from predictors
  if ( bEnableRasterSearch && (iMaxMVDistToPred || bAlwaysRasterSearch) )
  {
    for ( iStartY = iSrchRngVerTop; iStartY <= iSrchRngVerBottom; iStartY += 1 )
    {
      for ( iStartX = iSrchRngHorLeft; iStartX <= iSrchRngHorRight; iStartX += 1 )
      {
        xTZSearchHelp( pcPatternKey, cStruct, iStartX, iStartY, 0, 1 );
      }
    }
  }
  //Smaller MV, refine around predictor
  else if ( bStarRefinementEnable && cStruct.uiBestDistance > 0 )
  {
    // start refinement
    while ( cStruct.uiBestDistance > 0 )
    {
      iStartX = cStruct.iBestX;
      iStartY = cStruct.iBestY;
      cStruct.uiBestDistance = 0;
      cStruct.ucPointNr = 0;
      for ( iDist = 1; iDist < (Int)uiSearchRange + 1; iDist*=2 )
      {
        if ( bStarRefinementDiamond == 1 )
        {
          xTZ8PointDiamondSearch ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist, false );
        }
        else
        {
          xTZ8PointSquareSearch  ( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB, iStartX, iStartY, iDist );
        }
        if ( bStarRefinementStop && (cStruct.uiBestRound >= uiStarRefinementRounds) ) // stop criterion
        {
          break;
        }
      }

      // calculate only 2 missing points instead 8 points if cStrukt.uiBestDistance == 1
      if ( cStruct.uiBestDistance == 1 )
      {
        cStruct.uiBestDistance = 0;
        if ( cStruct.ucPointNr != 0 )
        {
          xTZ2PointSearch( pcPatternKey, cStruct, pcMvSrchRngLT, pcMvSrchRngRB );
        }
      }
    }
  }

  // write out best match
  rcMv.set( cStruct.iBestX, cStruct.iBestY );
  ruiSAD = cStruct.uiBestSad - m_pcRdCost->getCostOfVectorWithPredictor( cStruct.iBestX, cStruct.iBestY );

}


Void TEncSearch::xPatternSearchFracDIF(
                                       Bool         bIsLosslessCoded,
                                       TComPattern* pcPatternKey,
                                       Pel*         piRefY,
                                       Int          iRefStride,
                                       TComMv*      pcMvInt,
                                       TComMv&      rcMvHalf,
                                       TComMv&      rcMvQter,
                                       Distortion&  ruiCost
                                      )
{
  //  Reference pattern initialization (integer scale)
	
  TComPattern cPatternRoi;
  Int         iOffset    = pcMvInt->getHor() + pcMvInt->getVer() * iRefStride;
  cPatternRoi.initPattern(piRefY + iOffset,
                          pcPatternKey->getROIYWidth(),
                          pcPatternKey->getROIYHeight(),
                          iRefStride,
                          pcPatternKey->getBitDepthY());

  //  Half-pel refinement
  xExtDIFUpSamplingH ( &cPatternRoi );

  rcMvHalf = *pcMvInt;   rcMvHalf <<= 1;    // for mv-cost
  TComMv baseRefMv(0, 0);
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 2, rcMvHalf, !bIsLosslessCoded );

  m_pcRdCost->setCostScale( 0 );

  xExtDIFUpSamplingQ ( &cPatternRoi, rcMvHalf );
  baseRefMv = rcMvHalf;
  baseRefMv <<= 1;

  rcMvQter = *pcMvInt;   rcMvQter <<= 1;    // for mv-cost
  rcMvQter += rcMvHalf;  rcMvQter <<= 1;
  ruiCost = xPatternRefinement( pcPatternKey, baseRefMv, 1, rcMvQter, !bIsLosslessCoded );
}


//! encode residual and calculate rate-distortion for a CU block
Void TEncSearch::encodeResAndCalcRdInterCU( TComDataCU* pcCU, TComYuv* pcYuvOrg, TComYuv* pcYuvPred,
                                            TComYuv* pcYuvResi, TComYuv* pcYuvResiBest, TComYuv* pcYuvRec,
                                            Bool bSkipResidual DEBUG_STRING_FN_DECLARE(sDebug) )
{
  assert ( !pcCU->isIntra(0) );

  const UInt cuWidthPixels      = pcCU->getWidth ( 0 );
  const UInt cuHeightPixels     = pcCU->getHeight( 0 );
  const Int  numValidComponents = pcCU->getPic()->getNumberValidComponents();
  const TComSPS &sps=*(pcCU->getSlice()->getSPS());

  // The pcCU is not marked as skip-mode at this point, and its m_pcTrCoeff, m_pcArlCoeff, m_puhCbf, m_puhTrIdx will all be 0.
  // due to prior calls to TComDataCU::initEstData(  );

  if ( bSkipResidual ) //  No residual coding : SKIP mode
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    pcYuvResi->clear();

    pcYuvPred->copyToPartYuv( pcYuvRec, 0 );
    Distortion distortion = 0;

    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID compID=ComponentID(comp);
      const UInt csx=pcYuvOrg->getComponentScaleX(compID);
      const UInt csy=pcYuvOrg->getComponentScaleY(compID);
      distortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID), pcYuvRec->getStride(compID), pcYuvOrg->getAddr(compID),
                                               pcYuvOrg->getStride(compID), cuWidthPixels >> csx, cuHeightPixels >> csy, compID);
    }

    m_pcRDGoOnSbacCoder->load(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST]);
    m_pcEntropyCoder->resetBits();

    if (pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex( pcCU, 0, true );

    UInt uiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    pcCU->getTotalBits()       = uiBits;
    pcCU->getTotalDistortion() = distortion;
    pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( uiBits, distortion );

    m_pcRDGoOnSbacCoder->store(m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_TEMP_BEST]);

#if DEBUG_STRING
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif

    return;
  }

  //  Residual coding.

   pcYuvResi->subtract( pcYuvOrg, pcYuvPred, 0, cuWidthPixels );

  TComTURecurse tuLevel0(pcCU, 0);

  Double     nonZeroCost       = 0;
  UInt       nonZeroBits       = 0;
  Distortion nonZeroDistortion = 0;
  Distortion zeroDistortion    = 0;

  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_CURR_BEST ] );

  xEstimateInterResidualQT( pcYuvResi,  nonZeroCost, nonZeroBits, nonZeroDistortion, &zeroDistortion, tuLevel0 DEBUG_STRING_PASS_INTO(sDebug) );

  // -------------------------------------------------------
  // set the coefficients in the pcCU, and also calculates the residual data.
  // If a block full of 0's is efficient, then just use 0's.
  // The costs at this point do not include header bits.

  m_pcEntropyCoder->resetBits();
  m_pcEntropyCoder->encodeQtRootCbfZero( );
  const UInt   zeroResiBits = m_pcEntropyCoder->getNumberOfWrittenBits();
  const Double zeroCost     = (pcCU->isLosslessCoded( 0 )) ? (nonZeroCost+1) : (m_pcRdCost->calcRdCost( zeroResiBits, zeroDistortion ));

  if ( zeroCost < nonZeroCost || !pcCU->getQtRootCbf(0) )
  {
    const UInt uiQPartNum = tuLevel0.GetAbsPartIdxNumParts();
    ::memset( pcCU->getTransformIdx()     , 0, uiQPartNum * sizeof(UChar) );
    for (Int comp=0; comp < numValidComponents; comp++)
    {
      const ComponentID component = ComponentID(comp);
      ::memset( pcCU->getCbf( component ) , 0, uiQPartNum * sizeof(UChar) );
      ::memset( pcCU->getCrossComponentPredictionAlpha(component), 0, ( uiQPartNum * sizeof(SChar) ) );
    }
    static const UInt useTS[MAX_NUM_COMPONENT]={0,0,0};
    pcCU->setTransformSkipSubParts ( useTS, 0, pcCU->getDepth(0) );
#if DEBUG_STRING
    sDebug.clear();
    for(UInt i=0; i<MAX_NUM_COMPONENT+1; i++)
    {
      sDebug+=debug_reorder_data_inter_token[i];
    }
#endif
  }
  else
  {
    xSetInterResidualQTData( NULL, false, tuLevel0); // Call first time to set coefficients.
  }

  // all decisions now made. Fully encode the CU, including the headers:
  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[pcCU->getDepth(0)][CI_CURR_BEST] );

  UInt finalBits = 0;
  xAddSymbolBitsInter( pcCU, finalBits );
  // we've now encoded the pcCU, and so have a valid bit cost

  if ( !pcCU->getQtRootCbf( 0 ) )
  {
    pcYuvResiBest->clear(); // Clear the residual image, if we didn't code it.
  }
  else
  {
    xSetInterResidualQTData( pcYuvResiBest, true, tuLevel0 ); // else set the residual image data pcYUVResiBest from the various temp images.
  }
  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ pcCU->getDepth( 0 ) ][ CI_TEMP_BEST ] );

  pcYuvRec->addClip ( pcYuvPred, pcYuvResiBest, 0, cuWidthPixels, sps.getBitDepths() );

  // update with clipped distortion and cost (previously unclipped reconstruction values were used)

  Distortion finalDistortion = 0;
  for(Int comp=0; comp<numValidComponents; comp++)
  {
    const ComponentID compID=ComponentID(comp);
    finalDistortion += m_pcRdCost->getDistPart( sps.getBitDepth(toChannelType(compID)), pcYuvRec->getAddr(compID ), pcYuvRec->getStride(compID ), pcYuvOrg->getAddr(compID ), pcYuvOrg->getStride(compID), cuWidthPixels >> pcYuvOrg->getComponentScaleX(compID), cuHeightPixels >> pcYuvOrg->getComponentScaleY(compID), compID);
  }

  pcCU->getTotalBits()       = finalBits;
  pcCU->getTotalDistortion() = finalDistortion;
  pcCU->getTotalCost()       = m_pcRdCost->calcRdCost( finalBits, finalDistortion );
}



Void TEncSearch::xEstimateInterResidualQT( TComYuv    *pcResi,
                                           Double     &rdCost,
                                           UInt       &ruiBits,
                                           Distortion &ruiDist,
                                           Distortion *puiZeroDist,
                                           TComTU     &rTu
                                           DEBUG_STRING_FN_DECLARE(sDebug) )
{
  TComDataCU *pcCU        = rTu.getCU();
  const UInt uiAbsPartIdx = rTu.GetAbsPartIdxTU();
  const UInt uiDepth      = rTu.GetTransformDepthTotal();
  const UInt uiTrMode     = rTu.GetTransformDepthRel();
  const UInt subTUDepth   = uiTrMode + 1;
  const UInt numValidComp = pcCU->getPic()->getNumberValidComponents();
  DEBUG_STRING_NEW(sSingleStringComp[MAX_NUM_COMPONENT])

  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  UInt SplitFlag = ((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && pcCU->isInter(uiAbsPartIdx) && ( pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N ));
#if DEBUG_STRING
  const Int debugPredModeMask = DebugStringGetPredModeMask(pcCU->getPredictionMode(uiAbsPartIdx));
#endif

  Bool bCheckFull;

  if ( SplitFlag && uiDepth == pcCU->getDepth(uiAbsPartIdx) && ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) ) )
  {
    bCheckFull = false;
  }
  else
  {
    bCheckFull =  ( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() );
  }

  const Bool bCheckSplit  = ( uiLog2TrSize >  pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) );

  assert( bCheckFull || bCheckSplit );

  // code full block
  Double     dSingleCost = MAX_DOUBLE;
  UInt       uiSingleBits                                                                                                        = 0;
  Distortion uiSingleDistComp            [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  Distortion uiSingleDist                                                                                                        = 0;
  TCoeff     uiAbsSum                    [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  UInt       uiBestTransformMode         [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};
  //  Stores the best explicit RDPCM mode for a TU encoded without split
  UInt       bestExplicitRdpcmModeUnSplit[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{3,3}, {3,3}, {3,3}};
  SChar      bestCrossCPredictionAlpha   [MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/] = {{0,0},{0,0},{0,0}};

  m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );

  if( bCheckFull )
  {
    Double minCost[MAX_NUM_COMPONENT][2/*0 = top (or whole TU for non-4:2:2) sub-TU, 1 = bottom sub-TU*/];
    Bool checkTransformSkip[MAX_NUM_COMPONENT];
    pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

    m_pcEntropyCoder->resetBits();

    memset( m_pTempPel, 0, sizeof( Pel ) * rTu.getRect(COMPONENT_Y).width * rTu.getRect(COMPONENT_Y).height ); // not necessary needed for inside of recursion (only at the beginning)

    const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
    TCoeff *pcCoeffCurr[MAX_NUM_COMPONENT];
#if ADAPTIVE_QP_SELECTION
    TCoeff *pcArlCoeffCurr[MAX_NUM_COMPONENT];
#endif

    for(UInt i=0; i<numValidComp; i++)
    {
      minCost[i][0] = MAX_DOUBLE;
      minCost[i][1] = MAX_DOUBLE;
    }

    Pel crossCPredictedResidualBuffer[ MAX_TU_SIZE * MAX_TU_SIZE ];

    for(UInt i=0; i<numValidComp; i++)
    {
      checkTransformSkip[i]=false;
      const ComponentID compID=ComponentID(i);
      const Int channelBitDepth=pcCU->getSlice()->getSPS()->getBitDepth(toChannelType(compID));
      pcCoeffCurr[compID]    = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
#if ADAPTIVE_QP_SELECTION
      pcArlCoeffCurr[compID] = m_ppcQTTempArlCoeff[compID ][uiQTTempAccessLayer] +  rTu.getCoefficientOffset(compID);
#endif

      if(rTu.ProcessComponentSection(compID))
      {
        const QpParam cQP(*pcCU, compID);

        checkTransformSkip[compID] = pcCU->getSlice()->getPPS()->getUseTransformSkip() &&
                                     TUCompRectHasAssociatedTransformSkipFlag(rTu.getRect(compID), pcCU->getSlice()->getPPS()->getPpsRangeExtension().getLog2MaxTransformSkipBlockSize()) &&
                                     (!pcCU->isLosslessCoded(0));

        const Bool splitIntoSubTUs = rTu.getRect(compID).width != rTu.getRect(compID).height;

        TComTURecurse TUIterator(rTu, false, (splitIntoSubTUs ? TComTU::VERTICAL_SPLIT : TComTU::DONT_SPLIT), true, compID);

        const UInt partIdxesPerSubTU = TUIterator.GetAbsPartIdxNumParts(compID);

        do
        {
          const UInt           subTUIndex             = TUIterator.GetSectionNumber();
          const UInt           subTUAbsPartIdx        = TUIterator.GetAbsPartIdxTU(compID);
          const TComRectangle &tuCompRect             = TUIterator.getRect(compID);
          const UInt           subTUBufferOffset      = tuCompRect.width * tuCompRect.height * subTUIndex;

                TCoeff        *currentCoefficients    = pcCoeffCurr[compID] + subTUBufferOffset;
#if ADAPTIVE_QP_SELECTION
                TCoeff        *currentARLCoefficients = pcArlCoeffCurr[compID] + subTUBufferOffset;
#endif
          const Bool isCrossCPredictionAvailable      =    isChroma(compID)
                                                         && pcCU->getSlice()->getPPS()->getPpsRangeExtension().getCrossComponentPredictionEnabledFlag()
                                                         && (pcCU->getCbf(subTUAbsPartIdx, COMPONENT_Y, uiTrMode) != 0);

          SChar preCalcAlpha = 0;
          const Pel *pLumaResi = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( COMPONENT_Y, rTu.getRect( COMPONENT_Y ).x0, rTu.getRect( COMPONENT_Y ).y0 );

          if (isCrossCPredictionAvailable)
          {
            const Bool bUseReconstructedResidualForEstimate = m_pcEncCfg->getUseReconBasedCrossCPredictionEstimate();
            const Pel  *const lumaResidualForEstimate       = bUseReconstructedResidualForEstimate ? pLumaResi                                                     : pcResi->getAddrPix(COMPONENT_Y, tuCompRect.x0, tuCompRect.y0);
            const UInt        lumaResidualStrideForEstimate = bUseReconstructedResidualForEstimate ? m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y) : pcResi->getStride(COMPONENT_Y);

            preCalcAlpha = xCalcCrossComponentPredictionAlpha(TUIterator,
                                                              compID,
                                                              lumaResidualForEstimate,
                                                              pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                              tuCompRect.width,
                                                              tuCompRect.height,
                                                              lumaResidualStrideForEstimate,
                                                              pcResi->getStride(compID));
          }

          const Int transformSkipModesToTest    = checkTransformSkip[compID] ? 2 : 1;
          const Int crossCPredictionModesToTest = (preCalcAlpha != 0)        ? 2 : 1; // preCalcAlpha cannot be anything other than 0 if isCrossCPredictionAvailable is false

          const Bool isOneMode                  = (crossCPredictionModesToTest == 1) && (transformSkipModesToTest == 1);

          for (Int transformSkipModeId = 0; transformSkipModeId < transformSkipModesToTest; transformSkipModeId++)
          {
            pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);

            for (Int crossCPredictionModeId = 0; crossCPredictionModeId < crossCPredictionModesToTest; crossCPredictionModeId++)
            {
              const Bool isFirstMode          = (transformSkipModeId == 0) && (crossCPredictionModeId == 0);
              const Bool bUseCrossCPrediction = crossCPredictionModeId != 0;

              m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
              m_pcEntropyCoder->resetBits();

              pcCU->setTransformSkipPartRange(transformSkipModeId, compID, subTUAbsPartIdx, partIdxesPerSubTU);
              pcCU->setCrossComponentPredictionAlphaPartRange((bUseCrossCPrediction ? preCalcAlpha : 0), compID, subTUAbsPartIdx, partIdxesPerSubTU );

              if ((compID != COMPONENT_Cr) && ((transformSkipModeId == 1) ? m_pcEncCfg->getUseRDOQTS() : m_pcEncCfg->getUseRDOQ()))
              {
                m_pcEntropyCoder->estimateBit(m_pcTrQuant->m_pcEstBitsSbac, tuCompRect.width, tuCompRect.height, toChannelType(compID));
              }

#if RDOQ_CHROMA_LAMBDA
              m_pcTrQuant->selectLambda(compID);
#endif

              Pel *pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
              UInt resiStride     = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);

              TCoeff bestCoeffComp   [MAX_TU_SIZE*MAX_TU_SIZE];
              Pel    bestResiComp    [MAX_TU_SIZE*MAX_TU_SIZE];

#if ADAPTIVE_QP_SELECTION
              TCoeff bestArlCoeffComp[MAX_TU_SIZE*MAX_TU_SIZE];
#endif
              TCoeff     currAbsSum   = 0;
              UInt       currCompBits = 0;
              Distortion currCompDist = 0;
              Double     currCompCost = 0;
              UInt       nonCoeffBits = 0;
              Distortion nonCoeffDist = 0;
              Double     nonCoeffCost = 0;

              if(!isOneMode && !isFirstMode)
              {
                memcpy(bestCoeffComp,    currentCoefficients,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(bestArlCoeffComp, currentARLCoefficients, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for(Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy(&bestResiComp[y * tuCompRect.width], (pcResiCurrComp + (y * resiStride)), (sizeof(Pel) * tuCompRect.width));
                }
              }

              if (bUseCrossCPrediction)
              {
                TComTrQuant::crossComponentPrediction(TUIterator,
                                                      compID,
                                                      pLumaResi,
                                                      pcResi->getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                      crossCPredictedResidualBuffer,
                                                      tuCompRect.width,
                                                      tuCompRect.height,
                                                      m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                      pcResi->getStride(compID),
                                                      tuCompRect.width,
                                                      false);

                m_pcTrQuant->transformNxN(TUIterator, compID, crossCPredictedResidualBuffer, tuCompRect.width, currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }
              else
              {
                m_pcTrQuant->transformNxN(TUIterator, compID, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ), pcResi->getStride(compID), currentCoefficients,
#if ADAPTIVE_QP_SELECTION
                                          currentARLCoefficients,
#endif
                                          currAbsSum, cQP);
              }

              if(isFirstMode || (currAbsSum == 0))
              {
                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pTempPel,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        tuCompRect.width,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        true);

                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride( compID ), pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }
                else
                {
                  nonCoeffDist = m_pcRdCost->getDistPart( channelBitDepth, m_pTempPel, tuCompRect.width, pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                          pcResi->getStride(compID), tuCompRect.width, tuCompRect.height, compID); // initialized with zero residual distortion
                }

                m_pcEntropyCoder->encodeQtCbfZero( TUIterator, toChannelType(compID) );

                if ( isCrossCPredictionAvailable )
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                nonCoeffBits = m_pcEntropyCoder->getNumberOfWrittenBits();
                nonCoeffCost = m_pcRdCost->calcRdCost( nonCoeffBits, nonCoeffDist );
              }

              if((puiZeroDist != NULL) && isFirstMode)
              {
                *puiZeroDist += nonCoeffDist; // initialized with zero residual distortion
              }

              DEBUG_STRING_NEW(sSingleStringTest)

              if( currAbsSum > 0 ) //if non-zero coefficients are present, a residual needs to be derived for further prediction
              {
                if (isFirstMode)
                {
                  m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
                  m_pcEntropyCoder->resetBits();
                }

                m_pcEntropyCoder->encodeQtCbf( TUIterator, compID, true );

                if (isCrossCPredictionAvailable)
                {
                  m_pcEntropyCoder->encodeCrossComponentPrediction( TUIterator, compID );
                }

                m_pcEntropyCoder->encodeCoeffNxN( TUIterator, currentCoefficients, compID );
                currCompBits = m_pcEntropyCoder->getNumberOfWrittenBits();

                pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 );

                m_pcTrQuant->invTransformNxN( TUIterator, compID, pcResiCurrComp, m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID), currentCoefficients, cQP DEBUG_STRING_PASS_INTO_OPTIONAL(&sSingleStringTest, (DebugOptionList::DebugString_InvTran.getInt()&debugPredModeMask)) );

                if (bUseCrossCPrediction)
                {
                  TComTrQuant::crossComponentPrediction(TUIterator,
                                                        compID,
                                                        pLumaResi,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                        tuCompRect.width,
                                                        tuCompRect.height,
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID     ),
                                                        true);
                }

                currCompDist = m_pcRdCost->getDistPart( channelBitDepth, m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                        pcResi->getAddrPix( compID, tuCompRect.x0, tuCompRect.y0 ),
                                                        pcResi->getStride(compID),
                                                        tuCompRect.width, tuCompRect.height, compID);

                currCompCost = m_pcRdCost->calcRdCost(currCompBits, currCompDist);
                  
                if (pcCU->isLosslessCoded(0))
                {
                  nonCoeffCost = MAX_DOUBLE;
                }
              }
              else if ((transformSkipModeId == 1) && !bUseCrossCPrediction)
              {
                currCompCost = MAX_DOUBLE;
              }
              else
              {
                currCompBits = nonCoeffBits;
                currCompDist = nonCoeffDist;
                currCompCost = nonCoeffCost;
              }

              // evaluate
              if ((currCompCost < minCost[compID][subTUIndex]) || ((transformSkipModeId == 1) && (currCompCost == minCost[compID][subTUIndex])))
              {
                bestExplicitRdpcmModeUnSplit[compID][subTUIndex] = pcCU->getExplicitRdpcmMode(compID, subTUAbsPartIdx);

                if(isFirstMode) //check for forced null
                {
                  if((nonCoeffCost < currCompCost) || (currAbsSum == 0))
                  {
                    memset(currentCoefficients, 0, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));

                    currAbsSum   = 0;
                    currCompBits = nonCoeffBits;
                    currCompDist = nonCoeffDist;
                    currCompCost = nonCoeffCost;
                  }
                }

#if DEBUG_STRING
                if (currAbsSum > 0)
                {
                  DEBUG_STRING_SWAP(sSingleStringComp[compID], sSingleStringTest)
                }
                else
                {
                  sSingleStringComp[compID].clear();
                }
#endif

                uiAbsSum                 [compID][subTUIndex] = currAbsSum;
                uiSingleDistComp         [compID][subTUIndex] = currCompDist;
                minCost                  [compID][subTUIndex] = currCompCost;
                uiBestTransformMode      [compID][subTUIndex] = transformSkipModeId;
                bestCrossCPredictionAlpha[compID][subTUIndex] = (crossCPredictionModeId == 1) ? pcCU->getCrossComponentPredictionAlpha(subTUAbsPartIdx, compID) : 0;

                if (uiAbsSum[compID][subTUIndex] == 0)
                {
                  if (bUseCrossCPrediction)
                  {
                    TComTrQuant::crossComponentPrediction(TUIterator,
                                                          compID,
                                                          pLumaResi,
                                                          m_pTempPel,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0),
                                                          tuCompRect.width,
                                                          tuCompRect.height,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(COMPONENT_Y),
                                                          tuCompRect.width,
                                                          m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID),
                                                          true);
                  }
                  else
                  {
                    pcResiCurrComp = m_pcQTTempTComYuv[uiQTTempAccessLayer].getAddrPix(compID, tuCompRect.x0, tuCompRect.y0);
                    const UInt uiStride = m_pcQTTempTComYuv[uiQTTempAccessLayer].getStride(compID);
                    for(UInt uiY = 0; uiY < tuCompRect.height; uiY++)
                    {
                      memset(pcResiCurrComp, 0, (sizeof(Pel) * tuCompRect.width));
                      pcResiCurrComp += uiStride;
                    }
                  }
                }
              }
              else
              {
                // reset
                memcpy(currentCoefficients,    bestCoeffComp,    (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#if ADAPTIVE_QP_SELECTION
                memcpy(currentARLCoefficients, bestArlCoeffComp, (sizeof(TCoeff) * tuCompRect.width * tuCompRect.height));
#endif
                for (Int y = 0; y < tuCompRect.height; y++)
                {
                  memcpy((pcResiCurrComp + (y * resiStride)), &bestResiComp[y * tuCompRect.width], (sizeof(Pel) * tuCompRect.width));
                }
              }
            }
          }

          pcCU->setExplicitRdpcmModePartRange            (   bestExplicitRdpcmModeUnSplit[compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU);
          pcCU->setTransformSkipPartRange                (   uiBestTransformMode         [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCbfPartRange                          ((((uiAbsSum                    [compID][subTUIndex] > 0) ? 1 : 0) << uiTrMode), compID, subTUAbsPartIdx, partIdxesPerSubTU );
          pcCU->setCrossComponentPredictionAlphaPartRange(   bestCrossCPredictionAlpha   [compID][subTUIndex],                            compID, subTUAbsPartIdx, partIdxesPerSubTU );
        } while (TUIterator.nextSection(rTu)); //end of sub-TU loop
      } // processing section
    } // component loop

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID = ComponentID(ch);
      if (rTu.ProcessComponentSection(compID) && (rTu.getRect(compID).width != rTu.getRect(compID).height))
      {
        offsetSubTUCBFs(rTu, compID); //the CBFs up to now have been defined for two sub-TUs - shift them down a level and replace with the parent level CBF
      }
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    if( uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      m_pcEntropyCoder->encodeTransformSubdivFlag( 0, 5 - uiLog2TrSize );
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const UInt chOrderChange = ((ch + 1) == numValidComp) ? 0 : (ch + 1);
      const ComponentID compID=ComponentID(chOrderChange);
      if( rTu.ProcessComponentSection(compID) )
      {
        m_pcEntropyCoder->encodeQtCbf( rTu, compID, true );
      }
    }

    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      if (rTu.ProcessComponentSection(compID))
      {
        if(isChroma(compID) && (uiAbsSum[COMPONENT_Y][0] != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction( rTu, compID );
        }

        m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr[compID], compID );
        for (UInt subTUIndex = 0; subTUIndex < 2; subTUIndex++)
        {
          uiSingleDist += uiSingleDistComp[compID][subTUIndex];
        }
      }
    }

    uiSingleBits = m_pcEntropyCoder->getNumberOfWrittenBits();

    dSingleCost = m_pcRdCost->calcRdCost( uiSingleBits, uiSingleDist );
  } // check full

  // code sub-blocks
  if( bCheckSplit )
  {
    if( bCheckFull )
    {
      m_pcRDGoOnSbacCoder->store( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
      m_pcRDGoOnSbacCoder->load ( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    }
    Distortion uiSubdivDist = 0;
    UInt       uiSubdivBits = 0;
    Double     dSubdivCost = 0.0;

    //save the non-split CBFs in case we need to restore them later

    UInt bestCBF     [MAX_NUM_COMPONENT];
    UInt bestsubTUCBF[MAX_NUM_COMPONENT][2];
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);

      if (rTu.ProcessComponentSection(compID))
      {
        bestCBF[compID] = pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode);

        const TComRectangle &tuCompRect = rTu.getRect(compID);
        if (tuCompRect.width != tuCompRect.height)
        {
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> 1;

          for (UInt subTU = 0; subTU < 2; subTU++)
          {
            bestsubTUCBF[compID][subTU] = pcCU->getCbf ((uiAbsPartIdx + (subTU * partIdxesPerSubTU)), compID, subTUDepth);
          }
        }
      }
    }


    TComTURecurse tuRecurseChild(rTu, false);
    const UInt uiQPartNumSubdiv = tuRecurseChild.GetAbsPartIdxNumParts();

    DEBUG_STRING_NEW(sSplitString[MAX_NUM_COMPONENT])

    do
    {
      DEBUG_STRING_NEW(childString)
      xEstimateInterResidualQT( pcResi, dSubdivCost, uiSubdivBits, uiSubdivDist, bCheckFull ? NULL : puiZeroDist,  tuRecurseChild DEBUG_STRING_PASS_INTO(childString));
#if DEBUG_STRING
      // split the string by component and append to the relevant output (because decoder decodes in channel order, whereas this search searches by TU-order)
      std::size_t lastPos=0;
      const std::size_t endStrng=childString.find(debug_reorder_data_inter_token[MAX_NUM_COMPONENT], lastPos);
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        if (lastPos!=std::string::npos && childString.find(debug_reorder_data_inter_token[ch], lastPos)==lastPos)
        {
          lastPos+=strlen(debug_reorder_data_inter_token[ch]); // skip leading string
        }
        std::size_t pos=childString.find(debug_reorder_data_inter_token[ch+1], lastPos);
        if (pos!=std::string::npos && pos>endStrng)
        {
          lastPos=endStrng;
        }
        sSplitString[ch]+=childString.substr(lastPos, (pos==std::string::npos)? std::string::npos : (pos-lastPos) );
        lastPos=pos;
      }
#endif
    } while ( tuRecurseChild.nextSection(rTu) ) ;

    UInt uiCbfAny=0;
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      UInt uiYUVCbf = 0;
      for( UInt ui = 0; ui < 4; ++ui )
      {
        uiYUVCbf |= pcCU->getCbf( uiAbsPartIdx + ui * uiQPartNumSubdiv, ComponentID(ch),  uiTrMode + 1 );
      }
      UChar *pBase=pcCU->getCbf( ComponentID(ch) );
      const UInt flags=uiYUVCbf << uiTrMode;
      for( UInt ui = 0; ui < 4 * uiQPartNumSubdiv; ++ui )
      {
        pBase[uiAbsPartIdx + ui] |= flags;
      }
      uiCbfAny|=uiYUVCbf;
    }

    m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_ROOT ] );
    m_pcEntropyCoder->resetBits();

    // when compID isn't a channel, code Cbfs:
    xEncodeInterResidualQT( MAX_NUM_COMPONENT, rTu );
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      xEncodeInterResidualQT( ComponentID(ch), rTu );
    }

    uiSubdivBits = m_pcEntropyCoder->getNumberOfWrittenBits();
    dSubdivCost  = m_pcRdCost->calcRdCost( uiSubdivBits, uiSubdivDist );

    if (!bCheckFull || (uiCbfAny && (dSubdivCost < dSingleCost)))
    {
      rdCost += dSubdivCost;
      ruiBits += uiSubdivBits;
      ruiDist += uiSubdivDist;
#if DEBUG_STRING
      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        DEBUG_STRING_APPEND(sDebug, sSplitString[ch])
      }
#endif
    }
    else
    {
      rdCost  += dSingleCost;
      ruiBits += uiSingleBits;
      ruiDist += uiSingleDist;

      //restore state to unsplit

      pcCU->setTrIdxSubParts( uiTrMode, uiAbsPartIdx, uiDepth );

      for(UInt ch = 0; ch < numValidComp; ch++)
      {
        const ComponentID compID=ComponentID(ch);

        DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[ch])
        if (rTu.ProcessComponentSection(compID))
        {
          DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])

          const Bool splitIntoSubTUs   = rTu.getRect(compID).width != rTu.getRect(compID).height;
          const UInt numberOfSections  = splitIntoSubTUs ? 2 : 1;
          const UInt partIdxesPerSubTU = rTu.GetAbsPartIdxNumParts(compID) >> (splitIntoSubTUs ? 1 : 0);

          for (UInt subTUIndex = 0; subTUIndex < numberOfSections; subTUIndex++)
          {
            const UInt  uisubTUPartIdx = uiAbsPartIdx + (subTUIndex * partIdxesPerSubTU);

            if (splitIntoSubTUs)
            {
              const UChar combinedCBF = (bestsubTUCBF[compID][subTUIndex] << subTUDepth) | (bestCBF[compID] << uiTrMode);
              pcCU->setCbfPartRange(combinedCBF, compID, uisubTUPartIdx, partIdxesPerSubTU);
            }
            else
            {
              pcCU->setCbfPartRange((bestCBF[compID] << uiTrMode), compID, uisubTUPartIdx, partIdxesPerSubTU);
            }

            pcCU->setCrossComponentPredictionAlphaPartRange(bestCrossCPredictionAlpha[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setTransformSkipPartRange(uiBestTransformMode[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
            pcCU->setExplicitRdpcmModePartRange(bestExplicitRdpcmModeUnSplit[compID][subTUIndex], compID, uisubTUPartIdx, partIdxesPerSubTU);
          }
        }
      }

      m_pcRDGoOnSbacCoder->load( m_pppcRDSbacCoder[ uiDepth ][ CI_QT_TRAFO_TEST ] );
    }
  }
  else
  {
    rdCost  += dSingleCost;
    ruiBits += uiSingleBits;
    ruiDist += uiSingleDist;
#if DEBUG_STRING
    for(UInt ch = 0; ch < numValidComp; ch++)
    {
      const ComponentID compID=ComponentID(ch);
      DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[compID])

      if (rTu.ProcessComponentSection(compID))
      {
        DEBUG_STRING_APPEND(sDebug, sSingleStringComp[compID])
      }
    }
#endif
  }
  DEBUG_STRING_APPEND(sDebug, debug_reorder_data_inter_token[MAX_NUM_COMPONENT])
}



Void TEncSearch::xEncodeInterResidualQT( const ComponentID compID, TComTU &rTu )
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  const UInt uiCurrTrMode = rTu.GetTransformDepthRel();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );

  const Bool bSubdiv = uiCurrTrMode != uiTrMode;

  const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();

  if (compID==MAX_NUM_COMPONENT)  // we are not processing a channel, instead we always recurse and code the CBFs
  {
    if( uiLog2TrSize <= pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() && uiLog2TrSize > pcCU->getQuadtreeTULog2MinSizeInCU(uiAbsPartIdx) )
    {
      if((pcCU->getSlice()->getSPS()->getQuadtreeTUMaxDepthInter() == 1) && (pcCU->getPartitionSize(uiAbsPartIdx) != SIZE_2Nx2N))
      {
        assert(bSubdiv); // Inferred splitting rule - see derivation and use of interSplitFlag in the specification.
      }
      else
      {
        m_pcEntropyCoder->encodeTransformSubdivFlag( bSubdiv, 5 - uiLog2TrSize );
      }
    }

    assert( !pcCU->isIntra(uiAbsPartIdx) );

    const Bool bFirstCbfOfCU = uiCurrTrMode == 0;

    for (UInt ch=COMPONENT_Cb; ch<pcCU->getPic()->getNumberValidComponents(); ch++)
    {
      const ComponentID compIdInner=ComponentID(ch);
      if( bFirstCbfOfCU || rTu.ProcessingAllQuadrants(compIdInner) )
      {
        if( bFirstCbfOfCU || pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) )
        {
          m_pcEntropyCoder->encodeQtCbf( rTu, compIdInner, !bSubdiv );
        }
      }
      else
      {
        assert( pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode ) == pcCU->getCbf( uiAbsPartIdx, compIdInner, uiCurrTrMode - 1 ) );
      }
    }

    if (!bSubdiv)
    {
      m_pcEntropyCoder->encodeQtCbf( rTu, COMPONENT_Y, true );
    }
  }

  if( !bSubdiv )
  {
    if (compID != MAX_NUM_COMPONENT) // we have already coded the CBFs, so now we code coefficients
    {
      if (rTu.ProcessComponentSection(compID))
      {
        if (isChroma(compID) && (pcCU->getCbf(uiAbsPartIdx, COMPONENT_Y, uiTrMode) != 0))
        {
          m_pcEntropyCoder->encodeCrossComponentPrediction(rTu, compID);
        }

        if (pcCU->getCbf(uiAbsPartIdx, compID, uiTrMode) != 0)
        {
          const UInt uiQTTempAccessLayer = pcCU->getSlice()->getSPS()->getQuadtreeTULog2MaxSize() - uiLog2TrSize;
          TCoeff *pcCoeffCurr = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + rTu.getCoefficientOffset(compID);
          m_pcEntropyCoder->encodeCoeffNxN( rTu, pcCoeffCurr, compID );
        }
      }
    }
  }
  else
  {
    if( compID==MAX_NUM_COMPONENT || pcCU->getCbf( uiAbsPartIdx, compID, uiCurrTrMode ) )
    {
      TComTURecurse tuRecurseChild(rTu, false);
      do
      {
        xEncodeInterResidualQT( compID, tuRecurseChild );
      } while (tuRecurseChild.nextSection(rTu));
    }
  }
}




Void TEncSearch::xSetInterResidualQTData( TComYuv* pcResi, Bool bSpatial, TComTU &rTu ) // TODO: turn this into two functions for bSpatial=true and false.
{
  TComDataCU* pcCU=rTu.getCU();
  const UInt uiCurrTrMode=rTu.GetTransformDepthRel();
  const UInt uiAbsPartIdx=rTu.GetAbsPartIdxTU();
  assert( pcCU->getDepth( 0 ) == pcCU->getDepth( uiAbsPartIdx ) );
  const UInt uiTrMode = pcCU->getTransformIdx( uiAbsPartIdx );
  const TComSPS *sps=pcCU->getSlice()->getSPS();

  if( uiCurrTrMode == uiTrMode )
  {
    const UInt uiLog2TrSize = rTu.GetLog2LumaTrSize();
    const UInt uiQTTempAccessLayer = sps->getQuadtreeTULog2MaxSize() - uiLog2TrSize;

    if( bSpatial )
    {
      // Data to be copied is in the spatial domain, i.e., inverse-transformed.

      for(UInt i=0; i<pcResi->getNumberValidComponents(); i++)
      {
        const ComponentID compID=ComponentID(i);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          m_pcQTTempTComYuv[uiQTTempAccessLayer].copyPartToPartComponentMxN    ( compID, pcResi, rectCompTU );
        }
      }
    }
    else
    {
      for (UInt ch=0; ch < getNumberValidComponents(sps->getChromaFormatIdc()); ch++)
      {
        const ComponentID compID   = ComponentID(ch);
        if (rTu.ProcessComponentSection(compID))
        {
          const TComRectangle &rectCompTU(rTu.getRect(compID));
          const UInt numCoeffInBlock    = rectCompTU.width * rectCompTU.height;
          const UInt offset             = rTu.getCoefficientOffset(compID);
          TCoeff* dest                  = pcCU->getCoeff(compID)                        + offset;
          const TCoeff* src             = m_ppcQTTempCoeff[compID][uiQTTempAccessLayer] + offset;
          ::memcpy( dest, src, sizeof(TCoeff)*numCoeffInBlock );

#if ADAPTIVE_QP_SELECTION
          TCoeff* pcArlCoeffSrc            = m_ppcQTTempArlCoeff[compID][uiQTTempAccessLayer] + offset;
          TCoeff* pcArlCoeffDst            = pcCU->getArlCoeff(compID)                        + offset;
          ::memcpy( pcArlCoeffDst, pcArlCoeffSrc, sizeof( TCoeff ) * numCoeffInBlock );
#endif
        }
      }
    }
  }
  else
  {

    TComTURecurse tuRecurseChild(rTu, false);
    do
    {
      xSetInterResidualQTData( pcResi, bSpatial, tuRecurseChild );
    } while (tuRecurseChild.nextSection(rTu));
  }
}




UInt TEncSearch::xModeBitsIntra( TComDataCU* pcCU, UInt uiMode, UInt uiPartOffset, UInt uiDepth, const ChannelType chType )
{
  // Reload only contexts required for coding intra mode information
  m_pcRDGoOnSbacCoder->loadIntraDirMode( m_pppcRDSbacCoder[uiDepth][CI_CURR_BEST], chType );

  // Temporarily set the intra dir being tested, and only
  // for absPartIdx, since encodeIntraDirModeLuma/Chroma only use
  // the entry at absPartIdx.

  UChar &rIntraDirVal=pcCU->getIntraDir( chType )[uiPartOffset];
  UChar origVal=rIntraDirVal;
  rIntraDirVal = uiMode;
  //pcCU->setIntraDirSubParts ( chType, uiMode, uiPartOffset, uiDepth + uiInitTrDepth );

  m_pcEntropyCoder->resetBits();
  if (isLuma(chType))
  {
    m_pcEntropyCoder->encodeIntraDirModeLuma ( pcCU, uiPartOffset);
  }
  else
  {
    m_pcEntropyCoder->encodeIntraDirModeChroma ( pcCU, uiPartOffset);
  }

  rIntraDirVal = origVal; // restore

  return m_pcEntropyCoder->getNumberOfWrittenBits();
}




UInt TEncSearch::xUpdateCandList( UInt uiMode, Double uiCost, UInt uiFastCandNum, UInt * CandModeList, Double * CandCostList )
{
  UInt i;
  UInt shift=0;

  while ( shift<uiFastCandNum && uiCost<CandCostList[ uiFastCandNum-1-shift ] )
  {
    shift++;
  }

  if( shift!=0 )
  {
    for(i=1; i<shift; i++)
    {
      CandModeList[ uiFastCandNum-i ] = CandModeList[ uiFastCandNum-1-i ];
      CandCostList[ uiFastCandNum-i ] = CandCostList[ uiFastCandNum-1-i ];
    }
    CandModeList[ uiFastCandNum-shift ] = uiMode;
    CandCostList[ uiFastCandNum-shift ] = uiCost;
    return 1;
  }

  return 0;
}





/** add inter-prediction syntax elements for a CU block
 * \param pcCU
 * \param uiQp
 * \param uiTrMode
 * \param ruiBits
 * \returns Void
 */
Void  TEncSearch::xAddSymbolBitsInter( TComDataCU* pcCU, UInt& ruiBits )
{
  if(pcCU->getMergeFlag( 0 ) && pcCU->getPartitionSize( 0 ) == SIZE_2Nx2N && !pcCU->getQtRootCbf( 0 ))
  {
    pcCU->setSkipFlagSubParts( true, 0, pcCU->getDepth(0) );

    m_pcEntropyCoder->resetBits();
    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }
    m_pcEntropyCoder->encodeSkipFlag(pcCU, 0, true);
    m_pcEntropyCoder->encodeMergeIndex(pcCU, 0, true);

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
  else
  {
    m_pcEntropyCoder->resetBits();

    if(pcCU->getSlice()->getPPS()->getTransquantBypassEnableFlag())
    {
      m_pcEntropyCoder->encodeCUTransquantBypassFlag(pcCU, 0, true);
    }

    m_pcEntropyCoder->encodeSkipFlag ( pcCU, 0, true );
    m_pcEntropyCoder->encodePredMode( pcCU, 0, true );
    m_pcEntropyCoder->encodePartSize( pcCU, 0, pcCU->getDepth(0), true );
    m_pcEntropyCoder->encodePredInfo( pcCU, 0 );

    Bool codeDeltaQp = false;
    Bool codeChromaQpAdj = false;
    m_pcEntropyCoder->encodeCoeff   ( pcCU, 0, pcCU->getDepth(0), codeDeltaQp, codeChromaQpAdj );

    ruiBits += m_pcEntropyCoder->getNumberOfWrittenBits();
  }
}





/**
 * \brief Generate half-sample interpolated block
 *
 * \param pattern Reference picture ROI
 * \param biPred    Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingH( TComPattern* pattern )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;
  Int halfFilterSize = (filterSize>>1);
  Pel *srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[0].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 0, false, chFmt, pattern->getBitDepthY());
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, m_filteredBlockTmp[2].getAddr(COMPONENT_Y), intStride, width+1, height+filterSize, 2, false, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + halfFilterSize * intStride + 1;
  dstPtr = m_filteredBlock[0][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
  dstPtr = m_filteredBlock[2][0].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+0, height+1, 2, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
  dstPtr = m_filteredBlock[0][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+0, 0, false, true, chFmt, pattern->getBitDepthY());

  intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[2][2].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width+1, height+1, 2, false, true, chFmt, pattern->getBitDepthY());
}





/**
 * \brief Generate quarter-sample interpolated blocks
 *
 * \param pattern    Reference picture ROI
 * \param halfPelRef Half-pel mv
 * \param biPred     Flag indicating whether block is for biprediction
 */
Void TEncSearch::xExtDIFUpSamplingQ( TComPattern* pattern, TComMv halfPelRef )
{
  Int width      = pattern->getROIYWidth();
  Int height     = pattern->getROIYHeight();
  Int srcStride  = pattern->getPatternLStride();

  Pel *srcPtr;
  Int intStride = m_filteredBlockTmp[0].getStride(COMPONENT_Y);
  Int dstStride = m_filteredBlock[0][0].getStride(COMPONENT_Y);
  Pel *intPtr;
  Pel *dstPtr;
  Int filterSize = NTAPS_LUMA;

  Int halfFilterSize = (filterSize>>1);

  Int extHeight = (halfPelRef.getVer() == 0) ? height + filterSize : height + filterSize-1;

  const ChromaFormat chFmt = m_filteredBlock[0][0].getChromaFormat();

  // Horizontal filter 1/4
  srcPtr = pattern->getROIY() - halfFilterSize * srcStride - 1;
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() >= 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 1, false, chFmt, pattern->getBitDepthY());

  // Horizontal filter 3/4
  srcPtr = pattern->getROIY() - halfFilterSize*srcStride - 1;
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() > 0)
  {
    srcPtr += srcStride;
  }
  if (halfPelRef.getHor() > 0)
  {
    srcPtr += 1;
  }
  m_if.filterHor(COMPONENT_Y, srcPtr, srcStride, intPtr, intStride, width, extHeight, 3, false, chFmt, pattern->getBitDepthY());

  // Generate @ 1,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][1].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,1
  intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][1].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());

  if (halfPelRef.getVer() != 0)
  {
    // Generate @ 2,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][1].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 2,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[2][3].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() == 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 2, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 0,1
    intPtr = m_filteredBlockTmp[1].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][1].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 0,3
    intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + halfFilterSize * intStride;
    dstPtr = m_filteredBlock[0][3].getAddr(COMPONENT_Y);
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 0, false, true, chFmt, pattern->getBitDepthY());
  }

  if (halfPelRef.getHor() != 0)
  {
    // Generate @ 1,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[1][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,2
    intPtr = m_filteredBlockTmp[2].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
    dstPtr = m_filteredBlock[3][2].getAddr(COMPONENT_Y);
    if (halfPelRef.getHor() > 0)
    {
      intPtr += 1;
    }
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }
  else
  {
    // Generate @ 1,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[1][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() >= 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

    // Generate @ 3,0
    intPtr = m_filteredBlockTmp[0].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride + 1;
    dstPtr = m_filteredBlock[3][0].getAddr(COMPONENT_Y);
    if (halfPelRef.getVer() > 0)
    {
      intPtr += intStride;
    }
    m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
  }

  // Generate @ 1,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[1][3].getAddr(COMPONENT_Y);
  if (halfPelRef.getVer() == 0)
  {
    intPtr += intStride;
  }
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 1, false, true, chFmt, pattern->getBitDepthY());

  // Generate @ 3,3
  intPtr = m_filteredBlockTmp[3].getAddr(COMPONENT_Y) + (halfFilterSize-1) * intStride;
  dstPtr = m_filteredBlock[3][3].getAddr(COMPONENT_Y);
  m_if.filterVer(COMPONENT_Y, intPtr, intStride, dstPtr, dstStride, width, height, 3, false, true, chFmt, pattern->getBitDepthY());
}





//! set wp tables
Void  TEncSearch::setWpScalingDistParam( TComDataCU* pcCU, Int iRefIdx, RefPicList eRefPicListCur )
{
  if ( iRefIdx<0 )
  {
    m_cDistParam.bApplyWeight = false;
    return;
  }

  TComSlice       *pcSlice  = pcCU->getSlice();
  WPScalingParam  *wp0 , *wp1;

  m_cDistParam.bApplyWeight = ( pcSlice->getSliceType()==P_SLICE && pcSlice->testWeightPred() ) || ( pcSlice->getSliceType()==B_SLICE && pcSlice->testWeightBiPred() ) ;

  if ( !m_cDistParam.bApplyWeight )
  {
    return;
  }

  Int iRefIdx0 = ( eRefPicListCur == REF_PIC_LIST_0 ) ? iRefIdx : (-1);
  Int iRefIdx1 = ( eRefPicListCur == REF_PIC_LIST_1 ) ? iRefIdx : (-1);

  getWpScaling( pcCU, iRefIdx0, iRefIdx1, wp0 , wp1 );

  if ( iRefIdx0 < 0 )
  {
    wp0 = NULL;
  }
  if ( iRefIdx1 < 0 )
  {
    wp1 = NULL;
  }

  m_cDistParam.wpCur  = NULL;

  if ( eRefPicListCur == REF_PIC_LIST_0 )
  {
    m_cDistParam.wpCur = wp0;
  }
  else
  {
    m_cDistParam.wpCur = wp1;
  }
}



//! \}
